var spoonDataDependencies = {
  "name" : "Spoon",
  "children" : [ {
    "name" : "compiler",
    "children" : [ {
      "name" : "compiler/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines interfaces for Java file compilation with Spoon. </p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.compiler;\n"
    }, {
      "name" : "compiler/SpoonFile.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport org.apache.commons.io.IOUtils;\nimport spoon.SpoonException;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\n\n/**\n * This interface represents files that can be used as resources for the Spoon\n * compiler.\n */\npublic interface SpoonFile extends SpoonResource {\n\n\t/**\n\t * Gets the file content as a stream.\n\t */\n\tInputStream getContent();\n\n\t/**\n\t * True if a Java source code file.\n\t */\n\tboolean isJava();\n\n\t/**\n\t * Tells if this file is an actual file (not a virtual file that holds\n\t * in-memory contents).\n\t *\n\t * @return\n\t */\n\tboolean isActualFile();\n\n\t/**\n\t * Gets the file content as a char array, considering encoding or encoding\n\t * provider.\n\t */\n\tdefault char[] getContentChars(Environment env) {\n\t\tbyte[] bytes;\n\t\ttry (InputStream contentStream = getContent()) {\n\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\t\t\tIOUtils.copy(contentStream, outputStream);\n\t\t\tbytes = outputStream.toByteArray();\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t\tif (env.getEncodingProvider() == null) {\n\t\t\treturn new String(bytes, env.getEncoding()).toCharArray();\n\t\t} else {\n\t\t\tCharset encoding = env.getEncodingProvider().detectEncoding(this, bytes);\n\t\t\treturn new String(bytes, encoding).toCharArray();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/ComplianceOptions.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\npublic class ComplianceOptions<T extends ComplianceOptions<T>> extends Options<T> {\n\tpublic ComplianceOptions() {\n\t\tsuper(ComplianceOptions.class);\n\t}\n\n\tpublic T compliance(int version) {\n\t\tif (version < 10) {\n\t\t\targs.add(\"-1.\" + version);\n\t\t} else {\n\t\t\targs.add(\"-\" + version);\n\t\t}\n\n\t\treturn myself;\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/AdvancedOptions.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\npublic class AdvancedOptions<T extends AdvancedOptions<T>> extends Options<T> {\n\tpublic AdvancedOptions() {\n\t\tsuper(AdvancedOptions.class);\n\t}\n\n\tpublic T continueExecution() {\n\t\targs.add(\"-noExit\");\n\t\treturn myself;\n\t}\n\n\tpublic T enableJavadoc() {\n\t\targs.add(\"-enableJavadoc\");\n\t\treturn myself;\n\t}\n\n\tpublic T preserveUnusedVars() {\n\t\targs.add(\"-preserveAllLocals\");\n\t\treturn myself;\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/JDTBuilder.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\n/**\n * Helper to build arguments for the JDT compiler.\n */\npublic interface JDTBuilder {\n\t/**\n\t * Classpath options for the compiler.\n\t */\n\tJDTBuilder classpathOptions(ClasspathOptions<?> options);\n\n\t/**\n\t * Compliance options for the compiler.\n\t */\n\tJDTBuilder complianceOptions(ComplianceOptions<?> options);\n\n\t/**\n\t * Annotation processing options for the compiler.\n\t */\n\tJDTBuilder annotationProcessingOptions(AnnotationProcessingOptions<?> options);\n\n\t/**\n\t * Advanced options for the compiler.\n\t */\n\tJDTBuilder advancedOptions(AdvancedOptions<?> options);\n\n\t/**\n\t * Sources for the compiler.\n\t */\n\tJDTBuilder sources(SourceOptions<?> options);\n\n\t/**\n\t * Builds arguments.\n\t */\n\tString[] build();\n}\n"
    }, {
      "name" : "compiler/builder/ClasspathOptions.java",
      "weight" : 59.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\nimport java.io.File;\n\npublic class ClasspathOptions<T extends ClasspathOptions<T>> extends Options<T> {\n\tpublic ClasspathOptions() {\n\t\tsuper(ClasspathOptions.class);\n\t}\n\n\tpublic T classpath(String classpath) {\n\t\tif (classpath == null) {\n\t\t\treturn myself;\n\t\t}\n\t\targs.add(\"-cp\");\n\t\targs.add(classpath);\n\t\treturn myself;\n\t}\n\n\tpublic T classpath(String... classpaths) {\n\t\tif (classpaths == null || classpaths.length == 0) {\n\t\t\treturn myself;\n\t\t}\n\t\treturn classpath(join(File.pathSeparator, classpaths));\n\t}\n\n\tpublic T bootclasspath(String bootclasspath) {\n\t\tif (bootclasspath == null) {\n\t\t\treturn myself;\n\t\t}\n\t\targs.add(\"-bootclasspath\");\n\t\targs.add(bootclasspath);\n\t\treturn myself;\n\t}\n\n\tpublic T bootclasspath(String... bootclasspaths) {\n\t\tif (bootclasspaths == null || bootclasspaths.length == 0) {\n\t\t\treturn myself;\n\t\t}\n\t\treturn bootclasspath(join(File.pathSeparator, bootclasspaths));\n\t}\n\n\tpublic T binaries(String directory) {\n\t\tif (directory == null) {\n\t\t\treturn binaries((File) null);\n\t\t}\n\t\treturn binaries(new File(directory));\n\t}\n\n\tpublic T binaries(File directory) {\n\t\tif (directory == null) {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(\"none\");\n\t\t} else {\n\t\t\targs.add(\"-d\");\n\t\t\targs.add(directory.getAbsolutePath());\n\t\t}\n\t\treturn myself;\n\t}\n\n\tpublic T encoding(String encoding) {\n\t\tif (encoding == null || encoding.isEmpty()) {\n\t\t\treturn myself;\n\t\t}\n\t\targs.add(\"-encoding\");\n\t\targs.add(encoding);\n\t\treturn myself;\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/EncodingProvider.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\nimport spoon.compiler.SpoonFile;\nimport java.nio.charset.Charset;\n\npublic interface EncodingProvider {\n\n\t/**\n\t* User-defined function, which is used to detect encoding for each file\n\t*/\n\tCharset detectEncoding(SpoonFile file, byte[] fileBytes);\n}\n"
    }, {
      "name" : "compiler/builder/JDTBuilderImpl.java",
      "weight" : 47.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class JDTBuilderImpl implements JDTBuilder {\n\tprivate final List<String> args = new ArrayList<>();\n\tprivate boolean hasSources = false;\n\n\t@Override\n\tpublic JDTBuilder classpathOptions(ClasspathOptions<?> options) {\n\t\tcheckSources();\n\t\targs.addAll(Arrays.asList(options.build()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic JDTBuilder complianceOptions(ComplianceOptions<?> options) {\n\t\tcheckSources();\n\t\targs.addAll(Arrays.asList(options.build()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic JDTBuilder annotationProcessingOptions(AnnotationProcessingOptions<?> options) {\n\t\tcheckSources();\n\t\targs.addAll(Arrays.asList(options.build()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic JDTBuilder advancedOptions(AdvancedOptions<?> options) {\n\t\tcheckSources();\n\t\targs.addAll(Arrays.asList(options.build()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic JDTBuilder sources(SourceOptions<?> options) {\n\t\thasSources = true;\n\t\targs.addAll(Arrays.asList(options.build()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String[] build() {\n\t\treturn args.toArray(new String[0]);\n\t}\n\n\tprivate void checkSources() {\n\t\tif (hasSources) {\n\t\t\tthrow new RuntimeException(\"Please, specify sources at the end.\");\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/Options.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic abstract class Options<T extends Options<T>> {\n\tstatic final String COMMA_DELIMITER = \",\";\n\tfinal List<String> args = new ArrayList<>();\n\tfinal T myself;\n\n\tpublic Options(Class<?> type) {\n\t\tthis.myself = (T) type.cast(this);\n\t}\n\n\tpublic String[] build() {\n\t\treturn args.toArray(new String[0]);\n\t}\n\n\tprotected String join(String delimiter, String[] classpath) {\n\t\tif (classpath == null || classpath.length == 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tfinal StringBuilder builder = new StringBuilder();\n\t\tfor (String entry : classpath) {\n\t\t\tbuilder.append(entry);\n\t\t\tbuilder.append(delimiter);\n\t\t}\n\t\treturn builder.toString();\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/SourceOptions.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\nimport org.apache.commons.io.IOUtils;\nimport spoon.compiler.SpoonFile;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SourceOptions<T extends SourceOptions<T>> extends Options<T> {\n\tpublic SourceOptions() {\n\t\tsuper(SourceOptions.class);\n\t}\n\n\t/** adds the given paths as concatenated string with File.pathSeparator as sources */\n\tpublic T sources(String sources) {\n\t\tif (sources == null || sources.isEmpty()) {\n\t\t\treturn myself;\n\t\t}\n\t\treturn sources(sources.split(File.pathSeparator));\n\t}\n\n\t/** adds the given paths as sources */\n\tpublic T sources(String... sources) {\n\t\tif (sources == null || sources.length == 0) {\n\t\t\targs.add(\".\");\n\t\t\treturn myself;\n\t\t}\n\t\targs.addAll(Arrays.asList(sources));\n\t\treturn myself;\n\t}\n\n\t/** adds the given {@link spoon.compiler.SpoonFile} as sources */\n\tpublic T sources(List<SpoonFile> sources) {\n\t\tif (sources == null || sources.isEmpty()) {\n\t\t\targs.add(\".\");\n\t\t\treturn myself;\n\t\t}\n\t\tfor (SpoonFile source : sources) {\n\t\t\tif (source.isActualFile()) {\n\t\t\t\targs.add(source.toString());\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tFile file = File.createTempFile(source.getName(), \".java\");\n\t\t\t\t\tfile.deleteOnExit();\n\t\t\t\t\tIOUtils.copy(source.getContent(), new FileOutputStream(file));\n\t\t\t\t\targs.add(file.toString());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn myself;\n\t}\n}\n"
    }, {
      "name" : "compiler/builder/AnnotationProcessingOptions.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler.builder;\n\npublic class AnnotationProcessingOptions<T extends AnnotationProcessingOptions<T>> extends Options<T> {\n\tpublic AnnotationProcessingOptions() {\n\t\tsuper(AnnotationProcessingOptions.class);\n\t}\n\n\tpublic T processors(String processors) {\n\t\tif (processors == null || processors.isEmpty()) {\n\t\t\treturn myself;\n\t\t}\n\t\targs.add(\"-processor\");\n\t\targs.add(processors);\n\t\treturn myself;\n\t}\n\n\tpublic T processors(String... processors) {\n\t\tif (processors == null || processors.length == 0) {\n\t\t\treturn myself;\n\t\t}\n\t\treturn processors(join(COMMA_DELIMITER, processors));\n\t}\n\n\tpublic T runProcessors() {\n\t\targs.add(\"-proc:only\");\n\t\treturn myself;\n\t}\n\n\tpublic T compileProcessors() {\n\t\targs.add(\"-proc:none\");\n\t\treturn myself;\n\t}\n}\n"
    }, {
      "name" : "compiler/ModelBuildingException.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport spoon.SpoonException;\n\n/**\n * thrown when the Spoon model of a program cannot be built\n */\npublic class ModelBuildingException extends SpoonException {\n\tprivate static final long serialVersionUID = 5029153216403064030L;\n\n\tpublic ModelBuildingException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\tpublic ModelBuildingException(String msg, Exception e) {\n\t\tsuper(msg, e);\n\t}\n}\n"
    }, {
      "name" : "compiler/SpoonResource.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport java.io.File;\n\n/**\n * This interface defines generic resources that are used by\n * {@link spoon.SpoonModelBuilder} in the Java compilation process.\n */\npublic interface SpoonResource {\n\n\t/**\n\t * Gets the folder that contains this resource.\n\t */\n\tSpoonFolder getParent();\n\n\t/**\n\t * Gets the name of this resource.\n\t */\n\tString getName();\n\n\t/**\n\t * Tells if this resource is a file.\n\t */\n\tboolean isFile();\n\n\t/**\n\t * Tells if this resource is an archive.\n\t */\n\tboolean isArchive();\n\n\t/**\n\t * Gets this resource path.\n\t */\n\tString getPath();\n\n\t/**\n\t * Gets the parent of this resource on the file system.\n\t */\n\tFile getFileSystemParent();\n\n\t/**\n\t * Gets the corresponding file if possible (returns null if this resource\n\t * does not correspond to any file on the filesystem).\n\t */\n\tFile toFile();\n}\n"
    }, {
      "name" : "compiler/InvalidClassPathException.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport spoon.SpoonException;\n\npublic class InvalidClassPathException extends SpoonException {\n\tprivate static final long serialVersionUID = 1L;\n\tpublic InvalidClassPathException() {\n\t}\n\tpublic InvalidClassPathException(String msg) {\n\t\tsuper(msg);\n\t}\n\tpublic InvalidClassPathException(Throwable e) {\n\t\tsuper(e);\n\t}\n\tpublic InvalidClassPathException(String msg, Exception e) {\n\t\tsuper(msg, e);\n\t}\n}\n"
    }, {
      "name" : "compiler/Environment.java",
      "weight" : 87.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport org.apache.log4j.Level;\nimport spoon.OutputType;\nimport spoon.compiler.builder.EncodingProvider;\nimport spoon.support.modelobs.FineModelChangeListener;\nimport spoon.processing.FileGenerator;\nimport spoon.processing.ProblemFixer;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.processing.ProcessorProperties;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.OutputDestinationHandler;\nimport spoon.support.CompressionType;\nimport spoon.support.compiler.SpoonProgress;\nimport spoon.support.sniper.SniperJavaPrettyPrinter;\n\nimport java.io.File;\nimport java.nio.charset.Charset;\nimport java.util.function.Supplier;\n\n/**\n * This interface represents the environment in which Spoon is launched -\n * accessible through {@link spoon.reflect.factory.Factory#getEnvironment()}. Its\n * primary use is to report messages, warnings, and errors.\n */\npublic interface Environment {\n\n\t/**\n\t * Gets the Java version compliance level.\n\t */\n\tint getComplianceLevel();\n\n\t/**\n\t * Sets the Java version compliance level.\n\t */\n\tvoid setComplianceLevel(int level);\n\n\t/**\n\t * This method should be called to print out a message with a source\n\t * position link during the processing.\n\t */\n\tvoid debugMessage(String message);\n\n\t/**\n\t * Returns the default file generator for this environment (gives the\n\t * default output directory for the created files).\n\t */\n\tFileGenerator<? extends CtElement> getDefaultFileGenerator();\n\n\t/**\n\t * Gets the processing manager.\n\t */\n\tProcessingManager getManager();\n\n\t/**\n\t * Returns the properties for a given processor.\n\t */\n\tProcessorProperties getProcessorProperties(String processorName);\n\n\t/**\n\t * Sets the properties for a given processor.\n\t */\n\tvoid setProcessorProperties(String processorName, ProcessorProperties prop);\n\n\t/**\n\t * Returns true is we let Spoon handle imports\n\t */\n\tboolean isAutoImports();\n\n\t/**\n\t * Tells if the processing is stopped, generally because one of the\n\t * processors called {@link #setProcessingStopped(boolean)} after reporting\n\t * an error.\n\t */\n\tboolean isProcessingStopped();\n\n\t/**\n\t * Helper method called by a processor to report an error, warning or\n\t * message as dictated by the severity parameter. Note that this does not\n\t * stop the processing or any remaining task. To do so, use\n\t * {@link #setProcessingStopped(boolean)}.\n\t *\n\t * @param processor\n\t *            The processor that report this message. Can be null.\n\t * @param level\n\t *            The level of the report\n\t * @param element\n\t *            The CtElement to which the report is associated\n\t * @param message\n\t *            The message to report\n\t */\n\tvoid report(Processor<?> processor, Level level, CtElement element, String message);\n\n\t/**\n\t * Helper method called by a processor to report an error, warning or\n\t * message as dictated by the severity parameter. Note that this does not\n\t * stop the processing or any remaining task. To do so, use\n\t * {@link #setProcessingStopped(boolean)}.\n\t *\n\t * @param processor\n\t *            The processor that report this message. Can be null.\n\t * @param level\n\t *            The level of the report\n\t * @param element\n\t *            The CtElement to which the report is associated\n\t * @param message\n\t *            The message to report\n\t * @param fixes\n\t *            The problem fixer(s) to correct this problem\n\t */\n\tvoid report(Processor<?> processor, Level level,\n\t\t\t\tCtElement element, String message, ProblemFixer<?>... fixes);\n\n\t/**\n\t * This method should be called to print out a message during the\n\t * processing.\n\t *\n\t * @param processor\n\t *            The processor that report this message. Can be null.\n\t * @param level\n\t *            The level of the report\n\t * @param message\n\t *            The message to report\n\t */\n\tvoid report(Processor<?> processor, Level level, String message);\n\n\t/**\n\t * This method should be called to report the end of the processing.\n\t */\n\tvoid reportEnd();\n\n\t/**\n\t * This method should be called to print out a progress message during the\n\t * processing. On contrary to regular messages, progress messages are not\n\t * meant to remain in the message logs and just indicate to the user some\n\t * task progression information.\n\t */\n\tvoid reportProgressMessage(String message);\n\n\t/**\n\t * Sets the default file generator for this environment.\n\t */\n\tvoid setDefaultFileGenerator(FileGenerator<? extends CtElement> generator);\n\n\t/**\n\t * Sets the processing manager of this environment.\n\t */\n\tvoid setManager(ProcessingManager manager);\n\n\t/**\n\t * This method can be called to stop the processing and all the remaining\n\t * tasks. In general, a processor calls it after reporting a fatal error.\n\t */\n\tvoid setProcessingStopped(boolean processingStopped);\n\n\t/**\n\t * Gets the size of the tabulations in the generated source code.\n\t */\n\tint getTabulationSize();\n\n\t/**\n\t * Sets the size of the tabulations in the generated source code.\n\t */\n\tvoid setTabulationSize(int size);\n\n\t/**\n\t * Tells if Spoon uses tabulations in the source code.\n\t */\n\tboolean isUsingTabulations();\n\n\t/**\n\t * Sets Spoon to use tabulations in the source code.\n\t */\n\tvoid useTabulations(boolean b);\n\n\t/**\n\t * Tell to the Java printer to automatically generate imports and use simple\n\t * names instead of fully-qualified name.\n\t */\n\tvoid setAutoImports(boolean autoImports);\n\n\t/**\n\t * Gets the error count from building, processing, and compiling within this\n\t * environment.\n\t */\n\tint getErrorCount();\n\n\t/**\n\t * Gets the warning count from building, processing, and compiling within\n\t * this environment.\n\t */\n\tint getWarningCount();\n\n\t/**\n\t * Returns the {@code ClassLoader} which is used by JDT and to resolve classes from references.\n\t *\n\t * By default, returns a class loader able to load classes from the\n\t * Spoon-specific class path set with  {@link #setSourceClasspath(String[])}\n\t */\n\tClassLoader getInputClassLoader();\n\n\t/**\n\t * Sets a specific classloader for JDT and reference resolution\n\t */\n\tvoid setInputClassLoader(ClassLoader classLoader);\n\n\t/**\n\t * When set, the generated source code will try to generate code that\n\t * preserves the line numbers of the original source code. This option may\n\t * lead to difficult-to-read indentation and formatting.\n\t */\n\tvoid setPreserveLineNumbers(boolean preserveLineNumbers);\n\n\t/**\n\t * Tells if the source generator will try to preserve the original line numbers.\n\t */\n\tboolean isPreserveLineNumbers();\n\n\t/**\n\t * Returns the source class path of the Spoon model.\n\t * This class path is used when the SpoonCompiler is building the model and also\n\t * to find external classes, referenced from within the model.\n\t */\n\tString[] getSourceClasspath();\n\n\t/**\n\t * Sets the source class path of the Spoon model.\n\t * After the class path is set, it can be retrieved by\n\t * {@link #getSourceClasspath()}. Only .jar files or directories with *.class files are accepted.\n\t * The *.jar or *.java files contained in given directories are ignored.\n\t *\n\t * @throws InvalidClassPathException if a given classpath does not exists or\n\t * does not have the right format (.jar file or directory)\n\t */\n\tvoid setSourceClasspath(String[] sourceClasspath);\n\n\t/**\n\t * Sets the option \"noclasspath\", use with caution (see explanation below).\n\t *\n\t * With this option, Spoon does not require the full classpath to build the\n\t * model. In this case, all references to classes that are not in the\n\t * classpath are handled with the reference mechanism. The \"simplename\" of\n\t * the reference object refers to the unbound identifier.\n\t *\n\t * This option facilitates the use of Spoon when is is hard to have the\n\t * complete and correct classpath, for example for mining software\n\t * repositories.\n\t *\n\t * For writing analyses, this option works well if you don't cross the\n\t * reference by a call to getDeclaration() (if you really want to do so,\n\t * then check for nullness of the result before).\n\t *\n\t * In normal mode, compilation errors are signaled as exception, with this\n\t * option enabled they are signaled as message only. The reason is that in\n\t * most cases, there are necessarily errors related to the missing classpath\n\t * elements.\n\t *\n\t */\n\tvoid setNoClasspath(boolean option);\n\n\t/** Returns the value ot the option noclasspath */\n\tboolean getNoClasspath();\n\n\t/**\n\t * Returns the value of the option copy-resources.\n\t */\n\tboolean isCopyResources();\n\n\t/**\n\t * Sets the option copy-resources to copy all resources in a project on the folder destination.\n\t */\n\tvoid setCopyResources(boolean copyResources);\n\n\t/**\n\t * Returns the value of the option enable-comments.\n\t */\n\tboolean isCommentsEnabled();\n\n\t/**\n\t * Sets the option enable-comments to parse comments of the target project.\n\t */\n\tvoid setCommentEnabled(boolean commentEnabled);\n\n\t/**\n\t * Gets the level of loggers asked by the user.\n\t */\n\tLevel getLevel();\n\n\t/**\n\t * Sets the level of loggers asked by the user.\n\t */\n\tvoid setLevel(String level);\n\n\t/**\n\t * Checks if we want compile the target source code and get their binary.\n\t */\n\tboolean shouldCompile();\n\n\t/**\n\t * Sets the compile argument.\n\t */\n\tvoid setShouldCompile(boolean shouldCompile);\n\n\t/**\n\t * Tells whether Spoon does no checks at all.\n\t * - parents are consistent (see {@link spoon.reflect.visitor.AstParentConsistencyChecker})\n\t * - hashcode violation (see {@link spoon.support.reflect.declaration.CtElementImpl#equals(Object)})\n\t * - method violation (see {@link spoon.reflect.declaration.CtType#addMethod(CtMethod)})\n\t * are active or not.\n\t *\n\t * By default all checks are enabled and {@link #checksAreSkipped()} return false.\n\t */\n\tboolean checksAreSkipped();\n\n\t/**\n\t * Disable all consistency checks on the AST. Dangerous! The only valid usage of this is to keep\n\t * full backward-compatibility.\n\t */\n\tvoid disableConsistencyChecks();\n\n\n\t/** Return the directory where binary .class files are created */\n\tvoid setBinaryOutputDirectory(String directory);\n\n\t/** Set the directory where binary .class files are created */\n\tString getBinaryOutputDirectory();\n\n\t/**\n\t * Sets the directory where source files are written\n\t */\n\tvoid setSourceOutputDirectory(File directory);\n\n\t/**\n\t * Returns the directory where source files are written\n\t */\n\tFile getSourceOutputDirectory();\n\n\t/**\n\t * Set the output destination that handles where source files are written\n\t */\n\tvoid setOutputDestinationHandler(OutputDestinationHandler outputDestinationHandler);\n\n\t/**\n\t * Returns the output destination that handles where source files are written\n\t */\n\tOutputDestinationHandler getOutputDestinationHandler();\n\n\t/**\n\t * get the model change listener that is used to follow the change of the AST.\n\t */\n\tFineModelChangeListener getModelChangeListener();\n\n\t/**\n\t * set the model change listener\n\t */\n\tvoid setModelChangeListener(FineModelChangeListener modelChangeListener);\n\n\t/**\n\t * Get the encoding used inside the project\n\t */\n\tCharset getEncoding();\n\n\t/**\n\t * Get encoding provider, which is used to detect encoding for each file separately\n\t */\n\tEncodingProvider getEncodingProvider();\n\n\t/**\n\t * Set the encoding to use for parsing source code\n\t */\n\tvoid setEncoding(Charset encoding);\n\n\t/**\n\t * Set encoding provider, which is used to detect encoding for each file separately\n\t */\n\tvoid setEncodingProvider(EncodingProvider encodingProvider);\n\n\t/**\n\t * Set the output type used for processing files\n\t */\n\tvoid setOutputType(OutputType outputType);\n\n\t/**\n\t * Get the output type\n\t */\n\tOutputType getOutputType();\n\n\tSpoonProgress getSpoonProgress();\n\n\tvoid setSpoonProgress(SpoonProgress spoonProgress);\n\n\t/**\n\t * Get the type of serialization to be used by default\n\t */\n\tCompressionType getCompressionType();\n\n\t/**\n\t * Set the type of serialization to be used by default\n\t */\n\tvoid setCompressionType(CompressionType serializationType);\n\n\t/**\n\t * @return new instance of {@link PrettyPrinter} which is configured for this environment\n\t */\n\tPrettyPrinter createPrettyPrinter();\n\n\t/**\n\t * @param creator a {@link Supplier}, which creates new instance of pretty printer.\n\t * Can be used to create a {@link SniperJavaPrettyPrinter} for enabling the sniper mode.\n\t *\n\t */\n\tvoid setPrettyPrinterCreator(Supplier<PrettyPrinter> creator);\n\n\n\t/**\n\t * @return true if spoon is allowed to create a model of a project that contains multiple times the same class\n\t */\n\tboolean isIgnoreDuplicateDeclarations();\n\n\t/**\n\t * @param ignoreDuplicateDeclarations (default false)  set to true to allow spoon to create a model of a project that\n\t *                                 contains multiple times the same class\n\t */\n\tvoid setIgnoreDuplicateDeclarations(boolean ignoreDuplicateDeclarations);\n}\n"
    }, {
      "name" : "compiler/SpoonFolder.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport java.util.List;\n\n/**\n * A Spoon resource that represents a folder.\n */\npublic interface SpoonFolder extends SpoonResource {\n\n\t/**\n\t * Gets all the files (excluding folders) in the folder.\n\t */\n\tList<SpoonFile> getFiles();\n\n\t/**\n\t * Gets all the files (including folders) in the folder.\n\t */\n\tList<SpoonFile> getAllFiles();\n\n\t/**\n\t * Gets all the Java source files in the folder.\n\t */\n\tList<SpoonFile> getAllJavaFiles();\n\n\t/**\n\t * Gets the subfolders in this folder.\n\t */\n\tList<SpoonFolder> getSubFolders();\n\n\t/**\n\t * Adds a file in this folder\n\t */\n\tvoid addFile(SpoonFile source);\n\n\t/**\n\t * Adds a sub folder in this folder\n\t */\n\tvoid addFolder(SpoonFolder source);\n}\n"
    }, {
      "name" : "compiler/SpoonResourceHelper.java",
      "weight" : 57.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.compiler;\n\nimport spoon.Launcher;\nimport spoon.support.compiler.FileSystemFile;\nimport spoon.support.compiler.FileSystemFolder;\nimport spoon.support.compiler.ZipFolder;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This class defines a helper for manipulating resources.\n */\npublic abstract class SpoonResourceHelper {\n\n\tprivate SpoonResourceHelper() {\n\t}\n\n\t/**\n\t * Tells if the given file is an archive file.\n\t */\n\tpublic static boolean isArchive(File f) {\n\t\treturn f.getName().endsWith(\".jar\") || f.getName().endsWith(\".zip\");\n\t}\n\n\t/**\n\t * Tells if the given file is file (files are not archives).\n\t */\n\tpublic static boolean isFile(File f) {\n\t\treturn f.isFile() && !isArchive(f);\n\t}\n\n\t/**\n\t * Creates the list of {@link SpoonResource} corresponding to the given\n\t * paths (files, folders, archives).\n\t */\n\tpublic static List<SpoonResource> resources(String... paths)\n\t\t\tthrows FileNotFoundException {\n\t\tList<SpoonResource> files = new ArrayList<>();\n\t\tfor (String path : paths) {\n\t\t\tfiles.add(createResource(new File(path)));\n\t\t}\n\t\treturn files;\n\t}\n\n\t/**\n\t * Creates the {@link SpoonFile} corresponding to the given file.\n\t */\n\tpublic static SpoonFile createFile(File f) throws FileNotFoundException {\n\t\tif (!f.exists()) {\n\t\t\tthrow new FileNotFoundException(f.toString());\n\t\t}\n\t\treturn new FileSystemFile(f);\n\t}\n\n\t/**\n\t * Creates the {@link SpoonResource} corresponding to the given file.\n\t */\n\tpublic static SpoonResource createResource(File f)\n\t\t\tthrows FileNotFoundException {\n\t\tif (isFile(f)) {\n\t\t\treturn createFile(f);\n\t\t}\n\t\treturn createFolder(f);\n\t}\n\n\t/**\n\t * Creates the {@link SpoonFolder} corresponding to the given file.\n\t */\n\tpublic static SpoonFolder createFolder(File f) throws FileNotFoundException {\n\t\tif (!f.exists()) {\n\t\t\tthrow new FileNotFoundException(f.toString() + \" does not exist\");\n\t\t}\n\t\ttry {\n\t\t\tif (f.isDirectory()) {\n\t\t\t\treturn new FileSystemFolder(f);\n\t\t\t}\n\t\t\tif (isArchive(f)) {\n\t\t\t\treturn new ZipFolder(f);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\n\t\treturn null;\n\t}\n\n}\n"
    } ]
  }, {
    "name" : "experimental",
    "children" : [ {
      "name" : "experimental/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * this is unstable code, subject to potential complete redesign, not only in snapshots but also in releases. you can use this code but you'll probably be impacted upon future changes.\n */\npackage spoon.experimental;\n\n"
    }, {
      "name" : "experimental/CtUnresolvedImport.java",
      "weight" : 66.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.experimental;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtImportKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtImportVisitor;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\npublic class CtUnresolvedImport extends CtElementImpl implements CtImport {\n\n\tpublic CtUnresolvedImport() {\n\t}\n\n\tprivate boolean isStatic;\n\n\tpublic void setStatic(boolean isStatic) {\n\t\tthis.isStatic = isStatic;\n\t}\n\n\tpublic boolean isStatic() {\n\t\treturn isStatic;\n\t}\n\n\tprivate String unresolvedReference;\n\n\tpublic void setUnresolvedReference(String reference) {\n\t\tthis.unresolvedReference = reference;\n\t}\n\n\tpublic String getUnresolvedReference() {\n\t\treturn unresolvedReference;\n\t}\n\n\t@Override\n\tpublic CtImportKind getImportKind() {\n\t\treturn CtImportKind.UNRESOLVED;\n\t}\n\n\t@Override\n\tpublic CtReference getReference() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T extends CtImport> T setReference(CtReference reference) {\n\t\tthrow new SpoonException(\"UnrseolvedImport reference cannot be set. Use CtImportImpl instead\");\n\t}\n\n\t@Override\n\tpublic void accept(CtImportVisitor visitor) {\n\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtImport(this);\n\t}\n\n\t@Override\n\tpublic CtUnresolvedImport clone() {\n\t\tFactory factory = getFactory();\n\t\treturn (CtUnresolvedImport) factory.createUnresolvedImport(unresolvedReference, isStatic);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(o instanceof CtUnresolvedImport)) {\n\t\t\treturn false;\n\t\t}\n\t\tCtUnresolvedImport other = (CtUnresolvedImport) o;\n\t\treturn other.isStatic() == isStatic && other.getUnresolvedReference().equals(unresolvedReference);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn unresolvedReference.hashCode() + (isStatic ? 1 : 0);\n\t}\n}\n"
    } ]
  }, {
    "name" : "javadoc",
    "children" : [ {
      "name" : "javadoc/internal/JavadocSnippet.java",
      "weight" : 37.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\nimport java.io.Serializable;\n\n/**\n* A piece of text inside a Javadoc description.\n*\n* <p>For example in <code>A class totally unrelated to {@link String}, I swear!</code> we would\n* have two snippets: one before and one after the inline tag (<code>{@link String}</code>).\n*/\npublic class JavadocSnippet implements JavadocDescriptionElement, Serializable {\n\tprivate String text;\n\n\tpublic JavadocSnippet(String text) {\n\t\tif (text == null) {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\tif (text.startsWith(\"/**\")) {\n\t\t\ttext = text.substring(3);\n\t\t}\n\t\tthis.text = text;\n\t}\n\n\t@Override\n\tpublic String toText() {\n\t\treturn this.text;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tJavadocSnippet that = (JavadocSnippet) o;\n\n\t\treturn text.equals(that.text);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn text.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"JavadocSnippet{\" + \"text='\" + text + '\\'' + '}';\n\t}\n}\n"
    }, {
      "name" : "javadoc/internal/Javadoc.java",
      "weight" : 153.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\nimport spoon.reflect.code.CtComment;\n\nimport static spoon.javadoc.internal.JavadocInlineTag.nextWord;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n* The structured content of a single Javadoc comment.\n*\n* <p>It is composed by a description and a list of block tags.\n*\n* <p>An example would be the text contained in this very Javadoc comment. At the moment of this\n* writing this comment does not contain any block tags (such as <code>@see AnotherClass</code>)\n*/\npublic class Javadoc implements Serializable {\n\n\tprivate JavadocDescription description;\n\tprivate List<JavadocBlockTag> blockTags;\n\n\tpublic Javadoc() {\n\t\tthis(new JavadocDescription());\n\t}\n\n\tpublic Javadoc(JavadocDescription description) {\n\t\tthis.description = description;\n\t\tthis.blockTags = new LinkedList<>();\n\t}\n\n\tpublic Javadoc addBlockTag(JavadocBlockTag blockTag) {\n\t\tthis.blockTags.add(blockTag);\n\t\treturn this;\n\t}\n\n\t/** For tags like \"@return good things\" where tagName is \"return\", and the rest is content. */\n\tpublic Javadoc addBlockTag(String tagName, String parameter, String content) {\n\t\treturn addBlockTag(tagName, parameter, content);\n\t}\n\n\tpublic Javadoc addBlockTag(String tagName) {\n\t\treturn addBlockTag(tagName, \"\", \"\");\n\t}\n\n\t/**\n\t\t* Return the text content of the document. It does not containing trailing spaces and asterisks\n\t\t* at the start of the line.\n\t\t*/\n\tpublic String toText() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif (!description.isEmpty()) {\n\t\t\tsb.append(description.toText());\n\t\t\tsb.append(System.lineSeparator());\n\t\t}\n\t\tif (!blockTags.isEmpty()) {\n\t\t\tsb.append(System.lineSeparator());\n\t\t}\n\t\tblockTags.forEach(\n\t\t\tbt -> {\n\t\t\t\tsb.append(bt.toText());\n\t\t\t\tsb.append(System.lineSeparator());\n\t\t\t});\n\t\treturn sb.toString();\n\t}\n\n\tpublic JavadocDescription getDescription() {\n\t\treturn description;\n\t}\n\n\t/** @return the current List of associated JavadocBlockTags */\n\tpublic List<JavadocBlockTag> getBlockTags() {\n\t\treturn this.blockTags;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tJavadoc document = (Javadoc) o;\n\n\t\treturn description.equals(document.description) && blockTags.equals(document.blockTags);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = description.hashCode();\n\t\tresult = 31 * result + blockTags.hashCode();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Javadoc{\" + \"description=\" + description + \", blockTags=\" + blockTags + '}';\n\t}\n\n\tprivate static String BLOCK_TAG_PREFIX = \"@\";\n\tprivate static Pattern BLOCK_PATTERN =\n\t\t\tPattern.compile(\"^\\\\s*\" + BLOCK_TAG_PREFIX, Pattern.MULTILINE);\n\n\t/** parse the description part (before tags) of a Javadoc */\n\tpublic static JavadocDescription parseText(String text) {\n\t\tJavadocDescription instance = new JavadocDescription();\n\t\tint index = 0;\n\t\tPair<Integer, Integer> nextInlineTagPos;\n\t\twhile ((nextInlineTagPos = indexOfNextInlineTag(text, index)) != null) {\n\t\t\tif (nextInlineTagPos.a != index) {\n\t\t\tinstance.addElement(new JavadocSnippet(text.substring(index, nextInlineTagPos.a)));\n\t\t\t}\n\t\t\tinstance.addElement(\n\t\t\t\tJavadocInlineTag.fromText(text.substring(nextInlineTagPos.a, nextInlineTagPos.b + 1)));\n\t\t\tindex = nextInlineTagPos.b + 1;\n\t\t}\n\t\tif (index < text.length()) {\n\t\t\tinstance.addElement(new JavadocSnippet(text.substring(index)));\n\t\t}\n\t\treturn instance;\n\t}\n\n\tprivate static Pair<Integer, Integer> indexOfNextInlineTag(String text, int start) {\n\t\tint index = text.indexOf(\"{@\", start);\n\t\tif (index == -1) {\n\t\t\treturn null;\n\t\t}\n\t\t// we are interested only in complete inline tags\n\t\tint closeIndex = text.indexOf(\"}\", index);\n\t\tif (closeIndex == -1) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Pair<>(index, closeIndex);\n\t}\n\n\t/** parses the Javadoc content (description + tags) */\n\tpublic static Javadoc parse(String commentContent) {\n\t\tList<String> cleanLines;\n\t\tcleanLines = Arrays.asList(commentContent.split(CtComment.LINE_SEPARATOR));\n\t\tint indexOfFirstBlockTag =\n\t\t\tcleanLines\n\t\t\t\t\t.stream()\n\t\t\t\t\t.filter(Javadoc::isABlockLine)\n\t\t\t\t\t.map(cleanLines::indexOf)\n\t\t\t\t\t.findFirst()\n\t\t\t\t\t.orElse(-1);\n\t\tList<String> blockLines;\n\t\tString descriptionText;\n\t\tif (indexOfFirstBlockTag == -1) {\n\t\t\tdescriptionText = trimRight(String.join(CtComment.LINE_SEPARATOR, cleanLines));\n\t\t\tblockLines = Collections.emptyList();\n\t\t} else {\n\t\t\tdescriptionText = trimRight(String.join(CtComment.LINE_SEPARATOR, cleanLines.subList(0, indexOfFirstBlockTag)));\n\n\t\t\t// Combine cleaned lines, but only starting with the first block tag till the end\n\t\t\t// In this combined string it is easier to handle multiple lines which actually belong\n\t\t\t// together\n\t\t\tString tagBlock =\n\t\t\t\tcleanLines\n\t\t\t\t\t.subList(indexOfFirstBlockTag, cleanLines.size())\n\t\t\t\t\t.stream()\n\t\t\t\t\t.collect(Collectors.joining(CtComment.LINE_SEPARATOR));\n\n\t\t\t// Split up the entire tag back again, considering now that some lines belong to the\n\t\t\t// same\n\t\t\t// block tag.\n\t\t\t// The pattern splits the block at each new line starting with the '@' symbol, thus the\n\t\t\t// symbol\n\t\t\t// then needs to be added again so that the block parsers handles everything correctly.\n\t\t\tblockLines =\n\t\t\t\tBLOCK_PATTERN\n\t\t\t\t\t.splitAsStream(tagBlock)\n\t\t\t\t\t.filter(x -> !x.isEmpty())\n\t\t\t\t\t.map(s -> BLOCK_TAG_PREFIX + s)\n\t\t\t\t\t.collect(Collectors.toList());\n\t\t}\n\t\tJavadoc document = new Javadoc(parseText(descriptionText));\n\t\tblockLines.forEach(l -> document.addBlockTag(parseBlockTag(l)));\n\t\treturn document;\n\t}\n\n\tprivate static JavadocBlockTag parseBlockTag(String line) {\n\t\tline = line.trim().substring(1);\n\t\tString tagName = nextWord(line);\n\t\tString rest = line.substring(tagName.length()).trim();\n\t\treturn new JavadocBlockTag(tagName, rest);\n\t}\n\n\tprivate static boolean isABlockLine(String line) {\n\t\treturn line.trim().startsWith(BLOCK_TAG_PREFIX);\n\t}\n\n\tprivate static String trimRight(String string) {\n\t\twhile (!string.isEmpty() && Character.isWhitespace(string.charAt(string.length() - 1))) {\n\t\t\tstring = string.substring(0, string.length() - 1);\n\t\t}\n\t\treturn string;\n\t}\n\n}\n"
    }, {
      "name" : "javadoc/internal/JavadocDescriptionElement.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\n/**\n* An element of a description: either an inline tag or a piece of text.\n*\n* <p>So for example <code>a text</code> or <code>{@link String}</code> could be valid description\n* elements.\n*/\npublic interface JavadocDescriptionElement {\n\t/** pretty-prints the Javadoc fragment */\n\tString toText();\n}\n"
    }, {
      "name" : "javadoc/internal/Pair.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\n\t/**\n\t* Simply a pair of objects.\n\t*\n\t* @param <A> type of object a.\n\t* @param <B> type of object b.\n\t*/\n\tpublic class Pair<A, B> {\n\tpublic final A a;\n\tpublic final B b;\n\n\tpublic Pair(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPair<?, ?> pair = (Pair<?, ?>) o;\n\n\t\tif (a != null ? !a.equals(pair.a) : pair.a != null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (b != null ? !b.equals(pair.b) : pair.b != null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = a != null ? a.hashCode() : 0;\n\t\treturn 31 * result + (b != null ? b.hashCode() : 0);\n\t}\n\t}\n"
    }, {
      "name" : "javadoc/internal/JavadocBlockTag.java",
      "weight" : 111.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\nimport java.io.Serializable;\n\n/**\n* A block tag.\n*\n* <p>Typically they are found at the end of Javadoc comments.\n*\n* <p>Examples: <code>@see AnotherClass</code> <code>@since v0.0.1</code> <code>@author Jim O'Java\n* </code>\n*/\npublic class JavadocBlockTag implements Serializable {\n\n\t/**\n\t\t* The type of tag: it could either correspond to a known tag (param, return, etc.) or represent\n\t\t* an unknown tag.\n\t\t*/\n\tpublic enum Type {\n\t\tAUTHOR,\n\t\tDEPRECATED,\n\t\tEXCEPTION,\n\t\tPARAM,\n\t\tRETURN,\n\t\tSEE,\n\t\tSERIAL,\n\t\tSERIAL_DATA,\n\t\tSERIAL_FIELD,\n\t\tSINCE,\n\t\tTHROWS,\n\t\tVERSION,\n\t\tUNKNOWN;\n\n\t\tType() {\n\t\t\tthis.keyword = name();\n\t\t}\n\n\t\tprivate String keyword;\n\n\t\tboolean hasName() {\n\t\t\treturn this == PARAM || this == THROWS;\n\t\t}\n\n\t\tstatic Type fromName(String tagName) {\n\t\t\tfor (Type t : Type.values()) {\n\t\t\t\tif (t.keyword.toUpperCase().equals(tagName.toUpperCase())) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn UNKNOWN;\n\t\t}\n\t}\n\n\tprivate Type type;\n\tprivate JavadocDescription content;\n\tprivate String name = \"\";\n\tprivate String tagName;\n\n\tpublic JavadocBlockTag(Type type, String content) {\n\t\tthis.type = type;\n\t\tthis.tagName = type.keyword;\n\t\tthis.content = Javadoc.parseText(content);\n\t}\n\n\tpublic JavadocBlockTag(String tagName, String content) {\n\t\tthis(Type.fromName(tagName), content);\n\t\tthis.tagName = tagName;\n\t}\n\n\tpublic JavadocBlockTag(String tagName, String paramName, String content) {\n\t\tthis(Type.fromName(tagName), content);\n\t\tthis.tagName = tagName;\n\t\tthis.name = paramName;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic JavadocDescription getContent() {\n\t\treturn content;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getTagName() {\n\t\treturn tagName;\n\t}\n\n\t/** pretty-prints the Javadoc tag */\n\tpublic String toText() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"@\");\n\t\tsb.append(tagName);\n\t\tsb.append(\" \").append(name);\n\t\tif (!content.isEmpty()) {\n\t\t\tsb.append(\" \");\n\t\t\tsb.append(content.toText());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tJavadocBlockTag that = (JavadocBlockTag) o;\n\n\t\tif (type != that.type) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!content.equals(that.content)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn name.equals(that.name);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = type.hashCode();\n\t\tresult = 31 * result + content.hashCode();\n\t\tresult = 31 * result + name.hashCode();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"JavadocBlockTag{\"\n\t\t\t+ \"type=\"\n\t\t\t+ type\n\t\t\t+ \", content='\"\n\t\t\t+ content\n\t\t\t+ '\\''\n\t\t\t+ \", name=\"\n\t\t\t+ name\n\t\t\t+ '}';\n\t}\n\t}\n"
    }, {
      "name" : "javadoc/internal/JavadocDescription.java",
      "weight" : 47.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\n\timport java.io.Serializable;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\n\t/**\n\t* A javadoc text, potentially containing inline tags.\n\t*/\n\tpublic class JavadocDescription implements Serializable {\n\n\tprivate List<JavadocDescriptionElement> elements;\n\n\tpublic JavadocDescription() {\n\t\telements = new LinkedList<>();\n\t}\n\n\tpublic JavadocDescription(List<JavadocDescriptionElement> elements) {\n\t\tthis();\n\n\t\tthis.elements.addAll(elements);\n\t}\n\n\tpublic boolean addElement(JavadocDescriptionElement element) {\n\t\treturn this.elements.add(element);\n\t}\n\n\tpublic List<JavadocDescriptionElement> getElements() {\n\t\treturn this.elements;\n\t}\n\n\tpublic String toText() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\telements.forEach(e -> sb.append(e.toText()));\n\t\treturn sb.toString();\n\t}\n\n\tpublic boolean isEmpty() {\n\t\treturn toText().isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tJavadocDescription that = (JavadocDescription) o;\n\n\t\treturn elements.equals(that.elements);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn elements.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"JavadocDescription{\" + \"elements=\" + elements + '}';\n\t}\n\t}\n"
    }, {
      "name" : "javadoc/internal/JavadocInlineTag.java",
      "weight" : 109.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n *  This file originally comes from JavaParser and is distributed under the terms of\n * a) the GNU Lesser General Public License as published by\n *     the Free Software Foundation, either version 3 of the License, or\n *     (at your option) any later version.\n * b) the terms of the Apache License\n */\npackage spoon.javadoc.internal;\n\nimport java.io.Serializable;\n\n/**\n* An inline tag contained in a Javadoc description.\n*\n* <p>For example <code>{@link String}</code>\n*/\npublic class JavadocInlineTag implements JavadocDescriptionElement, Serializable {\n\n\t/** Return the next word of the string, in other words it stops when a space is encountered. */\n\tpublic static String nextWord(String string) {\n\t\tint index = 0;\n\t\twhile (index < string.length() && !Character.isWhitespace(string.charAt(index))) {\n\t\t\tindex++;\n\t\t}\n\t\treturn string.substring(0, index);\n\t}\n\n\t/** parses a Javadoc tag */\n\tpublic static JavadocDescriptionElement fromText(String text) {\n\t\tif (!text.startsWith(\"{@\")) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\"Expected to start with '{@'. Text '%s'\", text));\n\t\t}\n\t\tif (!text.endsWith(\"}\")) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\"Expected to end with '}'. Text '%s'\", text));\n\t\t}\n\t\ttext = text.substring(2, text.length() - 1);\n\t\tString tagName = nextWord(text);\n\t\tType type = Type.fromName(tagName);\n\t\tString content = text.substring(tagName.length()).trim();\n\t\treturn new JavadocInlineTag(tagName, type, content);\n\t}\n\n\t/**\n\t\t* The type of tag: it could either correspond to a known tag (code, docRoot, etc.) or represent\n\t\t* an unknown tag.\n\t\t*/\n\tpublic enum Type {\n\t\tCODE,\n\t\tDOC_ROOT,\n\t\tINHERIT_DOC,\n\t\tLINK,\n\t\tLINKPLAIN,\n\t\tLITERAL,\n\t\tVALUE,\n\t\tUNKNOWN;\n\n\t\tType() {\n\t\t\tthis.keyword = name();\n\t\t}\n\n\t\tprivate String keyword;\n\n\t\tstatic JavadocInlineTag.Type fromName(String tagName) {\n\t\t\tfor (JavadocInlineTag.Type t : JavadocInlineTag.Type.values()) {\n\t\t\tif (t.keyword.equals(tagName.toUpperCase())) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\t}\n\t\t\treturn UNKNOWN;\n\t\t}\n\t}\n\n\tprivate String tagName;\n\tprivate Type type;\n\n\tpublic void setContent(String content) {\n\t\tthis.content = content;\n\t}\n\n\tprivate String content;\n\n\tpublic JavadocInlineTag(String tagName, Type type, String content) {\n\t\tthis.tagName = tagName;\n\t\tthis.type = type;\n\t\tthis.content = content;\n\t}\n\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\n\tpublic String getName() {\n\t\treturn tagName;\n\t}\n\n\t@Override\n\tpublic String toText() {\n\t\treturn \"{@\" + tagName + \" \" + this.content + \"}\";\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tJavadocInlineTag that = (JavadocInlineTag) o;\n\n\t\tif (tagName != null ? !tagName.equals(that.tagName) : that.tagName != null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (type != that.type) {\n\t\t\treturn false;\n\t\t}\n\t\treturn content != null ? content.equals(that.content) : that.content == null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = tagName != null ? tagName.hashCode() : 0;\n\t\tresult = 31 * result + (type != null ? type.hashCode() : 0);\n\t\tresult = 31 * result + (content != null ? content.hashCode() : 0);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"JavadocInlineTag{\"\n\t\t\t+ \"tagName='\"\n\t\t\t+ tagName\n\t\t\t+ '\\''\n\t\t\t+ \", type=\"\n\t\t\t+ type\n\t\t\t+ \", content='\"\n\t\t\t+ content\n\t\t\t+ '\\''\n\t\t\t+ '}';\n\t}\n\t}\n"
    } ]
  }, {
    "name" : "legacy",
    "children" : [ {
      "name" : "legacy/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package contains legacy code of Spoon. This code is kept for sake of maximum compatibility but no support is provided anymore.</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.legacy;\n"
    }, {
      "name" : "legacy/NameFilter.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.legacy;\n\n\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.filter.NamedElementFilter;\n\n\n/**\n * Filters elements by name (for instance to find a method). Example:\n *\n * <pre>\n * CtMethod&lt;?&gt; normalFor = type.getElements(\n * \t\tnew NameFilter&lt;CtMethod&lt;?&gt;&gt;(&quot;normalFor&quot;)).get(0);\n * </pre>\n *\n * Use {@link NamedElementFilter} instead: the actual NameFilter could return wrongly typed results. NamedElementFilter explicit the use of a type.\n */\npublic class NameFilter<T extends CtNamedElement> implements Filter<T> {\n\tprivate final String name;\n\n\t/**\n\t * @param name Name of the expected element\n\t */\n\tpublic NameFilter(String name) {\n\t\tif (name == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic boolean matches(T element) {\n\t\ttry {\n\t\t\treturn name.equals(element.getSimpleName());\n\t\t} catch (UnsupportedOperationException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getType() {\n\t\treturn (Class<T>) CtNamedElement.class;\n\t}\n}\n"
    } ]
  }, {
    "name" : "metamodel",
    "children" : [ {
      "name" : "metamodel/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * Ready to go meta?\n * This package contains classes that model the Spoon metamodel itself.\n * So this is the metametamodel.\n */\npackage spoon.metamodel;\n\n"
    }, {
      "name" : "metamodel/ConceptKind.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\n/**\n * Represents categories of metamodel types\n */\npublic enum ConceptKind {\n\t/**\n\t * Types of the metamodel that can be instantiated.\n\t * Examples: CtClass, CtField, CtThrow\n\t */\n\tLEAF,\n\t/**\n\t * Types of the metamodel which represent abstract concepts of Spoon\n\t * that cannot be directly instantiated. Some of them are marker interfaces.\n\t * Examples: CtExecutable, CtReference, CtBodyHolder, ...\n\t */\n\tABSTRACT;\n}\n"
    }, {
      "name" : "metamodel/Metamodel.java",
      "weight" : 419.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\nimport java.io.File;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModuleDirective;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.filter.AllTypeMembersFunction;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.compiler.FileSystemFolder;\nimport spoon.support.visitor.ClassTypingContext;\n\n/**\n * Represents the Spoon metamodel (incl. at runtime)\n */\npublic class Metamodel {\n\t/**\n\t * Returns all interfaces of the Spoon metamodel.\n\t * This method is stateless for sake of maintenance.\n\t * If you need to call it several times, you should store the result.\n\t */\n\tpublic static Set<CtType<?>> getAllMetamodelInterfaces() {\n\t\tSet<CtType<?>> result = new HashSet<>();\n\t\tFactory factory = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\n\t\t//avoid debug messages: Some annotations might be unreachable from the shadow element:\n\t\t//which causes bad meta model creation performance\n\t\tfactory.getEnvironment().setLevel(\"INFO\");\n\t\tresult.add(factory.Type().get(spoon.reflect.code.BinaryOperatorKind.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtAbstractInvocation.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtAnnotationFieldAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtArrayAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtArrayRead.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtArrayWrite.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtAssert.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtAssignment.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtBinaryOperator.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtBlock.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtBodyHolder.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtBreak.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCFlowBreak.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCase.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCatch.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCatchVariable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCodeElement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCodeSnippetExpression.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtCodeSnippetStatement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtComment.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtConditional.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtConstructorCall.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtContinue.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtDo.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtExecutableReferenceExpression.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtExpression.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtFieldAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtFieldRead.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtFieldWrite.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtFor.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtForEach.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtIf.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtInvocation.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtJavaDoc.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtJavaDocTag.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtLabelledFlowBreak.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtLambda.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtLiteral.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtLocalVariable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtLoop.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtNewArray.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtNewClass.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtOperatorAssignment.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtRHSReceiver.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtReturn.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtStatement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtStatementList.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtSuperAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtSwitch.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtSynchronized.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtTargetedExpression.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtThisAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtThrow.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtTry.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtTryWithResource.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtTypeAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtUnaryOperator.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtVariableAccess.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtVariableRead.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtVariableWrite.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.CtWhile.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.code.UnaryOperatorKind.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtAnnotatedElementType.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtAnnotation.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtAnnotationMethod.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtAnnotationType.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtAnonymousExecutable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtClass.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtCodeSnippet.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtCompilationUnit.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtConstructor.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtElement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtEnum.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtEnumValue.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtExecutable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtField.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtFormalTypeDeclarer.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtInterface.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtMethod.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtModifiable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtMultiTypedElement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtNamedElement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtPackage.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtParameter.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtShadowable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtType.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtTypeInformation.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtTypeMember.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtTypeParameter.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtTypedElement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtVariable.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.ModifierKind.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.ParentNotInitializedException.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtActualTypeContainer.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtArrayTypeReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtCatchVariableReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtExecutableReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtFieldReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtIntersectionTypeReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtLocalVariableReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtPackageReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtParameterReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtTypeParameterReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtTypeReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtUnboundVariableReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtVariableReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtWildcardReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtTypeMemberWildcardImportReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtImport.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtImportKind.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtModule.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtModuleRequirement.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtPackageDeclaration.class));\n\t\tresult.add(factory.Type().get(CtPackageExport.class));\n\t\tresult.add(factory.Type().get(CtProvidedService.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.reference.CtModuleReference.class));\n\t\tresult.add(factory.Type().get(spoon.reflect.declaration.CtUsedService.class));\n\t\tresult.add(factory.Type().get(CtModuleDirective.class));\n\t\treturn result;\n\t}\n\n\tprivate static final String CLASS_SUFFIX = \"Impl\";\n\t/**\n\t * qualified names of packages which contain interfaces of spoon model\n\t */\n\tpublic static final Set<String> MODEL_IFACE_PACKAGES = new HashSet<>(Arrays.asList(\n\t\t\t\"spoon.reflect.code\",\n\t\t\t\"spoon.reflect.declaration\",\n\t\t\t\"spoon.reflect.reference\"));\n\n\t/**\n\t * qualified names of packages which contain classes (implementations) of spoon model\n\t */\n\tpublic static final Set<String> MODEL_CLASS_PACKAGES = new HashSet<>(Arrays.asList(\n\t\t\t\"spoon.support.reflect.code\",\n\t\t\t\"spoon.support.reflect.declaration\",\n\t\t\t\"spoon.support.reflect.reference\"));\n\n\t/**\n\t * {@link MetamodelConcept}s by name\n\t */\n\tprivate final Map<String, MetamodelConcept> nameToConcept = new HashMap<>();\n\n\tprivate static Metamodel instance;\n\n\t/**\n\t * @return Spoon {@link Metamodel}, which is built once and then returns cached version\n\t */\n\tpublic static Metamodel getInstance() {\n\t\tif (instance == null) {\n\t\t\ttry {\n\t\t\t\t//this is needed just for CtGenerationTest#testGenerateRoleHandler\n\t\t\t\t//which must not use RoleHandler at time when RoleHandler is generated and Spoon model doesn't fit to old RoleHandlers\n\t\t\t\t//to avoid egg/chicken problem\n\t\t\t\tif (\"true\".equals(System.getProperty(MetamodelProperty.class.getName() + \"-noRoleHandler\"))) {\n\t\t\t\t\tMetamodelProperty.useRuntimeMethodInvocation = true;\n\t\t\t\t}\n\t\t\t} catch (SecurityException e) {\n\t\t\t\t//ignore that\n\t\t\t}\n\t\t\tinstance = new Metamodel();\n\t\t}\n\t\treturn instance;\n\t}\n\n\t/**\n\t *\n\t * Not in the public API.\n\t *\n\t * Parses spoon sources and creates factory with spoon model.\n\t *\n\t * @param spoonJavaSourcesDirectory the root directory of java sources of spoon model.\n\t * \tThe directory must contain \"spoon\" directory.\n\t */\n\tpublic Metamodel(File spoonJavaSourcesDirectory) {\n\t\tthis(createFactory(spoonJavaSourcesDirectory));\n\t}\n\n\t/**\n\t * @param factory already loaded factory with all Spoon model types\n\t */\n\tprotected Metamodel(Factory factory) {\n\t\tfor (String apiPackage : MODEL_IFACE_PACKAGES) {\n\t\t\tif (factory.Package().get(apiPackage) == null) {\n\t\t\t\tthrow new SpoonException(\"Spoon Factory model is missing API package \" + apiPackage);\n\t\t\t}\n\t\t\tString implPackage = replaceApiToImplPackage(apiPackage);\n\t\t\tif (factory.Package().get(implPackage) == null) {\n\t\t\t\tthrow new SpoonException(\"Spoon Factory model is missing implementation package \" + implPackage);\n\t\t\t}\n\t\t}\n\n\t\t//search for all interfaces of spoon model and create MetamodelConcepts for them\n\t\tfactory.getModel().filterChildren(new TypeFilter<>(CtInterface.class))\n\t\t\t.forEach((CtInterface<?> iface) -> {\n\t\t\t\tif (MODEL_IFACE_PACKAGES.contains(iface.getPackage().getQualifiedName())) {\n\t\t\t\t\tgetOrCreateConcept(iface);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Creates a {@link Metamodel} in runtime mode when spoon sources are not available.\n\t *\n\t * See also {@link #getInstance()}.\n\t */\n\tprivate Metamodel() {\n\t\tfor (CtType<?> iface : getAllMetamodelInterfaces()) {\n\t\t\tif (iface instanceof CtInterface) {\n\t\t\t\tgetOrCreateConcept(iface);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param clazz a {@link Class} of Spoon model\n\t * @return {@link MetamodelConcept} which describes the `clazz`\n\t */\n\tpublic MetamodelConcept getConcept(Class<? extends CtElement> clazz) {\n\t\tMetamodelConcept mc = nameToConcept.get(getConceptName(clazz));\n\t\tif (mc == null) {\n\t\t\tthrow new SpoonException(\"There is no Spoon metamodel concept for class \" + clazz.getName());\n\t\t}\n\t\treturn mc;\n\t}\n\n\t/**\n\t * @return all {@link MetamodelConcept}s of spoon meta model\n\t */\n\tpublic Collection<MetamodelConcept> getConcepts() {\n\t\treturn Collections.unmodifiableCollection(nameToConcept.values());\n\t}\n\n\t/**\n\t * @return List of Spoon model interfaces, which represents instantiable leafs of Spoon metamodel\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic List<CtType<? extends CtElement>> getAllInstantiableMetamodelInterfaces() {\n\t\tList<CtType<? extends CtElement>> result = new ArrayList<>();\n\t\tfor (MetamodelConcept mmConcept : getConcepts()) {\n\t\t\tif (mmConcept.getKind() == ConceptKind.LEAF) {\n\t\t\t\tresult.add((CtType) mmConcept.getMetamodelInterface());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param type a spoon model class or interface, whose concept name has to be returned\n\t * @return name of {@link MetamodelConcept}, which represents Spoon model {@link CtType}\n\t */\n\tpublic static String getConceptName(CtType<?> type) {\n\t\treturn getConceptName(type.getSimpleName());\n\t}\n\n\tpublic static String getConceptName(Class<? extends CtElement> conceptClass) {\n\t\treturn getConceptName(conceptClass.getSimpleName());\n\t}\n\n\t/**\n\t * @param simpleName a spoon model class or interface, whose concept name has to be returned\n\t * @return name of {@link MetamodelConcept}, which represents Spoon model {@link CtType}\n\t */\n\tprivate static String getConceptName(String simpleName) {\n\t\tif (simpleName.endsWith(CLASS_SUFFIX)) {\n\t\t\tsimpleName = simpleName.substring(0, simpleName.length() - CLASS_SUFFIX.length());\n\t\t}\n\t\treturn simpleName;\n\t}\n\n\t/**\n\t * @param iface the interface of spoon model element\n\t * @return {@link CtClass} of Spoon model which implements the spoon model interface. null if there is no implementation.\n\t */\n\tpublic static CtClass<?> getImplementationOfInterface(CtInterface<?> iface) {\n\t\tString impl = replaceApiToImplPackage(iface.getQualifiedName()) + CLASS_SUFFIX;\n\t\treturn (CtClass<?>) getType(impl, iface);\n\t}\n\n\t/**\n\t * @param impl the implementation class of a Spoon element\n\t * @return {@link CtInterface} of Spoon model which represents API of the spoon model class. null if there is no implementation.\n\t */\n\tpublic static CtInterface<?> getInterfaceOfImplementation(CtClass<?> impl) {\n\t\tString iface = impl.getQualifiedName();\n\t\tif (iface.endsWith(CLASS_SUFFIX) == false || iface.startsWith(\"spoon.support.reflect.\") == false) {\n\t\t\tthrow new SpoonException(\"Unexpected spoon model implementation class: \" + impl.getQualifiedName());\n\t\t}\n\t\tiface = iface.substring(0, iface.length() - CLASS_SUFFIX.length());\n\t\tiface = iface.replace(\"spoon.support.reflect\", \"spoon.reflect\");\n\t\treturn (CtInterface<?>) getType(iface, impl);\n\t}\n\n\t/**\n\t * @param method to be checked method\n\t * @return {@link CtRole} of spoon model method. Looking into all super class/interface implementations of this method\n\t */\n\tpublic static CtRole getRoleOfMethod(CtMethod<?> method) {\n\t\tFactory f = method.getFactory();\n\t\tCtAnnotation<PropertyGetter> getter = getInheritedAnnotation(method, f.createCtTypeReference(PropertyGetter.class));\n\t\tif (getter != null) {\n\t\t\treturn getter.getActualAnnotation().role();\n\t\t}\n\t\tCtAnnotation<PropertySetter> setter = getInheritedAnnotation(method, f.createCtTypeReference(PropertySetter.class));\n\t\tif (setter != null) {\n\t\t\treturn setter.getActualAnnotation().role();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static CtType<?> getType(String qualifiedName, CtElement anElement) {\n\t\tClass aClass;\n\t\ttry {\n\t\t\taClass = anElement.getClass().getClassLoader().loadClass(qualifiedName);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t//OK, that interface has no implementation class\n\t\t\treturn null;\n\t\t}\n\t\treturn anElement.getFactory().Type().get(aClass);\n\t}\n\n\tprivate static final String modelApiPackage = \"spoon.reflect\";\n\tprivate static final String modelApiImplPackage = \"spoon.support.reflect\";\n\n\tprivate static String replaceApiToImplPackage(String modelInterfaceQName) {\n\t\tif (modelInterfaceQName.startsWith(modelApiPackage) == false) {\n\t\t\tthrow new SpoonException(\"The qualified name \" + modelInterfaceQName + \" doesn't belong to Spoon model API package: \" + modelApiPackage);\n\t\t}\n\t\treturn modelApiImplPackage + modelInterfaceQName.substring(modelApiPackage.length());\n\t}\n\n\tprivate static Factory createFactory(File spoonJavaSourcesDirectory) {\n\t\tfinal Launcher launcher = new Launcher();\n\t\tlauncher.getEnvironment().setNoClasspath(true);\n\t\tlauncher.getEnvironment().setCommentEnabled(true);\n//\t\t// Spoon model interfaces\n\t\tArrays.asList(\"spoon/reflect/code\",\n\t\t\t\t\"spoon/reflect/declaration\",\n\t\t\t\t\"spoon/reflect/reference\",\n\t\t\t\t\"spoon/support/reflect/declaration\",\n\t\t\t\t\"spoon/support/reflect/code\",\n\t\t\t\t\"spoon/support/reflect/reference\").forEach(path ->\n\t\t\tlauncher.addInputResource(new FileSystemFolder(new File(spoonJavaSourcesDirectory, path))));\n\t\tlauncher.buildModel();\n\t\treturn launcher.getFactory();\n\t}\n\n\t/**\n\t * @param type can be class or interface of Spoon model element\n\t * @return existing or creates and initializes new {@link MetamodelConcept} which represents the `type`\n\t */\n\tprivate MetamodelConcept getOrCreateConcept(CtType<?> type) {\n\t\tString conceptName = getConceptName(type);\n\t\treturn getOrCreate(nameToConcept, conceptName,\n\t\t\t\t() -> new MetamodelConcept(conceptName),\n\t\t\t\tmmConcept -> initializeConcept(type, mmConcept));\n\t}\n\n\t/**\n\t * is called once for each {@link MetamodelConcept}, to initialize it.\n\t * @param type a class or inteface of the spoon model element\n\t * @param mmConcept to be initialize {@link MetamodelConcept}\n\t */\n\tprivate void initializeConcept(CtType<?> type, MetamodelConcept mmConcept) {\n\t\t//it is not initialized yet. Do it now\n\t\tif (type instanceof CtInterface<?>) {\n\t\t\tCtInterface<?> iface = (CtInterface<?>) type;\n\t\t\tmmConcept.setModelClass(getImplementationOfInterface(iface));\n\t\t\tmmConcept.setModelInterface(iface);\n\t\t} else if (type instanceof CtClass<?>) {\n\t\t\tCtClass<?> clazz = (CtClass<?>) type;\n\t\t\tmmConcept.setModelClass(clazz);\n\t\t\tmmConcept.setModelInterface(getInterfaceOfImplementation(clazz));\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected spoon model type: \" + type.getQualifiedName());\n\t\t}\n\n\t\t//add fields of interface\n\t\tif (mmConcept.getMetamodelInterface() != null) {\n\t\t\t//add fields of interface too. They are not added by above call of addFieldsOfType, because the MetamodelConcept already exists in nameToConcept\n\t\t\taddFieldsOfType(mmConcept, mmConcept.getMetamodelInterface());\n\t\t}\n\t\t//initialize all fields\n\t\tmmConcept.getRoleToProperty().forEach((role, mmField) -> {\n\t\t\t//if there are more methods for the same field then choose the one which best matches the field type\n\t\t\tmmField.sortByBestMatch();\n\t\t\t//finally initialize value type of this field\n\t\t\tmmField.setValueType(mmField.detectValueType());\n\t\t});\n\t}\n\n\t/**\n\t * adds all {@link MetamodelProperty}s of `ctType`\n\t * @param mmConcept the owner of to be created fields\n\t * @param ctType to be scanned {@link CtType}\n\t */\n\tprivate void addFieldsOfType(MetamodelConcept mmConcept, CtType<?> ctType) {\n\t\tctType.getTypeMembers().forEach(typeMember -> {\n\t\t\tif (typeMember instanceof CtMethod<?>) {\n\t\t\t\tCtMethod<?> method = (CtMethod<?>) typeMember;\n\t\t\t\tCtRole role = getRoleOfMethod(method);\n\t\t\t\tif (role != null) {\n\t\t\t\t\tMetamodelProperty field = mmConcept.getOrCreateMMField(role);\n\t\t\t\t\tfield.addMethod(method);\n\t\t\t\t} else {\n\t\t\t\t\tmmConcept.otherMethods.add(method);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\taddFieldsOfSuperType(mmConcept, ctType.getSuperclass());\n\t\tctType.getSuperInterfaces().forEach(superIfaceRef -> addFieldsOfSuperType(mmConcept, superIfaceRef));\n\t}\n\n\tprivate static Set<String> EXPECTED_TYPES_NOT_IN_CLASSPATH = new HashSet<>(Arrays.asList(\n\t\t\t\"java.lang.Cloneable\",\n\t\t\t\"java.lang.Object\",\n\t\t\t\"spoon.processing.FactoryAccessor\",\n\t\t\t\"spoon.reflect.cu.SourcePositionHolder\",\n\t\t\t\"spoon.reflect.visitor.CtVisitable\",\n\t\t\t\"spoon.reflect.visitor.chain.CtQueryable\",\n\t\t\t\"spoon.template.TemplateParameter\",\n\t\t\t\"java.lang.Iterable\",\n\t\t\t\"java.io.Serializable\"));\n\n\n\t/**\n\t * add all fields of `superTypeRef` into `mmConcept`\n\t * @param concept sub type\n\t * @param superTypeRef super type\n\t */\n\tprivate void addFieldsOfSuperType(MetamodelConcept concept, CtTypeReference<?> superTypeRef) {\n\t\tif (superTypeRef == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (EXPECTED_TYPES_NOT_IN_CLASSPATH.contains(superTypeRef.getQualifiedName())) {\n\t\t\t//ignore classes which are not part of spoon model\n\t\t\treturn;\n\t\t}\n\t\tCtType<?> superType = superTypeRef.getTypeDeclaration();\n\t\tif (superType == null) {\n\t\t\tthrow new SpoonException(\"Cannot create spoon meta model. The class \" + superTypeRef.getQualifiedName() + \" is missing class path\");\n\t\t}\n\t\t//call getOrCreateConcept recursively for super concepts\n\t\tMetamodelConcept superConcept = getOrCreateConcept(superType);\n\t\tif (superConcept != concept) {\n\t\t\tconcept.addSuperConcept(superConcept);\n\t\t}\n\t}\n\n\tstatic <K, V> V getOrCreate(Map<K, V> map, K key, Supplier<V> valueCreator) {\n\t\treturn getOrCreate(map, key, valueCreator, null);\n\t}\n\t/**\n\t * @param initializer is called immediately after the value is added to the map\n\t */\n\tstatic <K, V> V getOrCreate(Map<K, V> map, K key, Supplier<V> valueCreator, Consumer<V> initializer) {\n\t\tV value = map.get(key);\n\t\tif (value == null) {\n\t\t\tvalue = valueCreator.get();\n\t\t\tmap.put(key, value);\n\t\t\tif (initializer != null) {\n\t\t\t\tinitializer.accept(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n\tstatic <T> boolean addUniqueObject(Collection<T> col, T o) {\n\t\tif (containsObject(col, o)) {\n\t\t\treturn false;\n\t\t}\n\t\tcol.add(o);\n\t\treturn true;\n\t}\n\tstatic boolean containsObject(Iterable<?> iter, Object o) {\n\t\tfor (Object object : iter) {\n\t\t\tif (object == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/**\n\t * @param method a start method\n\t * @param annotationType a searched annotation type\n\t * @return annotation from the first method in superClass and superInterface hierarchy for the method with required annotationType\n\t */\n\tprivate static <A extends Annotation> CtAnnotation<A> getInheritedAnnotation(CtMethod<?> method, CtTypeReference<A> annotationType) {\n\t\tCtAnnotation<A> annotation = method.getAnnotation(annotationType);\n\t\tif (annotation == null) {\n\t\t\tCtType<?> declType = method.getDeclaringType();\n\t\t\tfinal ClassTypingContext ctc = new ClassTypingContext(declType);\n\t\t\tannotation = declType.map(new AllTypeMembersFunction(CtMethod.class)).map((CtMethod<?> currentMethod) -> {\n\t\t\t\tif (method == currentMethod) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (ctc.isSameSignature(method, currentMethod)) {\n\t\t\t\t\tCtAnnotation<A> annotation2 = currentMethod.getAnnotation(annotationType);\n\t\t\t\t\tif (annotation2 != null) {\n\t\t\t\t\t\treturn annotation2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}).first();\n\t\t}\n\t\treturn annotation;\n\t}\n}\n"
    }, {
      "name" : "metamodel/MMMethod.java",
      "weight" : 74.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.visitor.MethodTypingContext;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Represents a method used to get or set a {@link MetamodelProperty} of a {@link MetamodelConcept}.\n */\npublic class MMMethod {\n\tprivate final MetamodelProperty ownerField;\n\tprivate final CtMethod<?> method;\n\n\t/** methods with the same role and same signature in the type hierarchy */\n\tprivate final List<CtMethod<?>> ownMethods = new ArrayList<>();\n\n\tprivate final String signature;\n\tprivate final MMMethodKind methodKind;\n\n\t/**\n\t * Creates a {@link MMMethod} of a {@link MetamodelProperty}\n\t * @param field a owner field\n\t * @param method a method from ownerType or nearest super type\n\t */\n\tMMMethod(MetamodelProperty field, CtMethod<?> method) {\n\t\tthis.ownerField = field;\n\t\t//adapt method to scope of field.ownType\n\t\tMethodTypingContext mtc = new MethodTypingContext().setClassTypingContext(field.getOwner().getTypeContext()).setMethod(method);\n\t\tthis.method = (CtMethod<?>) mtc.getAdaptationScope();\n\t\tsignature = this.method.getSignature();\n\t\tmethodKind = MMMethodKind.kindOf(this.method);\n\t\tthis.addRelatedMethod(method);\n\t}\n\n\t/**\n\t * @return a {@link CtMethod}, which represents this {@link MMMethod}\n\t */\n\tpublic CtMethod<?> getActualCtMethod() {\n\t\treturn method;\n\t}\n\n\t/**\n\t * @return name of this {@link MMMethod}. It is equal to simple name of related {@link CtMethod}\n\t */\n\tpublic String getName() {\n\t\treturn method.getSimpleName();\n\t}\n\n\t/**\n\t * @return signature of this method, without the declaring type\n\t */\n\tpublic String getSignature() {\n\t\treturn signature;\n\t}\n\n\t/**\n\t * @return kind of this method. Getter, setter, ...\n\t */\n\tpublic MMMethodKind getKind() {\n\t\treturn methodKind;\n\t}\n\n\t/**\n\t * @return first own method in super type hierarchy of `targetType`\n\t */\n\tCtMethod<?> getCompatibleMethod(MetamodelConcept targetType) {\n\t\tfor (CtMethod<?> ctMethod : ownMethods) {\n\t\t\tif (targetType.getTypeContext().isSubtypeOf(ctMethod.getDeclaringType().getReference())) {\n\t\t\t\treturn ctMethod;\n\t\t\t}\n\t\t}\n\t\tthrow new SpoonException(\"No own method exists in type \" + ownerField);\n\t}\n\n\t/**\n\t * @param method\n\t * @return true of this {@link MMMethod} overrides `method`. In different words, if it represents the same method\n\t */\n\tpublic boolean overrides(CtMethod<?> method) {\n\t\treturn ownerField.getOwner().getTypeContext().isOverriding(this.method, method);\n\t}\n\n\t/**\n\t * @return the {@link MetamodelProperty} which is get or set by this {@link MMMethod}\n\t */\n\tpublic MetamodelProperty getProperty() {\n\t\treturn ownerField;\n\t}\n\n\t/**\n\t * @return {@link MetamodelConcept} where this {@link MMMethod} belongs to\n\t */\n\tpublic MetamodelConcept getOwner() {\n\t\treturn getProperty().getOwner();\n\t}\n\n\t/**\n\t * @return {@link CtMethod}s, which are declared in the {@link MetamodelConcept} or in the hierarchy, that have the same role and {@link MMMethodKind}.\n\t */\n\tpublic List<CtMethod<?>> getDeclaredMethods() {\n\t\treturn Collections.unmodifiableList(ownMethods);\n\t}\n\n\tvoid addRelatedMethod(CtMethod<?> method) {\n\t\tif (method.getDeclaringType().getSimpleName().endsWith(\"Impl\")) {\n\t\t\tthrow new SpoonException(\"the metametamodel should be entirely specified in the Spoon interfaces\");\n\t\t}\n\t\townMethods.add(method);\n\t}\n\n\t/**\n\t * @return the type returned by this method\n\t */\n\tpublic CtTypeReference<?> getReturnType() {\n\t\treturn method.getType();\n\t}\n\n\t/**\n\t * @return a value type of this method\n\t */\n\tpublic CtTypeReference<?> getValueType() {\n\t\tif (method.getParameters().isEmpty()) {\n\t\t\treturn method.getType();\n\t\t}\n\t\treturn method.getParameters().get(method.getParameters().size() - 1).getType();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getOwner().getName() + \"#\" + getSignature();\n\t}\n\n}\n"
    }, {
      "name" : "metamodel/MMMethodKind.java",
      "weight" : 58.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\nimport java.util.function.Predicate;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\n\n/**\n * Represents the type of metamodel method.\n * eg {@link spoon.reflect.declaration.CtType#addField(CtField)} has MMMethodKind{@link #ADD_FIRST}.\n */\npublic enum MMMethodKind {\n\t/**\n\t * Getter.\n\t * T get()\n\t */\n\tGET(-1, false, 1, m -> m.getParameters().isEmpty() && (m.getSimpleName().startsWith(\"get\") || m.getSimpleName().startsWith(\"is\"))),\n\t/**\n\t * Setter\n\t * void set(T)\n\t */\n\tSET(0, false, 1, m -> m.getParameters().size() == 1 && m.getSimpleName().startsWith(\"set\")),\n\t/**\n\t * void addFirst(T)\n\t */\n\tADD_FIRST(0, true, 10, m -> {\n\t\tif (m.getParameters().size() == 1) {\n\t\t\tif (m.getSimpleName().startsWith(\"add\") || m.getSimpleName().startsWith(\"insert\")) {\n\t\t\t\treturn m.getSimpleName().endsWith(\"AtTop\") || m.getSimpleName().endsWith(\"Begin\");\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}),\n\t/**\n\t * void add(T)\n\t */\n\tADD_LAST(0, true,  1, m -> {\n\t\tif (m.getParameters().size() == 1) {\n\t\t\treturn m.getSimpleName().startsWith(\"add\") || m.getSimpleName().startsWith(\"insert\");\n\t\t}\n\t\treturn false;\n\t}),\n\t/**\n\t * void addOn(int, T)\n\t */\n\tADD_ON(1, true, 1, m -> {\n\t\tif (m.getParameters().size() == 2 && \"int\".equals(m.getParameters().get(0).getType().getSimpleName())) {\n\t\t\treturn m.getSimpleName().startsWith(\"add\") || m.getSimpleName().startsWith(\"insert\");\n\t\t}\n\t\treturn false;\n\t}),\n\t/**\n\t * void remove(T)\n\t */\n\tREMOVE(0, true, 1, m -> m.getParameters().size() == 1 && m.getSimpleName().startsWith(\"remove\")),\n\n\t/**\n\t * Return element by its name\n\t * T get(String)\n\t */\n\tGET_BY(-1, true, 1, m -> m.getSimpleName().startsWith(\"get\")\n\t\t\t&& m.getParameters().size() == 1  && m.getParameters().get(0).getType().getQualifiedName().equals(String.class.getName())),\n\n\t/**\n\t * The not matching method\n\t */\n\tOTHER(-2, false, 0, m -> true);\n\n\tprivate final Predicate<CtMethod<?>> detector;\n\tprivate final int level;\n\tprivate final boolean multi;\n\tprivate final int valueParameterIndex;\n\n\tMMMethodKind(int valueParameterIndex, boolean multi, int level, Predicate<CtMethod<?>> detector) {\n\t\tthis.multi = multi;\n\t\tthis.level = level;\n\t\tthis.detector = detector;\n\t\tthis.valueParameterIndex = valueParameterIndex;\n\t}\n\n\t/**\n\t * @return true if this accessor provides access to elements of a collection.\n\t * \t\t false if it accessed full value of attribute\n\t */\n\tpublic boolean isMulti() {\n\t\treturn multi;\n\t}\n\n\t/**\n\t * Detect kind of method\n\t * @param method to be check method\n\t * @return detected {@link MMMethodKind}, which fits to the `method`\n\t */\n\tpublic static MMMethodKind kindOf(CtMethod<?> method) {\n\t\tMMMethodKind result = OTHER;\n\t\tfor (MMMethodKind k : values()) {\n\t\t\tif (k.detector.test(method) && result.level <= k.level) {\n\t\t\t\tif (result.level == k.level && k != OTHER) {\n\t\t\t\t\tthrow new SpoonException(\"Ambiguous method kinds \" + result.name() + \" X \" + k.name() + \" for method \" + method.getSignature());\n\t\t\t\t}\n\t\t\t\tresult = k;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    }, {
      "name" : "metamodel/MetamodelProperty.java",
      "weight" : 440.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\nimport static spoon.metamodel.Metamodel.addUniqueObject;\nimport static spoon.metamodel.Metamodel.getOrCreate;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.util.RtHelper;\n\n/**\n * Represents a property of the Spoon metamodel.\n * A property:\n *   - is an abstraction of a concrete field in an implementation class\n *   - the {@link MetamodelConcept} is the owner of this role, it models the implementation class that contains the field.\n *   - encapsulates a pair ({@link CtRole}, {@link MetamodelConcept}).\n *   - captures both the type of the field (eg list) and the type of items (eg String).\n */\npublic class MetamodelProperty {\n\t/**\n\t * Name of the field\n\t */\n\tprivate final String name;\n\t/**\n\t * {@link CtRole} of the field\n\t */\n\tprivate final CtRole role;\n\t/**\n\t * The list of {@link MetamodelConcept}s which contains this field\n\t */\n\tprivate final MetamodelConcept ownerConcept;\n\t/**\n\t * Type of value container [single, list, set, map]\n\t */\n\tprivate ContainerKind valueContainerType;\n\t/**\n\t * The type of value of this property - can be Set, List, Map or any non collection type\n\t */\n\tprivate CtTypeReference<?> valueType;\n\t/**\n\t * The item type of value of this property - can be non collection type\n\t */\n\tprivate CtTypeReference<?> itemValueType;\n\n\tprivate RoleHandler roleHandler;\n\n\tprivate Boolean derived;\n\tprivate Boolean unsettable;\n\n\tprivate Map<MMMethodKind, List<MMMethod>> methodsByKind = new HashMap<>();\n\tprivate Map<String, MMMethod> methodsBySignature;\n\n\t/**\n\t * methods of this field defined directly on ownerType.\n\t * There is PropertyGetter or PropertySetter annotation with `role` of this {@link MetamodelProperty}\n\t */\n\tprivate final List<MMMethod> roleMethods = new ArrayList<>();\n\t/**\n\t * methods of this field grouped by signature defined directly on ownerType.\n\t * There is PropertyGetter or PropertySetter annotation with `role` of this {@link MetamodelProperty}\n\t * note: There can be up to 2 methods in this list. 1) declaration from interface, 2) implementation from class\n\t */\n\tprivate final Map<String, MMMethod> roleMethodsBySignature = new HashMap<>();\n\t/**\n\t * List of {@link MetamodelProperty} with same `role`, from super type of `ownerConcept` {@link MetamodelConcept}\n\t */\n\tprivate final List<MetamodelProperty> superProperties = new ArrayList<>();\n\n\tprivate List<MMMethodKind> ambiguousMethodKinds = new ArrayList<>();\n\n\tMetamodelProperty(String name, CtRole role, MetamodelConcept ownerConcept) {\n\t\tthis.name = name;\n\t\tthis.role = role;\n\t\tthis.ownerConcept = ownerConcept;\n\t}\n\n\tvoid addMethod(CtMethod<?> method) {\n\t\taddMethod(method, true);\n\t}\n\n\t/**\n\t * @param method\n\t * @param createIfNotExist\n\t * @return existing {@link MMMethod}, which overrides `method` or creates and registers new one if `createIfNotExist`==true\n\t */\n\tMMMethod addMethod(CtMethod<?> method, boolean createIfNotExist) {\n\t\tfor (MMMethod mmMethod : roleMethods) {\n\t\t\tif (mmMethod.overrides(method)) {\n\t\t\t\t// linking this ctMethod to this mmMethod\n\t\t\t\tmmMethod.addRelatedMethod(method);\n\t\t\t\treturn mmMethod;\n\t\t\t}\n\t\t}\n\t\tif (createIfNotExist) {\n\t\t\tMMMethod mmMethod = new MMMethod(this, method);\n\t\t\troleMethods.add(mmMethod);\n\t\t\tgetOrCreate(methodsByKind, mmMethod.getKind(), () -> new ArrayList<>()).add(mmMethod);\n\t\t\tMMMethod conflict = roleMethodsBySignature.put(mmMethod.getSignature(), mmMethod);\n\t\t\tif (conflict != null) {\n\t\t\t\tthrow new SpoonException(\"Conflict on \" + getOwner().getName() + \".\" + name + \" method signature: \" + mmMethod.getSignature());\n\t\t\t}\n\t\t\treturn mmMethod;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvoid addSuperField(MetamodelProperty superMMField) {\n\t\tif (addUniqueObject(superProperties, superMMField)) {\n\t\t\t// we copy all methods of the super property\n\t\t\tfor (MMMethod superMethod : superMMField.getRoleMethods()) {\n\t\t\t\tCtMethod<?> method;\n\t\t\t\t// we want the super method that is compatible with this property\n\t\t\t\tmethod = superMethod.getCompatibleMethod(getOwner());\n\t\t\t\t// we add this CtMethod to this property\n\t\t\t\taddMethod(method, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic CtRole getRole() {\n\t\treturn role;\n\t}\n\n\t/** returns the concept that holds this property */\n\tpublic MetamodelConcept getOwner() {\n\t\treturn ownerConcept;\n\t}\n\n\t/** returns the kind of property (list, value, etc) */\n\tpublic ContainerKind getContainerKind() {\n\t\treturn valueContainerType;\n\t}\n\n\tCtTypeReference<?> detectValueType() {\n\t\tMMMethod mmGetMethod = getMethod(MMMethodKind.GET);\n\t\tif (mmGetMethod == null) {\n\t\t\tthrow new SpoonException(\"No getter exists for \" + getOwner().getName() + \".\" + getName());\n\t\t}\n\t\tMMMethod mmSetMethod = getMethod(MMMethodKind.SET);\n\t\tif (mmSetMethod == null) {\n\t\t\treturn mmGetMethod.getReturnType();\n\t\t}\n\t\tCtTypeReference<?> getterValueType = mmGetMethod.getReturnType();\n\t\tCtTypeReference<?> setterValueType = mmSetMethod.getValueType();\n\t\tif (getterValueType.equals(setterValueType)) {\n\t\t\treturn mmGetMethod.getReturnType();\n\t\t}\n\t\tif (containerKindOf(getterValueType.getActualClass()) != ContainerKind.SINGLE) {\n\t\t\tgetterValueType = getTypeofItems(getterValueType);\n\t\t\tsetterValueType = getTypeofItems(setterValueType);\n\t\t}\n\t\tif (getterValueType.equals(setterValueType)) {\n\t\t\treturn mmGetMethod.getReturnType();\n\t\t}\n\t\tif (getterValueType.isSubtypeOf(setterValueType)) {\n\t\t\t/*\n\t\t\t * Getter and setter have different type\n\t\t\t * For example:\n\t\t\t * CtBlock CtCatch#getBody\n\t\t\t * and\n\t\t\t * CtCatch#setBody(CtStatement)\n\t\t\t * In current metamodel we take type of setter to keep it simple\n\t\t\t */\n\t\t\treturn mmSetMethod.getValueType();\n\t\t}\n\t\tthrow new SpoonException(\"Incompatible getter and setter for \" + getOwner().getName() + \".\" + getName());\n\t}\n\n\tvoid setValueType(CtTypeReference<?> valueType) {\n\t\tFactory f = valueType.getFactory();\n\t\tif (valueType instanceof CtTypeParameterReference) {\n\t\t\tvalueType = ((CtTypeParameterReference) valueType).getBoundingType();\n\t\t\tif (valueType == null) {\n\t\t\t\tvalueType = f.Type().OBJECT;\n\t\t\t}\n\t\t}\n\t\tif (valueType.isImplicit()) {\n\t\t\tvalueType = valueType.clone();\n\t\t\t//never return type  with implicit==true, such type is then not pretty printed\n\t\t\tvalueType.setImplicit(false);\n\t\t}\n\t\tthis.valueType = valueType;\n\t\tthis.valueContainerType = containerKindOf(valueType.getActualClass());\n\t\tif (valueContainerType != ContainerKind.SINGLE) {\n\t\t\titemValueType = getTypeofItems(valueType);\n\t\t} else {\n\t\t\titemValueType = valueType;\n\t\t}\n\t}\n\n\t/**\n\t * Return the type of the field\n\t * for List&lt;String&gt; field the ValueType is List\n\t * for String field the ValueType is String\n\t *\n\t */\n\tpublic CtTypeReference<?> getTypeOfField() {\n\t\tif (valueType == null) {\n\t\t\tthrow new SpoonException(\"Model is not initialized yet\");\n\t\t}\n\t\treturn valueType;\n\t}\n\n\n\t/**\n\t * Returns the type of the property\n\t * for List&lt;String&gt; field the ValueType is String\n\t * for String field the ValueType is String (when getContainerKind == {@link ContainerKind#SINGLE}, {@link #getTypeofItems()} == {@link #getTypeOfField()}.\n\t *\n\t */\n\tpublic CtTypeReference<?> getTypeofItems() {\n\t\tif (itemValueType == null) {\n\t\t\tgetTypeOfField();\n\t\t}\n\t\treturn itemValueType;\n\t}\n\n\tpublic MMMethod getMethod(MMMethodKind kind) {\n\t\tList<MMMethod> ms = getMethods(kind);\n\t\treturn !ms.isEmpty() ? ms.get(0) : null;\n\t}\n\n\t/**\n\t * @return {@link MMMethod} accessing this property, which has signature `signature`\n\t */\n\tpublic MMMethod getMethodBySignature(String signature) {\n\t\tif (methodsBySignature == null) {\n\t\t\tmethodsBySignature = new HashMap<>();\n\t\t\tfor (List<MMMethod> mmMethods : methodsByKind.values()) {\n\t\t\t\tfor (MMMethod mmMethod : mmMethods) {\n\t\t\t\t\tString sigature = mmMethod.getSignature();\n\t\t\t\t\tmethodsBySignature.put(sigature, mmMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn methodsBySignature.get(signature);\n\t}\n\n\t/**\n\t * @param kind {@link MMMethodKind}\n\t * @return methods of required `kind`\n\t */\n\tpublic List<MMMethod> getMethods(MMMethodKind kind) {\n\t\tList<MMMethod> ms = methodsByKind.get(kind);\n\t\treturn ms == null ? Collections.emptyList() : Collections.unmodifiableList(ms);\n\t}\n\n\t/**\n\t * @return all methods which are accessing this property\n\t */\n\tpublic Set<MMMethod> getMethods() {\n\t\tSet<MMMethod> res = new HashSet<>();\n\t\tfor (List<MMMethod> methods : methodsByKind.values()) {\n\t\t\tres.addAll(methods);\n\t\t}\n\t\treturn Collections.unmodifiableSet(res);\n\t}\n\n\tvoid sortByBestMatch() {\n\t\t//resolve conflicts using value type. Move the most matching method to 0 index\n\t\t//in order GET, SET and others\n\t\tfor (MMMethodKind mk : MMMethodKind.values()) {\n\t\t\tsortByBestMatch(mk);\n\t\t}\n\t}\n\n\tvoid sortByBestMatch(MMMethodKind key) {\n\t\tList<MMMethod> methods = methodsByKind.get(key);\n\t\tif (methods != null && methods.size() > 1) {\n\t\t\tint idx = getIdxOfBestMatch(methods, key);\n\t\t\tif (idx >= 0) {\n\t\t\t\tif (idx > 0) {\n\t\t\t\t\t//move the matching to the beginning\n\t\t\t\t\tmethods.add(0, methods.remove(idx));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//add all methods as ambiguous\n\t\t\t\tambiguousMethodKinds.add(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param methods\n\t * @param key\n\t * @return index of the method which best matches the `key` accessor of this field\n\t *  -1 if it cannot be resolved\n\t */\n\tprivate int getIdxOfBestMatch(List<MMMethod> methods, MMMethodKind key) {\n\t\tMMMethod mmMethod = methods.get(0);\n\t\tif (mmMethod.getActualCtMethod().getParameters().isEmpty()) {\n\t\t\treturn getIdxOfBestMatchByReturnType(methods, key);\n\t\t} else {\n\t\t\tMMMethod mmGetMethod = getMethod(MMMethodKind.GET);\n\t\t\tif (mmGetMethod == null) {\n\t\t\t\t//we have no getter so we do not know the expected value type. Setters are ambiguous\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn getIdxOfBestMatchByInputParameter(methods, key, mmGetMethod.getReturnType());\n\t\t}\n\t}\n\n\tprivate int getIdxOfBestMatchByReturnType(List<MMMethod> methods, MMMethodKind key) {\n\t\tif (methods.size() > 2) {\n\t\t\tthrow new SpoonException(\"Resolving of more then 2 conflicting getters is not supported. There are: \" + methods.toString());\n\t\t}\n\t\t// There is no input parameter. We are resolving getter field.\n\t\t// choose the getter whose return value is a collection\n\t\t// of second one\n\t\tCtTypeReference<?> returnType1 = methods.get(0).getActualCtMethod().getType();\n\t\tCtTypeReference<?> returnType2 = methods.get(1).getActualCtMethod().getType();\n\t\tFactory f = returnType1.getFactory();\n\t\tboolean is1Iterable = returnType1.isSubtypeOf(f.Type().ITERABLE);\n\t\tboolean is2Iterable = returnType2.isSubtypeOf(f.Type().ITERABLE);\n\t\tif (is1Iterable != is2Iterable) {\n\t\t\t// they are not some. Only one of them is iterable\n\t\t\tif (is1Iterable) {\n\t\t\t\tif (isIterableOf(returnType1, returnType2)) {\n\t\t\t\t\t// use 1st method, which is multivalue\n\t\t\t\t\t// representation of 2nd method\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isIterableOf(returnType2, returnType1)) {\n\t\t\t\t\t// use 2nd method, which is multivalue\n\t\t\t\t\t// representation of 1st method\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// else report ambiguity\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @return true if item type of `iterableType` is super type of `itemType`\n\t */\n\tprivate boolean isIterableOf(CtTypeReference<?> iterableType, CtTypeReference<?> itemType) {\n\t\tCtTypeReference<?> iterableItemType = getTypeofItems(iterableType);\n\t\tif (iterableItemType != null) {\n\t\t\treturn itemType.isSubtypeOf(iterableItemType);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate int getIdxOfBestMatchByInputParameter(List<MMMethod> methods, MMMethodKind key, CtTypeReference<?> expectedValueType)  {\n\t\tint idx = -1;\n\t\tMatchLevel maxMatchLevel = null;\n\t\tif (key.isMulti()) {\n\t\t\texpectedValueType = getTypeofItems(expectedValueType);\n\t\t}\n\n\t\tfor (int i = 0; i < methods.size(); i++) {\n\t\t\tMMMethod mMethod = methods.get(i);\n\t\t\tMatchLevel matchLevel = getMatchLevel(expectedValueType, mMethod.getValueType());\n\t\t\tif (matchLevel != null) {\n\t\t\t\t//it is matching\n\t\t\t\tif (idx == -1) {\n\t\t\t\t\tidx = i;\n\t\t\t\t\tmaxMatchLevel = matchLevel;\n\t\t\t\t} else {\n\t\t\t\t\t//both methods have matching value type. Use the better match\n\t\t\t\t\tif (maxMatchLevel.ordinal() < matchLevel.ordinal()) {\n\t\t\t\t\t\tidx = i;\n\t\t\t\t\t\tmaxMatchLevel = matchLevel;\n\t\t\t\t\t} else if (maxMatchLevel == matchLevel) {\n\t\t\t\t\t\t//there is conflict\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} //else OK, we already have better match\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn idx;\n\t}\n\n\tprivate static CtTypeReference<?> getTypeofItems(CtTypeReference<?> valueType) {\n\t\tContainerKind valueContainerType = containerKindOf(valueType.getActualClass());\n\t\tif (valueContainerType == ContainerKind.SINGLE) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<?> itemValueType;\n\t\tif (valueContainerType == ContainerKind.MAP) {\n\t\t\tif (String.class.getName().equals(valueType.getActualTypeArguments().get(0).getQualifiedName()) == false) {\n\t\t\t\tthrow new SpoonException(\"Unexpected container of type: \" + valueType.toString());\n\t\t\t}\n\t\t\titemValueType = valueType.getActualTypeArguments().get(1);\n\t\t} else {\n\t\t\t//List or Set\n\t\t\titemValueType = valueType.getActualTypeArguments().get(0);\n\t\t}\n\t\tif (itemValueType instanceof CtTypeParameterReference) {\n\t\t\titemValueType = ((CtTypeParameterReference) itemValueType).getBoundingType();\n\t\t\tif (itemValueType == null) {\n\t\t\t\titemValueType = valueType.getFactory().Type().OBJECT;\n\t\t\t}\n\t\t}\n\t\treturn itemValueType;\n\t}\n\n\tprivate enum MatchLevel {\n\t\tSUBTYPE,\n\t\tERASED_EQUALS,\n\t\tEQUALS\n\t}\n\n\t/**\n\t * Checks whether expectedType and realType are matching.\n\t *\n\t * @param expectedType\n\t * @param realType\n\t * @return new expectedType or null if it is not matching\n\t */\n\tprivate MatchLevel getMatchLevel(CtTypeReference<?> expectedType, CtTypeReference<?> realType) {\n\t\tif (expectedType.equals(realType)) {\n\t\t\treturn MatchLevel.EQUALS;\n\t\t}\n\t\tif (expectedType.getTypeErasure().equals(realType.getTypeErasure())) {\n\t\t\treturn MatchLevel.ERASED_EQUALS;\n\t\t}\n\t\tif (expectedType.isSubtypeOf(realType)) {\n\t\t\t/*\n\t\t\t * CtFieldReference<T> CtFieldAccess#getVariable() CtFieldAccess\n\t\t\t * inherits from CtVariableAccess which has\n\t\t\t * #setVariable(CtVariableReference<T>) it is OK to use expected\n\t\t\t * type CtFieldReference<T>, when setter has CtVariableReference<T>\n\t\t\t */\n\t\t\treturn MatchLevel.SUBTYPE;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param valueType whose Map value type is needed\n\t * @return Map value type If valueType is an Map. null if it is not\n\t */\n\tprivate CtTypeReference<?> getMapValueType(CtTypeReference<?> valueType) {\n\t\tif (valueType != null) {\n\t\t\tFactory f = valueType.getFactory();\n\t\t\tif (valueType.isSubtypeOf(f.Type().MAP) && valueType.getActualTypeArguments().size() == 2) {\n\t\t\t\treturn valueType.getActualTypeArguments().get(1);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return true if this {@link MetamodelProperty} is derived in owner concept, ig has the annotation @{@link DerivedProperty}.\n\t */\n\tpublic boolean isDerived() {\n\t\tif (derived == null) {\n\t\t\tif (getOwner().getKind() == ConceptKind.LEAF && isUnsettable()) {\n\t\t\t\tderived = Boolean.TRUE;\n\t\t\t\treturn derived;\n\t\t\t}\n\t\t\t// by default it's derived\n\t\t\tderived = Boolean.FALSE;\n\n\t\t\t//if DerivedProperty is found on any getter of this type, then this field is derived\n\t\t\tMMMethod getter = getMethod(MMMethodKind.GET);\n\t\t\tif (getter == null) {\n\t\t\t\tthrow new SpoonException(\"No getter defined for \" + this);\n\t\t\t}\n\t\t\tCtTypeReference<DerivedProperty> derivedProperty = getter.getActualCtMethod().getFactory().createCtTypeReference(DerivedProperty.class);\n\n\t\t\tfor (CtMethod<?> ctMethod : getter.getDeclaredMethods()) {\n\t\t\t\tif (ctMethod.getAnnotation(derivedProperty) != null) {\n\t\t\t\t\tderived = Boolean.TRUE;\n\t\t\t\t\treturn derived;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//inherit derived property from super type\n\t\t\t//if DerivedProperty annotation is not found on any get method, then it is not derived\n\n\t\t\t//check all super fields. If any of them is derived then this field is derived too\n\t\t\tfor (MetamodelProperty superField : superProperties) {\n\t\t\t\tif (superField.isDerived()) {\n\t\t\t\t\tderived = Boolean.TRUE;\n\t\t\t\t\treturn derived;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn derived;\n\t}\n\n\t/**\n\t * @return true if this {@link MetamodelProperty} is unsettable in owner concept\n\t * ie. if the property has the annotation @{@link UnsettableProperty}\n\t */\n\tpublic boolean isUnsettable() {\n\t\tif (unsettable == null) {\n\t\t\t// by default it's unsettable\n\t\t\tunsettable = Boolean.FALSE;\n\n\t\t\t//if UnsettablePropertyis found on any setter of this type, then this field is unsettable\n\t\t\tMMMethod setter = getMethod(MMMethodKind.SET);\n\t\t\tif (setter == null) {\n\t\t\t\tunsettable = Boolean.TRUE;\n\t\t\t\treturn unsettable;\n\t\t\t}\n\t\t\tCtTypeReference<UnsettableProperty> unsettableProperty = setter.getActualCtMethod().getFactory().createCtTypeReference(UnsettableProperty.class);\n\n\t\t\tfor (CtMethod<?> ctMethod : setter.getDeclaredMethods()) {\n\t\t\t\tif (ctMethod.getAnnotation(unsettableProperty) != null) {\n\t\t\t\t\tunsettable = Boolean.TRUE;\n\t\t\t\t\treturn unsettable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn unsettable;\n\t}\n\n\tprivate List<MMMethod> getRoleMethods() {\n\t\treturn Collections.unmodifiableList(roleMethods);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn ownerConcept.getName() + \"#\" + getName() + \"<\" + valueType + \">\";\n\t}\n\n\t/**\n\t * @return the super {@link MetamodelProperty} which has same valueType and which is upper in the metamodel hierarchy\n\t * For example:\n\t * The super property of {@link CtField}#NAME is {@link CtNamedElement}#NAME\n\t * This method can be used to optimize generated code.\n\t */\n\tpublic MetamodelProperty getSuperProperty() {\n\t\tList<MetamodelProperty> potentialRootSuperFields = new ArrayList<>();\n\t\tif (!roleMethods.isEmpty()) {\n\t\t\tpotentialRootSuperFields.add(this);\n\t\t}\n\t\tsuperProperties.forEach(superField -> {\n\t\t\taddUniqueObject(potentialRootSuperFields, superField.getSuperProperty());\n\t\t});\n\t\tint idx = 0;\n\t\tif (potentialRootSuperFields.size() > 1) {\n\t\t\tboolean needsSetter = getMethod(MMMethodKind.SET) != null;\n\t\t\tCtTypeReference<?> expectedValueType = this.getTypeOfField().getTypeErasure();\n\t\t\tfor (int i = 1; i < potentialRootSuperFields.size(); i++) {\n\t\t\t\tMetamodelProperty superField = potentialRootSuperFields.get(i);\n\t\t\t\tif (superField.getTypeOfField().getTypeErasure().equals(expectedValueType) == false) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (needsSetter && superField.getMethod(MMMethodKind.SET) == null) {\n\t\t\t\t\t//this field has setter but the superField has no setter. We cannot used it as super\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t}\n\t\treturn potentialRootSuperFields.get(idx);\n\t}\n\n\tprivate\tstatic ContainerKind containerKindOf(Class<?> valueClass) {\n\t\tif (List.class.isAssignableFrom(valueClass)) {\n\t\t\treturn ContainerKind.LIST;\n\t\t}\n\t\tif (Map.class.isAssignableFrom(valueClass)) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\tif (Collection.class.isAssignableFrom(valueClass)) {\n\t\t\treturn ContainerKind.SET;\n\t\t}\n\t\treturn ContainerKind.SINGLE;\n\t}\n\n\t/**\n\t * @return {@link RoleHandler} which can access runtime data of this Property\n\t */\n\tpublic RoleHandler getRoleHandler() {\n\t\tif (roleHandler == null) {\n\t\t\t//initialize it lazily, because CtGenerationTest#testGenerateRoleHandler needs metamodel to generate rolehandlers\n\t\t\t//and here it may happen that rolehandler doesn't exist yet\n\t\t\troleHandler = RoleHandlerHelper.getRoleHandler((Class) ownerConcept.getMetamodelInterface().getActualClass(), role);\n\t\t}\n\t\treturn roleHandler;\n\t}\n\n\tstatic boolean useRuntimeMethodInvocation = false;\n\n\t/**\n\t * @param element an instance whose attribute value is read\n\t * @return a value of attribute defined by this {@link MetamodelProperty} from the provided `element`\n\t */\n\tpublic <T, U> U getValue(T element) {\n\t\tif (useRuntimeMethodInvocation) {\n\t\t\tMMMethod method = getMethod(MMMethodKind.GET);\n\t\t\tif (method != null) {\n\t\t\t\tMethod rtMethod = RtHelper.getMethod(getOwner().getImplementationClass().getActualClass(), method.getName(), 0);\n\t\t\t\tif (rtMethod != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn (U) rtMethod.invoke(element);\n\t\t\t\t\t} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n\t\t\t\t\t\tthrow new SpoonException(\"Invocation of getter on \" + toString() + \" failed\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"Cannot invoke getter on \" + toString());\n\t\t\t}\n\t\t}\n\t\treturn getRoleHandler().getValue(element);\n\t}\n\n\t/**\n\t * @param element an instance whose attribute value is set\n\t * @param value to be set value of attribute defined by this {@link MetamodelProperty} on the provided `element`\n\t */\n\tpublic <T, U> void setValue(T element, U value) {\n\t\tif (useRuntimeMethodInvocation) {\n\t\t\tMMMethod method = getMethod(MMMethodKind.SET);\n\t\t\tif (method != null) {\n\t\t\t\tMethod rtMethod = RtHelper.getMethod(getOwner().getImplementationClass().getActualClass(), method.getName(), 1);\n\t\t\t\tif (rtMethod != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trtMethod.invoke(element, value);\n\t\t\t\t\t} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n\t\t\t\t\t\tthrow new SpoonException(\"Invocation of setter on \" + toString() + \" failed\", e);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"Cannot invoke setter on \" + toString());\n\t\t\t}\n\t\t}\n\t\tgetRoleHandler().setValue(element, value);\n\t}\n\n}\n"
    }, {
      "name" : "metamodel/MetamodelConcept.java",
      "weight" : 99.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.metamodel;\n\nimport static spoon.metamodel.Metamodel.addUniqueObject;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.visitor.ClassTypingContext;\n\n/**\n * Represents a concept of the Spoon metamodel (eg {@link CtClass}).\n */\npublic class MetamodelConcept {\n\t/**\n\t * Kind of this concept\n\t */\n\tprivate ConceptKind kind;\n\t/**\n\t * Name of the concept\n\t */\n\tprivate final String name;\n\t/**\n\t * Map of {@link CtRole} to {@link MetamodelProperty}s with values ordered same like CtScanner scans these properties when visiting this {@link MetamodelConcept}\n\t */\n\tprivate final Map<CtRole, MetamodelProperty> role2Property = new LinkedHashMap<>();\n\n\t/**\n\t * List of super concepts of this concept\n\t */\n\tprivate final List<MetamodelConcept> superConcepts = new ArrayList<>();\n\t/**\n\t * List of sub concepts of this concept\n\t */\n\tprivate final List<MetamodelConcept> subConcepts = new ArrayList<>();\n\n\t/**\n\t * The {@link CtClass} linked to this {@link MetamodelConcept}. Is null in case of class without interface\n\t */\n\tprivate CtClass<?> modelClass;\n\t/**\n\t * The {@link CtInterface} linked to this {@link MetamodelConcept}. Is null in case of interface without class\n\t */\n\tprivate CtInterface<?> modelInterface;\n\n\t/**\n\t * {@link ClassTypingContext} of this concept used to adapt methods from super type implementations to this {@link MetamodelConcept}\n\t */\n\tprivate ClassTypingContext typeContext;\n\n\t/**\n\t * own methods of {@link MetamodelConcept}, which does not belong to any role\n\t */\n\tfinal List<CtMethod<?>> otherMethods = new ArrayList<>();\n\n\tMetamodelConcept(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * @return interface name of {@link MetamodelConcept}. For example CtClass, CtForEach, ...\n\t * It is never followed by xxxImpl\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\n\tMetamodelProperty getOrCreateMMField(CtRole role) {\n\t\treturn Metamodel.getOrCreate(role2Property, role, () -> new MetamodelProperty(role.getCamelCaseName(), role, this));\n\t}\n\n\t/**\n\t * @return kind of this {@link MetamodelConcept}.\n\t */\n\tpublic ConceptKind getKind() {\n\t\tif (kind == null) {\n\t\t\tif (modelClass == null && modelInterface == null) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\t// we first consider interface\n\t\t\t\tif (modelClass == null) {\n\t\t\t\t\tthis.kind = ConceptKind.ABSTRACT;\n\t\t\t\t} else {\n\t\t\t\t\tif (modelClass.hasModifier(ModifierKind.ABSTRACT)) {\n\t\t\t\t\t\tthis.kind = ConceptKind.ABSTRACT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.kind = ConceptKind.LEAF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn kind;\n\t}\n\n\t/**\n\t * @return map of {@link MetamodelProperty}s by their {@link CtRole}\n\t */\n\tpublic Map<CtRole, MetamodelProperty> getRoleToProperty() {\n\t\treturn Collections.unmodifiableMap(role2Property);\n\t}\n\n\t/**\n\t * @return Collection of all {@link MetamodelProperty} of current {@link MetamodelConcept}\n\t * Note: actually is the order undefined\n\t * TODO: return List in the same order like it is scanned by CtScanner\n\t */\n\tpublic Collection<MetamodelProperty> getProperties() {\n\t\treturn Collections.unmodifiableCollection(role2Property.values());\n\t}\n\n\t/**\n\t * @param role a {@link CtRole}\n\t * @return {@link MetamodelProperty} for `role` of this concept\n\t */\n\tpublic MetamodelProperty getProperty(CtRole role) {\n\t\treturn role2Property.get(role);\n\t}\n\n\t/**\n\t * @return super types\n\t */\n\tpublic List<MetamodelConcept> getSuperConcepts() {\n\t\treturn superConcepts;\n\t}\n\n\tvoid addSuperConcept(MetamodelConcept superType) {\n\t\tif (superType == this) {\n\t\t\tthrow new SpoonException(\"Cannot add supertype to itself\");\n\t\t}\n\t\tif (addUniqueObject(superConcepts, superType)) {\n\t\t\tsuperType.subConcepts.add(this);\n\t\t\tsuperType.role2Property.forEach((role, superMMField) -> {\n\t\t\t\tMetamodelProperty mmField = getOrCreateMMField(role);\n\t\t\t\tmmField.addSuperField(superMMField);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @return {@link CtClass} which represents this {@link MetamodelConcept}\n\t */\n\tpublic CtClass<?> getImplementationClass() {\n\t\treturn modelClass;\n\t}\n\n\tvoid setModelClass(CtClass<?> modelClass) {\n\t\tthis.modelClass = modelClass;\n\t}\n\n\t/**\n\t * @return {@link CtInterface} which represents this {@link MetamodelConcept}\n\t */\n\tpublic CtInterface<?> getMetamodelInterface() {\n\t\treturn modelInterface;\n\t}\n\n\tvoid setModelInterface(CtInterface<?> modelInterface) {\n\t\tthis.modelInterface = modelInterface;\n\t}\n\n\t/**\n\t * @return {@link ClassTypingContext}, which can be used to adapt super type methods to this {@link MetamodelConcept}\n\t *\n\t * (package protected, not in the public API)\n\t */\n\tClassTypingContext getTypeContext() {\n\t\tif (typeContext == null) {\n\t\t\ttypeContext = new ClassTypingContext(modelClass != null ? modelClass : modelInterface);\n\t\t}\n\t\treturn typeContext;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getName();\n\t}\n}\n"
    } ]
  }, {
    "name" : "pattern",
    "children" : [ {
      "name" : "pattern/Pattern.java",
      "weight" : 82.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.PatternPrinter;\nimport spoon.pattern.internal.matcher.MatchingScanner;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.support.Experimental;\n\n/**\n * Represents a pattern for matching code. A pattern is composed of a list of AST models, where a model is an AST with some nodes being \"pattern parameters\".\n *\n * Main documentation at http://spoon.gforge.inria.fr/pattern.html.\n *\n * Instances can created with {@link PatternBuilder}.\n *\n * The {@link Pattern} can also be used to generate new code where\n * (Pattern) + (pattern parameters) =&gt; (copy of pattern where parameters are replaced by parameter values)\n * This is done with {@link #generator()} and it's methods\n *\n * Differences with {@link spoon.template.TemplateMatcher}:\n * - it can match sequences of elements\n * - it can match inlined elements\n */\n@Experimental\npublic class Pattern {\n\tprivate ListOfNodes modelValueResolver;\n\tprivate boolean addGeneratedBy = false;\n\tprivate final Factory factory;\n\t/** package-protected, must use {@link PatternBuilder} */\n\tPattern(Factory factory, ListOfNodes modelValueResolver) {\n\t\tthis.modelValueResolver = modelValueResolver;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * @return Map of parameter names to {@link ParameterInfo} for each parameter of this {@link Pattern}\n\t */\n\tpublic Map<String, ParameterInfo> getParameterInfos() {\n\t\tMap<String, ParameterInfo> parameters = new HashMap<>();\n\t\tmodelValueResolver.forEachParameterInfo((parameter, valueResolver) -> {\n\t\t\tParameterInfo existingParameter = parameters.get(parameter.getName());\n\t\t\tif (existingParameter != null) {\n\t\t\t\tif (existingParameter == parameter) {\n\t\t\t\t\t//OK, this parameter is already there\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"There is already a parameter: \" + parameter.getName());\n\t\t\t}\n\t\t\tparameters.put(parameter.getName(), parameter);\n\t\t});\n\t\treturn Collections.unmodifiableMap(parameters);\n\t}\n\n\t/**\n\t * @return a {@link Generator}, which can be used to generate a code based on this {@link Pattern}\n\t */\n\tpublic Generator generator() {\n\t\treturn new DefaultGenerator(factory, modelValueResolver).setAddGeneratedBy(addGeneratedBy);\n\t}\n\n\t/**\n\t * Finds all target program sub-trees that correspond to a template\n\t * and calls consumer.accept(Match)\n\t * @param input the root of to be searched AST\n\t * @param consumer the receiver of matches\n\t */\n\tpublic void forEachMatch(Object input, CtConsumer<Match> consumer) {\n\t\tif (input == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (input.getClass().isArray()) {\n\t\t\tinput = Arrays.asList((Object[]) input);\n\t\t}\n\n\t\tMatchingScanner scanner = new MatchingScanner(modelValueResolver, consumer);\n\t\tif (input instanceof Collection<?>) {\n\t\t\tscanner.scan(null, (Collection<CtElement>) input);\n\t\t} else if (input instanceof Map) {\n\t\t\tscanner.scan(null, (Map<String, ?>) input);\n\t\t} else {\n\t\t\tscanner.scan(null, (CtElement) input);\n\t\t}\n\t}\n\n\t/**\n\t * Finds all target program sub-trees that correspond to this pattern\n\t * and returns them.\n\t * @param root the root of to be searched AST. It can be a CtElement or List, Set, Map of CtElements\n\t * @return List of {@link Match}\n\t */\n\tpublic List<Match> getMatches(CtElement root) {\n\t\tList<Match> matches = new ArrayList<>();\n\t\tforEachMatch(root, match -> {\n\t\t\tmatches.add(match);\n\t\t});\n\t\treturn matches;\n\t}\n\n\t/**\n\t * @param addParameterComments if true then it adds comments with parameter names\n\t * @return pattern printed as java sources\n\t */\n\tpublic String print(boolean addParameterComments) {\n\t\treturn new PatternPrinter().setPrintParametersAsComments(addParameterComments).printNode(modelValueResolver);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn modelValueResolver.toString();\n\t}\n\n\tboolean isAddGeneratedBy() {\n\t\treturn addGeneratedBy;\n\t}\n\n\t// not public because pattern should be immutable (only configured through PatternBuilder\n\tPattern setAddGeneratedBy(boolean addGeneratedBy) {\n\t\tthis.addGeneratedBy = addGeneratedBy;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "pattern/Match.java",
      "weight" : 62.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Represents a single match of {@link Pattern}\n */\npublic class Match {\n\tprivate final List<?> matchingElements;\n\tprivate final ImmutableMap parameters;\n\n\tpublic Match(List<?> matches, ImmutableMap parameters) {\n\t\tthis.parameters = parameters;\n\t\tthis.matchingElements = matches;\n\t}\n\t/**\n\t * @return {@link List} of elements, which match to the Pattern.\n\t * Use {@link #getMatchingElement()} if the {@link Pattern} matches single root element.\n\t * But when {@link Pattern} contains sequence of root elements, then this is the right way how to get them all\n\t */\n\tpublic List<CtElement> getMatchingElements() {\n\t\treturn getMatchingElements(CtElement.class);\n\t}\n\t/**\n\t * Same like {@link #getMatchingElement()} but additionally it checks that each matching element is instance of `clazz`\n\t * @param clazz the required type of all elements.\n\t * @return a {@link List} typed to `clazz` or throws {@link SpoonException} if Pattern matched different elements\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> List<T> getMatchingElements(Class<T> clazz) {\n\t\tfor (Object object : matchingElements) {\n\t\t\tif (object != null && clazz.isInstance(object) == false) {\n\t\t\t\tthrow new SpoonException(\"Match contains a \" + object.getClass() + \" which cannot be cast to \" + clazz);\n\t\t\t}\n\t\t}\n\t\treturn (List<T>) matchingElements;\n\t}\n\n\t/**\n\t * @return a matching element of a {@link Pattern}\n\t * It fails if {@link Pattern} is designed to match sequence of elements. In such case use {@link #getMatchingElements()}\n\t */\n\tpublic CtElement getMatchingElement() {\n\t\treturn getMatchingElement(CtElement.class, true);\n\t}\n\t/**\n\t * Same like {@link #getMatchingElement()}, but checks that matching element is expected class and casts returned value to that type\n\t * @param clazz required type\n\t * @return matched element cast to `clazz`\n\t */\n\tpublic <T> T getMatchingElement(Class<T> clazz) {\n\t\treturn getMatchingElement(clazz, true);\n\t}\n\n\t/**\n\t * @param clazz the Class of returned element. throws SpoonException if matching value is not assignable to `clazz`\n\t * @param failIfMany if there is more then one matching element and `failIfMany` == true, then it throws SpoonException.\n\t * @return first matching element\n\t */\n\tprivate <T> T getMatchingElement(Class<T> clazz, boolean failIfMany) {\n\t\tif (matchingElements.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tif (failIfMany && matchingElements.size() != 1) {\n\t\t\tthrow new SpoonException(\"There is more then one match\");\n\t\t}\n\t\tObject object = matchingElements.get(0);\n\t\tif (object != null && clazz.isInstance(object) == false) {\n\t\t\tthrow new SpoonException(\"Match contains a \" + object.getClass() + \" which cannot be cast to \" + clazz);\n\t\t}\n\t\treturn clazz.cast(object);\n\t}\n\n\t/**\n\t * @return {@link ImmutableMap} with values of {@link Pattern} parameters, which fits to current match\n\t */\n\tpublic ImmutableMap getParameters() {\n\t\treturn parameters;\n\t}\n\t/**\n\t * @return {@link Map} with values of {@link Pattern} parameters, which fits to current match\n\t */\n\tpublic Map<String, Object> getParametersMap() {\n\t\treturn parameters.asMap();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"{\\n\");\n\t\tsb.append(parameters.toString());\n\t\tsb.append(\"\\n}\\n----------\");\n\t\tfor (int i = 0; i < matchingElements.size(); i++) {\n\t\t\tsb.append(\"\\n\").append(i + 1).append(\") \").append(matchingElements.get(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    }, {
      "name" : "pattern/InlinedStatementConfigurator.java",
      "weight" : 142.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport static spoon.pattern.PatternBuilder.bodyToStatements;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.node.ForEachNode;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.node.ParameterNode;\nimport spoon.pattern.internal.node.PrimitiveMatcher;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.pattern.internal.node.SwitchNode;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.CtAbstractVisitor;\nimport spoon.support.Experimental;\n\n/**\n * Builds inline statements of Pattern\n *\n * For example if the `for` statement in this pattern model\n * <pre><code>\n * for(Object x : $iterable$) {\n *\tSystem.out.println(x);\n * }\n * </code></pre>\n * is configured as inline statement and a Pattern is substituted\n * using parameter <code>$iterable$ = new String[]{\"A\", \"B\", \"C\"}</code>\n * then pattern generated this code\n * <pre><code>\n * System.out.println(\"A\");\n * System.out.println(\"B\");\n * System.out.println(\"C\");\n * </code></pre>\n * because inline statements are executed during substitution process and are not included in generated result.\n *\n * Main documentation at http://spoon.gforge.inria.fr/pattern.html.\n */\n@Experimental\npublic class InlinedStatementConfigurator {\n\n\tprivate final PatternBuilder patternBuilder;\n\tprivate boolean failOnMissingParameter = true;\n\tprivate ConflictResolutionMode conflictResolutionMode = ConflictResolutionMode.FAIL;\n\n\tpublic InlinedStatementConfigurator(PatternBuilder patternBuilder) {\n\t\tthis.patternBuilder = patternBuilder;\n\t}\n\n\t/**\n\t * @return current {@link ConflictResolutionMode}\n\t */\n\tpublic ConflictResolutionMode getConflictResolutionMode() {\n\t\treturn conflictResolutionMode;\n\t}\n\n\t/**\n\t * Defines what happens when before explicitly added {@link RootNode} has to be replaced by another {@link RootNode}\n\t * @param conflictResolutionMode to be applied mode\n\t * @return this to support fluent API\n\t */\n\tpublic InlinedStatementConfigurator setConflictResolutionMode(ConflictResolutionMode conflictResolutionMode) {\n\t\tthis.conflictResolutionMode = conflictResolutionMode;\n\t\treturn this;\n\t}\n\n\t/**\n\t * marks all CtIf and CtForEach whose expression contains a variable reference named `variableName` as inline statement.\n\t * @param variableName to be searched variable name\n\t * @return this to support fluent API\n\t */\n\tpublic InlinedStatementConfigurator inlineIfOrForeachReferringTo(String variableName) {\n\t\tpatternBuilder.patternQuery\n\t\t\t.filterChildren((CtVariableReference varRef) -> variableName.equals(varRef.getSimpleName()))\n\t\t\t.forEach(this::byElement);\n\t\treturn this;\n\t}\n\n\t/**\n\t * marks all CtIf and CtForEach whose expression contains element as inline statement.\n\t * @param element a child of CtIf or CtForEach\n\t * @return this to support fluent API\n\t */\n\tInlinedStatementConfigurator byElement(CtElement element) {\n\t\tCtStatement stmt = element instanceof CtStatement ? (CtStatement) element : element.getParent(CtStatement.class);\n\t\t//called for first parent statement of all current parameter substitutions\n\t\tstmt.accept(new CtAbstractVisitor() {\n\t\t\t@Override\n\t\t\tpublic void visitCtForEach(CtForEach foreach) {\n\t\t\t\tmarkAsInlined(foreach);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void visitCtIf(CtIf ifElement) {\n\t\t\t\tmarkAsInlined(ifElement);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * marks {@link CtForEach} as inline statement.\n\t * @param foreach to be marked {@link CtForEach} element\n\t * @return this to support fluent API\n\t */\n\tpublic InlinedStatementConfigurator markAsInlined(CtForEach foreach) {\n\t\t//detect meta elements by different way - e.g. comments?\n\t\tRootNode vr = patternBuilder.getPatternNode(foreach.getExpression());\n\t\tif ((vr instanceof PrimitiveMatcher) == false) {\n\t\t\tthrow new SpoonException(\"Each inline `for(x : iterable)` statement must have defined pattern parameter for `iterable` expression\");\n\t\t}\n\t\tPrimitiveMatcher parameterOfExpression = (PrimitiveMatcher) vr;\n\t\tForEachNode mvr = new ForEachNode();\n\t\tmvr.setIterableParameter(parameterOfExpression);\n\t\tCtLocalVariable<?> lv = foreach.getVariable();\n\t\t//create locally unique name of this local parameter\n\t\tString paramName = lv.getSimpleName();\n\t\tpatternBuilder.configureLocalParameters(pb -> {\n\t\t\tpb.parameter(paramName).byVariable(lv);\n\t\t\tmvr.setLocalParameter(pb.getCurrentParameter());\n\t\t});\n\t\tmvr.setNestedModel(patternBuilder.getPatternNode(foreach, CtRole.BODY, CtRole.STATEMENT));\n\t\t/*\n\t\t * create Substitution request for whole `foreach`,\n\t\t * resolve the expressions at substitution time\n\t\t * and substitute the body of `foreach` as subpattern\n\t\t * 0 or more times - once for each value of Iterable expression.\n\t\t */\n\t\tpatternBuilder.setNodeOfElement(foreach, mvr, conflictResolutionMode);\n\t\treturn this;\n\t}\n\n\t/**\n\t * marks {@link CtIf} as inline statement.\n\t * @param ifElement to be marked {@link CtIf} element\n\t * @return this to support fluent API\n\t */\n\tpublic InlinedStatementConfigurator markAsInlined(CtIf ifElement) {\n\t\tSwitchNode osp = new SwitchNode();\n\t\tboolean[] canBeInline = { true };\n\t\tforEachIfCase(ifElement, (expression, block) -> {\n\t\t\t//detect meta elements by different way - e.g. comments?\n\t\t\tif (expression != null) {\n\t\t\t\t//expression is not null, it is: if(expression) {}\n\t\t\t\tRootNode vrOfExpression = patternBuilder.getPatternNode(expression);\n\t\t\t\tif (vrOfExpression instanceof ParameterNode == false) {\n\t\t\t\t\tif (failOnMissingParameter) {\n\t\t\t\t\t\tthrow new SpoonException(\"Each inline `if` statement must have defined pattern parameter in expression. If you want to ignore this, then call InlinedStatementConfigurator#setFailOnMissingParameter(false) first.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcanBeInline[0] = false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vrOfExpression instanceof PrimitiveMatcher) {\n\t\t\t\t\tosp.addCase((PrimitiveMatcher) vrOfExpression, getPatternNode(bodyToStatements(block)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new SpoonException(\"Inline `if` statement have defined single value pattern parameter in expression. But there is \" + vrOfExpression.getClass().getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//expression is null, it is: else {}\n\t\t\t\tosp.addCase(null, getPatternNode(bodyToStatements(block)));\n\t\t\t}\n\t\t});\n\t\tif (canBeInline[0]) {\n\t\t\t/*\n\t\t\t * create Substitution request for whole `if`,\n\t\t\t * resolve the expressions at substitution time and substitute only the `if` then/else statements, not `if` itself.\n\t\t\t */\n\t\t\tpatternBuilder.setNodeOfElement(ifElement, osp, conflictResolutionMode);\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate ListOfNodes getPatternNode(List<? extends CtElement> template) {\n\t\tList<RootNode> nodes = new ArrayList<>(template.size());\n\t\tfor (CtElement element : template) {\n\t\t\tnodes.add(patternBuilder.getPatternNode(element));\n\t\t}\n\t\treturn new ListOfNodes(nodes);\n\t}\n\n\t/**\n\t * calls function once for each expression/then block and at the end calls function for last else block.\n\t *\n\t * @param ifElement\n\t * @param consumer\n\t * @return true if all function calls returns true or if there is no function call\n\t */\n\tprivate void forEachIfCase(CtIf ifElement, BiConsumer<CtExpression<Boolean>, CtStatement> consumer) {\n\t\tconsumer.accept(ifElement.getCondition(), ifElement.getThenStatement());\n\t\tCtStatement elseStmt = getElseIfStatement(ifElement.getElseStatement());\n\t\tif (elseStmt instanceof CtIf) {\n\t\t\t//another else if case\n\t\t\tforEachIfCase((CtIf) elseStmt, consumer);\n\t\t} else if (elseStmt != null) {\n\t\t\t//last else\n\t\t\tconsumer.accept(null, elseStmt);\n\t\t}\n\t}\n\n\tprivate CtStatement getElseIfStatement(CtStatement elseStmt) {\n\t\tif (elseStmt instanceof CtBlock<?>) {\n\t\t\tCtBlock<?> block = (CtBlock<?>) elseStmt;\n\t\t\tif (block.isImplicit()) {\n\t\t\t\tList<CtStatement> stmts = block.getStatements();\n\t\t\t\tif (stmts.size() == 1) {\n\t\t\t\t\tif (stmts.get(0) instanceof CtIf) {\n\t\t\t\t\t\treturn stmts.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn elseStmt;\n\t}\n\n\tpublic boolean isFailOnMissingParameter() {\n\t\treturn failOnMissingParameter;\n\t}\n\n\t/**\n\t * @param failOnMissingParameter set true if it should fail when some statement cannot be handled as inline\n\t * set false if ssuch statement should be kept as part of template.\n\t * @return this to support fluent API\n\t */\n\tpublic InlinedStatementConfigurator setFailOnMissingParameter(boolean failOnMissingParameter) {\n\t\tthis.failOnMissingParameter = failOnMissingParameter;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/SubstitutionRequestProvider.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport spoon.pattern.internal.node.RootNode;\n\n/**\n * Maps AST model object to the {@link RootNode}\n */\npublic interface SubstitutionRequestProvider {\n\t/**\n\t * @param object a node from the Pattern model to be matched\n\t * @return {@link RootNode}, which has to be used to match `object` from model of {@link SubstitutionRequestProvider}\n\t */\n\tRootNode getTemplateValueResolver(Object object);\n}\n"
    }, {
      "name" : "pattern/internal/matcher/TobeMatched.java",
      "weight" : 136.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.matcher;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.BiFunction;\n\nimport spoon.SpoonException;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Describes what next has to be matched.\n * It consists of current `parameters` represented by {@link ImmutableMap}\n * and by a to be matched target elements.\n * See children of {@link TobeMatched} for supported collections of target elements.\n */\npublic class TobeMatched {\n\t//TODO remove parameters. Send them individually into matching methods and return MatchResult\n\tprivate final ImmutableMap parameters;\n\t//Use list for everything because Spoon uses Sets with predictable iteration order\n\tprivate final List<?> targets;\n\tprivate final boolean ordered;\n\n\t/**\n\t * @param parameters to be matched parameters\n\t * @param containerKind the type of container in `target` value\n\t * @param target the to be matched target data. List, Set, Map or single value\n\t * @return new instance of {@link TobeMatched}, which contains `parameters` and `target` mapped using containerKind\n\t */\n\tpublic static TobeMatched create(ImmutableMap parameters, ContainerKind containerKind, Object target) {\n\t\tswitch (containerKind) {\n\t\tcase LIST:\n\t\t\treturn new TobeMatched(parameters, (List<Object>) target, true);\n\t\tcase SET:\n\t\t\treturn new TobeMatched(parameters, (Set<Object>) target, false);\n\t\tcase MAP:\n\t\t\treturn new TobeMatched(parameters, (Map<String, Object>) target);\n\t\tcase SINGLE:\n\t\t\treturn new TobeMatched(parameters, target);\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected RoleHandler containerKind: \" + containerKind);\n\t}\n\n\tprivate TobeMatched(ImmutableMap parameters, Object target) {\n\t\t//It is correct to put whole container as single value in cases when ParameterNode matches agains whole attribute value\n\t\tthis.parameters = parameters;\n\t\t//make a copy of origin collection, because it might be modified during matching process (by a refactoring algorithm)\n\t\tthis.targets = Collections.singletonList(target);\n\t\tthis.ordered = true;\n\t}\n\t/**\n\t * @param parameters current parameters\n\t * @param targets List or Set of to be matched targets\n\t * @param ordered defines the way how targets are matched. If true then first target is matched with first ValueResolver.\n\t * If false then all targets are tried with first ValueResolver.\n\t */\n\tprivate TobeMatched(ImmutableMap parameters, Collection<?> targets, boolean ordered) {\n\t\tthis.parameters = parameters;\n\t\t//make a copy of origin collection, because it might be modified during matching process (by a refactoring algorithm)\n\t\tthis.targets = targets == null ? Collections.emptyList() : Collections.unmodifiableList(new ArrayList<>(targets));\n\t\tthis.ordered = ordered;\n\t}\n\n\tprivate TobeMatched(ImmutableMap parameters, Map<String, ?> targets) {\n\t\tthis.parameters = parameters;\n\t\t//make a copy of origin collection, because it might be modified during matching process (by a refactoring algorithm)\n\t\tthis.targets = targets == null ? Collections.emptyList() : Collections.unmodifiableList(new ArrayList<>(targets.entrySet()));\n\t\tthis.ordered = false;\n\t}\n\n\tprivate TobeMatched(ImmutableMap parameters, List<?> targets, boolean ordered, int tobeRemovedIndex) {\n\t\tthis.parameters = parameters;\n\t\tthis.targets = new ArrayList<>(targets);\n\t\tif (tobeRemovedIndex >= 0) {\n\t\t\tthis.targets.remove(tobeRemovedIndex);\n\t\t}\n\t\tthis.ordered = ordered;\n\t}\n\n\t/**\n\t * @return parameters of last successful match.\n\t */\n\tpublic ImmutableMap getParameters() {\n\t\treturn parameters;\n\t}\n\n\t/**\n\t * @return {@link List} of to be matched targets, which\n\t * A) have to be matched by current matching step\n\t * B) remained after matching of all template nodes\n\t */\n\tpublic List<?> getTargets() {\n\t\treturn targets;\n\t}\n\n\t/**\n\t * @param tobeMatchedTargets {@link TobeMatched} with targets, which didn't matched yet. These which has to be matched next.\n\t * @return matched targets. It means these targets, which are not contained in `notMatchedTargets`\n\t */\n\tpublic List<?> getMatchedTargets(TobeMatched tobeMatchedTargets) {\n\t\tint nrOfMatches = getTargets().size() - tobeMatchedTargets.getTargets().size();\n\t\tif (nrOfMatches >= 0) {\n\t\t\tif (nrOfMatches == 0) {\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t\tList<Object> matched = new ArrayList(nrOfMatches);\n\t\t\tfor (Object target : getTargets()) {\n\t\t\t\tif (containsSame(tobeMatchedTargets.getTargets(), target)) {\n\t\t\t\t\t//this origin target is still available in this to be matched targets\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//this origin target is NOT available in this to be matched targets. It means it matched\n\t\t\t\tmatched.add(target);\n\t\t\t}\n\t\t\tif (matched.size() == nrOfMatches) {\n\t\t\t\treturn matched;\n\t\t\t}\n\t\t}\n\t\tthrow new SpoonException(\"Invalid input `originTobeMatched`\");\n\t}\n\n\tprivate boolean containsSame(List<?> items, Object object) {\n\t\tfor (Object item : items) {\n\t\t\tif (item == object) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return true if there is anything to match.\n\t */\n\tpublic boolean hasTargets() {\n\t\treturn !targets.isEmpty();\n\t}\n\n\t/**\n\t * Makes a copy of this match context with the same targets, but with new `parameters`\n\t * @param newParams to be used parameters\n\t * @return copy of {@link TobeMatched} with new parameters\n\t */\n\tpublic TobeMatched copyAndSetParams(ImmutableMap newParams) {\n\t\tif (parameters == newParams) {\n\t\t\treturn this;\n\t\t}\n\t\treturn new TobeMatched(newParams, targets, ordered, -1);\n\t}\n\n\t/**\n\t * Calls matcher algorithm to match target item\n\t * @param matcher a matching algorithm\n\t * @return {@link TobeMatched} with List of remaining (to be matched) targets or null if there is no match\n\t */\n\tpublic TobeMatched matchNext(BiFunction<Object, ImmutableMap, ImmutableMap> matcher) {\n\t\tif (targets.isEmpty()) {\n\t\t\t//no target -> no match\n\t\t\treturn null;\n\t\t}\n\t\tif (ordered) {\n\t\t\t//handle ordered list of targets - match with first target\n\t\t\tImmutableMap parameters = matcher.apply(targets.get(0), getParameters());\n\t\t\tif (parameters != null) {\n\t\t\t\t//return remaining match\n\t\t\t\treturn removeTarget(parameters, 0);\n\t\t\t}\n\t\t\treturn null;\n\t\t} else {\n\t\t\t//handle un-ordered list of targets - match with all targets, stop at first matching\n\t\t\tint idxOfMatch = 0;\n\t\t\twhile (idxOfMatch < targets.size()) {\n\t\t\t\tImmutableMap parameters = matcher.apply(targets.get(idxOfMatch), getParameters());\n\t\t\t\tif (parameters != null) {\n\t\t\t\t\treturn removeTarget(parameters, idxOfMatch);\n\t\t\t\t}\n\t\t\t\t//try to match next target\n\t\t\t\tidxOfMatch++;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * @param remainingMatch the {@link TobeMatched} whose parameters has to be returned\n\t * @return parameters from `remainingMatch`, if it exists. Else returns null\n\t */\n\tpublic static ImmutableMap getMatchedParameters(TobeMatched remainingMatch) {\n\t\treturn remainingMatch == null ? null : remainingMatch.getParameters();\n\t}\n\t/**\n\t * @param idxOfTobeRemovedTarget index of to be removed target\n\t * @return new {@link TobeMatched} without the target on the index `idxOfTobeRemovedTarget`\n\t */\n\tpublic TobeMatched removeTarget(int idxOfTobeRemovedTarget) {\n\t\treturn removeTarget(parameters, idxOfTobeRemovedTarget);\n\t}\n\tpublic TobeMatched removeTarget(ImmutableMap parameters, int idxOfTobeRemovedTarget) {\n\t\treturn new TobeMatched(parameters, targets, ordered, idxOfTobeRemovedTarget);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Parameters:\\n----------------\\n\")\n\t\t.append(parameters)\n\t\t.append(\"\\nTobe matched target elements\\n-----------------------\\n\");\n\t\tfor (int i = 0; i < targets.size(); i++) {\n\t\t\tsb.append('\\n').append(i + 1).append('/').append(targets.size()).append(\": \").append(targets.get(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/matcher/MatchingScanner.java",
      "weight" : 95.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.matcher;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.pattern.Match;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.support.util.ImmutableMapImpl;\n\n/**\n * Represents a Match of TemplateMatcher\n */\npublic class MatchingScanner extends EarlyTerminatingScanner<Void> {\n\tprivate final ListOfNodes pattern;\n\tprivate CtConsumer<? super Match> matchConsumer;\n\n\tpublic MatchingScanner(ListOfNodes pattern, CtConsumer<? super Match> matchConsumer) {\n\t\tthis.pattern = pattern;\n\t\tthis.matchConsumer = matchConsumer;\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, CtElement element) {\n\t\t//This is called only for elements which are in single value attribute. Like `CtType#superClass`\n\t\tif (searchMatchInList(role, Collections.singletonList(element), false) == 0) {\n\t\t\tsuper.scan(role, element);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, Collection<? extends CtElement> elements) {\n\t\tif (elements == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (elements instanceof List<?>) {\n\t\t\tsearchMatchInList(role, (List<? extends CtElement>) elements, true);\n\t\t} else if (elements instanceof Set<?>) {\n\t\t\tsearchMatchInSet(role, (Set<? extends CtElement>) elements);\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected Collection type \" + elements.getClass());\n\t\t}\n\t}\n\n\tprivate int searchMatchInList(CtRole role, List<? extends CtElement> list, boolean scanChildren) {\n\t\tint matchCount = 0;\n\t\tif (!list.isEmpty()) {\n\t\t\tTobeMatched tobeMatched = TobeMatched.create(\n\t\t\t\t\tnew ImmutableMapImpl(),\n\t\t\t\t\tContainerKind.LIST,\n\t\t\t\t\tlist);\n\t\t\twhile (tobeMatched.hasTargets()) {\n\t\t\t\tTobeMatched nextTobeMatched = pattern.matchAllWith(tobeMatched);\n\t\t\t\tif (nextTobeMatched != null) {\n\t\t\t\t\tList<?> matchedTargets = tobeMatched.getMatchedTargets(nextTobeMatched);\n\t\t\t\t\tif (!matchedTargets.isEmpty()) {\n\t\t\t\t\t\tmatchCount++;\n\t\t\t\t\t\t//send information about match to client\n\t\t\t\t\t\tmatchConsumer.accept(new Match(matchedTargets, nextTobeMatched.getParameters()));\n\t\t\t\t\t\t//do not scan children of matched elements. They already matched, so we must not scan them again\n\t\t\t\t\t\t//use targets of last match together with new parameters for next match\n\t\t\t\t\t\ttobeMatched = nextTobeMatched.copyAndSetParams(new ImmutableMapImpl());\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} //else the template matches nothing. Understand it as no match in this context\n\t\t\t\t}\n\t\t\t\tif (scanChildren) {\n\t\t\t\t\t//scan children of each not matched element too\n\t\t\t\t\tsuper.scan(role, tobeMatched.getTargets().get(0));\n\t\t\t\t}\n\t\t\t\t//try match with sub list starting on second element\n\t\t\t\ttobeMatched = tobeMatched.removeTarget(0);\n\t\t\t}\n\t\t}\n\t\treturn matchCount;\n\t}\n\n\tprivate void searchMatchInSet(CtRole role, Set<? extends CtElement> set) {\n\t\tif (!set.isEmpty()) {\n\t\t\t//copy targets, because it might be modified by call of matchConsumer, when refactoring spoon model\n\t\t\t//use List, because Spoon uses Sets with predictable order - so keep the order\n\t\t\tTobeMatched tobeMatched = TobeMatched.create(\n\t\t\t\t\tnew ImmutableMapImpl(),\n\t\t\t\t\tContainerKind.SET,\n\t\t\t\t\tset);\n\t\t\twhile (tobeMatched.hasTargets()) {\n\t\t\t\tTobeMatched nextTobeMatched = pattern.matchAllWith(tobeMatched);\n\t\t\t\tif (nextTobeMatched != null) {\n\t\t\t\t\tList<?> matchedTargets = tobeMatched.getMatchedTargets(nextTobeMatched);\n\t\t\t\t\tif (!matchedTargets.isEmpty()) {\n\t\t\t\t\t\t//send information about match to client\n\t\t\t\t\t\tmatchConsumer.accept(new Match(matchedTargets, nextTobeMatched.getParameters()));\n\t\t\t\t\t\t//do not scan children of matched elements. They already matched, so we must not scan them again\n\t\t\t\t\t\ttobeMatched = nextTobeMatched;\n\t\t\t\t\t\t//we have found a match. Try next match\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} //else the template matches nothing. Understand it as no more match in this context\n\t\t\t\t}\n\t\t\t\t//there was no match. Do not try it again\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//scan remaining not matched items of the Set\n\t\t\tfor (Object object : tobeMatched.getTargets()) {\n\t\t\t\t//scan children of each not matched element too\n\t\t\t\tsuper.scan(role, object);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, Map<String, ? extends CtElement> elements) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.scan(role, elements);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/matcher/ChainOfMatchersImpl.java",
      "weight" : 39.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.matcher;\n\nimport java.util.List;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.node.RootNode;\n\n/**\n * Chain of {@link RootNode}s. {@link RootNode}s are processed in the same order as they were added into chain\n */\npublic class ChainOfMatchersImpl implements Matchers {\n\tprivate final RootNode firstMatcher;\n\tprivate final Matchers next;\n\n\t/**\n\t * @param items\n\t * @param next\n\t * @return new {@link ChainOfMatchersImpl} which starts with items nodes and continues with `next` {@link Matchers}\n\t */\n\tpublic static Matchers create(List<? extends RootNode> items, Matchers next) {\n\t\treturn createFromList(next, items, 0);\n\t}\n\tprivate static Matchers createFromList(Matchers next, List<? extends RootNode> items, int idx) {\n\t\tRootNode matcher;\n\t\twhile (true) {\n\t\t\tif (idx >= items.size()) {\n\t\t\t\treturn next;\n\t\t\t}\n\t\t\tmatcher = items.get(idx);\n\t\t\tif (matcher != null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\treturn new ChainOfMatchersImpl(matcher, createFromList(next, items, idx + 1));\n\t}\n\n\tprivate ChainOfMatchersImpl(RootNode firstMatcher, Matchers next) {\n\t\tif (firstMatcher == null) {\n\t\t\tthrow new SpoonException(\"The firstMatcher Node MUST NOT be null\");\n\t\t}\n\t\tthis.firstMatcher = firstMatcher;\n\t\tif (next == null) {\n\t\t\tthrow new SpoonException(\"The next Node MUST NOT be null\");\n\t\t}\n\t\tthis.next = next;\n\t}\n\n\t@Override\n\tpublic TobeMatched matchAllWith(TobeMatched targets) {\n\t\treturn firstMatcher.matchTargets(targets, next);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/matcher/Matchers.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.matcher;\n\nimport spoon.pattern.internal.node.RootNode;\n\n/**\n * A container of {@link RootNode}s.\n */\npublic interface Matchers {\n\n\t/**\n\t * Matches all matchers of this {@link Matchers} instance with `targets`\n\t * @param targets to be matched target nodes and input parameters\n\t * @return {@link TobeMatched} with targets which remained after all {@link RootNode}s were matched + matched parameters\n\t */\n\tTobeMatched matchAllWith(TobeMatched targets);\n}\n"
    }, {
      "name" : "pattern/internal/ValueConvertorImpl.java",
      "weight" : 132.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport java.util.List;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.visitor.SignaturePrinter;\n\n/**\n * Converts the individual parameter values to required type\n */\npublic class ValueConvertorImpl implements ValueConvertor {\n\n\tpublic ValueConvertorImpl() {\n\t}\n\n\t@Override\n\tpublic <T> T getValueAs(Factory factory, String parameterName, Object value, Class<T> valueClass) {\n\t\tif (valueClass.isInstance(value)) {\n\t\t\treturn cloneIfNeeded(valueClass.cast(value));\n\t\t}\n\t\tif (CtExpression.class.isAssignableFrom(valueClass)) {\n\t\t\tif (value instanceof Class) {\n\t\t\t\treturn (T) factory.Code().createClassAccess(factory.Type().createReference((Class) value));\n\t\t\t}\n\t\t\tif (value instanceof CtTypeReference) {\n\t\t\t\t//convert type reference into code element as class access\n\t\t\t\tCtTypeReference<?> tr = (CtTypeReference<?>) value;\n\t\t\t\treturn (T) factory.Code().createClassAccess(tr);\n\t\t\t}\n\t\t\tif (value == null || value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Character) {\n\t\t\t\t//convert String to code element as Literal\n\t\t\t\treturn (T) factory.Code().createLiteral(value);\n\t\t\t}\n\t\t\tif (value.getClass().isArray()) {\n\t\t\t\tClass<?> itemClass = value.getClass().getComponentType();\n\t\t\t\tif (CtExpression.class.isAssignableFrom(itemClass)) {\n\t\t\t\t\tCtNewArray<Object> arr = factory.Core().createNewArray().setType(factory.Type().objectType());\n\t\t\t\t\tfor (CtExpression expr : (CtExpression[]) value) {\n\t\t\t\t\t\tarr.addElement(expr);\n\t\t\t\t\t}\n\t\t\t\t\treturn (T) arr;\n\t\t\t\t}\n\t\t\t\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t\t\t\tCtNewArray<?> arr = factory.Core().createNewArray().setType(factory.Type().createArrayReference(itemClass.getName()));\n\t\t\t\tfor (Object v : (Object[]) value) {\n\t\t\t\t\tif (v == null || v instanceof String || v instanceof Number || v instanceof Boolean || v instanceof Character) {\n\t\t\t\t\t\t//convert String to code element as Literal\n\t\t\t\t\t\tarr.addElement(factory.Code().createLiteral(v));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new SpoonException(\"Parameter value item class: \" + v.getClass().getName() + \" cannot be converted to class is: \" + valueClass.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (T) arr;\n\t\t\t}\n\t\t}\n\t\tif (CtStatement.class.isAssignableFrom(valueClass)) {\n\t\t\tif (value == null) {\n\t\t\t\t//skip null statements\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (value instanceof List) {\n\t\t\t\tList list = (List) value;\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (list.size() == 1) {\n\t\t\t\t\treturn (T) list.get(0);\n\t\t\t\t}\n\t\t\t\tCtBlock block = factory.createBlock();\n\t\t\t\tblock.setImplicit(true);\n\t\t\t\tfor (CtStatement statement : ((Iterable<CtStatement>) value)) {\n\t\t\t\t\tblock.addStatement(statement);\n\t\t\t\t}\n\t\t\t\treturn (T) block;\n\t\t\t}\n\t\t}\n\t\tif (valueClass.equals(String.class)) {\n\t\t\tif (value instanceof CtNamedElement) {\n\t\t\t\treturn (T) ((CtNamedElement) value).getSimpleName();\n\t\t\t} else if (value instanceof CtReference) {\n\t\t\t\treturn (T) ((CtReference) value).getSimpleName();\n\t\t\t} else if (value instanceof Class) {\n\t\t\t\treturn (T) ((Class) value).getSimpleName();\n\t\t\t} else if (value instanceof CtInvocation) {\n\t\t\t\treturn (T) getShortSignatureForJavadoc(((CtInvocation<?>) value).getExecutable());\n\t\t\t} else if (value instanceof CtExecutableReference) {\n\t\t\t\treturn (T) getShortSignatureForJavadoc((CtExecutableReference<?>) value);\n\t\t\t} else if (value instanceof CtExecutable) {\n\t\t\t\treturn (T) getShortSignatureForJavadoc(((CtExecutable<?>) value).getReference());\n\t\t\t} else if (value instanceof CtLiteral) {\n\t\t\t\tObject val = ((CtLiteral<Object>) value).getValue();\n\t\t\t\treturn val == null ? null : (T) val.toString();\n\t\t\t} else if (value instanceof Enum) {\n\t\t\t\treturn (T) ((Enum) value).name();\n\t\t\t} else if (value == null) {\n\t\t\t\tthrow new SpoonException(\"Missing parameter value for parameter `\" + parameterName + \"`\");\n\t\t\t}\n\t\t\tthrow new SpoonException(\"Parameter value has unexpected class: \" + value.getClass().getName() + \", whose conversion to String is not supported\");\n\t\t}\n\t\tif (CtTypeReference.class.isAssignableFrom(valueClass)) {\n\t\t\tif (value == null) {\n\t\t\t\tthrow new SpoonException(\"The null value is not valid substitution for CtTypeReference\");\n\t\t\t}\n\t\t\tif (value instanceof Class) {\n\t\t\t\treturn (T) factory.Type().createReference((Class<?>) value);\n\t\t\t} else if (value instanceof CtTypeReference) {\n\t\t\t\treturn (T) ((CtTypeReference<?>) value).clone();\n\t\t\t} else if (value instanceof CtType) {\n\t\t\t\treturn (T) ((CtType<?>) value).getReference();\n\t\t\t} else if (value instanceof String) {\n\t\t\t\treturn (T) factory.Type().createReference((String) value);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"unsupported reference substitution\");\n\t\t\t}\n\t\t}\n\n\t\tthrow new SpoonException(\"Parameter value class: \" + value.getClass().getName() + \" cannot be converted to class is: \" + valueClass.getName());\n\t}\n\n\t/*\n\t * return the typical Javadoc style link Foo#method(). The class name is not fully qualified.\n\t */\n\tprivate static String getShortSignatureForJavadoc(CtExecutableReference<?> ref) {\n\t\tSignaturePrinter sp = new SignaturePrinter();\n\t\tsp.writeNameAndParameters(ref);\n\t\treturn ref.getDeclaringType().getSimpleName() + CtExecutable.EXECUTABLE_SEPARATOR + sp.getSignature();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> T cloneIfNeeded(T value) {\n\t\tif (value instanceof CtElement) {\n\t\t\treturn (T) ((CtElement) value).clone();\n\t\t}\n\t\treturn value;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/PatternPrinter.java",
      "weight" : 214.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.function.Consumer;\n\nimport spoon.metamodel.Metamodel;\nimport spoon.metamodel.MetamodelConcept;\nimport spoon.metamodel.MetamodelProperty;\nimport spoon.pattern.internal.node.ConstantNode;\nimport spoon.pattern.internal.node.ElementNode;\nimport spoon.pattern.internal.node.InlineNode;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.node.ParameterNode;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.code.CtComment.CommentType;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.PrinterHelper;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Generates the source code corresponding to a Pattern's RootNode\n */\npublic class PatternPrinter extends DefaultGenerator {\n\n\tprivate static final Factory DEFAULT_FACTORY = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\n\tstatic {\n\t\tDEFAULT_FACTORY.getEnvironment().setCommentEnabled(true);\n\t}\n\n\tprivate List<ParamOnElement> params = new ArrayList<>();\n\tprivate boolean printParametersAsComments = true;\n\n\tpublic PatternPrinter() {\n\t\tsuper(DEFAULT_FACTORY, null);\n\t}\n\n\tpublic String printNode(RootNode node) {\n\t\tList<Object> generated = generateTargets(node, (ImmutableMap) null, null);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (Object ele : generated) {\n\t\t\tsb.append(ele.toString()).append(System.getProperty(\"line.separator\"));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(RootNode node, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tint firstResultIdx = result.getResults().size();\n\t\tif (node instanceof InlineNode) {\n\t\t\t//this is an inline node. Does not generate nodes normally, but generates origin inline statements\n\t\t\t((InlineNode) node).generateInlineTargets(this, result, parameters);\n\t\t} else {\n\t\t\tsuper.generateTargets(node, result, parameters);\n\t\t}\n\t\tT firstResult = getFirstResult(result, firstResultIdx);\n\t\tif (firstResult instanceof CtElement) {\n\t\t\tif (node instanceof ElementNode) {\n\t\t\t\tElementNode elementNode = (ElementNode) node;\n\t\t\t\tList<ParamOnElement> paramsOnElement = new ArrayList<>();\n\t\t\t\tfor (Map.Entry<MetamodelProperty, RootNode> e : elementNode.getRoleToNode().entrySet()) {\n\t\t\t\t\tMetamodelProperty mmField = e.getKey();\n\t\t\t\t\tforeachNode(e.getValue(), attrNode -> {\n\t\t\t\t\t\tif (attrNode instanceof ConstantNode || attrNode instanceof ElementNode) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//it is an attribute with an substitution\n\t\t\t\t\t\t//it will be added only if it is not already added linked to the CtElement\n\t\t\t\t\t\tparamsOnElement.add(new ParamOnElement((CtElement) firstResult, mmField.getRole(), attrNode));\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\taddParameterCommentTo((CtElement) firstResult, paramsOnElement.toArray(new ParamOnElement[0]));\n\t\t\t} else if (node instanceof ParameterNode) {\n\t\t\t\taddParameterCommentTo((CtElement) firstResult, new ParamOnElement((CtElement) firstResult, node));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void foreachNode(RootNode rootNode, Consumer<RootNode> consumer) {\n\t\tif (rootNode instanceof ListOfNodes) {\n\t\t\tListOfNodes list = (ListOfNodes) rootNode;\n\t\t\tfor (RootNode node : list.getNodes()) {\n\t\t\t\tforeachNode(node, consumer);\n\t\t\t}\n\t\t} else {\n\t\t\tconsumer.accept(rootNode);\n\t\t}\n\t}\n\n\tprivate boolean isCommentVisible(Object obj) {\n\t\tif (obj instanceof CtElement) {\n\t\t\tMetamodelConcept mmType = Metamodel.getInstance().getConcept((Class) obj.getClass());\n\t\t\tMetamodelProperty mmCommentField = mmType.getProperty(CtRole.COMMENT);\n\t\t\treturn mmCommentField != null && mmCommentField.isDerived() == false;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate <T> T getFirstResult(ResultHolder<T> result, int firstResultIdx) {\n\t\tList<T> results = result.getResults();\n\t\tif (firstResultIdx < results.size()) {\n\t\t\treturn results.get(firstResultIdx);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T> void getValueAs(ParameterInfo parameterInfo, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tObject obj = generatePatternParameterElement(parameterInfo, result.getRequiredClass());\n\t\tif (obj != null) {\n\t\t\tresult.addResult((T) obj);\n\t\t}\n\t}\n\n\tprivate void addParameterCommentTo(CtElement ele, ParamOnElement... paramsOnElement) {\n\t\tfor (ParamOnElement paramOnElement : paramsOnElement) {\n\t\t\tif (isNodeContained(paramOnElement.node) == false) {\n\t\t\t\tparams.add(paramOnElement);\n\t\t\t}\n\t\t}\n\t\tif (isPrintParametersAsComments() && isCommentVisible(ele) && !params.isEmpty()) {\n\t\t\tele.addComment(ele.getFactory().Code().createComment(getSubstitutionRequestsDescription(ele, params), CommentType.BLOCK));\n\t\t\tparams.clear();\n\t\t}\n\t}\n\n\tprivate boolean isNodeContained(RootNode node) {\n\t\tfor (ParamOnElement paramOnElement : params) {\n\t\t\tif (paramOnElement.node == node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates an element which will be printed in source code of pattern as marker of parameter\n\t * @param parameterInfo describes a pattern parameter to be printed\n\t * @param type class of the generated element\n\t * @return dummy template element, which represents a template type in source of generated Pattern.\n\t * Or null if potentialParameterMarker is not a marker of parameter\n\t */\n\tprivate <T> T generatePatternParameterElement(ParameterInfo parameterInfo, Class<T> type) {\n\t\tif (type != null) {\n\t\t\tif (type.isAssignableFrom(CtInvocation.class)) {\n\t\t\t\treturn (T) factory.createInvocation(factory.createThisAccess(factory.Type().objectType(), true), factory.createExecutableReference().setSimpleName(parameterInfo.getName()));\n\t\t\t}\n\t\t\tif (type.isAssignableFrom(CtLocalVariable.class)) {\n\t\t\t\treturn (T) factory.createLocalVariable(factory.Type().objectType(), parameterInfo.getName(), null);\n\t\t\t}\n\t\t\tif (type.isAssignableFrom(String.class)) {\n\t\t\t\treturn (T) parameterInfo.getName();\n\t\t\t}\n\t\t\tif (type.isAssignableFrom(CtTypeReference.class)) {\n\t\t\t\treturn (T) factory.Type().createReference(parameterInfo.getName());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static class ParamOnElement {\n\t\tfinal CtElement sourceElement;\n\t\tfinal RootNode node;\n\t\tfinal CtRole role;\n\t\tParamOnElement(CtElement sourceElement, RootNode node) {\n\t\t\tthis(sourceElement, null, node);\n\t\t}\n\t\tParamOnElement(CtElement sourceElement, CtRole role, RootNode node) {\n\t\t\tthis.sourceElement = sourceElement;\n\t\t\tthis.role = role;\n\t\t\tthis.node = node;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (role == null) {\n\t\t\t\treturn sourceElement.getClass().getName() + \": ${\" + node.toString() + \"}\";\n\t\t\t} else {\n\t\t\t\treturn sourceElement.getClass().getName() + \"/\" + role + \": \" + node.toString();\n\t\t\t}\n\t\t}\n\t}\n\tprivate String getSubstitutionRequestsDescription(CtElement ele, List<ParamOnElement> requestsOnPos) {\n\t\t//sort requestsOnPos by their path\n\t\tMap<String, ParamOnElement> reqByPath = new TreeMap<>();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (ParamOnElement reqPos : requestsOnPos) {\n\t\t\tsb.setLength(0);\n\t\t\tappendPathIn(sb, reqPos.sourceElement, ele);\n\t\t\tif (reqPos.role != null) {\n\t\t\t\tsb.append(\"/\").append(reqPos.role.getCamelCaseName());\n\t\t\t}\n\t\t\tString path = sb.toString();\n\t\t\treqByPath.put(path, reqPos);\n\t\t}\n\n\t\tPrinterHelper printer = new PrinterHelper(getFactory().getEnvironment());\n\t\t//all comments in Spoon are using \\n as separator\n\t\tprinter.setLineSeparator(\"\\n\");\n\t\tprinter.write(getElementTypeName(ele)).incTab();\n\t\tfor (Map.Entry<String, ParamOnElement> e : reqByPath.entrySet()) {\n\t\t\tprinter.writeln();\n\t\t\tprinter.write(e.getKey()).write('/');\n\t\t\tprinter.write(\" <= \").write(e.getValue().node.toString());\n\t\t}\n\t\treturn printer.toString();\n\t}\n\n\tprivate boolean appendPathIn(StringBuilder sb, CtElement element, CtElement parent) {\n\t\tif (element != parent && element != null) {\n\t\t\tCtRole roleInParent = element.getRoleInParent();\n\t\t\tif (roleInParent == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (appendPathIn(sb, element.getParent(), parent)) {\n\t\t\t\tsb.append(\"/\").append(getElementTypeName(element.getParent()));\n\t\t\t}\n\t\t\tsb.append(\".\").append(roleInParent.getCamelCaseName());\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic String getElementTypeName(CtElement element) {\n\t\tString name = element.getClass().getSimpleName();\n\t\tif (name.endsWith(\"Impl\")) {\n\t\t\treturn name.substring(0, name.length() - 4);\n\t\t}\n\t\treturn name;\n\t}\n\n\tpublic PatternPrinter setPrintParametersAsComments(boolean printParametersAsComments) {\n\t\tthis.printParametersAsComments = printParametersAsComments;\n\t\treturn this;\n\t}\n\n\tpublic boolean isPrintParametersAsComments() {\n\t\treturn printParametersAsComments;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/ListOfNodes.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.ChainOfMatchersImpl;\nimport spoon.pattern.internal.matcher.Matchers;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\n/**\n * List of {@link RootNode}s. The {@link RootNode}s are processed in same order like they were inserted in the list\n */\npublic class ListOfNodes extends AbstractNode {\n\tprotected List<RootNode> nodes;\n\n\tpublic ListOfNodes(List<RootNode> nodes) {\n\t\tthis.nodes = nodes;\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tfor (RootNode node : nodes) {\n\t\t\tnode.forEachParameterInfo(consumer);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tfor (RootNode node : nodes) {\n\t\t\tgenerator.generateTargets(node, result, parameters);\n\t\t}\n\t}\n\n\t@Override\n\tpublic TobeMatched matchTargets(TobeMatched targets, Matchers nextMatchers) {\n\t\treturn ChainOfMatchersImpl.create(nodes, nextMatchers).matchAllWith(targets);\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\tRootNode node = nodes.get(i);\n\t\t\tif (node == oldNode) {\n\t\t\t\tnodes.set(i, newNode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (node.replaceNode(oldNode, newNode)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @return {@link List} of {@link RootNode}s of this {@link ListOfNodes}\n\t */\n\tpublic List<RootNode> getNodes() {\n\t\treturn nodes;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/AbstractPrimitiveMatcher.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.internal.matcher.TobeMatched;\n\n/**\n * Delivers to be substituted value\n * Matches value\n */\nabstract class AbstractPrimitiveMatcher extends AbstractRepeatableMatcher implements PrimitiveMatcher {\n\n\tprotected AbstractPrimitiveMatcher() {\n\t}\n\n\n\t@Override\n\tpublic TobeMatched matchAllWith(TobeMatched tobeMatched) {\n\t\t//we are matching single CtElement or attribute value\n\t\treturn tobeMatched.matchNext((target, parameters) -> {\n\t\t\treturn matchTarget(target, tobeMatched.getParameters());\n\t\t});\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/ElementNode.java",
      "weight" : 279.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.SpoonException;\nimport spoon.metamodel.Metamodel;\nimport spoon.metamodel.MetamodelConcept;\nimport spoon.metamodel.MetamodelProperty;\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.Matchers;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Collectors;\n\nimport static spoon.pattern.internal.matcher.TobeMatched.getMatchedParameters;\n\n/**\n * Generates/Matches a copy of a single CtElement AST node with all it's children (whole AST tree of the root CtElement)\n */\npublic class ElementNode extends AbstractPrimitiveMatcher {\n\n\t/**\n\t * Creates an implicit {@link ElementNode}, which contains all non derived attributes of `element` and all it's children\n\t * @param element source element, which is used to initialize {@link ElementNode}\n\t * @param patternElementToSubstRequests the {@link Map}, which will receive mapping between `element` and it's children\n\t * and newly created tree of {@link ElementNode}s\n\t * @return a tree of {@link ElementNode}s, which reflects tree of `element`\n\t */\n\tpublic static ElementNode create(CtElement element, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tMetamodelConcept mmConcept = Metamodel.getInstance().getConcept(element.getClass());\n\t\tElementNode elementNode = new ElementNode(mmConcept, element);\n\t\tif (patternElementToSubstRequests.put(element, elementNode) != null) {\n\t\t\tthrow new SpoonException(\"Each pattern element can have only one implicit Node.\");\n\t\t}\n\t\t//iterate over all attributes of that element\n\t\tfor (MetamodelProperty  mmField : mmConcept.getProperties()) {\n\t\t\tif (mmField.isDerived()) {\n\t\t\t\t//skip derived fields, they are not relevant for matching or generating\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telementNode.setNodeOfRole(mmField.getRole(), create(mmField.getContainerKind(), mmField.getValue(element), patternElementToSubstRequests));\n\t\t}\n\t\treturn elementNode;\n\t}\n\n\t/**\n\t * Same like {@link #create(CtElement, Map)} but with {@link List} of elements or primitive objects\n\t *\n\t * @param objects List of objects which has to be transformed to nodes\n\t * @param patternElementToSubstRequests mapping between {@link CtElement} from `objects` to created `node`\n\t * @return a list of trees of nodes, which reflects list of `objects`\n\t */\n\tpublic static ListOfNodes create(List<?> objects, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tif (objects == null) {\n\t\t\tobjects = Collections.emptyList();\n\t\t}\n\t\treturn listOfNodesToNode(objects.stream().map(i -> create(i, patternElementToSubstRequests)).collect(Collectors.toList()));\n\t}\n\n\t/**\n\t * Same like {@link #create(CtElement, Map)} but with {@link Set} of elements or primitive objects\n\t *\n\t * @param templates Set of objects which has to be transformed to nodes\n\t * @param patternElementToSubstRequests mapping between {@link CtElement} from `templates` to created `node`\n\t * @return a list of trees of nodes, which reflects Set of `templates`\n\t */\n\tpublic static ListOfNodes create(Set<?> templates, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tif (templates == null) {\n\t\t\ttemplates = Collections.emptySet();\n\t\t}\n\t\t//collect plain template nodes without any substitution request as List, because Spoon Sets have predictable order.\n\t\tList<RootNode> constantMatchers = new ArrayList<>(templates.size());\n\t\t//collect template nodes with a substitution request\n\t\tList<RootNode> variableMatchers = new ArrayList<>();\n\t\tfor (Object template : templates) {\n\t\t\tRootNode matcher = create(template, patternElementToSubstRequests);\n\t\t\tif (matcher instanceof ElementNode) {\n\t\t\t\tconstantMatchers.add(matcher);\n\t\t\t} else {\n\t\t\t\tvariableMatchers.add(matcher);\n\t\t\t}\n\t\t}\n\t\t//first match the Set with constant matchers and then with variable matchers\n\t\tconstantMatchers.addAll(variableMatchers);\n\t\treturn listOfNodesToNode(constantMatchers);\n\t}\n\n\t/**\n\t * Same like {@link #create(CtElement, Map)} but with {@link Map} of String to elements or primitive objects\n\t *\n\t * @param map Map of objects which has to be transformed to nodes\n\t * @param patternElementToSubstRequests mapping between {@link CtElement} from `map` to created `node`\n\t * @return a list of {@link MapEntryNode}s, which reflects `map`\n\t */\n\tpublic static ListOfNodes create(Map<String, ?> map, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tif (map == null) {\n\t\t\tmap = Collections.emptyMap();\n\t\t}\n\t\t//collect Entries with constant matcher keys\n\t\tList<MapEntryNode> constantMatchers = new ArrayList<>(map.size());\n\t\t//collect Entries with variable matcher keys\n\t\tList<MapEntryNode> variableMatchers = new ArrayList<>();\n\t\tMatchers last = null;\n\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {\n\t\t\tMapEntryNode mem = new MapEntryNode(\n\t\t\t\t\tcreate(entry.getKey(), patternElementToSubstRequests),\n\t\t\t\t\tcreate(entry.getValue(), patternElementToSubstRequests));\n\t\t\tif (mem.getKey() == entry.getKey()) {\n\t\t\t\tconstantMatchers.add(mem);\n\t\t\t} else {\n\t\t\t\tvariableMatchers.add(mem);\n\t\t\t}\n\t\t}\n\t\t//first match the Map.Entries with constant matchers and then with variable matchers\n\t\tconstantMatchers.addAll(variableMatchers);\n\t\treturn listOfNodesToNode(constantMatchers);\n\t}\n\n\tprivate static RootNode create(Object object, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tif (object instanceof CtElement) {\n\t\t\treturn create((CtElement) object, patternElementToSubstRequests);\n\t\t}\n\t\treturn new ConstantNode<>(object);\n\t}\n\n\tprivate static RootNode create(ContainerKind containerKind, Object templates, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tswitch (containerKind) {\n\t\tcase LIST:\n\t\t\treturn create((List) templates, patternElementToSubstRequests);\n\t\tcase SET:\n\t\t\treturn create((Set) templates, patternElementToSubstRequests);\n\t\tcase MAP:\n\t\t\treturn create((Map) templates, patternElementToSubstRequests);\n\t\tcase SINGLE:\n\t\t\treturn create(templates, patternElementToSubstRequests);\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected RoleHandler containerKind: \" + containerKind);\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprivate static ListOfNodes listOfNodesToNode(List<? extends RootNode> nodes) {\n\t\treturn new ListOfNodes((List) nodes);\n\t}\n\n\tprivate CtElement templateElement;\n\tprivate MetamodelConcept elementType;\n\tprivate Map<MetamodelProperty, RootNode> roleToNode = new HashMap<>();\n\n\t/**\n\t * @param elementType The type of Spoon node which has to be generated/matched by this {@link ElementNode}\n\t * @param templateElement - optional ref to template element which was used to created this {@link ElementNode}.\n\t * \tIt is used e.g. to generate generatedBy comment\n\t */\n\tpublic ElementNode(MetamodelConcept elementType, CtElement templateElement) {\n\t\tthis.elementType = elementType;\n\t\tthis.templateElement = templateElement;\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\tfor (Map.Entry<MetamodelProperty, RootNode> e : roleToNode.entrySet()) {\n\t\t\tRootNode node = e.getValue();\n\t\t\tif (node == oldNode) {\n\t\t\t\te.setValue(newNode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (node.replaceNode(oldNode, newNode)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Map<MetamodelProperty, RootNode> getRoleToNode() {\n\t\treturn roleToNode == null ? Collections.emptyMap() : Collections.unmodifiableMap(roleToNode);\n\t}\n\n\tpublic RootNode getNodeOfRole(CtRole attributeRole) {\n\t\treturn roleToNode.get(getFieldOfRole(attributeRole));\n\t}\n\n\tpublic RootNode setNodeOfRole(CtRole role, RootNode newAttrNode) {\n\t\treturn roleToNode.put(getFieldOfRole(role), newAttrNode);\n\t}\n\n\t/**\n\t * @param role\n\t * @return a {@link RootNode}, which exists on the `role` or creates implicit container for that role\n\t */\n\tpublic RootNode getOrCreateNodeOfRole(CtRole role, Map<CtElement, RootNode> patternElementToSubstRequests) {\n\t\tRootNode node = getNodeOfRole(role);\n\t\tif (node == null) {\n\t\t\tMetamodelProperty mmField = elementType.getProperty(role);\n\t\t\tif (mmField == null || mmField.isDerived()) {\n\t\t\t\tthrow new SpoonException(\"The role \" + role + \" doesn't exist or is derived for \" + elementType);\n\t\t\t}\n\t\t\tnode = create(mmField.getContainerKind(), null, patternElementToSubstRequests);\n\t\t\tsetNodeOfRole(role, node);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * @param role to be returned {@link CtRole}\n\t * @param type required type of returned value\n\t * @return value of {@link ConstantNode} on the `role` attribute of this {@link ElementNode} or null if there is none or has different type\n\t */\n\tpublic <T> T getValueOfRole(CtRole role, Class<T> type) {\n\t\tRootNode node = getNodeOfRole(role);\n\t\tif (node instanceof ConstantNode) {\n//\t\t\tFIX it delivers value of StringNode too ... generated by must be added into produced elements\n\t\t\tConstantNode cn = (ConstantNode) node;\n\t\t\tif (type.isInstance(cn.getTemplateNode())) {\n\t\t\t\treturn (T) cn.getTemplateNode();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate MetamodelProperty getFieldOfRole(CtRole role) {\n\t\tMetamodelProperty mmField = elementType.getProperty(role);\n\t\tif (mmField == null) {\n\t\t\tthrow new SpoonException(\"CtRole.\" + role.name() + \" isn't available for \" + elementType);\n\t\t}\n\t\tif (mmField.isDerived()) {\n\t\t\tthrow new SpoonException(\"CtRole.\" + role.name() + \" is derived in \" + elementType + \" so it can't be used for matching or generating\");\n\t\t}\n\t\treturn mmField;\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tif (roleToNode != null) {\n\t\t\tfor (RootNode node : roleToNode.values()) {\n\t\t\t\tnode.forEachParameterInfo(consumer);\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <U> void generateTargets(DefaultGenerator generator, ResultHolder<U> result, ImmutableMap parameters) {\n\t\t//TODO implement create on MetamodelConcept\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tCtElement clone = generator.getFactory().Core().create((Class) elementType.getMetamodelInterface().getActualClass());\n\t\tgenerateSingleNodeAttributes(generator, clone, parameters);\n\t\tgenerator.applyGeneratedBy(clone, generator.getGeneratedByComment(templateElement));\n\t\tresult.addResult((U) clone);\n\t}\n\n\tprotected void generateSingleNodeAttributes(DefaultGenerator generator, CtElement clone, ImmutableMap parameters) {\n\t\tfor (Map.Entry<MetamodelProperty, RootNode> e : getRoleToNode().entrySet()) {\n\t\t\tMetamodelProperty mmField = e.getKey();\n\t\t\tswitch (mmField.getContainerKind()) {\n\t\t\tcase SINGLE:\n\t\t\t\tmmField.setValue(clone, generator.generateSingleTarget(e.getValue(), parameters, mmField.getTypeofItems().getActualClass()));\n\t\t\t\tbreak;\n\t\t\tcase LIST:\n\t\t\t\tmmField.setValue(clone, generator.generateTargets(e.getValue(), parameters, mmField.getTypeofItems().getActualClass()));\n\t\t\t\tbreak;\n\t\t\tcase SET:\n\t\t\t\tmmField.setValue(clone, new LinkedHashSet<>(generator.generateTargets(e.getValue(), parameters, mmField.getTypeofItems().getActualClass())));\n\t\t\t\tbreak;\n\t\t\tcase MAP:\n\t\t\t\tmmField.setValue(clone, entriesToMap(generator.generateTargets(e.getValue(), parameters, Map.Entry.class)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate <T> Map<String, T> entriesToMap(List<Map.Entry> entries) {\n\t\tMap<String, T> map = new LinkedHashMap<>(entries.size());\n\t\tfor (Map.Entry<String, T> entry : entries) {\n\t\t\tmap.put(entry.getKey(), entry.getValue());\n\t\t}\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic ImmutableMap matchTarget(Object target, ImmutableMap parameters) {\n\t\tif (target == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (target.getClass() != elementType.getImplementationClass().getActualClass()) {\n\t\t\treturn null;\n\t\t}\n\n\t\t//it is spoon element, it matches if to be matched attributes matches\n\t\t//to be matched attributes must be same or substituted\n\t\t//iterate over all attributes of to be matched class\n\t\tfor (Map.Entry<MetamodelProperty, RootNode> e : roleToNode.entrySet()) {\n\t\t\tparameters = matchesRole(parameters, (CtElement) target, e.getKey(), e.getValue());\n\t\t\tif (parameters == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn parameters;\n\t}\n\n\tprotected ImmutableMap matchesRole(ImmutableMap parameters, CtElement target, MetamodelProperty mmField, RootNode attrNode) {\n\t\tif (isMatchingRole(mmField.getRole(), elementType.getMetamodelInterface().getActualClass()) == false) {\n\t\t\treturn parameters;\n\t\t}\n\t\tTobeMatched tobeMatched;\n\t\tif (attrNode instanceof ParameterNode) {\n\t\t\t//whole attribute value (whole List/Set/Map) has to be stored in parameter\n\t\t\ttobeMatched = TobeMatched.create(parameters, ContainerKind.SINGLE, mmField.getValue(target));\n\t\t} else {\n\t\t\t//each item of attribute value (item of List/Set/Map) has to be matched individually\n\t\t\ttobeMatched = TobeMatched.create(parameters, mmField.getContainerKind(), mmField.getValue(target));\n\t\t}\n\t\treturn getMatchedParameters(attrNode.matchTargets(tobeMatched, RootNode.MATCH_ALL));\n\t}\n\n\tprivate static final Map<CtRole, Class[]> roleToSkippedClass = new HashMap<>();\n\tstatic {\n\t\troleToSkippedClass.put(CtRole.COMMENT, new Class[]{Object.class});\n\t\troleToSkippedClass.put(CtRole.POSITION, new Class[]{Object.class});\n\t\troleToSkippedClass.put(CtRole.IS_IMPLICIT, new Class[]{Object.class});\n\t\troleToSkippedClass.put(CtRole.TYPE, new Class[]{CtExecutableReference.class});\n\t\troleToSkippedClass.put(CtRole.DECLARING_TYPE, new Class[]{CtExecutableReference.class});\n\t}\n\n\t/**\n\t * @param role the role to be checked\n\t * @param targetClass the class which is going to be checked\n\t * @return true if the role is relevant to matching process\n\t */\n\tprivate static boolean isMatchingRole(CtRole role, Class<?> targetClass) {\n\t\tClass<?>[] classes = roleToSkippedClass.get(role);\n\t\tif (classes != null) {\n\t\t\tfor (Class<?> cls : classes) {\n\t\t\t\tif (cls.isAssignableFrom(targetClass)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn elementType.getName() + \": \" + super.toString();\n\t}\n\n\tpublic MetamodelConcept getElementType() {\n\t\treturn elementType;\n\t}\n\n\tpublic void setElementType(MetamodelConcept elementType) {\n\t\tthis.elementType = elementType;\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn Quantifier.POSSESSIVE;\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\t//it always matches only once\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/MapEntryNode.java",
      "weight" : 103.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.SpoonException;\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport static spoon.pattern.internal.matcher.TobeMatched.getMatchedParameters;\n\n/**\n * Represents a ValueResolver of one Map.Entry\n */\npublic class MapEntryNode extends AbstractPrimitiveMatcher {\n\tprivate RootNode key;\n\tprivate RootNode value;\n\n\tpublic MapEntryNode(RootNode key, RootNode value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t}\n\n\tpublic RootNode getKey() {\n\t\treturn key;\n\t}\n\tpublic RootNode getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\tif (key == oldNode) {\n\t\t\tkey = newNode;\n\t\t\treturn true;\n\t\t}\n\t\tif (value == oldNode) {\n\t\t\tvalue = newNode;\n\t\t\treturn true;\n\t\t}\n\t\tif (key.replaceNode(oldNode, newNode)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn value.replaceNode(oldNode, newNode);\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tkey.forEachParameterInfo(consumer);\n\t\tvalue.forEachParameterInfo(consumer);\n\t}\n\n\tprivate static class Entry implements Map.Entry<String, CtElement> {\n\t\tprivate final String key;\n\t\tprivate CtElement value;\n\n\t\tEntry(String key, CtElement value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getKey() {\n\t\t\treturn key;\n\t\t}\n\n\t\t@Override\n\t\tpublic CtElement getValue() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic CtElement setValue(CtElement value) {\n\t\t\tCtElement oldV = this.value;\n\t\t\tthis.value = value;\n\t\t\treturn oldV;\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tString entryKey = generator.generateSingleTarget(key, parameters, String.class);\n\t\tCtElement entryValue = generator.generateSingleTarget(value, parameters, CtElement.class);\n\t\tif (entryKey != null && entryValue != null) {\n\t\t\tresult.addResult((T) new Entry(entryKey, entryValue));\n\t\t}\n\t}\n\t@Override\n\tpublic ImmutableMap matchTarget(Object target, ImmutableMap parameters) {\n\t\tif (target instanceof Map.Entry) {\n\t\t\tMap.Entry<String, CtElement> targetEntry = (Map.Entry<String, CtElement>) target;\n\t\t\tparameters = getMatchedParameters(getKey().matchAllWith(TobeMatched.create(parameters, ContainerKind.SINGLE, targetEntry.getKey())));\n\t\t\tif (parameters == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn getMatchedParameters(getValue().matchAllWith(TobeMatched.create(parameters, ContainerKind.SINGLE, targetEntry.getValue())));\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected target type \" + target.getClass().getName());\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\tif (key instanceof ParameterNode) {\n\t\t\treturn ((ParameterNode) key).getMatchingStrategy();\n\t\t}\n\t\treturn Quantifier.POSSESSIVE;\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\tif (key instanceof ParameterNode) {\n\t\t\treturn ((ParameterNode) key).isTryNextMatch(parameters);\n\t\t}\n\t\t//it is not a parameterized node, so it matches only once\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/AbstractNode.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.internal.PatternPrinter;\n\n/**\n * Represents a parameterized Pattern ValueResolver, which can be used\n * <ul>\n * <li>to generate a zero, one or more copies of model using provided parameters</li>\n * <li>to match zero, one or more instances of model and deliver a matching parameters</li>\n * </ul>\n */\npublic abstract class AbstractNode implements RootNode {\n\tprivate boolean simplifyGenerated = false;\n\t@Override\n\tpublic String toString() {\n\t\treturn new PatternPrinter().printNode(this);\n\t}\n\t@Override\n\tpublic boolean isSimplifyGenerated() {\n\t\treturn simplifyGenerated;\n\t}\n\t@Override\n\tpublic void setSimplifyGenerated(boolean simplifyGenerated) {\n\t\tthis.simplifyGenerated = simplifyGenerated;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/SwitchNode.java",
      "weight" : 184.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.Matchers;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.factory.CoreFactory;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\n/**\n * List of conditional cases\n * {code}\n * if (a) {\n *  ... someStatements if a == true..\n * } else if (b) {\n *  ... someStatements if b == true..\n * } else {\n *  ... someStatements in other cases ...\n * }\n */\npublic class SwitchNode extends AbstractNode implements InlineNode {\n\n\tprivate List<CaseNode> cases = new ArrayList<>();\n\n\tpublic SwitchNode() {\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\tfor (CaseNode caseNode : cases) {\n\t\t\tif (caseNode.replaceNode(oldNode, newNode)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Adds another case into this switch statement\n\t * @param vrOfExpression if value of this parameter is true then statement has to be used. If vrOfExpression is null, then statement is always used\n\t * @param statement optional statement\n\t */\n\tpublic void addCase(PrimitiveMatcher vrOfExpression, RootNode statement) {\n\t\tcases.add(new CaseNode(vrOfExpression, statement));\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tfor (CaseNode case1 : cases) {\n\t\t\tif (case1.isCaseSelected(generator, parameters)) {\n\t\t\t\t//generate result using first matching if branch\n\t\t\t\tgenerator.generateTargets(case1, result, parameters);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tfor (CaseNode case1 : cases) {\n\t\t\tif (case1.vrOfExpression != null) {\n\t\t\t\tcase1.vrOfExpression.forEachParameterInfo(consumer);\n\t\t\t}\n\t\t\tif (case1.statement != null) {\n\t\t\t\tcase1.statement.forEachParameterInfo(consumer);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic TobeMatched matchTargets(TobeMatched targets, Matchers nextMatchers) {\n\t\tboolean hasDefaultCase = false;\n\t\t//detect which case is matching - if any\n\t\tfor (CaseNode case1 : cases) {\n\t\t\tTobeMatched match = case1.matchTargets(targets, nextMatchers);\n\t\t\tif (match != null) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t\tif (case1.vrOfExpression == null) {\n\t\t\t\thasDefaultCase = true;\n\t\t\t}\n\t\t}\n\t\t//no case matched\n\t\tif (hasDefaultCase) {\n\t\t\t//nothing matched and even the default case didn't matched, so whole switch cannot match\n\t\t\treturn null;\n\t\t}\n\t\t/*\n\t\t * else this switch is optional and matches 0 targets - OK, it is match too.\n\t\t * 1) set all expressions to false\n\t\t * 2) match nextMatchers\n\t\t */\n\t\treturn new CaseNode(null, null).matchTargets(targets, nextMatchers);\n\t}\n\n\tprivate class CaseNode extends AbstractNode implements InlineNode {\n\t\t/*\n\t\t * is null for the default case\n\t\t */\n\t\tprivate PrimitiveMatcher vrOfExpression;\n\t\tprivate RootNode statement;\n\t\tprivate CaseNode(PrimitiveMatcher vrOfExpression, RootNode statement) {\n\t\t\tthis.vrOfExpression = vrOfExpression;\n\t\t\tthis.statement = statement;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\t\tif (vrOfExpression != null) {\n\t\t\t\tif (vrOfExpression == oldNode) {\n\t\t\t\t\tvrOfExpression = (PrimitiveMatcher) newNode;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (vrOfExpression.replaceNode(oldNode, newNode)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement != null) {\n\t\t\t\tif (statement == oldNode) {\n\t\t\t\t\tstatement = newNode;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn statement.replaceNode(oldNode, newNode);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic TobeMatched matchTargets(TobeMatched targets, Matchers nextMatchers) {\n\t\t\tImmutableMap parameters = targets.getParameters();\n\t\t\t//set all switch parameter values following match case. Even no matching case is OK - everything is false then\n\t\t\tfor (CaseNode case1 : cases) {\n\t\t\t\tif (case1.vrOfExpression != null) {\n\t\t\t\t\t//set expression of this `if` depending on if this case matched or not\n\t\t\t\t\tparameters = case1.vrOfExpression.matchTarget(case1 == this, parameters);\n\t\t\t\t\tif (parameters == null) {\n\t\t\t\t\t\t//this value doesn't matches we cannot match this case\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargets = targets.copyAndSetParams(parameters);\n\t\t\tif (statement != null) {\n\t\t\t\treturn statement.matchTargets(targets, nextMatchers);\n\t\t\t}\n\t\t\treturn nextMatchers.matchAllWith(targets);\n\t\t}\n\t\t@Override\n\t\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\t\tSwitchNode.this.forEachParameterInfo(consumer);\n\t\t}\n\t\t@Override\n\t\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\t\tif (statement != null) {\n\t\t\t\tgenerator.generateTargets(statement, result, parameters);\n\t\t\t}\n\t\t}\n\t\tprivate boolean isCaseSelected(DefaultGenerator generator, ImmutableMap parameters) {\n\t\t\tif (vrOfExpression == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tBoolean value = generator.generateSingleTarget(vrOfExpression, parameters, Boolean.class);\n\t\t\treturn value == null ? false : value.booleanValue();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> void generateInlineTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\t\tFactory f = generator.getFactory();\n\t\t\tCoreFactory cf = f.Core();\n\t\t\tCtBlock<?> block = cf.createBlock();\n\t\t\tif (statement != null) {\n\t\t\t\tblock.setStatements(generator.generateTargets(statement, parameters, CtStatement.class));\n\t\t\t}\n\t\t\tif (vrOfExpression != null) {\n\t\t\t\t//There is if expression\n\t\t\t\tCtIf ifStmt = cf.createIf();\n\t\t\t\tifStmt.setCondition(generator.generateSingleTarget(vrOfExpression, parameters, CtExpression.class));\n\t\t\t\tifStmt.setThenStatement(block);\n\t\t\t\tresult.addResult((T) ifStmt);\n\t\t\t} else {\n\t\t\t\t//There is no expression. It represents the last else block\n\t\t\t\tresult.addResult((T) block);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void generateInlineTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tCtStatement resultStmt = null;\n\t\tCtStatement lastElse = null;\n\t\tCtIf lastIf = null;\n\t\tfor (CaseNode caseNode : cases) {\n\t\t\tCtStatement stmt = generator.generateSingleTarget(caseNode, parameters, CtStatement.class);\n\t\t\tif (stmt instanceof CtIf) {\n\t\t\t\tCtIf ifStmt = (CtIf) stmt;\n\t\t\t\tif (lastIf == null) {\n\t\t\t\t\t//it is first IF\n\t\t\t\t\tresultStmt = ifStmt;\n\t\t\t\t\tlastIf = ifStmt;\n\t\t\t\t} else {\n\t\t\t\t\t//it is next IF. Append it as else into last IF\n\t\t\t\t\tlastIf.setElseStatement(ifStmt);\n\t\t\t\t\tlastIf = ifStmt;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (lastElse != null) {\n\t\t\t\t\tthrow new SpoonException(\"Only one SwitchNode can have no expression.\");\n\t\t\t\t}\n\t\t\t\tlastElse = stmt;\n\t\t\t}\n\t\t}\n\t\tif (lastIf == null) {\n\t\t\t//there is no IF\n\t\t\tif (lastElse != null) {\n\t\t\t\tresult.addResult((T) lastElse);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (lastElse != null) {\n\t\t\t//append last else into lastIf\n\t\t\tlastIf.setElseStatement(lastElse);\n\t\t}\n\t\tresult.addResult((T) resultStmt);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/RepeatableMatcher.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.Quantifier;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Defines API of a repeatable matcher.\n * It is kind of {@link RootNode}, where one {@link RootNode} may match 0, 1 or more `target` nodes.\n */\npublic interface RepeatableMatcher extends RootNode {\n\t/**\n\t * If two {@link RepeatableMatcher}s in a list are matching the same element,\n\t * then returned {@link Quantifier} defines how resolve this conflict\n\t * @return {@link Quantifier}\n\t */\n\tQuantifier getMatchingStrategy();\n\n\t/**\n\t * @return true if this matcher can be applied more then once in the same container of targets\n\t * Note: even if false, it may be applied again to another container and to match EQUAL value\n\t */\n\tdefault boolean isRepeatable() {\n\t\treturn false;\n\t}\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if this ValueResolver MUST match with next target in the state defined by current `parameters`.\n\t * false if match is optional\n\t */\n\tdefault boolean isMandatory(ImmutableMap parameters) {\n\t\treturn true;\n\t}\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if this ValueResolver should be processed again to match next target in the state defined by current `parameters`.\n\t */\n\tboolean isTryNextMatch(ImmutableMap parameters);\n}\n"
    }, {
      "name" : "pattern/internal/node/AbstractRepeatableMatcher.java",
      "weight" : 77.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.matcher.Matchers;\nimport spoon.pattern.internal.matcher.TobeMatched;\n\n/**\n * Defines algorithm of repeatable matcher.\n */\nabstract class AbstractRepeatableMatcher extends AbstractNode implements RepeatableMatcher {\n\n\t@Override\n\tpublic TobeMatched matchTargets(TobeMatched targets, Matchers next) {\n\t\tif (isRepeatable() == false) {\n\t\t\t//handle non repeatable Nodes\n\t\t\tboolean isMandatory = isMandatory(targets.getParameters());\n\t\t\t//match maximum one value\n\t\t\tTobeMatched tmp = matchAllWith(targets);\n\t\t\tif (tmp == null) {\n\t\t\t\tif (isMandatory) {\n\t\t\t\t\t//this mandatory valueResolver didn't match\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t//no match - OK, it was optional\n\t\t\t} else {\n\t\t\t\ttargets = tmp;\n\t\t\t}\n\t\t\t//the `matcher` has all values. Match next\n\t\t\treturn next.matchAllWith(targets);\n\t\t}\n\t\t//it is repeatable node\n\t\t//first match mandatory targets\n\t\twhile (isMandatory(targets.getParameters())) {\n\t\t\tTobeMatched tmp = matchAllWith(targets);\n\t\t\tif (tmp == null) {\n\t\t\t\t//this mandatory valueResolver didn't match\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t//check whether we have to match next\n\t\t\t//we need this check because #isMandatory()==true for each state. In such case the #isTryNextMatch must be able to finish the cycle\n\t\t\tif (isTryNextMatch(tmp.getParameters()) == false) {\n\t\t\t\t//the `matcher` has all values. Match next\n\t\t\t\treturn next.matchAllWith(tmp);\n\t\t\t}\n\t\t\t//use new matching request to match next mandatory parameter\n\t\t\ttargets = tmp;\n\t\t}\n\t\t//then continue optional targets\n\t\treturn matchOptionalTargets(targets, next);\n\t}\n\n\tprivate TobeMatched matchOptionalTargets(TobeMatched targets, Matchers next) {\n\t\tif (isTryNextMatch(targets.getParameters()) == false) {\n\t\t\t//the `matcher` has all values. Match next\n\t\t\treturn next.matchAllWith(targets);\n\t\t}\n\t\tswitch (getMatchingStrategy()) {\n\t\tcase GREEDY: {\n\t\t\t{ //first try to match using this matcher\n\t\t\t\tTobeMatched match = matchAllWith(targets);\n\t\t\t\tif (match != null) {\n\t\t\t\t\t//this matcher passed, try to match next one using current SimpleValueResolver\n\t\t\t\t\tmatch = matchOptionalTargets(match, next);\n\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\t//all next passed too, return that match\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//greedy matching with current nodeSubstRequest didn't pass. Try to match using remaining templates\n\t\t\treturn next.matchAllWith(targets);\n\t\t}\n\t\tcase RELUCTANT: {\n\t\t\t{ //first try to match using next matcher.\n\t\t\t\tTobeMatched match = next.matchAllWith(targets);\n\t\t\t\tif (match != null) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//reluctant matching didn't pass on next elements. Try to match using this matcher\n\t\t\tTobeMatched match = matchAllWith(targets);\n\t\t\tif (match == null) {\n\t\t\t\t//nothing matched\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t//this matcher passed. Match next one using current SimpleValueResolver\n\t\t\treturn matchOptionalTargets(match, next);\n\t\t}\n\t\tcase POSSESSIVE:\n\t\t\t//match everything using this matcher. Never try other way\n\t\t\t//Check if we should try next match\n\t\t\twhile (isTryNextMatch(targets.getParameters())) {\n\t\t\t\tTobeMatched tmp = matchAllWith(targets);\n\t\t\t\tif (tmp == null) {\n\t\t\t\t\tif (isMandatory(targets.getParameters())) {\n\t\t\t\t\t\t//this mandatory valueResolver didn't match\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t//it was optional. Ignore this valueResolver and continue with next\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//use new matching request\n\t\t\t\ttargets = tmp;\n\t\t\t}\n\t\t\treturn next.matchAllWith(targets);\n\t\t}\n\t\tthrow new SpoonException(\"Unsupported quantifier \" + getMatchingStrategy());\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/ConstantNode.java",
      "weight" : 52.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.function.BiConsumer;\n\n/**\n * Generates/Matches a copy of single template object\n */\npublic class ConstantNode<T> extends AbstractPrimitiveMatcher {\n\tprotected final T template;\n\n\tpublic ConstantNode(T template) {\n\t\tthis.template = template;\n\t}\n\n\tpublic T getTemplateNode() {\n\t\treturn template;\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\t//it has no parameters\n\t}\n\n\t@Override\n\tpublic <U> void generateTargets(DefaultGenerator generator, ResultHolder<U> result, ImmutableMap parameters) {\n\t\tresult.addResult((U) template);\n\t}\n\n\t@Override\n\tpublic ImmutableMap matchTarget(Object target, ImmutableMap parameters) {\n\t\tif (target == null && template == null) {\n\t\t\treturn parameters;\n\t\t}\n\t\tif (target == null || template == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (target.getClass() != template.getClass()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn target.equals(template) ? parameters : null;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.valueOf(template);\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn Quantifier.POSSESSIVE;\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\t//it always matches only once\n\t\treturn false;\n\t}\n}\n\n"
    }, {
      "name" : "pattern/internal/node/RootNode.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport java.util.function.BiConsumer;\n\nimport spoon.pattern.Generator;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.Matchers;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Represents a parameterized Pattern ValueResolver, which can be used\n * <ul>\n * <li>to generate a zero, one or more copies of model using provided parameters</li>\n * <li>to match zero, one or more instances of model and deliver a matching parameters</li>\n * </ul>\n */\npublic interface RootNode extends Matchers {\n\t/**\n\t * Calls consumer for each pair of parameter definition ({@link ParameterInfo}) and {@link RootNode}, which uses it\n\t * @param consumer the receiver of pairs of {@link ParameterInfo} and {@link RootNode}\n\t */\n\tvoid forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer);\n\n\t/**\n\t * Generates zero, one or more target depending on kind of this {@link RootNode}, expected `result` and input `parameters`\n\t * @param generator {@link Generator} which drives generation process\n\t * @param result holder for the generated objects\n\t * @param parameters a {@link ImmutableMap} holding parameters\n\t */\n\t<T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters);\n\n\t/**\n\t * @return true if generated result has to be evaluated to apply simplifications.\n\t * e.g. (\"a\" + \"b\") id simplified to \"ab\"\n\t */\n\tboolean isSimplifyGenerated();\n\t/**\n\t * @param simplifyGenerated true if generated result of this {@link RootNode} has to be evaluated to apply simplifications.\n\t */\n\tvoid setSimplifyGenerated(boolean simplifyGenerated);\n\n\t/**\n\t * @param targets to be matched target nodes and input parameters\n\t * @param nextMatchers Chain of matchers which has to be processed after this {@link RootNode}\n\t * @return new parameters and container with remaining targets\n\t */\n\tTobeMatched matchTargets(TobeMatched targets, Matchers nextMatchers);\n\n\t/**\n\t * The special implementation of {@link Matchers}, which is used as last {@link RootNode} in case when ALL target nodes must match with all template nodes\n\t */\n\tMatchers MATCH_ALL = new Matchers() {\n\t\t@Override\n\t\tpublic TobeMatched matchAllWith(TobeMatched targets) {\n\t\t\t//It matches only when there is no remaining target element\n\t\t\treturn targets.hasTargets() ? null : targets;\n\t\t}\n\t};\n\t/**\n\t * The special implementation of {@link Matchers}, which is used as last {@link RootNode} in case when SOME target nodes must match with all template nodes\n\t */\n\tMatchers MATCH_PART = new Matchers() {\n\t\t@Override\n\t\tpublic TobeMatched matchAllWith(TobeMatched targets) {\n\t\t\t//There can remain some unmatched target(s) - it is OK in this context.\n\t\t\treturn targets;\n\t\t}\n\t};\n\n\t@Override\n\tdefault TobeMatched matchAllWith(TobeMatched targets) {\n\t\treturn matchTargets(targets, MATCH_PART);\n\t}\n\n\t/**\n\t * Call it to modify Pattern structure. It is actually called mainly by PatternBuilder.\n\t * TODO: May be we can move this method into some internal interface?\n\t * @param oldNode old {@link RootNode}\n\t * @param newNode new {@link RootNode}\n\t * @return a true if `oldNode` was found in this {@link RootNode} or it's children and replaced by `newNode`\n\t * false if `oldNode` was not found\n\t */\n\tboolean replaceNode(RootNode oldNode, RootNode newNode);\n}\n"
    }, {
      "name" : "pattern/internal/node/StringNode.java",
      "weight" : 197.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.SpoonException;\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Delivers single String value, which is created by replacing string markers in constant String template\n * by String value of appropriate parameter.\n */\npublic class StringNode extends AbstractPrimitiveMatcher {\n\tprivate final String stringValueWithMarkers;\n\t/*\n\t * Use LinkedHashMap to assure defined replacement order\n\t */\n\tprivate final Map<String, ParameterInfo> tobeReplacedSubstrings = new LinkedHashMap<>();\n\tprivate ParameterInfo[] params;\n\tprivate Pattern regExpPattern;\n\n\tpublic StringNode(String stringValueWithMarkers) {\n\t\tthis.stringValueWithMarkers = stringValueWithMarkers;\n\t}\n\n\tprivate String getStringValueWithMarkers() {\n\t\treturn stringValueWithMarkers;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tClass<?> requiredClass = result.getRequiredClass();\n\t\tif (requiredClass != null && requiredClass.isAssignableFrom(String.class) == false) {\n\t\t\tthrow new SpoonException(\"StringValueResolver provides only String values. It doesn't support: \" + requiredClass);\n\t\t}\n\t\t/*\n\t\t * initial value of result String. It usually contains some substrings (markers),\n\t\t * which are replaced by values of related parameters\n\t\t */\n\t\tString stringValue = getStringValueWithMarkers();\n\t\tfor (Map.Entry<String, ParameterInfo> requests : tobeReplacedSubstrings.entrySet()) {\n\t\t\tParameterInfo param = requests.getValue();\n\t\t\tString replaceMarker = requests.getKey();\n\t\t\tResultHolder.Single<String> ctx = new ResultHolder.Single<>(String.class);\n\t\t\tgenerator.getValueAs(param, ctx, parameters);\n\t\t\tString substrValue = ctx.getResult() == null ? \"\" : ctx.getResult();\n\t\t\tstringValue = substituteSubstring(stringValue, replaceMarker, substrValue);\n\t\t}\n\t\t//convert stringValue from String to type required by result and add it into result\n\t\tresult.addResult((T) stringValue);\n\t}\n\n\t@Override\n\tpublic ImmutableMap matchTarget(Object target, ImmutableMap parameters) {\n\t\tif ((target instanceof String) == false) {\n\t\t\treturn null;\n\t\t}\n\t\tString targetString = (String) target;\n\t\tjava.util.regex.Pattern re = getMatchingPattern();\n\t\tMatcher m = re.matcher(targetString);\n\t\tif (m.matches() == false) {\n\t\t\treturn null;\n\t\t}\n\t\tParameterInfo[] params = getMatchingParameterInfos();\n\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\tString paramValue = m.group(i + 1);\n\t\t\tparameters = params[i].addValueAs(parameters, paramValue);\n\t\t\tif (parameters == null) {\n\t\t\t\t//two occurrences of the same parameter are matching on different value\n\t\t\t\t//whole string doesn't matches\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn parameters;\n\t}\n\n\t/**\n\t * @return The string whose occurrence in target string will be replaced by parameter value\n\t */\n\tpublic ParameterInfo getParameterInfo(String replaceMarker) {\n\t\treturn tobeReplacedSubstrings.get(replaceMarker);\n\t}\n\n\t/**\n\t * Defines that this Substitution request will replace all occurrences of `replaceMarker` in target string by value of `param`\n\t * @param replaceMarker the substring whose occurrences will be substituted\n\t * @param param the declaration of to be replaced parameter\n\t */\n\tpublic void setReplaceMarker(String replaceMarker, ParameterInfo param) {\n\t\ttobeReplacedSubstrings.put(replaceMarker, param);\n\t}\n\n\t/**\n\t * @return {@link ParameterInfo} to replace marker map\n\t */\n\tpublic Map<String, ParameterInfo> getReplaceMarkers() {\n\t\treturn Collections.unmodifiableMap(tobeReplacedSubstrings);\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tMap<ParameterInfo, Boolean> visitedParams = new IdentityHashMap<>(tobeReplacedSubstrings.size());\n\t\tfor (ParameterInfo parameterInfo : tobeReplacedSubstrings.values()) {\n\t\t\t//assure that each parameterInfo is called only once\n\t\t\tif (visitedParams.put(parameterInfo, Boolean.TRUE) == null) {\n\t\t\t\tconsumer.accept(parameterInfo, this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ParameterInfo[] getMatchingParameterInfos() {\n\t\tgetMatchingPattern();\n\t\treturn params;\n\t}\n\n\tprivate List<Region> getRegions() {\n\t\tList<Region> regions = new ArrayList<>();\n\t\tfor (Map.Entry<String, ParameterInfo> markers : tobeReplacedSubstrings.entrySet()) {\n\t\t\taddRegionsOf(regions, markers.getValue(), markers.getKey());\n\t\t}\n\t\tregions.sort((a, b) -> a.from - b.from);\n\t\treturn regions;\n\t}\n\n\tprivate synchronized Pattern getMatchingPattern() {\n\t\tif (regExpPattern == null) {\n\t\t\tList<Region> regions = getRegions();\n\t\t\tStringBuilder re = new StringBuilder();\n\t\t\tList<ParameterInfo> paramsByRegions = new ArrayList<>();\n\t\t\tint start = 0;\n\t\t\tfor (Region region : regions) {\n\t\t\t\tif (region.from > start) {\n\t\t\t\t\tre.append(escapeRegExp(getStringValueWithMarkers().substring(start, region.from)));\n\t\t\t\t} else if (start > 0) {\n\t\t\t\t\tthrow new SpoonException(\"Cannot detect string parts if parameter separators are missing in pattern value: \" + getStringValueWithMarkers());\n\t\t\t\t}\n\t\t\t\tre.append(\"(\")\t//start RE matching group\n\t\t\t\t\t.append(\".*?\")\t//match any character, but not greedy\n\t\t\t\t\t.append(\")\");\t//end of RE matching group\n\t\t\t\tparamsByRegions.add(region.param);\n\t\t\t\tstart = region.to;\n\t\t\t}\n\t\t\tif (start < getStringValueWithMarkers().length()) {\n\t\t\t\tre.append(escapeRegExp(getStringValueWithMarkers().substring(start)));\n\t\t\t}\n\t\t\tregExpPattern = Pattern.compile(re.toString());\n\t\t\tparams = paramsByRegions.toArray(new ParameterInfo[0]);\n\t\t}\n\t\treturn regExpPattern;\n\t}\n\n\t/**\n\t * Represents a to be replaced region of `getStringValueWithMarkers()`\n\t */\n\tprivate static class Region {\n\t\tParameterInfo param;\n\t\tint from;\n\t\tint to;\n\n\t\tRegion(ParameterInfo param, int from, int to) {\n\t\t\tthis.param = param;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t}\n\t}\n\n\tprivate void addRegionsOf(List<Region> regions, ParameterInfo param, String marker) {\n\t\tint start = 0;\n\t\twhile (start < getStringValueWithMarkers().length()) {\n\t\t\tstart = getStringValueWithMarkers().indexOf(marker, start);\n\t\t\tif (start < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregions.add(new Region(param, start, start + marker.length()));\n\t\t\tstart += marker.length();\n\t\t}\n\t}\n\n\t/**\n\t * Replaces all occurrences of `tobeReplacedSubstring` in `str` by `substrValue`\n\t * @param str to be modified string\n\t * @param tobeReplacedSubstring all occurrences of this String will be replaced by `substrValue`\n\t * @param substrValue a replacement\n\t * @return replaced string\n\t */\n\tprivate String substituteSubstring(String str, String tobeReplacedSubstring, String substrValue) {\n\t\treturn str.replaceAll(escapeRegExp(tobeReplacedSubstring), escapeRegReplace(substrValue));\n\t}\n\n\tprivate String escapeRegExp(String str) {\n\t\treturn \"\\\\Q\" + str + \"\\\\E\";\n\t}\n\n\tprivate String escapeRegReplace(String str) {\n\t\treturn str.replaceAll(\"\\\\$\", \"\\\\\\\\\\\\$\");\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint off = 0;\n\t\tfor (Region region : getRegions()) {\n\t\t\tif (region.from > off) {\n\t\t\t\tsb.append(getStringValueWithMarkers().substring(off, region.from));\n\t\t\t}\n\t\t\tsb.append(\"${\").append(region.param.getName()).append(\"}\");\n\t\t\toff = region.to;\n\t\t}\n\t\tif (getStringValueWithMarkers().length() > off) {\n\t\t\tsb.append(getStringValueWithMarkers().substring(off));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Applies substring substitution to `targetNode`. Converts old node to {@link StringNode} if needed.\n\t * @param targetNode\n\t * @param replaceMarker\n\t * @param param\n\t * @return {@link StringNode} which contains all the data of origin `targetNode` and new replaceMarker request\n\t */\n\tpublic static StringNode setReplaceMarker(RootNode targetNode, String replaceMarker, ParameterInfo param) {\n\t\tStringNode stringNode = null;\n\t\tif (targetNode instanceof ConstantNode) {\n\t\t\tConstantNode constantNode = (ConstantNode) targetNode;\n\t\t\tif (constantNode.getTemplateNode() instanceof String) {\n\t\t\t\tstringNode = new StringNode((String) constantNode.getTemplateNode());\n\t\t\t}\n\t\t} else if (targetNode instanceof StringNode) {\n\t\t\tstringNode = (StringNode) targetNode;\n\t\t}\n\t\tif (stringNode == null) {\n\t\t\tthrow new SpoonException(\"Cannot add StringNode\");\n\t\t}\n\t\tstringNode.setReplaceMarker(replaceMarker, param);\n\t\treturn stringNode;\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn Quantifier.POSSESSIVE;\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\t//it always matches only once\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/ParameterNode.java",
      "weight" : 53.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.function.BiConsumer;\n\n/**\n * Represents pattern model variable\n * Delivers/Matches 0, 1 or more values of defined parameter.\n * The values may have type which extends {@link CtElement} or any other type of some SpoonModel attribute. E.g. String\n */\npublic class ParameterNode extends AbstractPrimitiveMatcher {\n\tprivate final ParameterInfo parameterInfo;\n\n\tpublic ParameterNode(ParameterInfo parameterInfo) {\n\t\tthis.parameterInfo = parameterInfo;\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tgenerator.getValueAs(parameterInfo, result, parameters);\n\t}\n\n\t@Override\n\tpublic ImmutableMap matchTarget(Object target, ImmutableMap parameters) {\n\t\treturn parameterInfo.addValueAs(parameters, target);\n\t}\n\n\tpublic ParameterInfo getParameterInfo() {\n\t\treturn parameterInfo;\n\t}\n\n\t@Override\n\tpublic boolean isRepeatable() {\n\t\treturn parameterInfo.isRepeatable();\n\t}\n\n\t@Override\n\tpublic boolean isMandatory(ImmutableMap parameters) {\n\t\treturn parameterInfo.isMandatory(parameters);\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\treturn parameterInfo.isTryNextMatch(parameters);\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn parameterInfo.getMatchingStrategy();\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\tconsumer.accept(parameterInfo, this);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"${\" + parameterInfo + \"}\";\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/InlineNode.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.Generator;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Represents a kind of {@link RootNode},\n * whose AST statements are understood as pattern statements.\n * For example CtForEach statement is handled as repeated generation of pattern\n * Or CtIf statement is handled as optionally generated pattern\n */\npublic interface InlineNode extends RootNode {\n\t/**\n\t * Generates inline statements of this inline {@link RootNode}.\n\t * This method is used when sources of pattern have to be printed\n\t * @param generator a to be used {@link Generator}\n\t * @param result holder of the result\n\t * @param parameters a {@link ImmutableMap} with current parameters\n\t */\n\t<T> void generateInlineTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters);\n}\n"
    }, {
      "name" : "pattern/internal/node/ForEachNode.java",
      "weight" : 104.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.DefaultGenerator;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.util.ImmutableMap;\n\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\n/**\n * Pattern node of multiple occurrences of the same model, just with different parameters.\n * Example with three occurrences of model `System.out.println(_x_)`, with parameter `_x_`\n * <pre><code>\n * System.out.println(\"a\")\n * System.out.println(\"b\")\n * System.out.println(getStringOf(p1, p2))\n * </code></pre>\n * where parameter values are _x_ = [\"a\", \"b\", getStringOf(p1, p2)]\n */\npublic class ForEachNode extends AbstractRepeatableMatcher implements InlineNode {\n\n\tprivate PrimitiveMatcher iterableParameter;\n\tprivate RootNode nestedModel;\n\tprivate ParameterInfo localParameter;\n\n\tpublic ForEachNode() {\n\t}\n\n\t@Override\n\tpublic boolean replaceNode(RootNode oldNode, RootNode newNode) {\n\t\tif (iterableParameter == oldNode) {\n\t\t\t//before defined iterable parameter has to be replaced by another iterable parameter\n\t\t\t//Maybe it makes no sense, because\n\t\t\t//1) the iterable parameter has to be defined first\n\t\t\t//2) then ForEachNode can be created for that\n\t\t\t//3) then this method might be called to replace iterable parameter again\n\t\t\t//... but does that use case makes sense? Probably not.\n\t\t\titerableParameter = (PrimitiveMatcher) newNode;\n\t\t\treturn true;\n\t\t}\n\t\tif (iterableParameter.replaceNode(oldNode, newNode)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (nestedModel == oldNode) {\n\t\t\tnestedModel = newNode;\n\t\t\treturn true;\n\t\t}\n\t\treturn nestedModel.replaceNode(oldNode, newNode);\n\t}\n\n\t@Override\n\tpublic <T> void generateTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tfor (Object parameterValue : generator.generateTargets(iterableParameter, parameters, Object.class)) {\n\t\t\tgenerator.generateTargets(nestedModel, result, parameters.putValue(localParameter.getName(), parameterValue));\n\t\t}\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn iterableParameter.getMatchingStrategy();\n\t}\n\n\t@Override\n\tpublic TobeMatched matchAllWith(TobeMatched tobeMatched) {\n\t\tTobeMatched  localMatch = nestedModel.matchAllWith(tobeMatched.copyAndSetParams(tobeMatched.getParameters().checkpoint()));\n\t\tif (localMatch == null) {\n\t\t\t//nested model did not match.\n\t\t\treturn null;\n\t\t}\n\t\t//it matched.\n\t\tImmutableMap newParameters = tobeMatched.getParameters();\n\t\t//copy values of local parameters\n\t\tfor (Map.Entry<String, Object> e : localMatch.getParameters().getModifiedValues().entrySet()) {\n\t\t\tString name = e.getKey();\n\t\t\tObject value = e.getValue();\n\t\t\tif (name.equals(localParameter.getName())) {\n\t\t\t\t//value of local parameter has to be added to iterableParameter\n\t\t\t\tnewParameters = iterableParameter.matchTarget(value, newParameters);\n\t\t\t\tif (newParameters == null) {\n\t\t\t\t\t//new value did not passed the iterableParameter matcher\n\t\t\t\t\t//do not apply newParameters, which matched only partially, to parameters.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//it is new global parameter value. Just set it\n\t\t\t\tnewParameters = newParameters.putValue(name, value);\n\t\t\t}\n\t\t}\n\t\t//all local parameters were applied to newParameters. We can use newParameters as result of this iteration for next iteration\n\t\treturn localMatch.copyAndSetParams(newParameters);\n\t}\n\n\t@Override\n\tpublic void forEachParameterInfo(BiConsumer<ParameterInfo, RootNode> consumer) {\n\t\titerableParameter.forEachParameterInfo(consumer);\n\t\tconsumer.accept(localParameter, this);\n\t}\n\n\tpublic void setNestedModel(RootNode valueResolver) {\n\t\tthis.nestedModel = valueResolver;\n\t}\n\n\tpublic void setIterableParameter(PrimitiveMatcher substRequestOfIterable) {\n\t\tthis.iterableParameter = substRequestOfIterable;\n\t}\n\n\tpublic void setLocalParameter(ParameterInfo parameterInfo) {\n\t\tthis.localParameter = parameterInfo;\n\t}\n\n\t@Override\n\tpublic boolean isRepeatable() {\n\t\treturn iterableParameter.isRepeatable();\n\t}\n\n\t@Override\n\tpublic boolean isMandatory(ImmutableMap parameters) {\n\t\treturn iterableParameter.isMandatory(parameters);\n\t}\n\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\treturn iterableParameter.isTryNextMatch(parameters);\n\t}\n\n\t@Override\n\tpublic <T> void generateInlineTargets(DefaultGenerator generator, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tFactory f = generator.getFactory();\n\t\tCtForEach forEach = f.Core().createForEach();\n\t\tforEach.setVariable(f.Code().createLocalVariable(f.Type().objectType(), localParameter.getName(), null));\n\t\tforEach.setExpression(generator.generateSingleTarget(iterableParameter, parameters, CtExpression.class));\n\t\tCtBlock<?> body = f.createBlock();\n\t\tbody.setStatements(generator.generateTargets(nestedModel, parameters, CtStatement.class));\n\t\tforEach.setBody(body);\n\t\tresult.addResult((T) forEach);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/node/PrimitiveMatcher.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.node;\n\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Defines API of a primitive matcher - matcher for single target object\n */\npublic interface PrimitiveMatcher extends RepeatableMatcher {\n\n\t/**\n\t * @param target - to be matched element\n\t * @param parameters will receive the matching parameter values\n\t * @return true if `element` matches with pattern of this matcher\n\t */\n\tImmutableMap matchTarget(Object target, ImmutableMap parameters);\n}\n"
    }, {
      "name" : "pattern/internal/parameter/SetParameterInfo.java",
      "weight" : 63.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport spoon.support.util.ImmutableMap;\n\n/**\n */\npublic class SetParameterInfo extends AbstractParameterInfo {\n\n\tpublic SetParameterInfo(AbstractParameterInfo next) {\n\t\tsuper(next);\n\t}\n\n\t@Override\n\tprotected String getPlainName() {\n\t\treturn getWrappedName(getContainerName());\n\t}\n\n\t@Override\n\tprotected String getWrappedName(String containerName) {\n\t\treturn containerName;\n\t}\n\n\t@Override\n\tprotected Object addValueAs(Object container, Function<Object, Object> merger) {\n\t\tSet<Object> set = castTo(container, Set.class);\n\t\tObject newValue = merger.apply(null);\n\t\tif (newValue == NO_MERGE) {\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\tif (newValue == null) {\n\t\t\t//nothing to add. Keep existing set\n\t\t\treturn set;\n\t\t}\n\t\tif (set.contains(newValue)) {\n\t\t\t//the value is already there\n\t\t\treturn set;\n\t\t}\n\t\tSet<Object> newSet = new LinkedHashSet<>(set.size() + 1);\n\t\tnewSet.addAll(set);\n\t\tif (newValue instanceof Collection) {\n\t\t\tif (newSet.addAll((Collection) newValue) == false) {\n\t\t\t\t//all the values were already there. Return original set\n\t\t\t\treturn set;\n\t\t\t}\n\t\t} else {\n\t\t\tnewSet.add(newValue);\n\t\t}\n\t\treturn Collections.unmodifiableSet(newSet);\n\t}\n\n\t@Override\n\tprotected Set<Object> getEmptyContainer() {\n\t\treturn Collections.emptySet();\n\t}\n\t@Override\n\tprotected Object getValue(ImmutableMap parameters) {\n\t\treturn castTo(super.getValue(parameters), Set.class);\n\t}\n\n\t@Override\n\tprotected <T> T castTo(Object o, Class<T> type) {\n\t\tif (o instanceof List) {\n\t\t\to = new LinkedHashSet<>((List) o);\n\t\t} else if (o instanceof Object[]) {\n\t\t\to = new LinkedHashSet<>(Arrays.asList((Object[]) o));\n\t\t}\n\t\treturn super.castTo(o, type);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/parameter/MapParameterInfo.java",
      "weight" : 100.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport spoon.support.util.ImmutableMap;\nimport spoon.support.util.ImmutableMapImpl;\n\n/**\n * A kind of {@link ParameterInfo} which returns value by the named parameter\n * From a container of type {@link ImmutableMap} or {@link Map}\n */\npublic class MapParameterInfo extends AbstractParameterInfo {\n\n\tprivate final String name;\n\n\tpublic MapParameterInfo(String name) {\n\t\tthis(name, null);\n\t}\n\tpublic MapParameterInfo(AbstractParameterInfo next) {\n\t\tthis(null, next);\n\t}\n\tpublic MapParameterInfo(String name, AbstractParameterInfo next) {\n\t\tsuper(next);\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tprotected String getPlainName() {\n\t\treturn getWrappedName(getContainerName());\n\t}\n\n\t@Override\n\tprotected String getWrappedName(String containerName) {\n\t\tif (name == null) {\n\t\t\treturn containerName;\n\t\t}\n\t\tif (!containerName.isEmpty()) {\n\t\t\tcontainerName += \".\";\n\t\t}\n\t\treturn containerName + name;\n\t}\n\n\t@Override\n\tprotected Object addValueAs(Object container, Function<Object, Object> merger) {\n\t\tImmutableMap parameters = castTo(container, ImmutableMap.class);\n\t\tif (name == null) {\n\t\t\t//This accessor matches any entry - has no predefined key\n\t\t\tObject newValue = merger.apply(null);\n\t\t\tif (newValue == null) {\n\t\t\t\t//The accessor has no key, so null value means null Entry so nothing to add. Keep existing map\n\t\t\t\treturn parameters;\n\t\t\t}\n\t\t\tif (newValue == NO_MERGE) {\n\t\t\t\treturn NO_MERGE;\n\t\t\t}\n\t\t\tif (newValue instanceof Map.Entry<?, ?>) {\n\t\t\t\tMap.Entry<?, ?> newEntry = (Map.Entry<?, ?>) newValue;\n\t\t\t\tString newEntryKey = (String) newEntry.getKey();\n\t\t\t\tObject existingValue = parameters.getValue(newEntryKey);\n\t\t\t\tObject newEntryValue = merge(existingValue, newEntry.getValue());\n\t\t\t\tif (newEntryValue == NO_MERGE) {\n\t\t\t\t\treturn NO_MERGE;\n\t\t\t\t}\n\t\t\t\tif (existingValue == newEntryValue) {\n\t\t\t\t\t//it is already there\n\t\t\t\t\treturn parameters;\n\t\t\t\t}\n\t\t\t\treturn parameters.putValue(newEntryKey, newEntryValue);\n\t\t\t}\n\t\t\tif (newValue instanceof Map) {\n\t\t\t\tMap<String, Object> newMap = (Map) newValue;\n\t\t\t\tfor (Map.Entry<String, Object> newEntry : newMap.entrySet()) {\n\t\t\t\t\tString newEntryKey = newEntry.getKey();\n\t\t\t\t\tObject existingValue = parameters.getValue(newEntryKey);\n\t\t\t\t\tObject newEntryValue = merge(existingValue, newEntry.getValue());\n\t\t\t\t\tif (newEntryValue == NO_MERGE) {\n\t\t\t\t\t\treturn NO_MERGE;\n\t\t\t\t\t}\n\t\t\t\t\tif (existingValue != newEntryValue) {\n\t\t\t\t\t\t//it is not there yet. Add it\n\t\t\t\t\t\tparameters = parameters.putValue(newEntryKey, newEntryValue);\n\t\t\t\t\t}\n\t\t\t\t\t//it is there, continue to check next entry\n\t\t\t\t}\n\t\t\t\treturn parameters;\n\t\t\t}\n\t\t\t//only Map.Entries can be added to the Map if there is missing key\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\tObject existingValue = parameters.getValue(name);\n\t\tObject newValue = merger.apply(existingValue);\n\t\tif (newValue == NO_MERGE) {\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\tif (existingValue == newValue) {\n\t\t\t//it is already there.\n\t\t\treturn parameters;\n\t\t}\n\t\treturn parameters.putValue(name, newValue);\n\t}\n\n\t@Override\n\tprotected Object getValue(ImmutableMap parameters) {\n\t\tImmutableMap map = castTo(super.getValue(parameters), ImmutableMap.class);\n\t\treturn name == null ? map : map.getValue(name);\n\t}\n\n\t@Override\n\tprotected <T> T castTo(Object o, Class<T> type) {\n\t\tif (o instanceof Map) {\n\t\t\to = new ImmutableMapImpl((Map) o);\n\t\t}\n\t\treturn super.castTo(o, type);\n\t}\n\n\tprivate static final ImmutableMap EMPTY = new ImmutableMapImpl();\n\t@Override\n\tprotected ImmutableMap getEmptyContainer() {\n\t\treturn EMPTY;\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/parameter/AbstractParameterInfo.java",
      "weight" : 330.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.ValueConvertor;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.util.ImmutableMap;\n\npublic abstract class AbstractParameterInfo implements ParameterInfo {\n\n\t/**\n\t * is used as return value when value cannot be added\n\t */\n\tprotected static final Object NO_MERGE = new Object();\n\n\tprivate final AbstractParameterInfo containerItemAccessor;\n\n\tprivate ContainerKind containerKind = null;\n\tprivate Boolean repeatable = null;\n\tprivate int minOccurrences = 0;\n\tprivate int maxOccurrences = UNLIMITED_OCCURRENCES;\n\tprivate Quantifier matchingStrategy = Quantifier.GREEDY;\n\tprivate ValueConvertor valueConvertor;\n\n\tprivate Predicate<Object> matchCondition;\n\tprivate Class<?> parameterValueType;\n\n\tprotected AbstractParameterInfo(ParameterInfo containerItemAccessor) {\n\t\tthis.containerItemAccessor = (AbstractParameterInfo) containerItemAccessor;\n\t}\n\n\tprotected String getContainerName() {\n\t\tif (containerItemAccessor != null) {\n\t\t\treturn containerItemAccessor.getPlainName();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic final String getName() {\n\t\tAbstractParameterInfo cca = getContainerKindAccessor(getContainerKind(null, null));\n\t\tif (cca != null) {\n\t\t\treturn cca.getWrappedName(getPlainName());\n\t\t}\n\t\treturn getPlainName();\n\t}\n\n\tprotected abstract String getPlainName();\n\n\tprotected abstract String getWrappedName(String containerName);\n\n\t@Override\n\tpublic ImmutableMap addValueAs(ImmutableMap parameters, Object value) {\n\t\tClass<?> requiredType = getParameterValueType();\n\t\tif (requiredType != null && value != null && requiredType.isInstance(value) == false) {\n\t\t\treturn null;\n\t\t}\n\t\tif (matches(value) == false) {\n\t\t\treturn null;\n\t\t}\n\t\tObject newContainer = addValueToContainer(parameters, existingValue -> {\n\t\t\treturn merge(existingValue, value);\n\t\t});\n\t\tif (newContainer == NO_MERGE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (ImmutableMap) newContainer;\n\t}\n\n\tprotected Object addValueToContainer(Object container, Function<Object, Object> merger) {\n\t\tif (containerItemAccessor != null) {\n\t\t\treturn containerItemAccessor.addValueToContainer(container, existingValue -> {\n\t\t\t\treturn addValueAs(existingValue, merger);\n\t\t\t});\n\t\t}\n\t\treturn addValueAs(container, merger);\n\t}\n\n\tprotected Object merge(Object existingValue, Object newValue) {\n\t\tContainerKind cc = getContainerKind(existingValue, newValue);\n\t\tAbstractParameterInfo cca = getContainerKindAccessor(cc);\n\t\tif (cca == null) {\n\t\t\treturn mergeSingle(existingValue, newValue);\n\t\t}\n\t\treturn cca.addValueAs(existingValue,\n\t\t\t\texistingListItemValue -> mergeSingle(existingListItemValue, newValue));\n\t}\n\n\tprotected AbstractParameterInfo getContainerKindAccessor(ContainerKind containerKind) {\n\t\tswitch (containerKind) {\n\t\tcase SINGLE:\n\t\t\treturn null;\n\t\tcase LIST:\n\t\t\treturn new ListParameterInfo(this);\n\t\tcase SET:\n\t\t\treturn new SetParameterInfo(this);\n\t\tcase MAP:\n\t\t\treturn new MapParameterInfo(this);\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected ContainerKind \" + containerKind);\n\t}\n\n\tprotected Object mergeSingle(Object existingValue, Object newValue) {\n\t\tif (newValue == null && getMinOccurrences() > 0) {\n\t\t\t//the newValue is not optional. Null doesn't matches\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\tif (existingValue != null) {\n\t\t\tif (existingValue.equals(newValue)) {\n\t\t\t\t//the value is already stored there. Keep existing value\n\t\t\t\treturn existingValue;\n\t\t\t}\n\t\t\tif (newValue != null && existingValue.getClass().equals(newValue.getClass())) {\n\t\t\t\tif (newValue instanceof CtTypeReference) {\n\t\t\t\t\tif (((CtTypeReference<?>) newValue).getTypeErasure().equals(((CtTypeReference<?>) existingValue).getTypeErasure())) {\n\t\t\t\t\t\t//accept type references with different erasure\n\t\t\t\t\t\treturn existingValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// another value would be inserted. TemplateMatcher does not support\n\t\t\t// matching of different values for the same template parameter\n\t\t\tLauncher.LOGGER.debug(\"incongruent match on parameter \" + getName() + \" with value \" + newValue);\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * takes existing item value from the `container`,\n\t * sends it as parameter into `merger` and get's new to be stored value\n\t * stores that value into new `container` and returns it\n\t * @param container a container of values\n\t * @param merger a code which merges existing value from container with new value and returns merged value, which has to be stored in the container instead\n\t * @return copy of the container with merged value\n\t */\n\tprotected abstract Object addValueAs(Object container, Function<Object, Object> merger);\n\n\tprotected <T> T castTo(Object o, Class<T> type) {\n\t\tif (o == null) {\n\t\t\treturn getEmptyContainer();\n\t\t}\n\t\tif (type.isInstance(o)) {\n\t\t\treturn (T) o;\n\t\t}\n\t\tthrow new SpoonException(\"Cannot access parameter container of type \" + o.getClass() + \". It expects \" + type);\n\t}\n\n\tprotected abstract <T> T getEmptyContainer();\n\n\t/**\n\t * @param requiredType a required type of the value which matches as value of this parameter\n\t * @param matchCondition a {@link Predicate} which selects matching values\n\t * @return\n\t */\n\tpublic <T> AbstractParameterInfo setMatchCondition(Class<T> requiredType, Predicate<T> matchCondition) {\n\t\tthis.parameterValueType = requiredType;\n\t\tthis.matchCondition = (Predicate) matchCondition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Checks whether `value` matches with required type and match condition.\n\t * @param value\n\t * @return\n\t */\n\tprotected boolean matches(Object value) {\n\t\tif (parameterValueType != null && (value == null || parameterValueType.isAssignableFrom(value.getClass()) == false)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (matchCondition == null) {\n\t\t\t//there is no matching condition. Everything matches\n\t\t\treturn true;\n\t\t}\n\t\t//there is a matching condition. It must match\n\t\treturn matchCondition.test(value);\n\t}\n\t/**\n\t * @return a type of parameter value - if known\n\t *\n\t * Note: Pattern builder needs to know the value type to be able to select substitute node.\n\t * For example patter:\n\t *   return _expression_.S();\n\t * either replaces only `_expression_.S()` if the parameter value is an expression\n\t * or replaces `return _expression_.S()` if the parameter value is a CtBlock\n\t */\n\t@Override\n\tpublic Class<?> getParameterValueType() {\n\t\treturn parameterValueType;\n\t}\n\n\t/**\n\t * @param parameterValueType a type of the value which is acceptable by this parameter\n\t * @return this to support fluent API\n\t */\n\tpublic AbstractParameterInfo setParameterValueType(Class<?> parameterValueType) {\n\t\tthis.parameterValueType = parameterValueType;\n\t\treturn this;\n\t}\n\t/**\n\t * @return true if the value container has to be a List, otherwise the container will be a single value\n\t */\n\t@Override\n\tpublic boolean isMultiple() {\n\t\treturn getContainerKind(null, null) != ContainerKind.SINGLE;\n\t}\n\n\t/**\n\t * @param repeatable if this matcher can be applied more than once in the same container of targets\n\t * Note: even if false, it may be applied again to another container and to match EQUAL value.\n\t * @return this to support fluent API\n\t */\n\tpublic AbstractParameterInfo setRepeatable(boolean repeatable) {\n\t\tthis.repeatable = repeatable;\n\t\treturn this;\n\t}\n\n\n\tpublic int getMinOccurrences() {\n\t\treturn minOccurrences;\n\t}\n\n\tpublic AbstractParameterInfo setMinOccurrences(int minOccurrences) {\n\t\tthis.minOccurrences = minOccurrences;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return maximum number of values in this parameter.\n\t * Note: if {@link #isMultiple()}==false, then it never returns value &gt; 1\n\t */\n\tpublic int getMaxOccurrences() {\n\t\treturn isMultiple() ? maxOccurrences : Math.min(maxOccurrences, 1);\n\t}\n\n\tpublic void setMaxOccurrences(int maxOccurrences) {\n\t\tthis.maxOccurrences = maxOccurrences;\n\t}\n\n\t@Override\n\tpublic Quantifier getMatchingStrategy() {\n\t\treturn matchingStrategy;\n\t}\n\n\tpublic void setMatchingStrategy(Quantifier matchingStrategy) {\n\t\tthis.matchingStrategy = matchingStrategy;\n\t}\n\n\t/**\n\t * @return the {@link ValueConvertor} used by reading and writing into parameter values defined by this {@link ParameterInfo}\n\t */\n\tpublic ValueConvertor getValueConvertor() {\n\t\tif (valueConvertor != null) {\n\t\t\treturn valueConvertor;\n\t\t}\n\t\tif (containerItemAccessor != null) {\n\t\t\treturn containerItemAccessor.getValueConvertor();\n\t\t}\n\t\tthrow new SpoonException(\"ValueConvertor is not defined.\");\n\t}\n\n\t/**\n\t * @param valueConvertor the {@link ValueConvertor} used by reading and writing into parameter values defined by this {@link ParameterInfo}\n\t */\n\tpublic AbstractParameterInfo setValueConvertor(ValueConvertor valueConvertor) {\n\t\tif (valueConvertor == null) {\n\t\t\tthrow new SpoonException(\"valueConvertor must not be null\");\n\t\t}\n\t\tthis.valueConvertor = valueConvertor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return true if this matcher can be applied more than once in the same container of targets\n\t * Note: even if false, it may be applied again to another container and to match EQUAL value\n\t */\n\t@Override\n\tpublic boolean isRepeatable() {\n\t\tif (repeatable != null) {\n\t\t\treturn repeatable;\n\t\t}\n\t\treturn isMultiple();\n\t}\n\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if the ValueResolver of this parameter MUST match with next target in the state defined by current `parameters`.\n\t * false if match is optional\n\t */\n\t@Override\n\tpublic boolean isMandatory(ImmutableMap parameters) {\n\t\tint nrOfValues = getNumberOfValues(parameters);\n\t\t//current number of values is smaller than minimum number of values. Value is mandatory\n\t\treturn nrOfValues < getMinOccurrences();\n\t}\n\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if the ValueResolver of this parameter should be processed again to match next target in the state defined by current `parameters`.\n\t */\n\t@Override\n\tpublic boolean isTryNextMatch(ImmutableMap parameters) {\n\t\tint nrOfValues = getNumberOfValues(parameters);\n\t\tif (getContainerKind(parameters) == ContainerKind.SINGLE) {\n\t\t\t/*\n\t\t\t * the single value parameters should always try next match.\n\t\t\t * If the matching value is equal to existing value, then second match is accepted and there stays single value\n\t\t\t */\n\t\t\treturn true;\n\t\t}\n\t\t//current number of values is smaller than maximum number of values. Can try next match\n\t\treturn nrOfValues < getMaxOccurrences();\n\t}\n\n\t/**\n\t * @param parameters\n\t * @return 0 if there is no value. 1 if there is single value or null. Number of values in collection if there is a collection\n\t */\n\tprivate int getNumberOfValues(ImmutableMap parameters) {\n\t\tif (parameters.hasValue(getName()) == false) {\n\t\t\treturn 0;\n\t\t}\n\t\tObject value = parameters.getValue(getName());\n\t\tif (value instanceof Collection) {\n\t\t\treturn ((Collection) value).size();\n\t\t}\n\t\treturn 1;\n\t}\n\tpublic ContainerKind getContainerKind() {\n\t\treturn containerKind;\n\t}\n\n\tpublic AbstractParameterInfo setContainerKind(ContainerKind containerKind) {\n\t\tthis.containerKind = containerKind;\n\t\treturn this;\n\t}\n\tprotected ContainerKind getContainerKind(ImmutableMap params) {\n\t\treturn getContainerKind(params.getValue(getName()), null);\n\t}\n\tprotected ContainerKind getContainerKind(Object existingValue, Object value) {\n\t\tif (containerKind != null) {\n\t\t\treturn containerKind;\n\t\t}\n\t\tif (existingValue instanceof List) {\n\t\t\treturn ContainerKind.LIST;\n\t\t}\n\t\tif (existingValue instanceof Set) {\n\t\t\treturn ContainerKind.SET;\n\t\t}\n\t\tif (existingValue instanceof Map) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\tif (existingValue instanceof ImmutableMap) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\tif (existingValue != null) {\n\t\t\treturn ContainerKind.SINGLE;\n\t\t}\n\n\t\tif (value instanceof List) {\n\t\t\treturn ContainerKind.LIST;\n\t\t}\n\t\tif (value instanceof Set) {\n\t\t\treturn ContainerKind.SET;\n\t\t}\n\t\tif (value instanceof Map.Entry<?, ?>) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\tif (value instanceof Map) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\tif (value instanceof ImmutableMap) {\n\t\t\treturn ContainerKind.MAP;\n\t\t}\n\t\treturn ContainerKind.SINGLE;\n\t}\n\n\t@Override\n\tpublic <T> void getValueAs(Factory factory, ResultHolder<T> result, ImmutableMap parameters) {\n\t\t//get raw parameter value\n\t\tObject rawValue = getValue(parameters);\n\t\tif (isMultiple() && rawValue instanceof CtBlock<?>)  {\n\t\t\t/*\n\t\t\t * The CtBlock of this parameter is just implicit container of list of statements.\n\t\t\t * Convert it to list here, so further code see list and not the single CtBlock element\n\t\t\t */\n\t\t\trawValue = ((CtBlock<?>) rawValue).getStatements();\n\t\t}\n\t\tconvertValue(factory, result, rawValue);\n\t}\n\n\tprotected Object getValue(ImmutableMap parameters) {\n\t\tif (containerItemAccessor != null) {\n\t\t\treturn containerItemAccessor.getValue(parameters);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\tprotected <T> void convertValue(Factory factory, ResultHolder<T> result, Object rawValue) {\n\t\t//convert raw parameter value to expected type\n\t\tif (result.isMultiple()) {\n\t\t\tforEachItem(rawValue, singleValue -> {\n\t\t\t\tT convertedValue = convertSingleValue(factory, singleValue, result.getRequiredClass());\n\t\t\t\tif (convertedValue != null) {\n\t\t\t\t\tresult.addResult(convertedValue);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\t//single value converts arrays in rawValues into single value\n\t\t\tresult.addResult(convertSingleValue(factory, rawValue, result.getRequiredClass()));\n\t\t}\n\t}\n\n\tprotected <T> T convertSingleValue(Factory factory, Object value, Class<T> type) {\n\t\tValueConvertor valueConvertor = getValueConvertor();\n\t\treturn valueConvertor.getValueAs(factory, getName(), value, type);\n\t}\n\n\t/**\n\t * calls consumer.accept(Object) once for each item of the `multipleValues` collection or array.\n\t * If it is not a collection or array then it calls consumer.accept(Object) once with `multipleValues`\n\t * If `multipleValues` is null then consumer.accept(Object) is not called\n\t * @param multipleValues to be iterated potential collection of items\n\t * @param consumer the receiver of items\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tstatic void forEachItem(Object multipleValues, Consumer<Object> consumer) {\n\t\tif (multipleValues instanceof CtStatementList) {\n\t\t\t//CtStatementList extends Iterable, but we want to handle it as one node.\n\t\t\tconsumer.accept(multipleValues);\n\t\t\treturn;\n\t\t}\n\t\tif (multipleValues instanceof Iterable) {\n\t\t\tfor (Object item : (Iterable<Object>) multipleValues) {\n\t\t\t\tconsumer.accept(item);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (multipleValues instanceof Object[]) {\n\t\t\tfor (Object item : (Object[]) multipleValues) {\n\t\t\t\tconsumer.accept(item);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconsumer.accept(multipleValues);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(getName());\n\t\tif (getParameterValueType() != null) {\n\t\t\tsb.append(\" : \");\n\t\t\tsb.append(getParameterValueType().getName());\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/parameter/ComputedParameterInfo.java",
      "weight" : 36.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport java.util.List;\nimport java.util.function.Function;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Represents a parameter which is related to a value of another parameter.\n * For example parameter which represents CtTypeReference has a value `abc.sample.AType`\n * And computed parameter which represents name of type referenced by CtTypeReference\n * has a computed String value `AType`\n */\npublic class ComputedParameterInfo extends AbstractParameterInfo {\n\n\tprivate final ParameterComputer computer;\n\n\tpublic ComputedParameterInfo(ParameterComputer computer, ParameterInfo next) {\n\t\tsuper(next);\n\t\tthis.computer = computer;\n\t}\n\n\t@Override\n\tprotected String getPlainName() {\n\t\treturn getWrappedName(getContainerName());\n\t}\n\n\t@Override\n\tprotected String getWrappedName(String containerName) {\n\t\treturn containerName + \"$\" + computer.getName();\n\t}\n\n\t@Override\n\tprotected Object addValueAs(Object container, Function<Object, Object> merger) {\n\t\t//do not try to match on computed value\n\t\treturn container;\n\t}\n\n\t@Override\n\tprotected List<Object> getEmptyContainer() {\n\t\tthrow new SpoonException(\"ComputedParameterInfo#getEmptyContainer should not be used\");\n\t}\n\t@Override\n\tpublic <T> void getValueAs(Factory factory, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tResultHolder<?> inputHolder = computer.createInputHolder();\n\t\tsuper.getValueAs(factory, inputHolder, parameters);\n\t\tcomputer.computeValue((ResultHolder) result, inputHolder);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/parameter/ListParameterInfo.java",
      "weight" : 90.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport spoon.support.util.ImmutableMap;\n\n/**\n */\npublic class ListParameterInfo extends AbstractParameterInfo {\n\n\tprivate final int idx;\n\n\tpublic ListParameterInfo(ParameterInfo next) {\n\t\tthis(-1, next);\n\t}\n\tpublic ListParameterInfo(int idx, ParameterInfo next) {\n\t\tsuper(next);\n\t\tthis.idx = idx;\n\t}\n\n\t@Override\n\tprotected String getPlainName() {\n\t\treturn getWrappedName(getContainerName());\n\t}\n\n\t@Override\n\tprotected String getWrappedName(String containerName) {\n\t\tif (idx < 0) {\n\t\t\treturn containerName;\n\t\t}\n\t\treturn containerName + \"[\" + idx + \"]\";\n\t}\n\n\t@Override\n\tprotected Object addValueAs(Object container, Function<Object, Object> merger) {\n\t\tList<Object> list = castTo(container, List.class);\n\t\tObject existingValue = getExistingValue(list);\n\t\tObject newValue = merger.apply(existingValue);\n\t\tif (newValue == NO_MERGE) {\n\t\t\treturn NO_MERGE;\n\t\t}\n\t\tif (existingValue == newValue) {\n\t\t\t//the value is already there. Keep existing list\n\t\t\treturn list;\n\t\t}\n\t\tif (newValue == null) {\n\t\t\t//nothing to add. Keep existing list\n\t\t\treturn list;\n\t\t}\n\t\tList<Object> newList = new ArrayList<>(list.size() + 1);\n\t\tnewList.addAll(list);\n\t\tif (idx >= 0) {\n\t\t\twhile (idx >= newList.size()) {\n\t\t\t\tnewList.add(null);\n\t\t\t}\n\t\t\tnewList.set(idx, newValue);\n\t\t} else {\n\t\t\tif (newValue instanceof Collection) {\n\t\t\t\tnewList.addAll((Collection) newValue);\n\t\t\t} else {\n\t\t\t\tnewList.add(newValue);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(newList);\n\t}\n\n\tprotected Object getExistingValue(List<Object> list) {\n\t\tif (list == null || idx < 0 || idx >= list.size()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn list.get(idx);\n\t}\n\t@Override\n\tprotected List<Object> getEmptyContainer() {\n\t\treturn Collections.emptyList();\n\t}\n\t@Override\n\tprotected Object getValue(ImmutableMap parameters) {\n\t\tList<Object> list = castTo(super.getValue(parameters), List.class);\n\t\tif (idx < 0) {\n\t\t\treturn list;\n\t\t}\n\t\tif (idx < list.size()) {\n\t\t\treturn list.get(idx);\n\t\t}\n\t\treturn null;\n\t}\n\t@Override\n\tprotected <T> T castTo(Object o, Class<T> type) {\n\t\tif (o instanceof Set) {\n\t\t\to = new ArrayList<>((Set) o);\n\t\t} else if (o instanceof Object[]) {\n\t\t\to = Arrays.asList((Object[]) o);\n\t\t}\n\t\treturn super.castTo(o, type);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/parameter/ParameterComputer.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport spoon.pattern.internal.ResultHolder;\n\n/**\n * Computes a value of {@link ComputedParameterInfo}\n * I - type of input value\n * O - type of computed value\n */\npublic interface ParameterComputer {\n\n\t/**\n\t * @return user friendly name of this computer\n\t */\n\tString getName();\n\n\t/**\n\t * @return holder for input value\n\t */\n\tResultHolder<?> createInputHolder();\n\n\t/**\n\t * @param outputHolder holds result of computation\n\t * @param inputHolder holds input of computation\n\t */\n\tvoid computeValue(ResultHolder<Object> outputHolder, ResultHolder<?> inputHolder);\n}\n"
    }, {
      "name" : "pattern/internal/parameter/ParameterInfo.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport spoon.pattern.Pattern;\nimport spoon.pattern.Quantifier;\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Represents the parameter of {@link Pattern}\n * defines acceptable value of parameter value during matching. For example type, filter on attribute values.\n */\npublic interface ParameterInfo {\n\tint UNLIMITED_OCCURRENCES = Integer.MAX_VALUE;\n\n\t/**\n\t * @return the full name of the parameter from the root of parameter container to the value represented by this {@link ParameterInfo}\n\t */\n\tString getName();\n\n\t/**\n\t * Matches `value` into `parameters` under the name/structure defined by this ParameterInfo.\n\t * 1) checks that value matches with optional internal rules of this {@link ParameterInfo}\n\t * 2) creates new copy of {@link ImmutableMap} which contains the new `value` and returns that copy\n\t *\n\t * @param parameters the existing parameters\n\t * @param value the new, to be stored value\n\t * @return copy of `parameters` with new value or existing `parameters` if value is already there or null if value doesn't fit into these parameters\n\t */\n\tImmutableMap addValueAs(ImmutableMap parameters, Object value);\n\n\t/**\n\t * Takes the value of parameter identified by this {@link ParameterInfo} from the `parameters`\n\t * and adds that 0, 1 or more values into result (depending on type of result)\n\t * @param factory the factory used to create new entities if conversion of value is needed before it can be added into `result`\n\t * @param result the receiver of the result value. It defined required type of returned value and multiplicity of returned value\n\t * @param parameters here are stored all the parameter values\n\t */\n\t<T> void getValueAs(Factory factory, ResultHolder<T> result, ImmutableMap parameters);\n\n\t/**\n\t * @return true if the value container has to be a List, otherwise the container will be a single value\n\t */\n\tboolean isMultiple();\n\n\t/**\n\t * @return a type of parameter value - if known\n\t *\n\t * Note: Pattern builder needs to know the value type to be able to select substitute node.\n\t * For example patter:\n\t *   return _expression_.S();\n\t * either replaces only `_expression_.S()` if the parameter value is an expression\n\t * or replaces `return _expression_.S()` if the parameter value is a CtBlock\n\t */\n\tClass<?> getParameterValueType();\n\n\t/**\n\t * @return the strategy used to resolve conflict between two {@link RootNode}s\n\t */\n\tQuantifier getMatchingStrategy();\n\n\t/**\n\t * @return true if this matcher can be applied more then once in the same container of targets\n\t * Note: even if false, it may be applied again to another container and to match EQUAL value\n\t */\n\tboolean isRepeatable();\n\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if the ValueResolver of this parameter MUST match with next target in the state defined by current `parameters`.\n\t * false if match is optional\n\t */\n\tboolean isMandatory(ImmutableMap parameters);\n\n\t/**\n\t * @param parameters matching parameters\n\t * @return true if the ValueResolver of this parameter should be processed again to match next target in the state defined by current `parameters`.\n\t */\n\tboolean isTryNextMatch(ImmutableMap parameters);\n}\n"
    }, {
      "name" : "pattern/internal/parameter/SimpleNameOfTypeReferenceParameterComputer.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal.parameter;\n\nimport spoon.pattern.internal.ResultHolder;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * a {@link ParameterComputer} which computes simpleName of {@link CtTypeReference}\n */\npublic class SimpleNameOfTypeReferenceParameterComputer implements ParameterComputer {\n\n\tpublic static final SimpleNameOfTypeReferenceParameterComputer INSTANCE = new SimpleNameOfTypeReferenceParameterComputer();\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"simpleName\";\n\t}\n\n\t@Override\n\tpublic ResultHolder<?> createInputHolder() {\n\t\treturn new ResultHolder.Single<>(CtTypeReference.class);\n\t}\n\n\t@Override\n\tpublic void computeValue(ResultHolder<Object> outputHolder, ResultHolder<?> inputHolder) {\n\t\tString name = null;\n\t\tCtTypeReference<?> typeRef = ((ResultHolder.Single<CtTypeReference<?>>) inputHolder).getResult();\n\t\tif (typeRef != null) {\n\t\t\tname = typeRef.getSimpleName();\n\t\t}\n\t\toutputHolder.addResult(name);\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/ResultHolder.java",
      "weight" : 75.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.function.Function;\n\nimport spoon.SpoonException;\n\n/**\n * Container for single or multiple values of required type\n */\npublic abstract class ResultHolder<T> {\n\tprivate final Class<T> requiredClass;\n\n\tpublic ResultHolder(Class<T> requiredClass) {\n\t\tthis.requiredClass = requiredClass;\n\t}\n\n\t/**\n\t * @return the class of values, which acceptable by this result holder\n\t */\n\tpublic Class<T> getRequiredClass() {\n\t\treturn requiredClass;\n\t}\n\n\t/**\n\t * @return true if it accepts 0, 1 or more values. false if it accepts exactly one value. If none, then value is null\n\t */\n\tpublic abstract boolean isMultiple();\n\n\t/**\n\t * adds a result into this result holder\n\t * @param value a new value of result holder\n\t */\n\tpublic abstract void addResult(T value);\n\n\t/**\n\t * calls consumer.accept(value) once for each contained value\n\t * @param consumer\n\t */\n\tpublic abstract void mapEachResult(Function<T, T> consumer);\n\t/**\n\t * @return List of actually stored results\n\t */\n\tpublic abstract List<T> getResults();\n\n\t/**\n\t * Container of single value of required type\n\t *\n\t * @param <T>\n\t */\n\tpublic static class Single<T> extends ResultHolder<T> {\n\n\t\tprivate T result;\n\n\t\tpublic Single(Class<T> requiredClass) {\n\t\t\tsuper(requiredClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isMultiple() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void addResult(T value) {\n\t\t\tif (this.result != null) {\n\t\t\t\tthrow new SpoonException(\"Cannot add second value into single value ConversionContext\");\n\t\t\t}\n\t\t\tthis.result = value;\n\t\t}\n\n\t\tpublic T getResult() {\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void mapEachResult(Function<T, T> consumer) {\n\t\t\tresult = consumer.apply(result);\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> getResults() {\n\t\t\treturn result == null ? Collections.emptyList() : Collections.singletonList(result);\n\t\t}\n\t}\n\n\t/**\n\t * Container of multiple values of required type\n\t *\n\t * @param <T>\n\t */\n\tpublic static class Multiple<T> extends ResultHolder<T> {\n\n\t\tList<T> result = new ArrayList<>();\n\n\t\tpublic Multiple(Class<T> requiredClass) {\n\t\t\tsuper(requiredClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isMultiple() {\n\t\t\treturn true;\n\t\t}\n\t\t@Override\n\t\tpublic void addResult(T value) {\n\t\t\tthis.result.add(value);\n\t\t}\n\n\t\tpublic List<T> getResult() {\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> getResults() {\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic void mapEachResult(Function<T, T> consumer) {\n\t\t\tfor (ListIterator<T> iter = result.listIterator(); iter.hasNext();) {\n\t\t\t\titer.set(consumer.apply(iter.next()));\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "pattern/internal/ValueConvertor.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport spoon.reflect.factory.Factory;\n\n/**\n * Converts the individual parameter values to required type after substitution\n * Converts the matching model values to parameter values during matching process\n */\npublic interface ValueConvertor {\n\t<T> T getValueAs(Factory factory, String parameterName, Object value, Class<T> valueClass);\n}\n"
    }, {
      "name" : "pattern/internal/DefaultGenerator.java",
      "weight" : 202.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern.internal;\n\nimport spoon.pattern.Generator;\nimport spoon.pattern.PatternBuilder;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.SpoonClassNotFoundException;\nimport spoon.support.util.ImmutableMap;\nimport spoon.support.util.ImmutableMapImpl;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Drives generation process\n */\npublic class DefaultGenerator implements Generator {\n\tprotected final Factory factory;\n\tprivate boolean addGeneratedBy = false;\n\tprivate ListOfNodes nodes;\n\n\tpublic DefaultGenerator(Factory factory, ListOfNodes nodes) {\n\t\tthis.nodes = nodes;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Generates one target depending on kind of this {@link RootNode}, expected `expectedType` and input `parameters`\n\t * @param node to be generated node\n\t * @param parameters {@link ImmutableMap}\n\t * @param expectedType defines {@link Class} of returned value\n\t *\n\t * @return a generate value or null\n\t */\n\tpublic <T> T generateSingleTarget(RootNode node, ImmutableMap parameters, Class<T> expectedType) {\n\t\tResultHolder.Single<T> result = new ResultHolder.Single<>(expectedType);\n\t\tgenerateTargets(node, result, parameters);\n\t\treturn result.getResult();\n\t}\n\n\t/**\n\t * Generates zero, one or more targets depending on kind of this {@link RootNode}, expected `expectedType` and input `parameters`\n\t * @param node to be generated node\n\t * @param parameters {@link ImmutableMap}\n\t * @param expectedType defines {@link Class} of returned value\n\t *\n\t * @return a {@link List} of generated targets\n\t */\n\tpublic <T> List<T> generateTargets(RootNode node, ImmutableMap parameters, Class<T> expectedType) {\n\t\tResultHolder.Multiple<T> result = new ResultHolder.Multiple<>(expectedType);\n\t\tgenerateTargets(node, result, parameters);\n\t\treturn result.getResult();\n\t}\n\n\n\t/**\n\t * Generates zero, one or more target depending on kind of this {@link RootNode}, expected `result` and input `parameters`\n\t * @param node to be generated node\n\t * @param result the holder which receives the generated node\n\t * @param parameters the input parameters\n\t */\n\tpublic <T> void generateTargets(RootNode node, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tnode.generateTargets(this, result, parameters);\n\t\tif (node.isSimplifyGenerated()) {\n\t\t\t// simplify this element, it contains a substituted element\n\t\t\tresult.mapEachResult(element -> {\n\t\t\t\tif (element instanceof CtCodeElement) {\n\t\t\t\t\tCtCodeElement code = (CtCodeElement) element;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcode = code.partiallyEvaluate();\n\t\t\t\t\t\tif (result.getRequiredClass().isInstance(code)) {\n\t\t\t\t\t\t\treturn (T) code;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * else the simplified code is not matching with required type. For example\n\t\t\t\t\t\t * statement String.class.getName() was converted to expression\n\t\t\t\t\t\t * \"java.lang.String\"\n\t\t\t\t\t\t */\n\t\t\t\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\t\t\t\t// ignore it. Do not simplify this element\n\t\t\t\t\t\tgetFactory().getEnvironment()\n\t\t\t\t\t\t\t\t.debugMessage(\"Partial evaluation was skipped because of: \" + e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn element;\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns zero, one or more values into `result`. The value comes from `parameters` from the location defined by `parameterInfo`\n\t * @param parameterInfo the {@link ParameterInfo}, which describes exact parameter from `parameters`\n\t * @param result the holder which receives the generated node\n\t * @param parameters the input parameters\n\t */\n\tpublic <T> void getValueAs(ParameterInfo parameterInfo, ResultHolder<T> result, ImmutableMap parameters) {\n\t\tparameterInfo.getValueAs(factory, result, parameters);\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\tpublic DefaultGenerator setAddGeneratedBy(boolean addGeneratedBy) {\n\t\tthis.addGeneratedBy = addGeneratedBy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a Generated by comment to the javadoc of generatedElement\n\t * @param generatedElement a newly generated element\n\t * @param genBy the documentation to be added\n\t */\n\tpublic void applyGeneratedBy(CtElement generatedElement, String genBy) {\n\t\tif (isAddGeneratedBy() && generatedElement instanceof CtTypeMember) {\n\t\t\tif (genBy != null) {\n\t\t\t\taddGeneratedByComment(generatedElement, genBy);\n\t\t\t}\n\t\t}\n\t}\n\tpublic String getGeneratedByComment(CtElement ele) {\n\t\tSourcePosition pos = ele.getPosition();\n\t\tif (pos != null && pos.isValidPosition()) {\n\t\t\tCompilationUnit cu = pos.getCompilationUnit();\n\t\t\tif (cu != null) {\n\t\t\t\tCtType<?> mainType = cu.getMainType();\n\t\t\t\tif (mainType != null) {\n\t\t\t\t\tStringBuilder result = new StringBuilder();\n\t\t\t\t\tresult.append(\"Generated by \");\n\t\t\t\t\tresult.append(mainType.getQualifiedName());\n\t\t\t\t\tappendInnerTypedElements(result, mainType, ele);\n\t\t\t\t\tresult.append('(');\n\t\t\t\t\tresult.append(mainType.getSimpleName());\n\t\t\t\t\tresult.append(\".java:\");\n\t\t\t\t\tresult.append(pos.getLine());\n\t\t\t\t\tresult.append(')');\n\t\t\t\t\treturn  result.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate void appendInnerTypedElements(StringBuilder result, CtType<?> mainType, CtElement ele) {\n\t\tCtTypeMember typeMember = getFirst(ele, CtTypeMember.class);\n\t\tif (typeMember != null && isMainType(typeMember, mainType) == false) {\n\t\t\tif (typeMember.isParentInitialized()) {\n\t\t\t\tappendInnerTypedElements(result, mainType, typeMember.getParent());\n\t\t\t}\n\t\t\tif (typeMember instanceof CtType) {\n\t\t\t\tresult.append('$');\n\t\t\t} else {\n\t\t\t\tresult.append('#');\n\t\t\t}\n\t\t\tresult.append(typeMember.getSimpleName());\n\t\t}\n\t}\n\n\tprivate boolean isMainType(CtTypeMember tm, CtType<?> mainType) {\n\t\tif (tm instanceof CtType) {\n\t\t\treturn mainType.getQualifiedName().equals(((CtType) tm).getQualifiedName());\n\t\t}\n\t\treturn false;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T extends CtElement> T getFirst(CtElement ele, Class<T> clazz) {\n\t\tif (ele != null) {\n\t\t\tif (clazz.isAssignableFrom(ele.getClass())) {\n\t\t\t\treturn (T) ele;\n\t\t\t}\n\t\t\tif (ele.isParentInitialized()) {\n\t\t\t\treturn getFirst(ele.getParent(), clazz);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void addGeneratedByComment(CtElement ele, String generatedBy) {\n\t\tif (generatedBy == null) {\n\t\t\treturn;\n\t\t}\n\t\tString EOL = System.getProperty(\"line.separator\");\n\t\tCtComment comment = getJavaDoc(ele);\n\t\tString content = comment.getContent();\n\t\tif (!content.trim().isEmpty()) {\n\t\t\tcontent += EOL + EOL;\n\t\t}\n\t\tcontent += generatedBy;\n\t\tcomment.setContent(content);\n\t}\n\n\tprivate CtComment getJavaDoc(CtElement ele) {\n\t\tfor (CtComment comment : ele.getComments()) {\n\t\t\tif (comment.getCommentType() == CtComment.CommentType.JAVADOC) {\n\t\t\t\treturn comment;\n\t\t\t}\n\t\t}\n\t\tCtComment c = ele.getFactory().Code().createComment(\"\", CtComment.CommentType.JAVADOC);\n\t\tele.addComment(c);\n\t\treturn c;\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> List<T> generate(Class<T> valueType, ImmutableMap params) {\n\t\treturn setAddGeneratedBy(isAddGeneratedBy()).generateTargets(nodes, params, valueType);\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> List<T> generate(Class<T> valueType, Map<String, Object> params) {\n\t\treturn generate(valueType, new ImmutableMapImpl(params));\n\t}\n\n\t@Override\n\tpublic <T extends CtType<?>> T generateType(String typeQualifiedName, Map<String, Object> params) {\n\t\tCtTypeReference<?> newTypeRef = factory.Type().createReference(typeQualifiedName);\n\t\tCtPackage ownerPackage = newTypeRef.getFactory().Package().getOrCreate(newTypeRef.getPackage().getQualifiedName());\n\t\treturn createType(ownerPackage, newTypeRef.getSimpleName(), params);\n\t}\n\n\t/**\n\t * Generates type in the package `ownerPackage` with simple name `typeSimpleName` using this {@link Generator} and provided `params`\n\t *\n\t * Note: the root of pattern element must be one or more types.\n\t *\n\t * @param ownerPackage the target package\n\t * @param typeSimpleName the simple name of future generated type\n\t * @param params the pattern parameters\n\t * @return the generated type\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T extends CtType<?>> T createType(CtPackage ownerPackage, String typeSimpleName, Map<String, Object> params) {\n\t\t@SuppressWarnings({ \"rawtypes\" })\n\t\tList<CtType> types = generate(CtType.class, new ImmutableMapImpl(params,\n\t\t\t\tPatternBuilder.TARGET_TYPE, ownerPackage.getFactory().Type().createReference(getQualifiedName(ownerPackage, typeSimpleName))));\n\t\tT result = null;\n\t\tfor (CtType<?> type : types) {\n\t\t\townerPackage.addType(type);\n\t\t\tif (type.getSimpleName().equals(typeSimpleName)) {\n\t\t\t\tresult = (T) type;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic <T extends CtTypeMember> List<T> addToType(Class<T> valueType, Map<String, Object> params, CtType<?> targetType) {\n\t\tList<T> results = generate(valueType, new ImmutableMapImpl(params, PatternBuilder.TARGET_TYPE, targetType.getReference()));\n\t\tfor (T result : results) {\n\t\t\tif (result instanceof CtTypeMember) {\n\t\t\t\ttargetType.addTypeMember((CtTypeMember) result);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate static String getQualifiedName(CtPackage pckg, String simpleName) {\n\t\tif (pckg.isUnnamedPackage()) {\n\t\t\treturn simpleName;\n\t\t}\n\t\treturn pckg.getQualifiedName() + CtPackage.PACKAGE_SEPARATOR + simpleName;\n\t}\n\n\tpublic boolean isAddGeneratedBy() {\n\t\treturn addGeneratedBy;\n\t}\n\n}\n"
    }, {
      "name" : "pattern/PatternParameterConfigurator.java",
      "weight" : 640.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport spoon.SpoonException;\nimport spoon.metamodel.Metamodel;\nimport spoon.pattern.internal.ValueConvertor;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.node.MapEntryNode;\nimport spoon.pattern.internal.node.ParameterNode;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.pattern.internal.node.StringNode;\nimport spoon.pattern.internal.parameter.AbstractParameterInfo;\nimport spoon.pattern.internal.parameter.ComputedParameterInfo;\nimport spoon.pattern.internal.parameter.ListParameterInfo;\nimport spoon.pattern.internal.parameter.MapParameterInfo;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.pattern.internal.parameter.SimpleNameOfTypeReferenceParameterComputer;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtQueryable;\nimport spoon.reflect.visitor.filter.AllTypeMembersFunction;\nimport spoon.reflect.visitor.filter.InvocationFilter;\nimport spoon.reflect.visitor.filter.NamedElementFilter;\nimport spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction;\nimport spoon.reflect.visitor.filter.VariableReferenceFunction;\nimport spoon.support.Experimental;\nimport spoon.template.Parameter;\nimport spoon.template.Template;\nimport spoon.template.TemplateParameter;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Predicate;\n\nimport static spoon.pattern.PatternBuilder.getLocalTypeRefBySimpleName;\n\n/**\n * Used to define pattern parameters.\n *\n * Main documentation at http://spoon.gforge.inria.fr/pattern.html.\n */\n@Experimental\npublic class PatternParameterConfigurator {\n\tprivate final PatternBuilder patternBuilder;\n\tprivate final Map<String, AbstractParameterInfo> parameterInfos;\n\tprivate AbstractParameterInfo currentParameter;\n\tprivate List<CtElement> substitutedNodes = new ArrayList<>();\n\tprivate ConflictResolutionMode conflictResolutionMode = ConflictResolutionMode.FAIL;\n\n\tPatternParameterConfigurator(PatternBuilder patternBuilder, Map<String, AbstractParameterInfo> parameterInfos) {\n\t\tthis.patternBuilder = patternBuilder;\n\t\tthis.parameterInfos = parameterInfos;\n\t}\n\n\t/**\n\t * @return current {@link ConflictResolutionMode}\n\t */\n\tpublic ConflictResolutionMode getConflictResolutionMode() {\n\t\treturn conflictResolutionMode;\n\t}\n\n\t/**\n\t * Defines what happens when before explicitly added {@link RootNode} has to be replaced by another {@link RootNode}\n\t * @param conflictResolutionMode to be applied mode\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator setConflictResolutionMode(ConflictResolutionMode conflictResolutionMode) {\n\t\tthis.conflictResolutionMode = conflictResolutionMode;\n\t\treturn this;\n\t}\n\n\tpublic CtQueryable queryModel() {\n\t\treturn patternBuilder.patternQuery;\n\t}\n\n\tprivate AbstractParameterInfo getParameterInfo(String parameterName, boolean createIfNotExist) {\n\t\tAbstractParameterInfo pi = parameterInfos.get(parameterName);\n\t\tif (pi == null) {\n\t\t\tpi = new MapParameterInfo(parameterName).setValueConvertor(patternBuilder.getDefaultValueConvertor());\n\t\t\tparameterInfos.put(parameterName, pi);\n\t\t}\n\t\treturn pi;\n\t}\n\n\t/**\n\t * Creates a parameter with name `paramName` and assigns it into context, so next calls on builder will be applied to this parameter\n\t * @param paramName to be build parameter name\n\t * @return this {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator parameter(String paramName) {\n\t\tcurrentParameter = getParameterInfo(paramName, true);\n\t\tsubstitutedNodes.clear();\n\t\treturn this;\n\t}\n\n\tpublic PatternParameterConfigurator setMinOccurrence(int minOccurrence) {\n\t\tcurrentParameter.setMinOccurrences(minOccurrence);\n\t\treturn this;\n\t}\n\n\tpublic PatternParameterConfigurator setMaxOccurrence(int maxOccurrence) {\n\t\tif (maxOccurrence == ParameterInfo.UNLIMITED_OCCURRENCES || maxOccurrence > 1 && currentParameter.isMultiple() == false) {\n\t\t\tthrow new SpoonException(\"Cannot set maxOccurrences > 1 for single value parameter. Call setMultiple(true) first.\");\n\t\t}\n\t\tcurrentParameter.setMaxOccurrences(maxOccurrence);\n\t\treturn this;\n\t}\n\n\tpublic PatternParameterConfigurator setMatchingStrategy(Quantifier quantifier) {\n\t\tcurrentParameter.setMatchingStrategy(quantifier);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set expected type of Parameter. In some cases legacy Template needs to know the type of parameter value to select substituted element.\n\t * See {@link ValueConvertor}, which provides conversion between matched element and expected parameter type\n\t * @param valueType a expected type of parameter value\n\t * @return this {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator setValueType(Class<?> valueType) {\n\t\tcurrentParameter.setParameterValueType(valueType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Defines type of parameter value (List/Set/Map/single).\n\t * If not defined then real value type of property is used. If null, then default is {@link ContainerKind#SINGLE}\n\t * @param containerKind to be used {@link ContainerKind}\n\t * @return this {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator setContainerKind(ContainerKind containerKind) {\n\t\tcurrentParameter.setContainerKind(containerKind);\n\t\treturn this;\n\t}\n\n\tpublic ParameterInfo getCurrentParameter() {\n\t\tif (currentParameter == null) {\n\t\t\tthrow new SpoonException(\"Parameter name must be defined first by call of #parameter(String) method.\");\n\t\t}\n\t\treturn currentParameter;\n\t}\n\n\t/**\n\t * `type` itself and all the references to the `type` are subject for substitution by current parameter\n\t * @param type to be substituted Class\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byType(Class<?> type) {\n\t\treturn byType(type.getName());\n\t}\n\n\t/**\n\t * type identified by `typeQualifiedName` itself and all the references (with arbitrary actual type arguments)\n\t * to that type are subject for substitution by current parameter\n\t * @param typeQualifiedName a fully qualified name of to be substituted Class\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byType(String typeQualifiedName) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\t//substitute all references with same qualified name (ignoring actual type arguments) to that type\n\t\tqueryModel().filterChildren((CtTypeReference<?> typeRef) -> typeRef.getQualifiedName().equals(typeQualifiedName))\n\t\t\t.forEach((CtTypeReference<?> typeRef) -> {\n\t\t\t\taddSubstitutionRequest(pi, typeRef);\n\t\t\t});\n\t\t/**\n\t\t * If Type itself is found part of model, then substitute it's simple name too\n\t\t */\n\t\tCtType<?> type2 = queryModel().filterChildren((CtType<?> t) -> t.getQualifiedName().equals(typeQualifiedName)).first();\n\t\tif (type2 != null) {\n\t\t\t//Substitute name of template too\n\t\t\taddSubstitutionRequest(pi, type2, CtRole.NAME);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * type referred by {@link CtTypeReference} `type` and all the references (with same actual type arguments)\n\t * to that type are subject for substitution by current parameter\n\t * @param type a fully qualified name of to be substituted Class\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byType(CtTypeReference<?> type) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\t//substitute all references (with same actual type arguments too) to that type\n\t\tqueryModel().filterChildren((CtTypeReference<?> typeRef) -> typeRef.equals(type))\n\t\t\t.forEach((CtTypeReference<?> typeRef) -> {\n\t\t\t\taddSubstitutionRequest(pi, typeRef);\n\t\t\t});\n\t\t/**\n\t\t * If Type itself is found part of model, then substitute it's simple name too\n\t\t */\n\t\tString typeQName = type.getQualifiedName();\n\t\tCtType<?> type2 = queryModel().filterChildren((CtType<?> t) -> t.getQualifiedName().equals(typeQName)).first();\n\t\tif (type2 != null) {\n\t\t\t//Substitute name of template too\n\t\t\tComputedParameterInfo piName = new ComputedParameterInfo(SimpleNameOfTypeReferenceParameterComputer.INSTANCE, pi);\n\t\t\tpiName.setParameterValueType(String.class);\n\t\t\taddSubstitutionRequest(piName, type2, CtRole.NAME);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Searches for a type visible in scope `templateType`, whose simple name is equal to `localTypeSimpleName`\n\t * @param searchScope the Type which is searched for local Type\n\t * @param localTypeSimpleName the simple name of to be returned Type\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byLocalType(CtType<?> searchScope, String localTypeSimpleName) {\n\t\tbyLocalType(searchScope, localTypeSimpleName, false);\n\t\treturn this;\n\t}\n\n\tPatternParameterConfigurator byLocalType(CtType<?> searchScope, String localTypeSimpleName, boolean optional) {\n\t\tString nestedType = getLocalTypeRefBySimpleName(searchScope, localTypeSimpleName);\n\t\tif (nestedType == null) {\n\t\t\t//such type doesn't exist\n\t\t\tif (optional) {\n\t\t\t\t//no problem\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthrow new SpoonException(\"Template parameter \" + localTypeSimpleName + \" doesn't match to any local type\");\n\t\t}\n\t\t//There is a local type with such name. Replace it\n\t\tbyType(nestedType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * variable read/write of `variable`\n\t * @param variableName a variable whose references will be substituted\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byVariable(String variableName) {\n\t\tCtVariable<?> var = queryModel().map(new PotentialVariableDeclarationFunction(variableName)).first();\n\t\tif (var != null) {\n\t\t\tbyVariable(var);\n\t\t}\t//else may be we should fail?\n\t\treturn this;\n\t}\n\n\t/**\n\t * variable read/write of `variable`\n\t * @param variable a variable whose references will be substituted\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byVariable(CtVariable<?> variable) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tCtQueryable root = queryModel();\n\t\tif (patternBuilder.isInModel(variable)) {\n\t\t\t//variable is part of model, start search from variable\n\t\t\troot = variable;\n\t\t}\n\t\troot.map(new VariableReferenceFunction(variable))\n\t\t\t.forEach((CtVariableReference<?> varRef) -> {\n\t\t\t\taddSubstitutionRequest(pi, varRef);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * each invocation of `method` will be replaces by parameter value\n\t * @param method the method whose invocation has to be substituted\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byInvocation(CtMethod<?> method) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().filterChildren(new InvocationFilter(method))\n\t\t\t.forEach((CtInvocation<?> inv) -> {\n\t\t\t\taddSubstitutionRequest(pi, inv);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add parameters for each field reference to variable named `variableName`\n\t * For example this pattern model\n\t * class Params {\n\t *   int paramA;\n\t *   int paramB;\n\t * }\n\t * void matcher(Params p) {\n\t *   return p.paramA + p.paramB;\n\t * }\n\t *\n\t * called with `byFieldRefOfVariable(\"p\")` will create pattern parameters: `paramA` and `paramB`\n\t *\n\t * @param varName the name of the variable reference\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byFieldAccessOnVariable(String varName) {\n\t\tCtVariable<?> var = queryModel().map(new PotentialVariableDeclarationFunction(varName)).first();\n\t\tif (var != null) {\n\t\t\tcreatePatternParameterForVariable(var);\n\t\t} else {\n\t\t\tList<CtVariable<?>> vars = queryModel().filterChildren(new NamedElementFilter(CtVariable.class, varName)).list();\n\t\t\tif (vars.size() > 1) {\n\t\t\t\tthrow new SpoonException(\"Ambiguous variable \" + varName);\n\t\t\t} else if (vars.size() == 1) {\n\t\t\t\tcreatePatternParameterForVariable(vars.get(0));\n\t\t\t} //else may be we should fail when variable is not found?\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add parameters for each variable reference of `variable`\n\t * @param variable to be substituted variable\n\t * @return this to support fluent API\n\t */\n\tprivate void createPatternParameterForVariable(CtVariable<?> variable) {\n\t\tCtQueryable searchScope;\n\t\tif (patternBuilder.isInModel(variable)) {\n\t\t\taddSubstitutionRequest(\n\t\t\t\t\tparameter(variable.getSimpleName()).getCurrentParameter(),\n\t\t\t\t\tvariable);\n\t\t\tsearchScope = variable;\n\t\t} else {\n\t\t\tsearchScope = queryModel();\n\t\t}\n\t\tsearchScope.map(new VariableReferenceFunction(variable))\n\t\t\t\t.forEach((CtVariableReference<?> varRef) -> {\n\t\t\t\t\tCtFieldRead<?> fieldRead = varRef.getParent(CtFieldRead.class);\n\t\t\t\t\tif (fieldRead != null) {\n\t\t\t\t\t\taddSubstitutionRequest(\n\t\t\t\t\t\t\t\tparameter(fieldRead.getVariable().getSimpleName()).getCurrentParameter(),\n\t\t\t\t\t\t\t\tfieldRead);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddSubstitutionRequest(\n\t\t\t\t\t\t\t\tparameter(varRef.getSimpleName()).getCurrentParameter(),\n\t\t\t\t\t\t\t\tvarRef);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t/**\n\t * Creates pattern parameter for each field of type {@link TemplateParameter}\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byTemplateParameter() {\n\t\treturn byTemplateParameter(null);\n\t}\n\n\t/**\n\t * Creates pattern parameter for each field of type {@link TemplateParameter}.<br>\n\t * Note: This method is here for compatibility with obsolete legacy {@link Template} based concept.\n\t * We suggest to define each parameter individually using `byXxxx(...)` methods of this class instead.\n\t *\n\t * @param parameterValues pattern parameter values.\n\t * \t\tNote these values may influence the way how pattern parameters are created.\n\t * \t\tThis unclear and ambiguous technique was used in legacy templates\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byTemplateParameter(Map<String, Object> parameterValues) {\n\t\tCtType<?> templateType = patternBuilder.getTemplateTypeRef().getTypeDeclaration();\n\t\ttemplateType.map(new AllTypeMembersFunction()).forEach((CtTypeMember typeMember) -> {\n\t\t\tconfigureByTemplateParameter(templateType, parameterValues, typeMember);\n\t\t});\n\t\treturn this;\n\t}\n\n\tprivate void configureByTemplateParameter(CtType<?> templateType, Map<String, Object> parameterValues, CtTypeMember typeMember) {\n\t\tFactory f = typeMember.getFactory();\n\t\tCtTypeReference<CtTypeReference> typeReferenceRef = f.Type().createReference(CtTypeReference.class);\n\t\tCtTypeReference<CtStatement> ctStatementRef = f.Type().createReference(CtStatement.class);\n\t\tCtTypeReference<TemplateParameter> templateParamRef = f.Type().createReference(TemplateParameter.class);\n\t\tParameter param = typeMember.getAnnotation(Parameter.class);\n\t\tif (param != null) {\n\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\tCtField<?> paramField = (CtField<?>) typeMember;\n\t\t\t\t/*\n\t\t\t\t * We have found a CtField annotated by @Parameter.\n\t\t\t\t * Use it as Pattern parameter\n\t\t\t\t */\n\t\t\t\tString fieldName = typeMember.getSimpleName();\n\t\t\t\tString stringMarker = (param.value() != null && !param.value().isEmpty()) ? param.value() : fieldName;\n\t\t\t\t//for the compatibility reasons with Parameters.getNamesToValues(), use the proxy name as parameter name\n\t\t\t\tString parameterName = stringMarker;\n\n\t\t\t\tCtTypeReference<?> paramType = paramField.getType();\n\n\t\t\t\tif (paramType.isSubtypeOf(f.Type().ITERABLE) || paramType instanceof CtArrayTypeReference<?>) {\n\t\t\t\t\t//parameter is a multivalue\n\t\t\t\t\t// here we need to replace all named element and all references whose simpleName == stringMarker\n\t\t\t\t\tparameter(parameterName).setContainerKind(ContainerKind.LIST).byNamedElement(stringMarker).byReferenceName(stringMarker);\n\t\t\t\t} else if (paramType.isSubtypeOf(typeReferenceRef) || paramType.getQualifiedName().equals(Class.class.getName())) {\n\t\t\t\t\t/*\n\t\t\t\t\t * parameter with value type TypeReference or Class, identifies replacement of local type whose name is equal to parameter name\n\t\t\t\t\t */\n\t\t\t\t\tString nestedType = getLocalTypeRefBySimpleName(templateType, stringMarker);\n\t\t\t\t\tif (nestedType != null) {\n\t\t\t\t\t\t//all references to nestedType has to be replaced\n\t\t\t\t\t\tparameter(parameterName).byType(nestedType);\n\t\t\t\t\t}\n\t\t\t\t\t//and replace the variable references by class access\n\t\t\t\t\tparameter(parameterName).byVariable(paramField);\n\t\t\t\t} else if (paramType.getQualifiedName().equals(String.class.getName())) {\n\t\t\t\t\tString nestedType = getLocalTypeRefBySimpleName(templateType, stringMarker);\n\t\t\t\t\tif (nestedType != null) {\n\t\t\t\t\t\t//There is a local type with such name. Replace it\n\t\t\t\t\t\tparameter(parameterName).byType(nestedType);\n\t\t\t\t\t}\n\t\t\t\t} else if (paramType.isSubtypeOf(templateParamRef)) {\n\t\t\t\t\tparameter(parameterName)\n\t\t\t\t\t\t.byTemplateParameterReference(paramField);\n\t\t\t\t\t//if there is any invocation of method with name matching to stringMarker, then substitute their invocations too.\n\t\t\t\t\ttemplateType.getMethodsByName(stringMarker).forEach(m -> {\n\t\t\t\t\t\tparameter(parameterName).byInvocation(m);\n\t\t\t\t\t});\n\t\t\t\t} else if (paramType.isSubtypeOf(ctStatementRef)) {\n\t\t\t\t\t//if there is any invocation of method with name matching to stringMarker, then substitute their invocations too.\n\t\t\t\t\ttemplateType.getMethodsByName(stringMarker).forEach(m -> {\n\t\t\t\t\t\tparameter(parameterName).setContainerKind(ContainerKind.LIST).byInvocation(m);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t//it is not a String. It is used to substitute CtLiteral of parameter value\n\t\t\t\t\tparameter(parameterName)\n\t\t\t\t\t\t//all occurrences of parameter name in pattern model are subject of substitution\n\t\t\t\t\t\t.byVariable(paramField);\n\t\t\t\t}\n\t\t\t\tif (paramType.getQualifiedName().equals(Object.class.getName()) && parameterValues != null) {\n\t\t\t\t\t//if the parameter type is Object, then detect the real parameter type from the parameter value\n\t\t\t\t\tObject value = parameterValues.get(parameterName);\n\t\t\t\t\tif (value instanceof CtLiteral || value instanceof CtTypeReference) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the real parameter value is CtLiteral or CtTypeReference\n\t\t\t\t\t\t * We should replace all method invocations whose name equals to stringMarker\n\t\t\t\t\t\t * by that CtLiteral or qualified name of CtTypeReference\n\t\t\t\t\t\t */\n\t\t\t\t\t\tParameterInfo pi = parameter(parameterName).getCurrentParameter();\n\t\t\t\t\t\tqueryModel().filterChildren((CtInvocation<?> inv) -> {\n\t\t\t\t\t\t\treturn inv.getExecutable().getSimpleName().equals(stringMarker);\n\t\t\t\t\t\t}).forEach((CtInvocation<?> inv) -> {\n\t\t\t\t\t\t\taddSubstitutionRequest(pi, inv);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//any value can be converted to String. Substitute content of all string attributes\n\t\t\t\tparameter(parameterName).setConflictResolutionMode(ConflictResolutionMode.KEEP_OLD_NODE)\n\t\t\t\t\t.bySubstring(stringMarker);\n\n\t\t\t\tif (parameterValues != null) {\n\t\t\t\t\t//handle automatic inline statements\n\t\t\t\t\taddInlineStatements(fieldName, parameterValues.get(parameterName));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//TODO CtMethod was may be supported in old Template engine!!!\n\t\t\t\tthrow new SpoonException(\"Template Parameter annotation on \" + typeMember.getClass().getName() + \" is not supported\");\n\t\t\t}\n\t\t} else if (typeMember instanceof CtField<?> && ((CtField<?>) typeMember).getType().isSubtypeOf(templateParamRef)) {\n\t\t\tCtField<?> field = (CtField<?>) typeMember;\n\t\t\tString parameterName = typeMember.getSimpleName();\n\t\t\tObject value = parameterValues == null ? null : parameterValues.get(parameterName);\n\t\t\tClass valueType = null;\n\t\t\tboolean multiple = false;\n\t\t\tif (value != null) {\n\t\t\t\tvalueType = value.getClass();\n\t\t\t\tif (value instanceof CtBlock) {\n\t\t\t\t\t//the CtBlock in this situation is expected as container of Statements in legacy templates.\n\t\t\t\t\tmultiple = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparameter(parameterName).setValueType(valueType).setContainerKind(multiple ? ContainerKind.LIST : ContainerKind.SINGLE)\n\t\t\t\t.byTemplateParameterReference(field);\n\n\t\t\tif (parameterValues != null) {\n\t\t\t\t//handle automatic inline statements\n\t\t\t\taddInlineStatements(parameterName, parameterValues.get(parameterName));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addInlineStatements(String variableName, Object paramValue) {\n\t\tif (paramValue != null && paramValue.getClass().isArray()) {\n\t\t\t//the parameters with Array value are meta parameters in legacy templates\n\t\t\tpatternBuilder.configureInlineStatements(sb -> {\n\t\t\t\t//we are adding inline statements automatically from legacy templates,\n\t\t\t\t//so do not fail if it is sometime not possible - it means that it is not a inline statement then\n\t\t\t\tsb.setFailOnMissingParameter(false);\n\t\t\t\tsb.inlineIfOrForeachReferringTo(variableName);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Creates pattern parameter for each key of parameterValues {@link Map}.\n\t * The parameter is created only if doesn't exist yet.\n\t * If the parameter value is a CtTypeReference, then all local types whose simple name equals to parameter name are substituted\n\t * Then any name in source code which contains a parameter name will be converted to parameter\n\t *\n\t * Note: This unclear and ambiguous technique was used in legacy templates\n\t * We suggest to define each parameter individually using `byXxxx(...)` methods of this class instead.\n\t *\n\t * @param parameterValues pattern parameter values or null if not known\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byParameterValues(Map<String, Object> parameterValues) {\n\t\tif (parameterValues != null) {\n\t\t\tCtType<?> templateType = patternBuilder.getTemplateTypeRef().getTypeDeclaration();\n\t\t\t//configure template parameters based on parameter values only - these without any declaration in Template\n\t\t\tparameterValues.forEach((paramName, paramValue) -> {\n\t\t\t\tif (isSubstituted(paramName) == false) {\n\t\t\t\t\t//and only these parameters whose name isn't already handled by explicit template parameters\n\t\t\t\t\t//replace types whose name fits to name of parameter\n\t\t\t\t\tparameter(paramName)\n\t\t\t\t\t\t.setConflictResolutionMode(ConflictResolutionMode.KEEP_OLD_NODE)\n\t\t\t\t\t\t.byLocalType(templateType, paramName, true);\n\t\t\t\t\tparameter(paramName)\n\t\t\t\t\t\t.setConflictResolutionMode(ConflictResolutionMode.KEEP_OLD_NODE)\n\t\t\t\t\t\t.bySubstring(paramName);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * variable read/write of `variable` of type {@link TemplateParameter}\n\t * @param variable a variable whose references will be substituted\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byTemplateParameterReference(CtVariable<?> variable) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().map(new VariableReferenceFunction(variable))\n\t\t\t.forEach((CtVariableReference<?> varRef) -> {\n\t\t\t\t/*\n\t\t\t\t * the target of substitution is always the invocation of TemplateParameter#S()\n\t\t\t\t */\n\t\t\t\tCtVariableAccess<?> varAccess = (CtVariableAccess<?>) varRef.getParent();\n\t\t\t\tCtElement invocationOfS = varAccess.getParent();\n\t\t\t\tif (invocationOfS instanceof CtInvocation<?>) {\n\t\t\t\t\tCtInvocation<?> invocation = (CtInvocation<?>) invocationOfS;\n\t\t\t\t\tif (\"S\".equals(invocation.getExecutable().getSimpleName())) {\n\t\t\t\t\t\taddSubstitutionRequest(pi, invocation);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"TemplateParameter reference is NOT used as target of invocation of TemplateParameter#S()\");\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * All spoon model string attributes whose value is equal to `stringMarker`\n\t * are subject for substitution by current parameter\n\t * @param stringMarker a string value which has to be substituted\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byString(String stringMarker) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tnew StringAttributeScanner() {\n\t\t\t@Override\n\t\t\tprotected void visitStringAttribute(RoleHandler roleHandler, CtElement element, String value) {\n\t\t\t\tif (stringMarker.equals(value)) {\n\t\t\t\t\taddSubstitutionRequest(pi, element, roleHandler.getRole());\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void visitStringAttribute(RoleHandler roleHandler, CtElement element, String mapEntryKey, CtElement mapEntryValue) {\n\t\t\t\tif (stringMarker.equals(mapEntryKey)) {\n\t\t\t\t\tpatternBuilder.modifyNodeOfAttributeOfElement(element, roleHandler.getRole(), conflictResolutionMode, oldAttrNode -> {\n\t\t\t\t\t\tif (oldAttrNode instanceof MapEntryNode) {\n\t\t\t\t\t\t\tMapEntryNode mapEntryNode = (MapEntryNode) oldAttrNode;\n\t\t\t\t\t\t\treturn new MapEntryNode(new ParameterNode(pi), mapEntryNode.getValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn oldAttrNode;\n\t\t\t\t\t});\n\n\t\t\t\t}\n\t\t\t}\n\t\t}.scan(patternBuilder.getPatternModel());\n\t\treturn this;\n\t}\n\n\t/**\n\t * All spoon model string attributes whose value contains whole string or a substring equal to `stringMarker`\n\t * are subject for substitution by current parameter. Only the `stringMarker` substring of the string value is substituted!\n\t * @param stringMarker a string value which has to be substituted\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator bySubstring(String stringMarker) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tnew StringAttributeScanner() {\n\t\t\t@Override\n\t\t\tprotected void visitStringAttribute(RoleHandler roleHandler, CtElement element, String value) {\n\t\t\t\tif (value != null && value.contains(stringMarker)) {\n\t\t\t\t\taddSubstitutionRequest(pi, element, roleHandler.getRole(), stringMarker);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void visitStringAttribute(RoleHandler roleHandler, CtElement element, String mapEntryKey, CtElement mapEntryValue) {\n\t\t\t\tif (mapEntryKey != null && mapEntryKey.contains(stringMarker)) {\n\t\t\t\t\tpatternBuilder.modifyNodeOfAttributeOfElement(element, roleHandler.getRole(), conflictResolutionMode, oldAttrNode -> {\n\t\t\t\t\t\tList<RootNode> nodes = ((ListOfNodes) oldAttrNode).getNodes();\n\t\t\t\t\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\t\t\t\t\tRootNode node = nodes.get(i);\n\t\t\t\t\t\t\tif (node instanceof MapEntryNode) {\n\t\t\t\t\t\t\t\tMapEntryNode mapEntryNode = (MapEntryNode) node;\n\t\t\t\t\t\t\t\tnodes.set(i, new MapEntryNode(StringNode.setReplaceMarker(mapEntryNode.getKey(), stringMarker, pi), mapEntryNode.getValue()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn oldAttrNode;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}.scan(patternBuilder.getPatternModel());\n\t\treturn this;\n\t}\n\n\t/**\n\t * CtScanner implementation, which calls {@link #visitStringAttribute(RoleHandler, CtElement, String)}\n\t * for each String attribute of each {@link CtElement} of scanned AST\n\t */\n\tprivate abstract static class StringAttributeScanner extends CtScanner {\n\t\t/**\n\t\t * List of all Spoon model {@link RoleHandler}s, which provides access to attribute value of type String\n\t\t */\n\t\tprivate static List<RoleHandler> stringAttributeRoleHandlers = new ArrayList<>();\n\t\tstatic {\n\t\t\tRoleHandlerHelper.forEachRoleHandler(rh -> {\n\t\t\t\tif (rh.getValueClass().isAssignableFrom(String.class)) {\n\t\t\t\t\t//accept String and Object class\n\t\t\t\t\tstringAttributeRoleHandlers.add(rh);\n\t\t\t\t}\n\t\t\t\tif (rh.getContainerKind() == ContainerKind.MAP) {\n\t\t\t\t\t//accept Map where key is String too\n\t\t\t\t\tstringAttributeRoleHandlers.add(rh);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic void scan(CtElement element) {\n\t\t\tvisitStringAttribute(element);\n\t\t\tsuper.scan(element);\n\t\t}\n\t\tprivate void visitStringAttribute(CtElement element) {\n\t\t\tfor (RoleHandler roleHandler : stringAttributeRoleHandlers) {\n\t\t\t\tif (roleHandler.getTargetType().isInstance(element)) {\n\t\t\t\t\tif (Metamodel.getInstance().getConcept(element.getClass()).getProperty(roleHandler.getRole()).isUnsettable()) {\n\t\t\t\t\t\t//do not visit unsettable string attributes, which cannot be modified by pattern\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tObject value = roleHandler.getValue(element);\n\t\t\t\t\tif (value instanceof String) {\n\t\t\t\t\t\tvisitStringAttribute(roleHandler, element, (String) value);\n\t\t\t\t\t} else if (value instanceof Map) {\n\t\t\t\t\t\tfor (Map.Entry<String, CtElement> e : ((Map<String, CtElement>) value).entrySet()) {\n\t\t\t\t\t\t\tvisitStringAttribute(roleHandler, element, e.getKey(), e.getValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//else it is a CtLiteral with non string value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprotected abstract void visitStringAttribute(RoleHandler roleHandler, CtElement element, String value);\n\t\tprotected abstract void visitStringAttribute(RoleHandler roleHandler, CtElement element, String mapEntryKey, CtElement mapEntryValue);\n\t}\n\n\t/**\n\t * Any named element by it's simple name\n\t * @param simpleName simple name of {@link CtNamedElement}\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byNamedElement(String simpleName) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().filterChildren((CtNamedElement named) -> simpleName.equals(named.getSimpleName()))\n\t\t\t.forEach((CtNamedElement named) -> {\n\t\t\t\taddSubstitutionRequest(pi, named);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Any reference identified by it's simple name.\n\t *\n\t * Can be used to match any method call for instance.\n\t *\n\t * In some cases, the selected object is actually the parent of the reference (eg the invocation).\n\t * This is implemented in {@link PatternParameterConfigurator#getSubstitutedNodeOfElement(ParameterInfo, CtElement)}\n\t *\n\t *\n\t * @param simpleName simple name of {@link CtReference}\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byReferenceName(String simpleName) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().filterChildren((CtReference ref) -> simpleName.equals(ref.getSimpleName()))\n\t\t\t.forEach((CtReference ref) -> {\n\t\t\t\taddSubstitutionRequest(pi, ref);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * All elements matched by {@link Filter} will be substituted by parameter value\n\t * @param filter {@link Filter}, which defines to be substituted elements\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byFilter(Filter<?> filter) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().filterChildren(filter)\n\t\t\t.forEach((CtElement ele) -> {\n\t\t\t\taddSubstitutionRequest(pi, ele);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Elements will be substituted by parameter value\n\t * @param elements to be substituted elements\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byElement(CtElement... elements) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tfor (CtElement element : elements) {\n\t\t\taddSubstitutionRequest(pi, element);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Attribute defined by `role` of all elements matched by {@link Filter} will be substituted by parameter value\n\t * @param role {@link CtRole}, which defines to be substituted elements\n\t * @param filter {@link Filter}, which defines to be substituted elements\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byRole(CtRole role, Filter<?> filter) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tqueryModel().filterChildren(filter)\n\t\t\t.forEach((CtElement ele) -> {\n\t\t\t\taddSubstitutionRequest(pi, ele, role);\n\t\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Attribute defined by `role` of `element`  will be substituted by parameter value\n\t * @param role {@link CtRole}, which defines to be substituted elements\n\t * @param elements to be substituted element\n\t * @return {@link PatternParameterConfigurator} to support fluent API\n\t */\n\tpublic PatternParameterConfigurator byRole(CtRole role, CtElement... elements) {\n\t\tParameterInfo pi = getCurrentParameter();\n\t\tfor (CtElement element : elements) {\n\t\t\taddSubstitutionRequest(pi, element, role);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param type a required type of the value which matches as value of this parameter\n\t * @param matchCondition a {@link Predicate} which selects matching values\n\t * @return this to support fluent API\n\t */\n\tpublic <T> PatternParameterConfigurator byCondition(Class<T> type, Predicate<T> matchCondition) {\n\t\tcurrentParameter.setMatchCondition(type, matchCondition);\n\t\treturn this;\n\t}\n\n\t/**\n\t * marks a CtIf and CtForEach to be matched, even when inlined.\n\t * @return this to support fluent API\n\t */\n\tpublic PatternParameterConfigurator matchInlinedStatements() {\n\t\tInlinedStatementConfigurator sb = new InlinedStatementConfigurator(patternBuilder);\n\t\tfor (CtElement ctElement : substitutedNodes) {\n\t\t\tsb.byElement(ctElement);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic boolean isSubstituted(String paramName) {\n\t\tif (patternBuilder.getParameterInfo(paramName) == null) {\n\t\t\treturn false;\n\t\t}\n\t\tParameterInfo pi = getParameterInfo(paramName, false);\n\t\tif (pi == null) {\n\t\t\treturn false;\n\t\t}\n\t\tclass Result {\n\t\t\tboolean isUsed = false;\n\t\t}\n\t\tResult result = new Result();\n\t\tpatternBuilder.forEachNodeOfParameter(pi, parameterized -> result.isUsed = true);\n\t\treturn result.isUsed;\n\t}\n\n\tvoid addSubstitutionRequest(ParameterInfo parameter, CtElement element) {\n\t\t//remember elements substituted by current parameter to be able to use them for marking inline statements\n\t\tsubstitutedNodes.add(element);\n\t\tParameterElementPair pep = getSubstitutedNodeOfElement(parameter, element);\n\t\tpatternBuilder.setNodeOfElement(pep.element, new ParameterNode(pep.parameter), conflictResolutionMode);\n\t\tif (patternBuilder.isAutoSimplifySubstitutions() && pep.element.isParentInitialized()) {\n\t\t\tRootNode node = patternBuilder.getOptionalPatternNode(pep.element.getParent());\n\t\t\tif (node != null) {\n\t\t\t\tnode.setSimplifyGenerated(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Adds request to substitute value of `attributeRole` of `element`, by the value of this {@link ListOfNodes} parameter {@link ParameterInfo} value\n\t * @param element whose attribute of {@link CtRole} `attributeRole` have to be replaced\n\t */\n\tvoid addSubstitutionRequest(ParameterInfo parameter, CtElement element, CtRole attributeRole) {\n\t\tpatternBuilder.setNodeOfAttributeOfElement(element, attributeRole, new ParameterNode(parameter), conflictResolutionMode);\n\t}\n\n\t/**\n\t * Adds request to substitute substring of {@link String} value of `attributeRole` of `element`, by the value of this {@link ListOfNodes} parameter {@link ParameterInfo} value\n\t * @param element whose part of String attribute of {@link CtRole} `attributeRole` have to be replaced\n\t */\n\tvoid addSubstitutionRequest(ParameterInfo parameter, CtElement element, CtRole attributeRole, String subStringMarker) {\n\t\tpatternBuilder.modifyNodeOfAttributeOfElement(element, attributeRole, conflictResolutionMode, oldAttrNode -> {\n\t\t\treturn StringNode.setReplaceMarker(oldAttrNode, subStringMarker, parameter);\n\t\t});\n\t}\n\n\tpublic static class ParameterElementPair {\n\t\tfinal ParameterInfo parameter;\n\t\tfinal CtElement element;\n\t\tpublic ParameterElementPair(ParameterInfo parameter, CtElement element) {\n\t\t\tthis.parameter = parameter;\n\t\t\tthis.element = element;\n\t\t}\n\t\tpublic ParameterElementPair copyAndSet(ParameterInfo param) {\n\t\t\treturn new ParameterElementPair(param, element);\n\t\t}\n\t\tpublic ParameterElementPair copyAndSet(CtElement element) {\n\t\t\treturn new ParameterElementPair(parameter, element);\n\t\t}\n\t}\n\n\t/**\n\t * Arguments for that implicit behavior:\n\t * - most of the clients doesn't understand the Spoon model deep enough to distinguish between CtInvocation, CtExecutableReference, ... so the implicit fallback is to the elements which are directly visible in source code\n\t * - the Pattern builder code is simpler for clients\n\t */\n\tprivate ParameterElementPair getSubstitutedNodeOfElement(ParameterInfo parameter, CtElement element) {\n\t\tParameterElementPair parameterElementPair = new ParameterElementPair(parameter, element);\n\t\tparameterElementPair = transformVariableAccessToVariableReference(parameterElementPair);\n\t\tparameterElementPair = transformArrayAccess(parameterElementPair);\n\t\tparameterElementPair = transformTemplateParameterInvocationOfS(parameterElementPair);\n\t\tparameterElementPair = transformExecutableRefToInvocation(parameterElementPair);\n\t\tparameterElementPair = transformCtReturnIfNeeded(parameterElementPair);\n\t\t//if spoon creates an implicit parent (e.g. CtBlock) around the pattern parameter, then replace that implicit parent\n\t\tparameterElementPair = getLastImplicitParent(parameterElementPair);\n\t\treturn parameterElementPair;\n\t}\n\n\t/**\n\t * for input `element` expression `X` in expression `X[Y]` it returns expression `X[Y]`\n\t * and registers extra {@link ListParameterInfo} to the parameter assigned to `X`\n\t * @param pep pair of parameter and element which has to be transformed\n\t * @return\n\t */\n\tprivate ParameterElementPair transformArrayAccess(ParameterElementPair pep) {\n\t\tCtElement element = pep.element;\n\t\tif (element.isParentInitialized()) {\n\t\t\tCtElement parent = element.getParent();\n\t\t\tif (parent instanceof CtArrayAccess<?, ?>) {\n\t\t\t\tCtArrayAccess<?, ?> arrayAccess = (CtArrayAccess<?, ?>) parent;\n\t\t\t\tCtExpression<?> expr = arrayAccess.getIndexExpression();\n\t\t\t\tif (expr instanceof CtLiteral<?>) {\n\t\t\t\t\tCtLiteral<?> idxLiteral = (CtLiteral<?>) expr;\n\t\t\t\t\tObject idx = idxLiteral.getValue();\n\t\t\t\t\tif (idx instanceof Number) {\n\t\t\t\t\t\treturn new ParameterElementPair(new ListParameterInfo(((Number) idx).intValue(), pep.parameter), arrayAccess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pep;\n\t}\n\n\t/**\n\t * @return a node, which has to be substituted instead of variable reference `varRef`\n\t */\n\tprivate ParameterElementPair transformVariableAccessToVariableReference(ParameterElementPair pep) {\n\t\tif (pep.element instanceof CtVariableReference<?>) {\n\t\t\tCtVariableReference<?> varRef = (CtVariableReference<?>) pep.element;\n\t\t\t/*\n\t\t\t * the target of substitution is always the parent node of variableReference\n\t\t\t * - the expression - CtVariableAccess\n\t\t\t * which can be replaced by any other CtVariableAccess.\n\t\t\t * For example CtFieldRead can be replaced by CtVariableRead or by CtLiteral\n\t\t\t */\n\t\t\treturn pep.copyAndSet(varRef.getParent());\n\t\t}\n\t\treturn pep;\n\t}\n\n\t/**\n\t * @return an invocation of {@link TemplateParameter#S()} if it is parent of `element`\n\t */\n\tprivate ParameterElementPair transformTemplateParameterInvocationOfS(ParameterElementPair pep) {\n\t\tCtElement element = pep.element;\n\t\tif (element.isParentInitialized()) {\n\t\t\tCtElement parent = element.getParent();\n\t\t\tif (parent instanceof CtInvocation<?>) {\n\t\t\t\tCtInvocation<?> invocation = (CtInvocation<?>) parent;\n\t\t\t\tCtExecutableReference<?> executableRef = invocation.getExecutable();\n\t\t\t\tif (\"S\".equals(executableRef.getSimpleName())) {\n\t\t\t\t\tif (TemplateParameter.class.getName().equals(executableRef.getDeclaringType().getQualifiedName())) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the invocation of TemplateParameter#S() has to be substituted\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn pep.copyAndSet(invocation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pep;\n\t}\n\n\tprivate ParameterElementPair transformExecutableRefToInvocation(ParameterElementPair pep) {\n\t\tCtElement element = pep.element;\n\t\tif (element instanceof CtExecutableReference<?>) {\n\t\t\tCtExecutableReference<?> execRef = (CtExecutableReference<?>) element;\n\t\t\tif (element.isParentInitialized()) {\n\t\t\t\tCtElement parent = execRef.getParent();\n\t\t\t\tif (parent instanceof CtInvocation<?>) {\n\t\t\t\t\t/*\n\t\t\t\t\t * the invocation has to be substituted\n\t\t\t\t\t */\n\t\t\t\t\treturn pep.copyAndSet(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pep;\n\t}\n\n\tprivate ParameterElementPair transformCtReturnIfNeeded(ParameterElementPair pep) {\n\t\tCtElement element = pep.element;\n\t\tif (element.isParentInitialized() && element.getParent() instanceof CtReturn<?>) {\n\t\t\t//we are substituting return expression. If the parameter value is CtBlock, then we have to substitute CtReturn instead\n\t\t\tClass<?> valueType = pep.parameter.getParameterValueType();\n\t\t\tif (valueType != null && CtBlock.class.isAssignableFrom(valueType)) {\n\t\t\t\t//substitute CtReturn\n\t\t\t\treturn pep.copyAndSet(element.getParent());\n\t\t\t}\n\t\t}\n\t\treturn pep;\n\t}\n\n\t/**\n\t * @return last implicit parent of element\n\t */\n\tprivate ParameterElementPair getLastImplicitParent(ParameterElementPair pep) {\n\t\tCtElement element = pep.element;\n\t\twhile (element.isParentInitialized()) {\n\t\t\tCtElement parent = element.getParent();\n\t\t\tif ((parent instanceof CtBlock) == false || parent.isImplicit() == false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telement = parent;\n\t\t}\n\t\treturn pep.copyAndSet(element);\n\t}\n}\n"
    }, {
      "name" : "pattern/Quantifier.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\n/**\n * Defines a matching strategy for pattern parameters, default is {@link #GREEDY}.\n */\npublic enum Quantifier {\n\t/**\n\t * Force the matcher to read in, or eat,\n\t * the entire input prior to attempting the next match (default).\n\t * If the next match attempt (the entire input) fails, the matcher backs off the input by one and tries again,\n\t * repeating the process until a match is found or there are no more elements left to back off from.\n\t */\n\tGREEDY,\n\t/**\n\t * The reluctant quantifier takes the opposite approach: It start at the beginning of the input,\n\t * then reluctantly eats one character at a time looking for a match.\n\t * The last thing it tries is the entire input.\n\t */\n\tRELUCTANT,\n\t/**\n\t * The possessive quantifier always eats the entire input string,\n\t * trying once (and only once) for a match. Unlike the greedy quantifiers, possessive quantifiers never back off,\n\t * even if doing so would allow the overall match to succeed.\n\t */\n\tPOSSESSIVE\n}\n"
    }, {
      "name" : "pattern/PatternBuilder.java",
      "weight" : 351.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.ValueConvertor;\nimport spoon.pattern.internal.ValueConvertorImpl;\nimport spoon.pattern.internal.node.ElementNode;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.pattern.internal.node.RootNode;\nimport spoon.pattern.internal.parameter.AbstractParameterInfo;\nimport spoon.pattern.internal.parameter.ParameterInfo;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.QueryFactory;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtFunction;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryable;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.Experimental;\n\n/**\n * The master class to create a {@link Pattern} instance.\n *\n * Main documentation at http://spoon.gforge.inria.fr/pattern.html.\n */\n@Experimental\npublic class PatternBuilder {\n\n\tpublic static final String TARGET_TYPE = \"targetType\";\n\n\t/**\n\t * Creates a {@link PatternBuilder} from the List of template elements\n\t * @param patternModel a List of Spoon AST nodes, which represents a template of to be generated or to be matched code\n\t * @return new instance of {@link PatternBuilder}\n\t */\n\tpublic static PatternBuilder create(List<? extends CtElement> patternModel) {\n\t\treturn new PatternBuilder(patternModel);\n\t}\n\n\tpublic static PatternBuilder create(CtElement... elems) {\n\t\treturn new PatternBuilder(Arrays.asList(elems));\n\t}\n\n\tprivate final List<CtElement> patternModel;\n\tprotected final ListOfNodes patternNodes;\n\tprivate final Map<CtElement, RootNode> patternElementToSubstRequests = new IdentityHashMap<>();\n\tprivate final Set<RootNode> explicitNodes = Collections.newSetFromMap(new IdentityHashMap<>());\n\n\tprivate CtTypeReference<?> templateTypeRef;\n\tprivate final Map<String, AbstractParameterInfo> parameterInfos = new HashMap<>();\n\tCtQueryable patternQuery;\n\tprivate ValueConvertor valueConvertor;\n\tprivate boolean addGeneratedBy = false;\n\tprivate boolean autoSimplifySubstitutions = false;\n\tprivate boolean built = false;\n\n\tstatic class PatternQuery implements CtQueryable {\n\t\tprivate final QueryFactory queryFactory;\n\t\tprivate final List<CtElement> modelElements;\n\t\tPatternQuery(QueryFactory queryFactory, List<CtElement> modelElements) {\n\t\t\tthis.queryFactory = queryFactory;\n\t\t\tthis.modelElements = modelElements;\n\t\t}\n\t\t@Override\n\t\tpublic <R extends CtElement> CtQuery filterChildren(Filter<R> filter) {\n\t\t\treturn queryFactory.createQuery(modelElements).filterChildren(filter);\n\t\t}\n\t\t@Override\n\t\tpublic <I, R> CtQuery map(CtFunction<I, R> function) {\n\t\t\treturn queryFactory.createQuery(modelElements).map(function);\n\t\t}\n\t\t@Override\n\t\tpublic <I> CtQuery map(CtConsumableFunction<I> queryStep) {\n\t\t\treturn queryFactory.createQuery(modelElements).map(queryStep);\n\t\t}\n\t}\n\n\tprotected PatternBuilder(List<? extends CtElement> template) {\n\t\tif (template == null) {\n\t\t\tthrow new SpoonException(\"Cannot create a Pattern from an null model\");\n\t\t}\n\t\tthis.templateTypeRef = getDeclaringTypeRef(template);\n\t\tthis.patternModel = Collections.unmodifiableList(new ArrayList<>(template));\n\t\tthis.valueConvertor = new ValueConvertorImpl();\n\t\tpatternNodes = ElementNode.create(this.patternModel, patternElementToSubstRequests);\n\t\tpatternQuery = new PatternBuilder.PatternQuery(getFactory().Query(), patternModel);\n\t\tif (this.templateTypeRef != null) {\n\t\t\tconfigurePatternParameters(pb -> {\n\t\t\t\tpb.parameter(TARGET_TYPE).byType(this.templateTypeRef).setValueType(CtTypeReference.class);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate CtTypeReference<?> getDeclaringTypeRef(List<? extends CtElement> template) {\n\t\tCtType<?> type = null;\n\t\tfor (CtElement ctElement : template) {\n\t\t\tCtType t;\n\t\t\tif (ctElement instanceof CtType) {\n\t\t\t\tt = (CtType) ctElement;\n\t\t\t\ttype = mergeType(type, t);\n\t\t\t}\n\t\t\tt = ctElement.getParent(CtType.class);\n\t\t\tif (t != null) {\n\t\t\t\ttype = mergeType(type, t);\n\t\t\t}\n\t\t}\n\t\treturn type == null ? null : type.getReference();\n\t}\n\n\tprivate CtType<?> mergeType(CtType<?> type, CtType t) {\n\t\tif (type == null) {\n\t\t\treturn t;\n\t\t}\n\t\tif (type == t) {\n\t\t\treturn type;\n\t\t}\n\t\tif (type.hasParent(t)) {\n\t\t\treturn t;\n\t\t}\n\t\tif (t.hasParent(type)) {\n\t\t\treturn type;\n\t\t}\n\t\tthrow new SpoonException(\"The pattern on nested types are not supported.\");\n\t}\n\n\t/**\n\t * @param element a CtElement\n\t * @return {@link RootNode}, which handles matching/generation of an `object` from the source spoon AST.\n\t * or null, if there is none\n\t */\n\tRootNode getOptionalPatternNode(CtElement element, CtRole... roles) {\n\t\treturn getPatternNode(true, element, roles);\n\t}\n\tRootNode getPatternNode(CtElement element, CtRole... roles) {\n\t\treturn getPatternNode(false, element, roles);\n\t}\n\tprivate RootNode getPatternNode(boolean optional, CtElement element, CtRole... roles) {\n\t\tRootNode node = patternElementToSubstRequests.get(element);\n\t\tfor (CtRole role : roles) {\n\t\t\tif (node instanceof ElementNode) {\n\t\t\t\tElementNode elementNode = (ElementNode) node;\n\t\t\t\tnode = elementNode.getNodeOfRole(role);\n\t\t\t\tif (node == null) {\n\t\t\t\t\tif (optional) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new SpoonException(\"The role \" + role + \" resolved to null Node\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (optional) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"The role \" + role + \" can't be resolved on Node of class \" + node.getClass());\n\t\t\t}\n\t\t}\n\t\tif (node == null) {\n\t\t\tif (optional) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new SpoonException(\"There is no Node for element\");\n\t\t}\n\t\treturn node;\n\t}\n\n\tvoid modifyNodeOfElement(CtElement element, ConflictResolutionMode conflictMode, Function<RootNode, RootNode> elementNodeChanger) {\n\t\tRootNode oldNode = patternElementToSubstRequests.get(element);\n\t\tRootNode newNode = elementNodeChanger.apply(oldNode);\n\t\tif (newNode == null) {\n\t\t\tthrow new SpoonException(\"Removing of Node is not supported\");\n\t\t}\n\t\thandleConflict(conflictMode, oldNode, newNode, tobeUsedNode -> {\n\t\t\tif (patternNodes.replaceNode(oldNode, tobeUsedNode) == false) {\n\t\t\t\tif (conflictMode == ConflictResolutionMode.KEEP_OLD_NODE) {\n\t\t\t\t\t//The parent of oldNode was already replaced. OK - Keep that parent old node\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"Old node was not found\");\n\t\t\t}\n\t\t\t//update element to node mapping\n\t\t\tpatternElementToSubstRequests.put(element, tobeUsedNode);\n\t\t});\n\t}\n\n\tvoid modifyNodeOfAttributeOfElement(CtElement element, CtRole role, ConflictResolutionMode conflictMode, Function<RootNode, RootNode> elementNodeChanger) {\n\t\tmodifyNodeOfElement(element, conflictMode, node -> {\n\t\t\tif (node instanceof ElementNode) {\n\t\t\t\tElementNode elementNode = (ElementNode) node;\n\t\t\t\tRootNode oldAttrNode = elementNode.getNodeOfRole(role);\n\t\t\t\tRootNode newAttrNode = elementNodeChanger.apply(oldAttrNode);\n\t\t\t\tif (newAttrNode == null) {\n\t\t\t\t\tthrow new SpoonException(\"Removing of Node is not supported\");\n\t\t\t\t}\n\t\t\t\thandleConflict(conflictMode, oldAttrNode, newAttrNode, (tobeUsedNode) -> {\n\t\t\t\t\telementNode.setNodeOfRole(role, tobeUsedNode);\n\t\t\t\t});\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tif (conflictMode == ConflictResolutionMode.KEEP_OLD_NODE) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tthrow new SpoonException(\"The Node of atttribute of element cannot be set because element has a Node of class: \" + node.getClass().getName());\n\t\t});\n\t}\n\n\tprivate void handleConflict(ConflictResolutionMode conflictMode, RootNode oldNode, RootNode newNode, Consumer<RootNode> applyNewNode) {\n\t\tif (oldNode != newNode) {\n\t\t\tif (conflictMode == ConflictResolutionMode.APPEND) {\n\t\t\t\tif (oldNode instanceof ListOfNodes == false) {\n\t\t\t\t\toldNode = new ListOfNodes(new ArrayList<>(Arrays.asList(oldNode)));\n\t\t\t\t}\n\t\t\t\tif (newNode instanceof ListOfNodes) {\n\t\t\t\t\t((ListOfNodes) oldNode).getNodes().addAll(((ListOfNodes) newNode).getNodes());\n\t\t\t\t} else {\n\t\t\t\t\t((ListOfNodes) oldNode).getNodes().add(newNode);\n\t\t\t\t}\n\t\t\t\texplicitNodes.add(oldNode);\n\t\t\t\texplicitNodes.add(newNode);\n\t\t\t\tapplyNewNode.accept(oldNode);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (explicitNodes.contains(oldNode)) {\n\t\t\t\t//the oldNode was explicitly added before\n\t\t\t\tif (conflictMode == ConflictResolutionMode.FAIL) {\n\t\t\t\t\tthrow new SpoonException(\"Can't replace once assigned Node \" + oldNode + \" by a \" + newNode);\n\t\t\t\t}\n\t\t\t\tif (conflictMode == ConflictResolutionMode.KEEP_OLD_NODE) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\texplicitNodes.remove(oldNode);\n\t\t\texplicitNodes.add(newNode);\n\t\t\tapplyNewNode.accept(newNode);\n\t\t}\n\t}\n\n\t/**\n\t * Changes the Pattern by way the `node` is used at position of template element.\n\t * It is used for example to mark that `element` as pattern parameter\n\t * @param element\n\t * @param node\n\t * @param conflictMode\n\t */\n\tvoid setNodeOfElement(CtElement element, RootNode node, ConflictResolutionMode conflictMode) {\n\t\tmodifyNodeOfElement(element, conflictMode, oldNode -> {\n\t\t\treturn node;\n\t\t});\n\t}\n\n\t/**\n\t * Changes the Pattern by way the `node` is used at position of template element attribute of `role`.\n\t * It is used for example to mark that `element` as pattern parameter\n\t * @param element\n\t * @param role\n\t * @param node\n\t * @param conflictMode\n\t */\n\tvoid setNodeOfAttributeOfElement(CtElement element, CtRole role, RootNode node, ConflictResolutionMode conflictMode) {\n\t\tmodifyNodeOfAttributeOfElement(element, role, conflictMode, oldAttrNode -> {\n\t\t\treturn node;\n\t\t});\n\t}\n\n\t/**\n\t * @param element to be checked element\n\t * @return true if element `element` is a template or a child of template\n\t */\n\tboolean isInModel(CtElement element) {\n\t\tif (element != null) {\n\t\t\tfor (CtElement patternElement : patternModel) {\n\t\t\t\tif (element == patternElement || element.hasParent(patternElement)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Pattern build() {\n\t\tif (built) {\n\t\t\tthrow new SpoonException(\"The Pattern may be built only once\");\n\t\t}\n\t\tbuilt = true;\n\t\t//clean the mapping so it is not possible to further modify built pattern using this builder\n\t\tpatternElementToSubstRequests.clear();\n\t\treturn new Pattern(getFactory(), new ListOfNodes(patternNodes.getNodes())).setAddGeneratedBy(isAddGeneratedBy());\n\t}\n\n\tstatic List<? extends CtElement> bodyToStatements(CtStatement statementOrBlock) {\n\t\tif (statementOrBlock instanceof CtBlock) {\n\t\t\treturn ((CtBlock<?>) statementOrBlock).getStatements();\n\t\t}\n\t\treturn Collections.singletonList(statementOrBlock);\n\t}\n\n\t/**\n\t * @return default {@link ValueConvertor}, which will be assigned to all new {@link ParameterInfo}s\n\t */\n\tValueConvertor getDefaultValueConvertor() {\n\t\treturn valueConvertor;\n\t}\n\n\t/**\n\t * @param valueConvertor default {@link ValueConvertor}, which will be assigned to all {@link ParameterInfo}s created after this call\n\t * @return this to support fluent API\n\t */\n\tPatternBuilder setDefaultValueConvertor(ValueConvertor valueConvertor) {\n\t\tthis.valueConvertor = valueConvertor;\n\t\treturn this;\n\t}\n\n\t/**\n\t * All the variable references, whose variables are out of the template model\n\t * are automatically marked as pattern parameters\n\t * @return this to support fluent API\n\t */\n\tpublic PatternBuilder configurePatternParameters() {\n\t\tconfigurePatternParameters(pb -> {\n\t\t\t//add this substitution request only if there isn't another one yet\n\t\t\tpb.setConflictResolutionMode(ConflictResolutionMode.KEEP_OLD_NODE);\n\t\t\t/*\n\t\t\t * detect other parameters.\n\t\t\t * contract: All variable references, which are declared outside of template are automatically considered as template parameters\n\t\t\t */\n\t\t\tpb.queryModel().filterChildren(new TypeFilter<>(CtVariableReference.class))\n\t\t\t\t.forEach((CtVariableReference<?> varRef) -> {\n\t\t\t\t\tCtVariable<?> var = varRef.getDeclaration();\n\t\t\t\t\tif (var == null || isInModel(var) == false) {\n\t\t\t\t\t\t//the varRef has declaration out of the scope of the template. It must be a template parameter.\n\t\t\t\t\t\tParameterInfo parameter = pb.parameter(varRef.getSimpleName()).getCurrentParameter();\n\t\t\t\t\t\tpb.addSubstitutionRequest(parameter, varRef);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configure pattern parameters with a {@link PatternParameterConfigurator}\n\t * @return this\n\t */\n\tpublic PatternBuilder configurePatternParameters(Consumer<PatternParameterConfigurator> parametersBuilder) {\n\t\tPatternParameterConfigurator pb = new PatternParameterConfigurator(this, parameterInfos);\n\t\tparametersBuilder.accept(pb);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used by inline for each statement to define template parameter which is local in the scope of the inline statement\n\t */\n\tPatternBuilder configureLocalParameters(Consumer<PatternParameterConfigurator> parametersBuilder) {\n\t\tPatternParameterConfigurator pb = new PatternParameterConfigurator(this, new HashMap<>());\n\t\tparametersBuilder.accept(pb);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures inlined statements\n\t *\n\t * For example if the `for` statement in this pattern model\n\t * <pre><code>\n\t * for(Object x : $iterable$) {\n\t *\tSystem.out.println(x);\n\t * }\n\t * </code></pre>\n\t * is configured as inline statement and a Pattern is substituted\n\t * using parameter <code>$iterable$ = new String[]{\"A\", \"B\", \"C\"}</code>\n\t * then pattern generated this code\n\t * <pre><code>\n\t * System.out.println(\"A\");\n\t * System.out.println(\"B\");\n\t * System.out.println(\"C\");\n\t * </code></pre>\n\t * because inline statements are executed during substitution process and are not included in generated result.\n\t *\n\t * The inline statements may be used in PatternMatching process (opposite to Pattern substitution) too.\n\t * @param consumer\n\t * @return this to support fluent API\n\t */\n\tpublic PatternBuilder configureInlineStatements(Consumer<InlinedStatementConfigurator> consumer) {\n\t\tInlinedStatementConfigurator sb = new InlinedStatementConfigurator(this);\n\t\tconsumer.accept(sb);\n\t\treturn this;\n\t}\n\n\tstatic String getLocalTypeRefBySimpleName(CtType<?> templateType, String typeSimpleName) {\n\t\tCtType<?> type = templateType.getNestedType(typeSimpleName);\n\t\tif (type != null) {\n\t\t\treturn type.getQualifiedName();\n\t\t}\n\t\ttype = templateType.getPackage().getType(typeSimpleName);\n\t\tif (type != null) {\n\t\t\treturn type.getQualifiedName();\n\t\t}\n\t\tSet<String> typeQNames = new HashSet<>();\n\t\ttemplateType\n\t\t\t.filterChildren((CtTypeReference<?> ref) -> typeSimpleName.equals(ref.getSimpleName()))\n\t\t\t.forEach((CtTypeReference<?> ref) -> typeQNames.add(ref.getQualifiedName()));\n\t\tif (typeQNames.size() > 1) {\n\t\t\tthrow new SpoonException(\"The type parameter \" + typeSimpleName + \" is ambiguous. It matches multiple types: \" + typeQNames);\n\t\t}\n\t\tif (typeQNames.size() == 1) {\n\t\t\treturn typeQNames.iterator().next();\n\t\t}\n\t\treturn null;\n\t}\n\n\tAbstractParameterInfo getParameterInfo(String parameterName) {\n\t\treturn parameterInfos.get(parameterName);\n\t}\n\n\tprotected Factory getFactory() {\n\t\tif (templateTypeRef != null) {\n\t\t\treturn templateTypeRef.getFactory();\n\t\t}\n\t\tif (!patternModel.isEmpty()) {\n\t\t\treturn patternModel.get(0).getFactory();\n\t\t}\n\t\tthrow new SpoonException(\"PatternBuilder has no CtElement to provide a Factory\");\n\t}\n\n\t/**\n\t * @return a {@link CtElement}s which are the template model of this Pattern\n\t */\n\tList<CtElement> getPatternModel() {\n\t\treturn patternModel;\n\t}\n\t/**\n\t * Calls `consumer` once for each {@link RootNode} element which uses `parameter`\n\t * @param parameter to be checked {@link ParameterInfo}\n\t * @param consumer receiver of calls\n\t */\n\tvoid forEachNodeOfParameter(ParameterInfo parameter, Consumer<RootNode> consumer) {\n\t\tpatternNodes.forEachParameterInfo((paramInfo, vr) -> {\n\t\t\tif (paramInfo == parameter) {\n\t\t\t\tconsumer.accept(vr);\n\t\t\t}\n\t\t});\n\t}\n\t/**\n\t * @return true if produced Pattern will append generated by comments\n\t */\n\tprivate boolean isAddGeneratedBy() {\n\t\treturn addGeneratedBy;\n\t}\n\t/**\n\t * @param addGeneratedBy true when generated by comments have to be appended to each generated type member\n\t * @return this to support fluent API\n\t */\n\tpublic PatternBuilder setAddGeneratedBy(boolean addGeneratedBy) {\n\t\tthis.addGeneratedBy = addGeneratedBy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return true if generated result has to be evaluated to apply simplifications.\n\t */\n\tpublic boolean isAutoSimplifySubstitutions() {\n\t\treturn autoSimplifySubstitutions;\n\t}\n\t/**\n\t * @param autoSimplifySubstitutions true if generated result of each substituted has to be evaluated to apply simplifications.\n\t * \tThe rule is applied only to substitutions defined after this call\n\t * @return this to support fluent API\n\t */\n\tpublic PatternBuilder setAutoSimplifySubstitutions(boolean autoSimplifySubstitutions) {\n\t\tthis.autoSimplifySubstitutions = autoSimplifySubstitutions;\n\t\treturn this;\n\t}\n\n\tCtTypeReference<?> getTemplateTypeRef() {\n\t\treturn templateTypeRef;\n\t}\n}\n"
    }, {
      "name" : "pattern/PatternBuilderHelper.java",
      "weight" : 99.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.visitor.Filter;\nimport spoon.support.Experimental;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Utility class to select parts of AST to be used as a model of a {@link PatternBuilder}.\n *\n * Main documentation at http://spoon.gforge.inria.fr/pattern.html.\n */\n@Experimental\npublic class PatternBuilderHelper {\n\t/**\n\t * The original type, which contains the AST of pattern model\n\t */\n\tprivate final CtType<?> patternType;\n\t/**\n\t * optional clone of patternType. It is created when AST of CtType has to be modified\n\t * before it can become a model of {@link Pattern}\n\t */\n\tprivate CtType<?> clonedPatternType;\n\t/**\n\t * holds the built pattern model\n\t */\n\tprivate List<CtElement> elements = null;\n\n\tpublic PatternBuilderHelper(CtType<?> templateTemplate) {\n\t\tthis.patternType = templateTemplate;\n\t}\n\n\t/**\n\t * Returns clone of the patternType.\n\t * The clone is done only once. Later calls returns cached clone.\n\t * @return\n\t */\n\tprivate CtType<?> getClonedPatternType() {\n\t\tif (clonedPatternType == null) {\n\t\t\tclonedPatternType = patternType.clone();\n\t\t\tif (patternType.isParentInitialized()) {\n\t\t\t\t//set parent package, to keep origin qualified name of the Template. It is needed for correct substitution of Template name by target type reference\n\t\t\t\tclonedPatternType.setParent(patternType.getParent());\n\t\t\t}\n\t\t\tsetElements(Collections.singletonList(clonedPatternType));\n\t\t}\n\t\treturn clonedPatternType;\n\t}\n\n\t/**\n\t * Sets a template model from {@link CtTypeMember} of a template type\n\t * @param typeMemberName the name of the {@link CtTypeMember} of a template type\n\t */\n\tpublic PatternBuilderHelper setTypeMember(String typeMemberName) {\n\t\tsetTypeMember(tm -> typeMemberName.equals(tm.getSimpleName()));\n\t\treturn this;\n\t}\n\t/**\n\t * Sets a template model from {@link CtTypeMember} of a template type\n\t * @param filter the {@link Filter} whose match defines to be used {@link CtTypeMember}\n\t */\n\tprivate PatternBuilderHelper setTypeMember(Filter<CtTypeMember> filter) {\n\t\tsetElements(getByFilter(filter));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets a template model from body of the method of template type\n\t * @param methodName the name of {@link CtMethod}\n\t */\n\tpublic PatternBuilderHelper setBodyOfMethod(String methodName) {\n\t\tsetBodyOfMethod(tm -> methodName.equals(tm.getSimpleName()));\n\t\treturn this;\n\t}\n\t/**\n\t * Sets a template model from body of the method of template type selected by filter\n\t * @param filter the {@link Filter} whose match defines to be used {@link CtMethod}\n\t */\n\tprivate void setBodyOfMethod(Filter<CtMethod<?>> filter) {\n\t\tCtBlock<?> body =  getOneByFilter(filter).getBody();\n\t\tsetElements(body.getStatements());\n\t}\n\n\t/**\n\t * Sets a template model from return expression of the method of template type selected by filter\n\t * @param methodName the name of {@link CtMethod}\n\t */\n\tpublic PatternBuilderHelper setReturnExpressionOfMethod(String methodName) {\n\t\tsetReturnExpressionOfMethod(tm -> methodName.equals(tm.getSimpleName()));\n\t\treturn this;\n\t}\n\t/**\n\t * Sets a template model from return expression of the method of template type selected by filter\n\t * @param filter the {@link Filter} whose match defines to be used {@link CtExecutable}\n\t */\n\tprivate void setReturnExpressionOfMethod(Filter<CtMethod<?>> filter) {\n\t\tCtMethod<?> method = getOneByFilter(filter);\n\t\tCtBlock<?> body = method.getBody();\n\t\tif (body.getStatements().size() != 1) {\n\t\t\tthrow new SpoonException(\"The body of \" + method.getSignature() + \" must contain exactly one statement. But there is:\\n\" + body.toString());\n\t\t}\n\t\tCtStatement firstStatement = body.getStatements().get(0);\n\t\tif (firstStatement instanceof CtReturn<?> == false) {\n\t\t\tthrow new SpoonException(\"The body of \" + method.getSignature() + \" must contain return statement. But there is:\\n\" + body.toString());\n\t\t}\n\t\tsetElements(Collections.singletonList(((CtReturn<?>) firstStatement).getReturnedExpression()));\n\t}\n\n\tprivate <T extends CtElement> List<T> getByFilter(Filter<T> filter) {\n\t\tList<T> elements = patternType.filterChildren(filter).list();\n\t\tif (elements == null || elements.isEmpty()) {\n\t\t\tthrow new SpoonException(\"Element not found in \" + patternType.getShortRepresentation());\n\t\t}\n\t\treturn elements;\n\t}\n\tprivate <T extends CtElement> T getOneByFilter(Filter<T> filter) {\n\t\tList<T> elements = getByFilter(filter);\n\t\tif (elements.size() != 1) {\n\t\t\tthrow new SpoonException(\"Only one element must be selected, but there are: \" + elements);\n\t\t}\n\t\treturn elements.get(0);\n\t}\n\n\t/**\n\t * @param filter whose matches will be kept in the template. All others will be removed\n\t */\n\tpublic PatternBuilderHelper keepTypeMembers(Filter<? super CtElement> filter) {\n\t\tfor (CtTypeMember ctTypeMember : new ArrayList<>(getClonedPatternType().getTypeMembers())) {\n\t\t\tif (filter.matches(ctTypeMember) == false) {\n\t\t\t\tctTypeMember.delete();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * removes super class from the template\n\t */\n\tpublic PatternBuilderHelper removeSuperClass() {\n\t\tgetClonedPatternType().setSuperclass(null);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return a List of {@link CtElement}s, which has to be used as pattern model\n\t */\n\tpublic List<CtElement> getPatternElements() {\n\t\treturn elements;\n\t}\n\n\t/**\n\t * @param template a List of {@link CtElement}s, which has to be used as pattern model\n\t */\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprivate void setElements(List<? extends CtElement> template) {\n\t\tthis.elements = (List) template;\n\t}\n}\n"
    }, {
      "name" : "pattern/ConflictResolutionMode.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport spoon.SpoonException;\nimport spoon.pattern.internal.node.RootNode;\n\n/**\n * Defines what happens when a {@link RootNode} has to be replaced by another {@link RootNode}, default in {@link #FAIL}.\n */\npublic enum ConflictResolutionMode {\n\t/**\n\t * Throw {@link SpoonException} if a conflict happens, it is the default in most cases. But there are some standard Pattern builder algorithms (mainly these which deals with legacy Templates), which are using the other modes.\n\t */\n\tFAIL,\n\t/**\n\t * Get rid of old {@link RootNode} and use new {@link RootNode} instead\n\t */\n\tUSE_NEW_NODE,\n\t/**\n\t * Keep old {@link RootNode} and ignore requests to add new {@link RootNode}\n\t */\n\tKEEP_OLD_NODE,\n\t/**\n\t * Add new {@link RootNode} after existing nodes\n\t */\n\tAPPEND\n}\n"
    }, {
      "name" : "pattern/Generator.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.pattern;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.Experimental;\nimport spoon.support.util.ImmutableMap;\n\n/**\n * Generates code from patterns. The core idea is to replace pattern parameters by objects.\n */\n@Experimental\npublic interface Generator {\n\t/**\n\t * @return a {@link Factory}, which has to be used to generate instances\n\t */\n\tFactory getFactory();\n\n\n\t/**\n\t * Main method to generate a new AST made from substituting of parameters by values in `params`\n\t * @param valueType - the expected type of returned items\n\t * @param params - the substitution parameters, it can be CtElement, primitive literals like String, Integer, ... and or List or Set of them.\n\t * @return List of generated elements\n\t */\n\t<T extends CtElement> List<T> generate(Class<T> valueType, Map<String, Object> params);\n\n\t/** Utility method that provides the same feature as {@link #generate(Class, Map)}, but with a {@link ImmutableMap} as parameter (a Spoon elegant utility type) */\n\t<T extends CtElement> List<T> generate(Class<T> valueType, ImmutableMap params);\n\n\t/**\n\t * Adds type members (fields and methods) to `targetType`.\n\t *\n\t * The root elements of the pattern must be type members.\n\t *\n\t * @param valueType the type of generated elements\n\t * @param params the pattern parameters\n\t * @param targetType the existing type, which will contain the added generated {@link CtElement}s\n\t * @return List of generated elements\n\t */\n\t<T extends CtTypeMember> List<T> addToType(Class<T> valueType, Map<String, Object> params, CtType<?> targetType);\n\n\t/**\n\t * Generates type with qualified name `typeQualifiedName` the provided `params`.\n\t *\n\t * Note: the root element of pattern must be one type.\n\t *\n\t * @param typeQualifiedName the qualified name of to be generated type\n\t * @param params the pattern parameters\n\t * @return the generated type\n\t */\n\t<T extends CtType<?>> T generateType(String typeQualifiedName, Map<String, Object> params);\n\n}\n"
    } ]
  }, {
    "name" : "processing",
    "children" : [ {
      "name" : "processing/AbstractAnnotationProcessor.java",
      "weight" : 102.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport spoon.Launcher;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This class defines an abstract annotation processor to be subclassed by the\n * user for defining new annotation processors including Java 8 annotations.\n */\npublic abstract class AbstractAnnotationProcessor<A extends Annotation, E extends CtElement> extends AbstractProcessor<E> implements AnnotationProcessor<A, E> {\n\n\tMap<String, Class<? extends A>> consumedAnnotationTypes = new TreeMap<>();\n\n\tMap<String, Class<? extends A>> processedAnnotationTypes = new TreeMap<>();\n\n\t/**\n\t * Empty constructor only for all processors (invoked by Spoon).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AbstractAnnotationProcessor() {\n\t\tclearProcessedElementType();\n\n\t\tfor (Method m : getClass().getMethods()) {\n\t\t\tif (\"process\".equals(m.getName()) && (m.getParameterTypes().length == 2)) {\n\t\t\t\tClass<?> c = m.getParameterTypes()[0];\n\t\t\t\tif (inferConsumedAnnotationType() && (Annotation.class != c)) {\n\t\t\t\t\taddConsumedAnnotationType((Class<A>) c);\n\t\t\t\t}\n\t\t\t\tc = m.getParameterTypes()[1];\n\t\t\t\tif (CtElement.class != c) {\n\t\t\t\t\taddProcessedElementType((Class<E>) c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inferConsumedAnnotationType() && processedAnnotationTypes.isEmpty()) {\n\t\t\taddProcessedAnnotationType((Class<? extends A>) Annotation.class);\n\t\t}\n\t\tif (processedElementTypes.isEmpty()) {\n\t\t\taddProcessedElementType(CtElement.class);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a consumed annotation type (to be used in subclasses constructors).\n\t * A consumed annotation type is also part of the processed annotation\n\t * types.\n\t */\n\tprotected final void addConsumedAnnotationType(Class<? extends A> annotationType) {\n\t\taddProcessedAnnotationType(annotationType);\n\t\tconsumedAnnotationTypes.put(annotationType.getName(), annotationType);\n\t}\n\n\t/**\n\t * Adds a processed annotation type (to be used in subclasses constructors).\n\t */\n\tprotected final void addProcessedAnnotationType(Class<? extends A> annotationType) {\n\t\tprocessedAnnotationTypes.put(annotationType.getName(), annotationType);\n\t}\n\n\t/**\n\t * Removes a processed annotation type.\n\t */\n\tprotected final void removeProcessedAnnotationType(Class<? extends A> annotationType) {\n\t\tprocessedAnnotationTypes.remove(annotationType.getName());\n\t}\n\n\t/**\n\t * Clears the processed annotation types.\n\t */\n\tprotected final void clearProcessedAnnotationTypes() {\n\t\tprocessedAnnotationTypes.clear();\n\t}\n\n\t/**\n\t * Clears the consumed annotation types.\n\t */\n\tprotected final void clearConsumedAnnotationTypes() {\n\t\tconsumedAnnotationTypes.clear();\n\t}\n\n\t/**\n\t * Removes a processed annotation type.\n\t */\n\tprotected final void removeConsumedAnnotationType(Class<? extends A> annotationType) {\n\t\tconsumedAnnotationTypes.remove(annotationType.getName());\n\t}\n\n\t@Override\n\tpublic final Set<Class<? extends A>> getConsumedAnnotationTypes() {\n\t\treturn new HashSet<>(consumedAnnotationTypes.values());\n\t}\n\n\t@Override\n\tpublic final Set<Class<? extends A>> getProcessedAnnotationTypes() {\n\t\treturn new HashSet<>(processedAnnotationTypes.values());\n\t}\n\n\t@Override\n\tpublic boolean inferConsumedAnnotationType() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if the element is annotated with an annotation whose type is\n\t * processed.\n\t */\n\t@Override\n\tpublic final boolean isToBeProcessed(E element) {\n\t\tif ((element != null) && (element.getAnnotations() != null)) {\n\t\t\tfor (CtAnnotation<? extends Annotation> a : element.getAnnotations()) {\n\t\t\t\tif (shoudBeProcessed(a)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic final void process(E element) {\n\t\tfor (CtAnnotation<? extends Annotation> annotation : new ArrayList<>(element.getAnnotations())) {\n\t\t\tif (shoudBeProcessed(annotation)) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess((A) annotation.getActualAnnotation(), element);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tif (shoudBeConsumed(annotation)) {\n\t\t\t\t\telement.removeAnnotation(annotation);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Removes all annotations A on elements E.\n\t */\n\t@Override\n\tpublic boolean shoudBeConsumed(CtAnnotation<? extends Annotation> annotation) {\n\t\treturn consumedAnnotationTypes.containsKey(annotation.getAnnotationType().getQualifiedName());\n\t}\n\n\tprivate boolean shoudBeProcessed(CtAnnotation<? extends Annotation> annotation) {\n\t\treturn processedAnnotationTypes.containsKey(annotation.getAnnotationType().getQualifiedName());\n\t}\n\n}\n"
    }, {
      "name" : "processing/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package contains the core API for code processing.</p>\n * \t<p>See the {@link spoon.Launcher} implementation as an example of use.\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.processing;\n"
    }, {
      "name" : "processing/ProcessorPropertiesImpl.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ProcessorPropertiesImpl implements ProcessorProperties {\n\tprivate final Map<String, Object> _properties = new HashMap<>();\n\n\t@Override\n\tpublic <T> T get(Class<T> type, String name) {\n\t\tif (type.isPrimitive()) {\n\t\t\ttype = (Class<T>) ClassUtils.primitiveToWrapper(type);\n\t\t}\n\t\tT result = (T) _properties.get(name);\n\t\tif (result == null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn (type.isAssignableFrom(result.getClass())) ? result : null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void set(String name, Object o) {\n\t\t_properties.put(name, o);\n\t}\n\n\t/**\n\t * Gets the corresponding processor name.\n\t */\n\t@Override\n\tpublic String getProcessorName() {\n\t\treturn (String) _properties.get(\"__NAME__\");\n\t}\n\n}\n"
    }, {
      "name" : "processing/Property.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation shall be used on processor fields to declare them as being\n * properties (for configuration).\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Property {\n\t/**\n\t * An optional text that describes the property.\n\t */\n\tString value() default \"\";\n}\n"
    }, {
      "name" : "processing/AbstractProblemFixer.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\n\n/**\n * To be subclassed when defining a new problem fixer.\n */\npublic abstract class AbstractProblemFixer<T extends CtElement>\n\t\timplements ProblemFixer<T> {\n\tFactory factory;\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic AbstractProblemFixer() {\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n}\n"
    }, {
      "name" : "processing/ProblemFixer.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.Changes;\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface defines problem fixers. Problem fixers can be provided when a\n * problem is reported to the environment. The user can then chose what fixer to\n * use.\n *\n * @see Environment#report(Processor, org.apache.log4j.Level, CtElement, String,\n * ProblemFixer[])\n */\npublic interface ProblemFixer<T extends CtElement> extends FactoryAccessor {\n\n\t/**\n\t * Returns the description of this fixer\n\t */\n\tString getDescription();\n\n\t/**\n\t * Returns a short String that represent this fixer.\n\t */\n\tString getLabel();\n\n\t/**\n\t * Runs this fix on given element. This fixer should modify the given model\n\t * and return a list of the modified elements.\n\t *\n\t * @param element\n\t * \t\tthe element marked by a problem\n\t * @return List of modified elements\n\t */\n\tChanges run(T element);\n}\n"
    }, {
      "name" : "processing/ProcessingManager.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport java.util.Collection;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * The processing manager defines the API to process a program model of a given\n * {@link spoon.reflect.factory.Factory} with a set of processors. The program model has\n * been previously built using a {@link spoon.SpoonModelBuilder} - see\n * {@link spoon.SpoonModelBuilder#build()}. To use, add processors to\n * the manager, and then call the {@code process} method. Also, the method\n * {@link spoon.processing.Processor#processingDone()} is up called.\n *\n * @see spoon.compiler.Environment#getManager()\n */\npublic interface ProcessingManager extends FactoryAccessor {\n\n\t/**\n\t * Adds a processor by instantiating its type (a class that must define an\n\t * empty constructor).\n\t *\n\t * @see #getProcessors()\n\t */\n\tvoid addProcessor(Class<? extends Processor<?>> type);\n\n\t/**\n\t * Adds a processor.\n\t *\n\t * @see #getProcessors()\n\t */\n\tboolean addProcessor(Processor<?> p);\n\n\t/**\n\t * Adds a processor by instantiating its type (a class that must define an\n\t * empty constructor and implement {@link Processor}).\n\t *\n\t * @param qualifiedName\n\t *            the qualified name of the processor's type\n\t * @see #getProcessors()\n\t */\n\tvoid addProcessor(String qualifiedName);\n\n\t/**\n\t * Gets the processors that have been added to the manager and that will be\n\t * applied when invoking one of the {@code process} methods).\n\t *\n\t * @see #process(Collection)\n\t */\n\tCollection<Processor<?>> getProcessors();\n\n\t/**\n\t * Recursively processes a collection of {@link CtElement}s with this\n\t * manager. All the processors added to this manager (see\n\t * {@link #getProcessors()}) should be applied before the method returns\n\t * (blocking implementation) or before another call to a\n\t * <code>process</code> method (non-blocking implementation). Processors\n\t * that have been applied are removed from the manager and\n\t * {@link #getProcessors()} does not contain them anymore.\n\t */\n\tvoid process(Collection<? extends CtElement> elements);\n\n\t/**\n\t * Recursively processes a {@link CtElement} with this manager. All the\n\t * processors added to this manager (see {@link #getProcessors()}) should\n\t * be applied before the method returns (blocking implementation) or before\n\t * another call to a <code>process</code> method (non-blocking\n\t * implementation). Processors that have been applied are removed from the\n\t * manager and {@link #getProcessors()} does not contain them anymore.\n\t */\n\tvoid process(CtElement element);\n\n}\n"
    }, {
      "name" : "processing/ProcessInterruption.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\n/**\n * This exception is used to interrupt a processor during its processing.\n */\npublic class ProcessInterruption extends RuntimeException {\n\tpublic ProcessInterruption() {\n\t}\n\n\tpublic ProcessInterruption(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic ProcessInterruption(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n\n\tpublic ProcessInterruption(Throwable cause) {\n\t\tsuper(cause);\n\t}\n}\n"
    }, {
      "name" : "processing/AbstractProcessor.java",
      "weight" : 91.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport org.apache.log4j.Level;\nimport spoon.Launcher;\nimport spoon.compiler.Environment;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.testing.utils.ProcessorUtils;\n\nimport java.lang.reflect.Method;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * This class defines an abstract processor to be subclassed by the user for\n * defining new processors.\n */\npublic abstract class AbstractProcessor<E extends CtElement> implements Processor<E> {\n\n\tFactory factory;\n\n\tSet<Class<? extends CtElement>> processedElementTypes = new HashSet<>();\n\n\t/**\n\t * Empty constructor only for all processors (invoked by Spoon).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AbstractProcessor() {\n\t\tfor (Method m : getClass().getMethods()) {\n\t\t\tif (\"process\".equals(m.getName()) && (m.getParameterTypes().length == 1)) {\n\t\t\t\tClass<?> c = m.getParameterTypes()[0];\n\t\t\t\tif (CtElement.class != c) {\n\t\t\t\t\taddProcessedElementType((Class<E>) c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (processedElementTypes.isEmpty()) {\n\t\t\taddProcessedElementType(CtElement.class);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a processed element type. This method is typically invoked in\n\t * subclasses' constructors.\n\t */\n\tprotected void addProcessedElementType(Class<? extends CtElement> elementType) {\n\t\tprocessedElementTypes.add(elementType);\n\t}\n\n\t/**\n\t * Clears the processed element types.\n\t */\n\tprotected void clearProcessedElementType() {\n\t\tprocessedElementTypes.clear();\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn getFactory().getEnvironment();\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn this.factory;\n\t}\n\n\t@Override\n\tpublic Set<Class<? extends CtElement>> getProcessedElementTypes() {\n\t\treturn processedElementTypes;\n\t}\n\n\t/**\n\t * Helper method to load the properties of the given processor (uses\n\t * {@link Environment#getProcessorProperties(String)}).\n\t */\n\tpublic ProcessorProperties loadProperties() {\n\t\tProcessor<?> p = this;\n\t\tProcessorProperties props = null;\n\t\ttry {\n\t\t\tprops = p.getFactory().getEnvironment().getProcessorProperties(p.getClass().getName());\n\t\t} catch (Exception e) {\n\t\t\tp.getFactory().getEnvironment().report(p, Level.ERROR,\n\t\t\t\t\t\"unable to get properties for processor '\" + p.getClass().getName() + \"': \" + e.getMessage());\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn props;\n\t}\n\n\t@Override\n\tpublic TraversalStrategy getTraversalStrategy() {\n\t\treturn TraversalStrategy.POST_ORDER;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\tthis.initProperties(loadProperties());\n\t}\n\n\t@Override\n\tpublic boolean isToBeProcessed(E candidate) {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper method to initialize the properties of a given processor.\n\t */\n\t@Override\n\tpublic void initProperties(ProcessorProperties properties) {\n\t\tProcessorUtils.initProperties(this, properties);\n\t}\n\n\t/**\n\t * The manual meta-model processing cannot be overridden (use\n\t * {@link AbstractManualProcessor}) to do so.\n\t */\n\t@Override\n\tpublic final void process() {\n\t}\n\n\t@Override\n\tpublic void processingDone() {\n\t\t// do nothing by default\n\t}\n\n\t/**\n\t * Removes a processed element type.\n\t */\n\tprotected void removeProcessedElementType(Class<? extends CtElement> elementType) {\n\t\tprocessedElementTypes.remove(elementType);\n\t}\n\n\t@Override\n\tpublic void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t@Override\n\tpublic void interrupt() {\n\t\tthrow new ProcessInterruption();\n\t}\n}\n"
    }, {
      "name" : "processing/AnnotationProcessor.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface defines an annotation processor. An annotation processor is\n * triggered by Spoon when a visited element is annotated with one of the\n * processed or consumed annotations. To define a new annotation processor, the\n * user should subclass {@link spoon.processing.AbstractAnnotationProcessor},\n * the abstract default implementation of this interface.\n */\npublic interface AnnotationProcessor<A extends Annotation, E extends CtElement>\n\t\textends Processor<E> {\n\n\t/**\n\t * Do the annotation processing job for a given annotation.\n\t *\n\t * @param annotation\n\t * \t\tthe annotation to process\n\t * @param element\n\t * \t\tthe element that holds the processed annotations\n\t */\n\tvoid process(A annotation, E element);\n\n\t/**\n\t * Gets the annotations processed by this annotation processor, that is to\n\t * say the annotation types that trigger the\n\t * {@link #process(Annotation, CtElement)} method when visiting a program\n\t * element. The processed annotation types includes all the consumed\n\t * annotation types.\n\t *\n\t * @return the annotation classes\n\t */\n\tSet<Class<? extends A>> getProcessedAnnotationTypes();\n\n\t/**\n\t * Gets the annotations types consumed by this processor. A consumed\n\t * annotation is a special kind of processed annotation (see\n\t * {@link #getProcessedAnnotationTypes()} that is automatically removed from\n\t * the program once the associated processor has finished its job.\n\t *\n\t * @return the annotation classes\n\t */\n\tSet<Class<? extends A>> getConsumedAnnotationTypes();\n\n\t/**\n\t * Returns true (default) if the processor automatically infers the consumed\n\t * annotation type to the <code>A</code> actual type.\n\t */\n\tboolean inferConsumedAnnotationType();\n\n\t/**\n\t * Returns true if this annotation should be removed from the processed code.\n\t */\n\tboolean shoudBeConsumed(CtAnnotation<? extends Annotation> annotation);\n\n}\n"
    }, {
      "name" : "processing/SpoonTagger.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.reflect.declaration.CtClass;\n\n/**\n * Creates an empty class spoon.Spoon\n */\npublic class SpoonTagger extends AbstractManualProcessor {\n\n\t@Override\n\tpublic void process() {\n\t\tCtClass<?> spoon = getFactory().Class().create(\"spoon.Spoon\");\n\t}\n}\n"
    }, {
      "name" : "processing/Processor.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.Set;\n\n/**\n * This interface defines a generic code processor. To define a new processor,\n * the user should subclass {@link spoon.processing.AbstractProcessor}, the\n * abstract default implementation of this interface.\n *\n * If a processor contains fields annotated with @{@link Property}, they can be set using a {@link ProcessorProperties}\n */\npublic interface Processor<E extends CtElement> extends FactoryAccessor {\n\n\t/**\n\t * Gets the model's traversal strategy for this processor (default is\n\t * {@link TraversalStrategy#POST_ORDER}). Programmers should override this\n\t * method to return another strategy if needed.\n\t */\n\tTraversalStrategy getTraversalStrategy();\n\n\t/**\n\t * Gets the environment of this processor.\n\t */\n\tEnvironment getEnvironment();\n\n\t/**\n\t * Tells if this element is to be processed (returns <code>true</code> in\n\t * the default implementation).\n\t *\n\t * @param candidate\n\t * \t\tthe candidate\n\t * @return true if the candidate is to be processed by the\n\t * {@link #process(CtElement)}\n\t */\n\tboolean isToBeProcessed(E candidate);\n\n\t/**\n\t * A callback method upcalled by the meta-model scanner to perform a\n\t * dedicated job on the currently scanned element. The way Spoon upcalls\n\t * this method depends on the processed element types (\n\t * {@link #getProcessedElementTypes()}), the traversal strategy (\n\t * {@link #getTraversalStrategy()}), and the used processing manager (\n\t * {@link Environment#getManager()}. Also, this method is upcalled only if\n\t * the method {@link #isToBeProcessed(CtElement)} returns true for a given\n\t * scanned element. In order to manually scan the meta-model, one can define\n\t * the {@link #process()} method instead.\n\t *\n\t * @param element\n\t * \t\tthe element that is currently being scanned\n\t */\n\tvoid process(E element);\n\n\t/**\n\t * A callback method upcalled by the manager so that this processor can\n\t * manually implement a processing job. On contrary to\n\t * {@link #process(CtElement)}, this method does not rely on a built-in\n\t * meta-model scanner and has to implement its own traversal strategy on the\n\t * meta-model, which is stored in the factory (\n\t * {@link FactoryAccessor#getFactory}). Note that if a processor implements\n\t * both process methods, this one is upcalled first. This method does\n\t * nothing in default implementations (\n\t * {@link spoon.processing.AbstractProcessor}).\n\t */\n\tvoid process();\n\n\t/**\n\t * Do the processing job for a given element. This method is upcalled on an\n\t * element if the method {@link #isToBeProcessed(CtElement)} returns true.\n\t *\n\t * @param element\n\t *            the element that holds the processed annotations\n\t */\n\n\t/**\n\t * Gets all the element types than need to be processed.\n\t */\n\tSet<Class<? extends CtElement>> getProcessedElementTypes();\n\n\t/**\n\t * This method is upcalled by the {@link ProcessingManager} when this\n\t * processor has finished a full processing round on the program's model. It\n\t * is convenient to override this method to tune the application's strategy\n\t * of a set of processors, for instance by dynamically adding processors to\n\t * the processing manager when a processing round ends (see\n\t * {@link ProcessingManager#addProcessor(Class)}). Does nothing by default.\n\t */\n\tvoid processingDone();\n\n\t/**\n\t * This method is upcalled to initialize the processor before each\n\t * processing round. It is convenient to override this method rather than\n\t * using a default constructor to initialize the processor, since the\n\t * factory is not initialized at construction time. When overriding, do not\n\t * forget to call super.init() first so that all the initializations\n\t * performed by superclasses are also applied.\n\t */\n\tvoid init();\n\n\t/**\n\t * Initializes the properties defined by this processor by using the\n\t * environment.\n\t *\n\t * @see Environment#getProcessorProperties(String)\n\t */\n\tvoid initProperties(ProcessorProperties properties);\n\n\t/**\n\t * Interrupts the processing of this processor but changes on your AST are kept\n\t * and the invocation of this method doesn't interrupt the processing of all\n\t * processors specified in the {@link ProcessingManager}.\n\t */\n\tvoid interrupt();\n}\n"
    }, {
      "name" : "processing/TraversalStrategy.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\n/**\n * This enumeration defines the traversal strategies available for a processor.\n *\n * @see spoon.processing.Processor#getTraversalStrategy()\n */\npublic enum TraversalStrategy {\n\n\t/**\n\t * When this strategy is selected, the processor will traverse the parent\n\t * elements before the children. This implies that if the processor adds new\n\t * elements to a given model sub-tree, these new elements will be processed\n\t * too. This strategy can easily lead to complex processing behavior, so it\n\t * is to be used with care.\n\t */\n\tPRE_ORDER,\n\n\t/**\n\t * When this strategy is selected, the processor will traverse the child\n\t * elements before the parents. This implies that child elements that are\n\t * removed by a processor will still be processed before they are removed.\n\t */\n\tPOST_ORDER\n\n}\n"
    }, {
      "name" : "processing/FactoryAccessor.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.reflect.factory.Factory;\n\n/**\n * This interface represents an object that can access the meta-model factory.\n */\npublic interface FactoryAccessor {\n\n\t/**\n\t * Gets the factory of this object.\n\t */\n\tFactory getFactory();\n\n\t/**\n\t * Sets the factory object.\n\t */\n\tvoid setFactory(Factory factory);\n\n}\n"
    }, {
      "name" : "processing/FileGenerator.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport java.io.File;\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface should be implemented by processing tasks that generate new\n * files as processing results. This interface is typically implemented by\n * processors that generate files during processing. For a given processing\n * environment, the default file generator is set to the default output directory\n * that is retrieved by using\n * {@link spoon.compiler.Environment#getDefaultFileGenerator()}.\n */\npublic interface FileGenerator<T extends CtElement> extends Processor<T> {\n\t/**\n\t * Gets the root directory where files are created.\n\t */\n\tFile getOutputDirectory();\n\n\t/**\n\t * Gets the created files.\n\t */\n\tList<File> getCreatedFiles();\n\n}\n"
    }, {
      "name" : "processing/ProcessorProperties.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\n/**\n * An interface to retrieve processor properties.\n */\npublic interface ProcessorProperties {\n\n\t/**\n\t * Gets the property converted in given type or null (can be an array).\n\t */\n\t<T> T get(Class<T> type, String name);\n\n\t/**\n\t * Sets the given property.\n\t */\n\tvoid set(String name, Object o);\n\n\n\t/**\n\t * Gets the corresponding processor name.\n\t */\n\tString getProcessorName();\n\n}\n"
    }, {
      "name" : "processing/AbstractManualProcessor.java",
      "weight" : 58.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.processing;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.testing.utils.ProcessorUtils;\n\nimport java.util.Set;\n\n/**\n * This class defines an abstract processor to be subclassed by the user for\n * defining new manual processors. A manual processor should override the init\n * method (called once) and scan the meta-model manually.\n */\npublic abstract class AbstractManualProcessor implements Processor<CtElement> {\n\n\tFactory factory;\n\n\t/**\n\t * Empty constructor only for all processors (invoked by Spoon).\n\t */\n\tpublic AbstractManualProcessor() {\n\t}\n\n\t/**\n\t * Invalid method in this context.\n\t */\n\tprotected void addProcessedElementType(\n\t\t\tClass<? extends CtElement> elementType) {\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn getFactory().getEnvironment();\n\t}\n\n\t@Override\n\tpublic final Factory getFactory() {\n\t\treturn this.factory;\n\t}\n\n\t/**\n\t * Invalid method in this context.\n\t */\n\t@Override\n\tpublic final Set<Class<? extends CtElement>> getProcessedElementTypes() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Invalid method in this context.\n\t */\n\t@Override\n\tpublic final TraversalStrategy getTraversalStrategy() {\n\t\treturn TraversalStrategy.POST_ORDER;\n\t}\n\n\t@Override\n\tpublic void init() {\n\t}\n\n\t/**\n\t * Invalid method in this context.\n\t */\n\tpublic final boolean isPrivileged() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Always returns false in this context.\n\t */\n\t@Override\n\tpublic final boolean isToBeProcessed(CtElement candidate) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Does nothing in this context.\n\t */\n\t@Override\n\tpublic final void process(CtElement element) {\n\t}\n\n\t@Override\n\tpublic void processingDone() {\n\t\t// do nothing by default\n\t}\n\n\t@Override\n\tpublic final void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t@Override\n\tpublic final void initProperties(ProcessorProperties properties) {\n\t\tProcessorUtils.initProperties(this, properties);\n\t}\n\n\t@Override\n\tpublic void interrupt() {\n\t\tthrow new ProcessInterruption();\n\t}\n}\n"
    } ]
  }, {
    "name" : "refactoring",
    "children" : [ {
      "name" : "refactoring/CtRefactoring.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\n/**\n * Defines basic contract of all refactoring implementations.<br>\n * Contract: to process a required refactoring.<br>\n * Usage:<br>\n * <pre>\n * SomeRefactoring r = new SomeRefactoring();\n * //configure refactoring by calling setters on `r`\n * r.refactor();\n * </pre>\n * See child interfaces, which implements other supported refactoring methods\n */\npublic interface CtRefactoring {\n\t/**\n\t * Process refactoring operation\n\t */\n\tvoid refactor();\n}\n"
    }, {
      "name" : "refactoring/CtParameterRemoveRefactoring.java",
      "weight" : 211.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.visitor.CtAbstractVisitor;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.filter.AllMethodsSameSignatureFunction;\nimport spoon.reflect.visitor.filter.ExecutableReferenceFilter;\nimport spoon.reflect.visitor.filter.ParameterReferenceFunction;\n\n/**\n * Removes target {@link CtParameter} from the parent target {@link CtExecutable}\n * and from all overriding/overridden methods of related type hierarchies\n * and from all lambda expressions (if any) implementing the modified interface.\n * It removes arguments from all invocations of refactored executables too.<br>\n *\n * Before the refactoring is started it checks that:\n * <ul>\n * <li>to be removed parameter is NOT used in any refactored implementation\n * <li>to be removed argument contains read only expression, which can be safely removed\n * </ul>\n * If one of the validation constraints fails, then {@link RefactoringException} is thrown and nothing is changed.\n * You can override `#create*Issue(...)` methods to handle such exceptions individually.\n * <br>\n */\npublic class CtParameterRemoveRefactoring implements CtRefactoring {\n\n\tprivate CtParameter<?> target;\n\tprivate int parameterIndex;\n\t/**\n\t * List of all {@link CtExecutable}s whose parameter has to be removed\n\t */\n\tprivate List<CtExecutable<?>> targetExecutables;\n\t/**\n\t * List of all {@link CtInvocation}s whose argument has to be removed\n\t */\n\tprivate List<CtInvocation<?>> targetInvocations;\n\n\tpublic CtParameterRemoveRefactoring() {\n\t}\n\n\t/**\n\t * @return the {@link CtParameter} which has to be removed by this refactoring function\n\t */\n\tpublic CtParameter<?> getTarget() {\n\t\treturn target;\n\t}\n\n\t/**\n\t * @param target the {@link CtParameter} which has to be removed by this refactoring function\n\t * @return this to support fluent API\n\t */\n\tpublic CtParameterRemoveRefactoring setTarget(CtParameter<?> target) {\n\t\tif (this.target == target) {\n\t\t\treturn this;\n\t\t}\n\t\tthis.target = target;\n\t\tthis.parameterIndex = target.getParent().getParameters().indexOf(target);\n\t\ttargetExecutables = null;\n\t\ttargetInvocations = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return computes and returns all executables, which will be modified by this refactoring\n\t */\n\tpublic List<CtExecutable<?>> getTargetExecutables() {\n\t\tif (targetExecutables == null) {\n\t\t\tcomputeAllExecutables();\n\t\t}\n\t\treturn targetExecutables;\n\t}\n\n\t/**\n\t * @return computes and returns all invocations, which will be modified by this refactoring\n\t */\n\tpublic List<CtInvocation<?>> getTargetInvocations() {\n\t\tif (targetInvocations == null) {\n\t\t\tcomputeAllInvocations();\n\t\t}\n\t\treturn targetInvocations;\n\t}\n\n\t@Override\n\tpublic void refactor() {\n\t\tif (getTarget() == null) {\n\t\t\tthrow new SpoonException(\"The target of refactoring is not defined\");\n\t\t}\n\t\tdetectIssues();\n\t\trefactorNoCheck();\n\t}\n\n\t/**\n\t * validates whether this refactoring can be done without changing behavior of the refactored code.\n\t */\n\tprotected void detectIssues() {\n\t\tcheckAllExecutables();\n\t\tcheckAllInvocations();\n\t}\n\n\t/**\n\t * search for all methods and lambdas which has to be refactored together with target method\n\t */\n\tprivate void computeAllExecutables() {\n\t\tif (getTarget() == null) {\n\t\t\tthrow new SpoonException(\"The target of refactoring is not defined\");\n\t\t}\n\t\tfinal List<CtExecutable<?>> executables = new ArrayList<>();\n\t\tCtExecutable<?> targetExecutable = target.getParent();\n\t\t//all the executables, which belongs to same inheritance tree\n\t\texecutables.add(targetExecutable);\n\t\ttargetExecutable.map(new AllMethodsSameSignatureFunction()).forEach(new CtConsumer<CtExecutable<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtExecutable<?> executable) {\n\t\t\t\texecutables.add(executable);\n\t\t\t}\n\t\t});\n\t\ttargetExecutables = Collections.unmodifiableList(executables);\n\t}\n\n\t/**\n\t * search for all methods and lambdas which has to be refactored together with target method\n\t */\n\tprivate void computeAllInvocations() {\n\t\tExecutableReferenceFilter execRefFilter = new ExecutableReferenceFilter();\n\t\tfor (CtExecutable<?> exec : getTargetExecutables()) {\n\t\t\texecRefFilter.addExecutable(exec);\n\t\t}\n\t\t//all the invocations, which belongs to same inheritance tree\n\t\tfinal List<CtInvocation<?>> invocations = new ArrayList<>();\n\t\ttarget.getFactory().getModel().filterChildren(execRefFilter).forEach(new CtConsumer<CtExecutableReference<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtExecutableReference<?> t) {\n\t\t\t\tCtElement parent = t.getParent();\n\t\t\t\tif (parent instanceof CtInvocation<?>) {\n\t\t\t\t\tinvocations.add((CtInvocation<?>) parent);\n\t\t\t\t} //else ignore other hits, which are not in context of invocation\n\t\t\t}\n\t\t});\n\t\ttargetInvocations = Collections.unmodifiableList(invocations);\n\t}\n\n\tprivate void checkAllExecutables() {\n\t\tfor (CtExecutable<?> executable : getTargetExecutables()) {\n\t\t\tcheckExecutable(executable);\n\t\t}\n\t}\n\n\tprivate void checkExecutable(CtExecutable<?> executable) {\n\t\tfinal CtParameter<?> toBeRemovedParam = executable.getParameters().get(this.parameterIndex);\n\t\ttoBeRemovedParam.map(new ParameterReferenceFunction()).forEach(new CtConsumer<CtParameterReference<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtParameterReference<?> paramRef) {\n\t\t\t\t//some parameter uses are acceptable\n\t\t\t\t//e.g. parameter in invocation of super of method, which is going to be removed too.\n\t\t\t\tif (isAllowedParameterUsage(paramRef)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcreateParameterUsedIssue(toBeRemovedParam, paramRef);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void checkAllInvocations() {\n\t\tfor (CtInvocation<?> invocation : getTargetInvocations()) {\n\t\t\tcheckInvocation(invocation);\n\t\t}\n\t}\n\n\tprivate void checkInvocation(CtInvocation<?> invocation) {\n\t\tfinal CtExpression<?> toBeRemovedExpression = invocation.getArguments().get(this.parameterIndex);\n\t\tif (canRemoveExpression(toBeRemovedExpression) == false) {\n\t\t\tcreateExpressionCannotBeRemovedIssue(invocation, toBeRemovedExpression);\n\t\t}\n\t}\n\n\t/**\n\t * Detects whether found usage of removed parameter is acceptable\n\t * @param paramRef the found reference to\n\t * @return true if it is allowed parameter use\n\t */\n\tprotected boolean isAllowedParameterUsage(CtParameterReference<?> paramRef) {\n\t\treturn isRemovedParamOfRefactoredInvocation(paramRef);\n\t}\n\n\t/**\n\t * Detects whether `toBeRemovedExpression` can be safely removed during the refactoring\n\t *\n\t * @param toBeRemovedExpression the {@link CtExpression}, which will be removed by this refactoring\n\t * @return true if the expression used to deliver argument of removed parameter can be removed\n\t * false if cannot be removed and this refactoring has to be avoided.\n\t */\n\tprotected boolean canRemoveExpression(CtExpression<?> toBeRemovedExpression) {\n\t\tclass Context {\n\t\t\tboolean canBeRemoved = false;\n\t\t}\n\t\tfinal Context context = new Context();\n\t\ttoBeRemovedExpression.accept(new CtAbstractVisitor() {\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtVariableRead(CtVariableRead<T> variableRead) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtArrayRead(CtArrayRead<T> arrayRead) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtParameterReference(CtParameterReference<T> reference) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtLiteral(CtLiteral<T> literal) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtNewArray(CtNewArray<T> newArray) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtAnnotationFieldAccess(CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtThisAccess(CtThisAccess<T> thisAccess) {\n\t\t\t\tcontext.canBeRemoved = true;\n\t\t\t}\n\t\t\t//There are more expression which is save to remove. Including tree of unary/binary operators, conditional, etc.\n\t\t\t//It would be good to have a Filter, which matches read only expressions\n\t\t});\n\t\treturn context.canBeRemoved;\n\t}\n\n\tprotected boolean isRemovedParamOfRefactoredInvocation(CtParameterReference<?> paramRef) {\n\t\tCtInvocation<?> invocation = paramRef.getParent(CtInvocation.class);\n\t\tif (invocation == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getTargetInvocations().contains(invocation);\n\t}\n\n\t/**\n\t * Override this method to get access to details about this refactoring issue\n\t * @param usedParameter to be removed parameter, which is used by `parameterUsage`\n\t * @param parameterUsage the usage of parameter, which avoids it's remove\n\t */\n\tprotected void createParameterUsedIssue(CtParameter<?> usedParameter, CtParameterReference<?> parameterUsage) {\n\t\tthrow new RefactoringException(\"The parameter \" + usedParameter.getSimpleName()\n\t\t+ \" cannot be removed because it is used (\" + parameterUsage.getPosition() + \")\");\n\t}\n\n\t/**\n\t * Override this method to get access to details about this refactoring issue.\n\t * @param toBeRemovedExpression is the expression which delivers value for the argument of the removed parameter,\n\t * where {@link #canRemoveExpression(CtExpression)} returned false.\n\t */\n\tprotected void createExpressionCannotBeRemovedIssue(CtInvocation<?> invocation, CtExpression<?> toBeRemovedExpression) {\n\t\tthrow new RefactoringException(\"The expression \" + toBeRemovedExpression\n\t\t+ \", which creates argument of the to be removed parameter in invocation \" + invocation + \" cannot be removed.\"\n\t\t+ \" Override method `canRemoveExpression` to customize this behavior.\");\n\t}\n\n\tprotected void refactorNoCheck() {\n\t\tremoveInvocationArguments();\n\t\tremoveMethodParameters();\n\t}\n\n\tprotected void removeInvocationArguments() {\n\t\tList<CtInvocation<?>> invocations = getTargetInvocations();\n\t\tfor (CtInvocation<?> invocation : invocations) {\n\t\t\tremoveInvocationArgument(invocation);\n\t\t}\n\t}\n\n\tprotected void removeInvocationArgument(CtInvocation<?> invocation) {\n\t\tinvocation.removeArgument(invocation.getArguments().get(this.parameterIndex));\n\t}\n\n\tprotected void removeMethodParameters() {\n\t\tList<CtExecutable<?>> executables = getTargetExecutables();\n\t\tfor (CtExecutable<?> executable : executables) {\n\t\t\tremoveParameter(executable);\n\t\t}\n\t}\n\n\tprotected void removeParameter(CtExecutable<?> executable) {\n\t\texecutable.removeParameter(executable.getParameters().get(this.parameterIndex));\n\t}\n}\n"
    }, {
      "name" : "refactoring/Refactoring.java",
      "weight" : 153.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.Query;\nimport spoon.reflect.visitor.filter.TypeFilter;\n\nimport java.util.List;\n\n/**\n * Contains all methods to refactor code elements in the AST.\n */\npublic final class Refactoring {\n\tprivate Refactoring() { }\n\n\t/**\n\t * Changes name of a type element.\n\t *\n\t * @param type\n\t * \t\tType in the AST.\n\t * @param name\n\t * \t\tNew name of the element.\n\t */\n\tpublic static void changeTypeName(final CtType<?> type, String name) {\n\n\t\tfinal String typeQFN = type.getQualifiedName();\n\t\tfinal List<CtTypeReference<?>> references = Query.getElements(type.getFactory(), new TypeFilter<CtTypeReference<?>>(CtTypeReference.class) {\n\t\t\t@Override\n\t\t\tpublic boolean matches(CtTypeReference<?> reference) {\n\t\t\t\tString refFQN = reference.getQualifiedName();\n\t\t\t\treturn typeQFN.equals(refFQN);\n\t\t\t}\n\t\t});\n\n\t\ttype.setSimpleName(name);\n\t\tfor (CtTypeReference<?> reference : references) {\n\t\t\treference.setSimpleName(name);\n\t\t}\n\t}\n\n\t/**\n\t * Changes name of a method, propagates the change in the executable references of the model.\n\t */\n\tpublic static void changeMethodName(final CtMethod<?> method, String newName) {\n\n\t\tfinal List<CtExecutableReference<?>> references = Query.getElements(method.getFactory(), new TypeFilter<CtExecutableReference<?>>(CtExecutableReference.class) {\n\t\t\t@Override\n\t\t\tpublic boolean matches(CtExecutableReference<?> reference) {\n\t\t\t\treturn reference.getDeclaration() == method;\n\t\t\t}\n\t\t});\n\n\t\tmethod.setSimpleName(newName);\n\n\t\tfor (CtExecutableReference<?> reference : references) {\n\t\t\treference.setSimpleName(newName);\n\t\t}\n\t}\n\n\t/** See doc in {@link CtMethod#copyMethod()} */\n\tpublic static CtMethod<?> copyMethod(final CtMethod<?> method) {\n\t\tCtMethod<?> clone = method.clone();\n\t\tStringBuilder tentativeTypeName = new StringBuilder(method.getSimpleName() + \"Copy\");\n\t\tCtType parent = method.getParent(CtType.class);\n\t\twhile (!parent.getMethodsByName(tentativeTypeName.toString()).isEmpty()) {\n\t\t\ttentativeTypeName.append(\"X\");\n\t\t}\n\t\tfinal String cloneMethodName = tentativeTypeName.toString();\n\t\tclone.setSimpleName(cloneMethodName);\n\t\tparent.addMethod(clone);\n\t\tnew CtScanner() {\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\t\t\tCtExecutable<T> declaration = reference.getDeclaration();\n\t\t\t\tif (declaration == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (declaration == method) {\n\t\t\t\t\treference.setSimpleName(cloneMethodName);\n\t\t\t\t}\n\t\t\t\tif (reference.getDeclaration() != clone) {\n\t\t\t\t\tthrow new SpoonException(\"post condition broken \" + reference);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtExecutableReference(reference);\n\n\t\t\t}\n\t\t}.scan(clone);\n\t\treturn clone;\n\t}\n\n\n\t/** See doc in {@link CtType#copyType()} */\n\tpublic static CtType<?> copyType(final CtType<?> type) {\n\t\tCtType<?> clone = type.clone();\n\t\tStringBuilder tentativeTypeName = new StringBuilder(type.getSimpleName() + \"Copy\");\n\t\twhile (type.getFactory().Type().get(type.getPackage().getQualifiedName() + \".\" + tentativeTypeName) != null) {\n\t\t\ttentativeTypeName.append(\"X\");\n\t\t}\n\t\tfinal String cloneTypeName = tentativeTypeName.toString();\n\t\tclone.setSimpleName(cloneTypeName);\n\t\ttype.getPackage().addType(clone);\n\t\t//fix cloned type name\n\t\tnew CtScanner() {\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\t\t\t\tif (reference.getDeclaration() == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (reference.getDeclaration() == type) {\n\t\t\t\t\treference.setSimpleName(cloneTypeName);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtTypeReference(reference);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\t\t\tCtExecutable<T> declaration = reference.getDeclaration();\n\t\t\t\tif (declaration == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (declaration.hasParent(type)) {\n\t\t\t\t\treference.getDeclaringType().setSimpleName(cloneTypeName);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtExecutableReference(reference);\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\t\t\t\tCtField<T> declaration = reference.getDeclaration();\n\t\t\t\tif (declaration == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (declaration.hasParent(type)) {\n\t\t\t\t\treference.getDeclaringType().setSimpleName(cloneTypeName);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtFieldReference(reference);\n\t\t\t}\n\n\t\t}.scan(clone);\n\t\t//check that everything is OK\n\t\tnew CtScanner() {\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\t\t\t\tif (reference.getDeclaration() == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (reference.getDeclaration().getTopLevelType() != clone) {\n\t\t\t\t\tthrow new SpoonException(\"post condition broken \" + reference);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtTypeReference(reference);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\t\t\tCtExecutable<T> declaration = reference.getDeclaration();\n\t\t\t\tif (declaration == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!declaration.hasParent(clone)) {\n\t\t\t\t\tthrow new SpoonException(\"post condition broken \" + reference);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtExecutableReference(reference);\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\t\t\t\tCtField<T> declaration = reference.getDeclaration();\n\t\t\t\tif (declaration == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!declaration.hasParent(clone)) {\n\t\t\t\t\tthrow new SpoonException(\"post condition broken \" + reference);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtFieldReference(reference);\n\t\t\t}\n\n\t\t}.scan(clone);\n\t\treturn clone;\n\t}\n\n\t/**\n\t * Changes name of a {@link CtLocalVariable}.\n\t *\n\t * @param localVariable\n\t * \t\tto be renamed {@link CtLocalVariable} in the AST.\n\t * @param newName\n\t * \t\tNew name of the element.\n\t * @throws RefactoringException when rename to newName would cause model inconsistency, like ambiguity, shadowing of other variables, etc.\n\t */\n\tpublic static void changeLocalVariableName(CtLocalVariable<?> localVariable, String newName) throws RefactoringException {\n\t\tnew CtRenameLocalVariableRefactoring().setTarget(localVariable).setNewName(newName).refactor();\n\t}\n}\n"
    }, {
      "name" : "refactoring/RefactoringException.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport spoon.SpoonException;\n\n/**\n * Thrown when required refactoring would cause model inconsistency\n */\npublic class RefactoringException extends SpoonException {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic RefactoringException() {\n\t}\n\n\tpublic RefactoringException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\tpublic RefactoringException(Throwable e) {\n\t\tsuper(e);\n\t}\n\n\tpublic RefactoringException(String msg, Throwable e) {\n\t\tsuper(msg, e);\n\t}\n}\n"
    }, {
      "name" : "refactoring/CtRenameRefactoring.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport spoon.reflect.declaration.CtNamedElement;\n\n/**\n * The kind of refactoring, which renames a `target` element\n * to the `newName`<br>\n * Usage:<br>\n * <pre>\n * CtVariable someVariable = ...\n * new SomeRenameRefactoring().setTarget(someVariable).setNewName(\"mutchBetterName\").refactor();\n * </pre>\n */\npublic interface CtRenameRefactoring<T extends CtNamedElement> extends CtRefactoring {\n\t/**\n\t * @return target model element, which has to be refactored.\n\t */\n\tT getTarget();\n\t/**\n\t * @param target the model element, which has to be refactored.\n\t * @return this to support fluent API\n\t */\n\tCtRenameRefactoring<T> setTarget(T target);\n\n\t/**\n\t * @return the required name of the `target` model element\n\t */\n\tString getNewName();\n\t/**\n\t * @param newName the required name of the `target` model element\n\t * @return this to support fluent API\n\t */\n\tCtRenameRefactoring<T> setNewName(String newName);\n}\n"
    }, {
      "name" : "refactoring/AbstractRenameRefactoring.java",
      "weight" : 57.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport java.util.regex.Pattern;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtNamedElement;\n\n/**\n * abstract implementation of rename element refactoring\n *\n * @param <T> the type of target renamed element\n */\npublic abstract class AbstractRenameRefactoring<T extends CtNamedElement> implements CtRenameRefactoring<T> {\n\tpublic static final Pattern javaIdentifierRE = Pattern.compile(\"\\\\p{javaJavaIdentifierStart}\\\\p{javaJavaIdentifierPart}*\");\n\n\tprotected T target;\n\tprotected String newName;\n\tprotected Pattern newNameValidationRE;\n\n\tprotected AbstractRenameRefactoring(Pattern newNameValidationRE) {\n\t\tthis.newNameValidationRE = newNameValidationRE;\n\t}\n\n\t@Override\n\tpublic void refactor() {\n\t\tif (getTarget() == null) {\n\t\t\tthrow new SpoonException(\"The target of refactoring is not defined\");\n\t\t}\n\t\tif (getNewName() == null) {\n\t\t\tthrow new SpoonException(\"The new name of refactoring is not defined\");\n\t\t}\n\t\tdetectIssues();\n\t\trefactorNoCheck();\n\t}\n\n\tprotected abstract void refactorNoCheck();\n\n\tprotected void detectIssues() {\n\t\tcheckNewNameIsValid();\n\t\tdetectNameConflicts();\n\t}\n\n\t/**\n\t * client may implement this method to check whether {@link #newName} is valid\n\t */\n\tprotected void checkNewNameIsValid() {\n\t}\n\n\t/**\n\t * client may implement this method to check whether {@link #newName}\n\t * is in conflict with names of other model elements\n\t */\n\tprotected void detectNameConflicts() {\n\t}\n\n\t/**\n\t * Helper method, which can be used by the child classes to check if name is an java identifier\n\t * @param name the to be checked name\n\t * @return true if name is valid java identifier\n\t */\n\tprotected boolean isJavaIdentifier(String name) {\n\t\treturn javaIdentifierRE.matcher(name).matches();\n\t}\n\n\t@Override\n\tpublic T getTarget() {\n\t\treturn target;\n\t}\n\n\t@Override\n\tpublic AbstractRenameRefactoring<T> setTarget(T target) {\n\t\tthis.target = target;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String getNewName() {\n\t\treturn newName;\n\t}\n\n\t@Override\n\tpublic AbstractRenameRefactoring<T> setNewName(String newName) {\n\t\tif (newNameValidationRE != null && newNameValidationRE.matcher(newName).matches() == false) {\n\t\t\tthrow new SpoonException(\"New name \\\"\" + newName + \"\\\" is not valid name\");\n\t\t}\n\t\tthis.newName = newName;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "refactoring/CtRenameLocalVariableRefactoring.java",
      "weight" : 153.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.refactoring;\n\nimport java.util.Collection;\nimport java.util.regex.Pattern;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQueryable;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\nimport spoon.reflect.visitor.filter.LocalVariableReferenceFunction;\nimport spoon.reflect.visitor.filter.LocalVariableScopeFunction;\nimport spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction;\nimport spoon.reflect.visitor.filter.SiblingsFunction;\nimport spoon.reflect.visitor.filter.SiblingsFunction.Mode;\nimport spoon.reflect.visitor.filter.VariableReferenceFunction;\n\n/**\n * Spoon model refactoring function which renames `target` local variable to `newName`<br>\n * This refactoring will throw {@link RefactoringException} if the model would be not consistent after rename to new name.\n * The exception is thrown before the model modificatons are started.\n * <pre>\n * CtLocalVariable anLocalVariable = ...\n * RenameLocalVariableRefactor refactor = new RenameLocalVariableRefactor();\n * refactor.setTarget(anLocalVariable);\n * refactor.setNewName(\"someNewName\");\n * try {\n *   refactor.refactor();\n * } catch (RefactoringException e) {\n *   //handle name conflict or name shadowing problem\n * }\n * </pre>\n */\npublic class CtRenameLocalVariableRefactoring extends AbstractRenameRefactoring<CtLocalVariable<?>> {\n\n\tpublic static final Pattern validVariableNameRE = javaIdentifierRE;\n\n\tpublic CtRenameLocalVariableRefactoring() {\n\t\tsuper(validVariableNameRE);\n\t}\n\n\t@Override\n\tprotected void refactorNoCheck() {\n\t\tgetTarget().map(new VariableReferenceFunction()).forEach(new CtConsumer<CtReference>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtReference t) {\n\t\t\t\tt.setSimpleName(newName);\n\t\t\t}\n\t\t});\n\t\ttarget.setSimpleName(newName);\n\t}\n\n\tprivate static class QueryDriver implements CtScannerListener {\n\t\tint nrOfNestedLocalClasses = 0;\n\t\tCtElement ignoredParent;\n\n\t\t@Override\n\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\tif (ignoredParent != null && element != null && element.hasParent(ignoredParent)) {\n\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t}\n\t\t\tif (element instanceof CtType) {\n\t\t\t\tnrOfNestedLocalClasses++;\n\t\t\t}\n\t\t\treturn ScanningMode.NORMAL;\n\t\t}\n\n\t\t@Override\n\t\tpublic void exit(CtElement element) {\n\t\t\tif (ignoredParent == element) {\n\t\t\t\t//we are living scope of ignored parent. We can stop checking it\n\t\t\t\tignoredParent = null;\n\t\t\t}\n\t\t\tif (element instanceof CtType) {\n\t\t\t\tnrOfNestedLocalClasses--;\n\t\t\t}\n\t\t}\n\n\t\tpublic void ignoreChildrenOf(CtElement element) {\n\t\t\tif (ignoredParent != null) {\n\t\t\t\tthrow new SpoonException(\"Unexpected state. The ignoredParent is already set\");\n\t\t\t}\n\t\t\tignoredParent = element;\n\t\t}\n\n\t\tpublic boolean isInContextOfLocalClass() {\n\t\t\treturn nrOfNestedLocalClasses > 0;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void detectNameConflicts() {\n\t\t/*\n\t\t * There can be these conflicts\n\t\t * 1) target variable would shadow before declared variable (parameter, localVariable, catchVariable)\n\t\t * --------------------------------------------------------------------------------------------------\n\t\t */\n\t\tPotentialVariableDeclarationFunction potentialDeclarationFnc = new PotentialVariableDeclarationFunction(newName);\n\t\tCtVariable<?> var = getTarget().map(potentialDeclarationFnc).first();\n\t\tif (var != null) {\n\t\t\tif (var instanceof CtField) {\n\t\t\t\t/*\n\t\t\t\t * we have found a field of same name.\n\t\t\t\t * It is not problem, because variables can hide field declaration.\n\t\t\t\t * Do nothing - OK\n\t\t\t\t */\n\t\t\t} else if (potentialDeclarationFnc.isTypeOnTheWay()) {\n\t\t\t\t/*\n\t\t\t\t * There is a local class declaration between future variable reference and variable declaration `var`.\n\t\t\t\t * The found variable declaration `var` can be hidden by target variable with newName\n\t\t\t\t * as long as there is no reference to `var` in visibility scope of the target variable.\n\t\t\t\t * So search for such `var` reference now\n\t\t\t\t */\n\t\t\t\tCtVariableReference<?> shadowedVar = target\n\t\t\t\t\t\t.map(new SiblingsFunction().includingSelf(true).mode(Mode.NEXT))\n\t\t\t\t\t\t.map(new VariableReferenceFunction(var)).first();\n\t\t\t\tif (shadowedVar != null) {\n\t\t\t\t\t//found variable reference, which would be shadowed by variable after rename.\n\t\t\t\t\tcreateNameConflictIssue(var, shadowedVar);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * there is no local variable reference, which would be shadowed by variable after rename.\n\t\t\t\t\t * OK\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * the found variable is in conflict with target variable with newName\n\t\t\t\t */\n\t\t\t\tcreateNameConflictIssue(var);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * 2) target variable is shadowed by later declared variable\n\t\t * ---------------------------------------------------------\n\t\t */\n\t\tfinal QueryDriver queryDriver = new QueryDriver();\n\t\tgetTarget().map(new LocalVariableScopeFunction(queryDriver)).select(new Filter<CtElement>() {\n\t\t\t/**\n\t\t\t * return true for all CtVariables, which are in conflict\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic boolean matches(CtElement element) {\n\t\t\t\tif (element instanceof CtType<?>) {\n\t\t\t\t\tCtType<?> localClass = (CtType<?>) element;\n\t\t\t\t\t//TODO use faster hasField, implemented using map(new AllFieldsFunction()).select(new NameFilter(newName)).first()!=null\n\t\t\t\t\tCollection<CtFieldReference<?>> fields = localClass.getAllFields();\n\t\t\t\t\tfor (CtFieldReference<?> fieldRef : fields) {\n\t\t\t\t\t\tif (newName.equals(fieldRef.getSimpleName())) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * we have found a local class field, which will shadow input local variable if it's reference is in visibility scope of that field.\n\t\t\t\t\t\t\t * Search for target variable reference in visibility scope of this field.\n\t\t\t\t\t\t\t * If found than we cannot rename target variable to newName, because that reference would be shadowed\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tqueryDriver.ignoreChildrenOf(element);\n\t\t\t\t\t\t\tCtLocalVariableReference<?> shadowedVar = element.map(new LocalVariableReferenceFunction(target)).first();\n\t\t\t\t\t\t\tif (shadowedVar != null) {\n\t\t\t\t\t\t\t\tcreateNameConflictIssue(fieldRef.getFieldDeclaration(), shadowedVar);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (element instanceof CtVariable<?>) {\n\t\t\t\t\tCtVariable<?> variable = (CtVariable<?>) element;\n\t\t\t\t\tif (newName.equals(variable.getSimpleName()) == false) {\n\t\t\t\t\t\t//the variable with different name. Ignore it\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t//we have found a variable with new name\n\t\t\t\t\tif (variable instanceof CtField) {\n\t\t\t\t\t\tthrow new SpoonException(\"This should not happen. The children of local class which contains a field with new name should be skipped!\");\n\t\t\t\t\t}\n\t\t\t\t\tif (variable instanceof CtCatchVariable || variable instanceof CtLocalVariable || variable instanceof CtParameter) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * we have found a catch variable or local variable or parameter with new name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (queryDriver.isInContextOfLocalClass()) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We are in context of local class.\n\t\t\t\t\t\t\t * This variable would shadow input local variable after rename\n\t\t\t\t\t\t\t * so we cannot rename if there exist a local variable reference in variable visibility scope.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tqueryDriver.ignoreChildrenOf(variable.getParent());\n\t\t\t\t\t\t\tCtQueryable searchScope;\n\t\t\t\t\t\t\tif (variable instanceof CtLocalVariable) {\n\t\t\t\t\t\t\t\tsearchScope = variable.map(new SiblingsFunction().includingSelf(true).mode(Mode.NEXT));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsearchScope = variable.getParent();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tCtLocalVariableReference<?> shadowedVar = searchScope.map(new LocalVariableReferenceFunction(target)).first();\n\t\t\t\t\t\t\tif (shadowedVar != null) {\n\t\t\t\t\t\t\t\t//found local variable reference, which would be shadowed by variable after rename.\n\t\t\t\t\t\t\t\tcreateNameConflictIssue(variable, shadowedVar);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//there is no local variable reference, which would be shadowed by variable after rename.\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We are not in context of local class.\n\t\t\t\t\t\t\t * So this variable is in conflict. Return it\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tcreateNameConflictIssue(variable);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//CtField should not be there, because the children of local class which contains a field with new name should be skipped!\n\t\t\t\t\t\t//Any new variable type???\n\t\t\t\t\t\tthrow new SpoonException(\"Unexpected variable \" + variable.getClass().getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}).first();\n\t}\n\n\t/**\n\t * Override this method to get access to details about this refactoring issue\n\t * @param conflictVar - variable which would be in conflict with the `targetVariable` after it's rename to new name\n\t */\n\tprotected void createNameConflictIssue(CtVariable<?> conflictVar) {\n\t\tthrow new RefactoringException(conflictVar.getClass().getSimpleName() + \" with name \" + conflictVar.getSimpleName() + \" is in conflict.\");\n\t}\n\t/**\n\t * Override this method to get access to details about this refactoring issue\n\t * @param conflictVar - variable which would shadow reference to `targetVariable` after it's rename to new name\n\t * @param shadowedVarRef - the reference to `targetVariable`, which would be shadowed by `conflictVar`\n\t */\n\tprotected void createNameConflictIssue(CtVariable<?> conflictVar, CtVariableReference<?> shadowedVarRef) {\n\t\tthrow new RefactoringException(conflictVar.getClass().getSimpleName() + \" with name \" + conflictVar.getSimpleName() + \" would shadow local variable reference.\");\n\t}\n}\n"
    } ]
  }, {
    "name" : "reflect",
    "children" : [ {
      "name" : "reflect/reference/CtExecutableReference.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.List;\n\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtExecutable}. It can be a\n * {@link spoon.reflect.declaration.CtMethod} or a\n * {@link spoon.reflect.declaration.CtConstructor}.\n */\npublic interface CtExecutableReference<T> extends CtReference, CtActualTypeContainer {\n\n\tString CONSTRUCTOR_NAME = \"<init>\";\n\n\tString LAMBDA_NAME_PREFIX = \"lambda$\";\n\n\tString UNKNOWN_TYPE = \"<unknown>\";\n\n\t/**\n\t * Tells if this is a reference to a constructor.\n\t */\n\tboolean isConstructor();\n\n\t/**\n\t * Gets the runtime method that corresponds to an executable reference if\n\t * any.\n\t *\n\t * @return the method (null if not found)\n\t */\n\tMethod getActualMethod();\n\n\t/**\n\t * Gets the runtime constructor that corresponds to an executable reference\n\t * if any.\n\t *\n\t * @return the constructor (null if not found)\n\t */\n\tConstructor<?> getActualConstructor();\n\n\t@Override\n\t@DerivedProperty\n\tCtExecutable<T> getDeclaration();\n\n\t/**\n\t * Returns a subtype {@link CtExecutable} that corresponds to the reference\n\t * even if its declaring type isn't in the Spoon source path  (in this case,\n\t * the Spoon elements are built with runtime reflection).\n\t *\n\t * @return the executable declaration that corresponds to the reference.\n\t */\n\t@DerivedProperty\n\tCtExecutable<T> getExecutableDeclaration();\n\n\t/**\n\t * Gets the reference to the type that declares this executable.\n\t */\n\t@PropertyGetter(role = CtRole.DECLARING_TYPE)\n\tCtTypeReference<?> getDeclaringType();\n\n\t/**\n\t * For methods, gets the return type of the executable (may be null in noclasspath mode).\n\t * For constructors, gets the constructor class (which is also the return type of the contructor calls).\n\t */\n\t@PropertyGetter(role = CtRole.TYPE)\n\tCtTypeReference<T> getType();\n\n\t/**\n\t * Gets parameters of the executable.\n\t */\n\t@PropertyGetter(role = CtRole.ARGUMENT_TYPE)\n\tList<CtTypeReference<?>> getParameters();\n\n\t/**\n\t * Sets parameters of the executable.\n\t */\n\t@PropertySetter(role = CtRole.ARGUMENT_TYPE)\n\t<C extends CtExecutableReference<T>> C setParameters(List<CtTypeReference<?>> parameters);\n\n\t/**\n\t * Returns <code>true</code> if this executable overrides the given\n\t * executable.\n\t */\n\tboolean isOverriding(CtExecutableReference<?> executable);\n\n\t/**\n\t * Returns the method overridden by this one, if exists (null otherwise).\n\t * The returned method is searched in the superclass hierarchy\n\t * (and not in the super-interfaces).\n\t * The returned method can be an abstract method from an abstract class, a super implementation, or even a method from Object.\n\t */\n\t@DerivedProperty\n\tCtExecutableReference<?> getOverridingExecutable();\n\n\t/**\n\t * Gets an overriding executable for this executable from a given subtype,\n\t * if exists.\n\t *\n\t * @param <S>\n\t * \t\tsubtype of T\n\t * @param subType\n\t * \t\tstarting bottom type to find an overriding executable\n\t * \t\t(subtypes are not tested)\n\t * @return the first found (most concrete) executable that overrides this\n\t * executable (null if none found)\n\t */\n\t<S extends T> CtExecutableReference<S> getOverridingExecutable(CtTypeReference<?> subType);\n\n\t/**\n\t * Tells if the referenced executable is static.\n\t */\n\t@PropertyGetter(role = CtRole.IS_STATIC)\n\tboolean isStatic();\n\n\t/**\n\t * Sets the declaring type.\n\t */\n\t@PropertySetter(role = CtRole.DECLARING_TYPE)\n\t<C extends CtExecutableReference<T>> C setDeclaringType(CtTypeReference<?> declaringType);\n\n\t/**\n\t * Sets this executable reference to be static or not.\n\t */\n\t@PropertySetter(role = CtRole.IS_STATIC)\n\t<C extends CtExecutableReference<T>> C setStatic(boolean b);\n\n\t/**\n\t * Sets the type of the variable.\n\t */\n\t@PropertySetter(role = CtRole.TYPE)\n\t<C extends CtExecutableReference<T>> C setType(CtTypeReference<T> type);\n\n\t/**\n\t * Tells if the referenced executable is final.\n\t */\n\tboolean isFinal();\n\n\t/**\n\t * Gets the signature of this method or constructor, as explained in {@link spoon.reflect.declaration.CtMethod#getSignature()}.\n\t */\n\tString getSignature();\n\n\t@Override\n\tCtExecutableReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * \t<p>This package defines the references to program elements for the meta-model.</p>\n * \t<p>References usually correspond to elements defined in the {@link spoon.reflect.declaration} package. It is\n * \ta weak reference system which allow referencing elements that do not exist yet, or which are defined\n * \toutside of the reified program model. In that last case, some functions use regula Java reflection instead of\n * \tSpoon reflection and referenced elements should be in the classpath.</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.reference;\n"
    }, {
      "name" : "reflect/reference/CtActualTypeContainer.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.List;\n\n\n/**\n * This interface defines the capability related to binding generics (aka type parameters).\n */\npublic interface CtActualTypeContainer {\n\t/**\n\t * Gets the type arguments.\n\t */\n\t@PropertyGetter(role = CtRole.TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> getActualTypeArguments();\n\n\t/**\n\t * Sets the type arguments.\n\t */\n\t@PropertySetter(role = CtRole.TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments);\n\n\t/**\n\t * Adds a type argument.\n\t */\n\t<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);\n\n\t/**\n\t * Removes a type argument.\n\t */\n\tboolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument);\n}\n"
    }, {
      "name" : "reflect/reference/CtTypeReference.java",
      "weight" : 59.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\nimport spoon.support.SpoonClassNotFoundException;\n\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.PACKAGE_REF;\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtType} or sub-type.\n */\npublic interface CtTypeReference<T> extends CtReference, CtActualTypeContainer, CtTypeInformation, CtShadowable {\n\n\t/**\n\t * The name of the null type (\"&lt;nulltype&gt;\").\n\t */\n\tString NULL_TYPE_NAME = \"<nulltype>\";\n\n\t/**\n\t * Returns the simple (unqualified) name of this element.\n\t * Following the compilation convention, if the type is a local type,\n\t * the name starts with a numeric prefix (e.g. local class Foo has simple name 1Foo).\n\t */\n\t@Override\n\tString getSimpleName();\n\n\t/**\n\t * Gets the Java runtime class of the referenced type.\n\t *\n\t * This is a low-level feature, it should never been used.\n\t * For CtTypeReference, use {@link #getTypeDeclaration()} instead,\n\t * in order to only stay in the Spoon world and manipulate CtType instead of java.lang.Class.\n\t *\n\t * @return the Java class or throws a {@link SpoonClassNotFoundException} if the class is not found.\n\t * @throws SpoonClassNotFoundException if the class is not in the classpath\n\t * @deprecated (Since Spoon 7.0.0) use {@link #getTypeDeclaration()} instead\n\t */\n\tClass<T> getActualClass();\n\n\t/**\n\t * Returns the {@link CtType}, that corresponds to the\n\t * reference or <code>null</code> if the type declaration is not in the\n\t * analyzed source files,\n\t *\n\t * {@link #getTypeDeclaration()} is a newer and better alternative that never returns null.\n\t *\n\t * @return the referenced element or <code>null</code> if the type\n\t * declaration is not the analyzed source files.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtType<T> getDeclaration();\n\n\t/**\n\t * Returns the {@link CtType} that corresponds to the reference even if the\n\t * type isn't in the Spoon source path  (in this case, the Spoon elements are\n\t * built with runtime reflection, and the resulting CtType is called a \"shadow\" class,\n\t * see {@link CtShadowable#isShadow()}).\n\t *\n\t * @return the type declaration that corresponds to the reference or null if the reference points to a class that is not in the classpath.\n\t */\n\t@DerivedProperty\n\tCtType<T> getTypeDeclaration();\n\n\t/**\n\t * Gets the type that declares the referenced type.\n\t *\n\t * @return the declaring type if this references an inner class; null in\n\t * other cases\n\t */\n\t@PropertyGetter(role = CtRole.DECLARING_TYPE)\n\tCtTypeReference<?> getDeclaringType();\n\n\t/**\n\t * Gets the package of the referenced type.\n\t *\n\t * @return the declaring package or null if this if a inner class\n\t */\n\t@PropertyGetter(role = PACKAGE_REF)\n\tCtPackageReference getPackage();\n\n\t/**\n\t * Returns the corresponding non-primitive type for a primitive type (the\n\t * same type otherwise).\n\t */\n\tCtTypeReference<?> box();\n\n\t/**\n\t * Returns the primitive type for a boxing type (unchanged if the type does\n\t * not correspond to a boxing type).\n\t */\n\tCtTypeReference<?> unbox();\n\n\t/**\n\t * Sets the reference to the declaring type. Should be set to null if the\n\t * referenced type is not a inner type.\n\t */\n\t@PropertySetter(role = CtRole.DECLARING_TYPE)\n\t<C extends CtTypeReference<T>> C setDeclaringType(CtTypeReference<?> type);\n\n\t/**\n\t * Sets the reference to the declaring package.\n\t */\n\t@PropertySetter(role = PACKAGE_REF)\n\t<C extends CtTypeReference<T>> C setPackage(CtPackageReference pack);\n\n\t/**\n\t * Casts the type reference in {@link CtIntersectionTypeReference}.\n\t */\n\tCtIntersectionTypeReference<T> asCtIntersectionTypeReference();\n\n\t@Override\n\tCtTypeReference<T> clone();\n\n\t@Override\n\t@DerivedProperty\n\tSet<CtTypeReference<?>> getSuperInterfaces();\n\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<?> getSuperclass();\n\n\t@Override\n\t@DerivedProperty\n\tSet<ModifierKind> getModifiers();\n\n\t/**\n\t * Checks visibility based on public, protected, package protected and private modifiers of type\n\t * @param type\n\t * @return true if this can access that type\n\t */\n\tboolean canAccess(CtTypeReference<?> type);\n\n\t/**\n\t * @return true if this type can access that the `typeMember` in another type based on public, protected, package protected and private modifiers.\n\t */\n\tboolean canAccess(CtTypeMember typeMember);\n\n\t/**\n\t * Returns this, or top level type of this, if this is an inner type\n\t */\n\t@DerivedProperty\n\tCtTypeReference<?> getTopLevelType();\n\n\t/**\n\t * Computes nearest access path parent to this type from the context of this type reference.\n\t * The context is defined by this.getParent(CtType.class).\n\t *\n\t * Normally the declaring type can be used as access path. For example in this class hierarchy\n\t * <pre>\n\t * class A {\n\t *    class B {\n\t *       class C {}\n\t *    }\n\t * }\n\t * </pre>\n\t *\n\t * The C.getAccessParentFrom(null) will return B, because B can be used to access C, using code like <code>B.C</code><br>\n\t * But when some class (A or B) on the access path is not visible in type X, then we must found an alternative path.\n\t * For example in case like, when A and B are invisible, e.g because of modifier <code>protected</code>:\n\t * <pre>\n\t * class D extends B {\n\t * }\n\t * class X extends D {\n\t * \t class F extends C\n\t * }\n\t * </pre>\n\t * The C.getAccessParentFrom(X) will return D, because D can be used to access C in scope of X.\n\t *\n\t * @return type reference which can be used to access this type in scope of contextType.\n\t */\n\t@DerivedProperty\n\tCtTypeReference<?> getAccessType();\n\n\t/**\n\t * If this type reference is used as a type argument (see {@link #getActualTypeArguments()}), returns the type parameter declaration in the target type, returns null otherwise.\n\t *\n\t * In the following example, getTypeParameterDeclaration of \"String\" returns the type parameter definition \"X\".\n\t * <pre>\n\t * class Dog&lt;X&gt;{}\n\t * Dog&lt;String&gt;var = ...;\n\t * </pre>\n\t **\n\t * In this other example, getTypeParameterDeclaration of T in Dog&lt;T&gt; returns the type parameter definition \"X\" (while {@link #getDeclaration()} returns the \"T\" of Cat).\n\t * <pre>\n\t * class Dog&lt;X&gt;{}\n\t * class Cat&lt;T&gt; {\n\t * Dog&lt;T&gt; dog;\n\t * }\n\t * </pre>\n\t */\n\t@DerivedProperty\n\tCtTypeParameter getTypeParameterDeclaration();\n\n\t/**\n\t * @param parentIsImplicit false then fully qualified name is printed.\n\t * \t\ttrue then type simple name is printed.\n\t */\n\t@DerivedProperty\n\tCtTypeReference<T> setImplicitParent(boolean parentIsImplicit);\n\n\t/**\n\t * @return false then fully qualified name is printed.\n\t * \t\ttrue then type simple name is printed.\n\t */\n\t@DerivedProperty\n\tboolean isImplicitParent();\n}\n"
    }, {
      "name" : "reflect/reference/CtIntersectionTypeReference.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.BOUND;\n\n/**\n * This interface defines a reference to an intersection type in generics or in casts.\n */\npublic interface CtIntersectionTypeReference<T> extends CtTypeReference<T> {\n\t/**\n\t * Gets the bounds of the intersection type. Note that the first bound correspond to the current intersection type.\n\t * <pre>\n\t *     T extends Interface1 &amp; Interface2 // CtTypeParameterReference#getBoundingType == Interface1 and getBounds().get(0) == Interface1\n\t * </pre>\n\t */\n\t@PropertyGetter(role = BOUND)\n\tList<CtTypeReference<?>> getBounds();\n\n\t/**\n\t * Sets the bounds of the intersection type.\n\t */\n\t@PropertySetter(role = BOUND)\n\t<C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds);\n\n\t/**\n\t * Adds a bound.\n\t */\n\t@PropertySetter(role = BOUND)\n\t<C extends CtIntersectionTypeReference> C addBound(CtTypeReference<?> bound);\n\n\t/**\n\t * Removes a bound.\n\t */\n\t@PropertySetter(role = BOUND)\n\tboolean removeBound(CtTypeReference<?> bound);\n\n\t@Override\n\tCtIntersectionTypeReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtParameterReference.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.support.DerivedProperty;\n\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtParameter} of a method.\n */\npublic interface CtParameterReference<T> extends CtVariableReference<T> {\n\n\t/**\n\t * Gets the declaring executable of the referenced parameter.\n\t */\n\t@DerivedProperty\n\tCtExecutableReference<?> getDeclaringExecutable();\n\n\t@Override\n\t@DerivedProperty\n\tCtParameter<T> getDeclaration();\n\n\t@Override\n\tCtParameterReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtTypeMemberWildcardImportReference.java",
      "weight" : 45.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\n/**\n * This interface defines a import reference to all static type members of a type.<br>\n * Example:\n * <code>somePackage.Type.*;</code>\n */\npublic interface CtTypeMemberWildcardImportReference extends CtReference {\n\n\t/**\n\t * Returns the fully qualified name of type followed by `.*`\n\t */\n\t@DerivedProperty\n\tString getSimpleName();\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtReference> T setSimpleName(String simpleName);\n\n\t@PropertyGetter(role = CtRole.TYPE_REF)\n\tCtTypeReference<?> getTypeReference();\n\n\t@PropertySetter(role = CtRole.TYPE_REF)\n\tCtTypeMemberWildcardImportReference setTypeReference(CtTypeReference<?> typeReference);\n\n\t@Override\n\tCtTypeMemberWildcardImportReference clone();\n\n\t@Override\n\t@DerivedProperty\n\tCtType<?> getDeclaration();\n\n\t@Override\n\t@DerivedProperty\n\tList<CtAnnotation<? extends Annotation>> getAnnotations();\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E addAnnotation(CtAnnotation<? extends Annotation> annotation);\n\n\t@Override\n\t@UnsettableProperty\n\tboolean removeAnnotation(CtAnnotation<? extends Annotation> annotation);\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotation);\n\n\t@Override\n\t@DerivedProperty\n\tboolean isImplicit();\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setImplicit(boolean b);\n}\n"
    }, {
      "name" : "reflect/reference/CtLocalVariableReference.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.support.DerivedProperty;\n\n/**\n * This interface defines a reference to\n * {@link spoon.reflect.code.CtLocalVariable}.\n */\npublic interface CtLocalVariableReference<T> extends CtVariableReference<T> {\n\t@Override\n\t@DerivedProperty\n\tCtLocalVariable<T> getDeclaration();\n\n\t@Override\n\tCtLocalVariableReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtCatchVariableReference.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.support.DerivedProperty;\n\n/**\n * This interface defines a reference to {@link spoon.reflect.code.CtCatchVariable}.\n */\npublic interface CtCatchVariableReference<T> extends CtVariableReference<T> {\n\t// overriding the return type\n\t@Override\n\t@DerivedProperty\n\tCtCatchVariable<T> getDeclaration();\n\n\t@Override\n\tCtCatchVariableReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtUnboundVariableReference.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.UnsettableProperty;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\n\n/**\n * This interface defines a reference to an unbound\n * {@link spoon.reflect.declaration.CtVariable}.\n */\npublic interface CtUnboundVariableReference<T> extends CtVariableReference<T> {\n\t@Override\n\tCtUnboundVariableReference<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotation);\n}\n"
    }, {
      "name" : "reflect/reference/CtArrayTypeReference.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\n\n/**\n * This interface defines a reference to an array.\n */\npublic interface CtArrayTypeReference<T> extends CtTypeReference<T> {\n\n\t/**\n\t * Gets the type of the elements contained in this array.\n\t * e.g., if you have the array <code>int[][][]</code>,\n\t * this method returns a type reference for <code>int[][]</code>.\n\t */\n\t@PropertyGetter(role = CtRole.TYPE)\n\tCtTypeReference<?> getComponentType();\n\n\t/**\n\t * Gets the type of the array elements at the finest grain.\n\t * e.g., if you have the array <code>int[][][]</code>,\n\t * this method returns a type reference to \"int\".\n\t */\n\t@DerivedProperty\n\tCtTypeReference<?> getArrayType();\n\n\t/**\n\t * Sets the type of the elements contained in this array.\n\t */\n\t@PropertySetter(role = CtRole.TYPE)\n\t<C extends CtArrayTypeReference<T>> C setComponentType(CtTypeReference<?> componentType);\n\n\t/**\n\t * Returns the number of dimensions of this array type. This corresponds to\n\t * the number of array types recursively embedded into the current one (see\n\t * {@link #getComponentType()}).\n\t */\n\t@DerivedProperty\n\tint getDimensionCount();\n\n\t/**\n\t * Returns the simple name of the array type core component type (with no\n\t * []s). Use toString() to get the full array type including []s.\n\t */\n\t@Override\n\t@DerivedProperty\n\tString getSimpleName();\n\n\t/**\n\t * The simple name of an ArrayTypeReference is unsettable as it's retrieved from its component type.\n\t */\n\t@UnsettableProperty\n\t@Override\n\t<T extends CtReference> T setSimpleName(String simpleName);\n\n\t@Override\n\tCtArrayTypeReference<T> clone();\n\n}\n"
    }, {
      "name" : "reflect/reference/CtWildcardReference.java",
      "weight" : 21.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.UnsettableProperty;\n\n/**\n * Represents a wildcard in generic type annotations, i.e. the \"?\" (e.g. the \"?\" in Collection&lt;?&gt; or Collection&lt;? extends List&gt;).\n */\npublic interface CtWildcardReference extends CtTypeParameterReference {\n\t@Override\n\tCtWildcardReference clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtReference> C setSimpleName(String simpleName);\n\n\t/**\n\t * Returns {@code true} if the bounds are in <code>extends</code> clause.\n\t * {@code false} means a <code>super</code> clause.\n\t */\n\t@PropertyGetter(role = CtRole.IS_UPPER)\n\tboolean isUpper();\n\n\t/**\n\t * Set to {@code true} to write <code>extends</code> clause for bounds types.\n\t */\n\t@PropertySetter(role = CtRole.IS_UPPER)\n\t<T extends CtWildcardReference> T setUpper(boolean upper);\n\n\t/**\n\t * A type parameter can have an <code>extends</code> clause which declare\n\t * one ({@link CtTypeReference} or more ({@link CtIntersectionTypeReference} references.\n\t * <pre>\n\t *     // Extends with generics.\n\t *     T extends Interface1\n\t *     // Intersection type with generics.\n\t *     T extends Interface1 &amp; Interface2\n\t * </pre>\n\t */\n\t@PropertyGetter(role = CtRole.BOUNDING_TYPE)\n\t@Override\n\tCtTypeReference<?> getBoundingType();\n\n\t/**\n\t * Sets the <code>extends</code> clause of the type parameter.\n\t */\n\t@PropertySetter(role = CtRole.BOUNDING_TYPE)\n\t<T extends CtWildcardReference> T setBoundingType(CtTypeReference<?> superType);\n}\n"
    }, {
      "name" : "reflect/reference/CtFieldReference.java",
      "weight" : 30.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\n\nimport java.lang.reflect.Member;\n\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtField}.\n */\npublic interface CtFieldReference<T> extends CtVariableReference<T> {\n\t/**\n\t * Gets the runtime member that corresponds to a field reference if any.\n\t *\n\t * @return the member (null if not found)\n\t */\n\tMember getActualField();\n\n\t@Override\n\t@DerivedProperty\n\tCtField<T> getDeclaration();\n\n\t/**\n\t * Returns the {@link CtField} that corresponds to the reference\n\t * even if its declaring type isn't in the Spoon source path  (in this case,\n\t * the Spoon elements are built with runtime reflection)\n\t *\n\t * @return the field declaration that corresponds to the reference.\n\t */\n\t@DerivedProperty\n\tCtField<T> getFieldDeclaration();\n\n\t/**\n\t * Gets the type in which the field is declared.\n\t */\n\t@PropertyGetter(role = CtRole.DECLARING_TYPE)\n\tCtTypeReference<?> getDeclaringType();\n\n\t/**\n\t * Gets the qualified name of the field.\n\t */\n\tString getQualifiedName();\n\n\t/**\n\t * Tells if the referenced field is final.\n\t */\n\t@PropertyGetter(role = CtRole.IS_FINAL)\n\tboolean isFinal();\n\n\t/**\n\t * Tells if the referenced field is static.\n\t */\n\t@PropertyGetter(role = CtRole.IS_STATIC)\n\tboolean isStatic();\n\n\t/**\n\t * Sets the type in which the field is declared.\n\t */\n\t@PropertySetter(role = CtRole.DECLARING_TYPE)\n\t<C extends CtFieldReference<T>> C setDeclaringType(CtTypeReference<?> declaringType);\n\n\t/**\n\t * Forces a reference to a final element.\n\t */\n\t@PropertySetter(role = CtRole.IS_FINAL)\n\t<C extends CtFieldReference<T>> C setFinal(boolean b);\n\n\t/**\n\t * Forces a reference to a static element.\n\t */\n\t@PropertySetter(role = CtRole.IS_STATIC)\n\t<C extends CtFieldReference<T>> C setStatic(boolean b);\n\n\t@Override\n\tCtFieldReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtModuleReference.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.declaration.CtModule;\nimport spoon.support.DerivedProperty;\n\n/**\n * Represents a reference to a {@link CtModule}\n */\npublic interface CtModuleReference extends CtReference {\n\n\t@Override\n\t@DerivedProperty\n\tCtModule getDeclaration();\n\n\t@Override\n\tCtModuleReference clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtPackageReference.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.support.DerivedProperty;\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtPackage}.\n */\npublic interface CtPackageReference extends CtReference {\n\t/**\n\t * Gets the package element when available in the source code.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtPackage getDeclaration();\n\n\t/**\n\t * Gets the package element when available in the class path.\n\t */\n\tPackage getActualPackage();\n\n\t/**\n\t * Returns {@code true} if this is a reference to an <i>unnamed</i>\n\t * Java package. See JLS §7.4.2. Unnamed Packages.\n\t */\n\tboolean isUnnamedPackage();\n\n\t@Override\n\tCtPackageReference clone();\n\n\t/**\n\t * The simple name of a CtPackageReference is always the fully qualified name of its referenced package. (see {@link spoon.reflect.factory.PackageFactory})\n\t * @return The fully qualified name of its referenced package\n\t */\n\t@Override\n\tString getSimpleName();\n\n\t/**\n\t * The qualified name of a CtPackageReference is directly given by its simple name (see {@link CtPackageReference#getSimpleName})\n\t * @return the fully qualified name of its referenced package\n\t */\n\tString getQualifiedName();\n}\n"
    }, {
      "name" : "reflect/reference/CtVariableReference.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\n\nimport java.util.Set;\n\n\n/**\n * This interface defines a reference to a\n * {@link spoon.reflect.declaration.CtVariable} or sub-type.\n */\npublic interface CtVariableReference<T> extends CtReference {\n\n\t/**\n\t * Gets the type of the variable.\n\t */\n\t@PropertyGetter(role = CtRole.TYPE)\n\tCtTypeReference<T> getType();\n\n\t/**\n\t * Sets the type of the variable.\n\t */\n\t@PropertySetter(role = CtRole.TYPE)\n\t<C extends CtVariableReference<T>> C setType(CtTypeReference<T> type);\n\n\t/**\n\t * Tries to get the declaration of the reference.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtVariable<T> getDeclaration();\n\n\t/**\n\t * Gets modifiers of the reference.\n\t */\n\tSet<ModifierKind> getModifiers();\n\n\t@Override\n\tCtVariableReference<T> clone();\n}\n"
    }, {
      "name" : "reflect/reference/CtReference.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\n\n\n/**\n * This is the root interface for named program element references. References\n * can point to program element built in the model or not. In the latter case,\n * introspection methods fall back on runtime reflection (\n * <code>java.lang.reflect</code>) to access the program information, as long as\n * available in the classpath.\n *\n * @see spoon.reflect.declaration.CtElement\n */\npublic interface CtReference extends CtElement {\n\n\t/**\n\t * Gets the simple name of referenced element.\n\t */\n\t@PropertyGetter(role = CtRole.NAME)\n\tString getSimpleName();\n\n\t/**\n\t * Sets the name of referenced element.\n\t */\n\t@PropertySetter(role = CtRole.NAME)\n\t<T extends CtReference> T setSimpleName(String simpleName);\n\n\t/**\n\t * Returns the declaration that corresponds to the referenced element only\n\t * if the declaration is in the analyzed source files.\n\t * It is strongly advised to use the more robust {@link CtTypeReference#getTypeDeclaration()} and {@link CtExecutableReference#getExecutableDeclaration()} that never return null.\n\t * @return referenced element or null if element is not in the source path (aka input resource).\n\t */\n\t@DerivedProperty\n\tCtElement getDeclaration();\n\n\t@Override\n\tCtReference clone();\n\n\t/** comments are not possible for references */\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setComments(List<CtComment> comments);\n}\n"
    }, {
      "name" : "reflect/reference/CtTypeParameterReference.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.reference;\n\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\n\n\n/**\n * This interface defines a reference to a type parameter (aka generics).\n */\npublic interface CtTypeParameterReference extends CtTypeReference<Object> {\n\n\t/**\n\t * A type parameter can have an <code>extends</code> clause which declare\n\t * one ({@link CtTypeReference} or more ({@link CtIntersectionTypeReference} references.\n\t * <pre>\n\t *     // Extends with generics.\n\t *     T extends Interface1\n\t *     // Intersection type with generics.\n\t *     T extends Interface1 &amp; Interface2\n\t * </pre>\n\t */\n\t@DerivedProperty\n\tCtTypeReference<?> getBoundingType();\n\n\t/**\n\t * Returns the {@link CtTypeParameter}, a {@link CtTypeParameter}, that declares the type parameter\n\t * referenced or <code>null</code> if the reference is not in a context where such type parameter is declared.\n\t * See also {@link #getTypeParameterDeclaration()} which has a different semantic.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtTypeParameter getDeclaration();\n\n\t// overriding the return type\n\t@Override\n\tCtTypeParameterReference clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments);\n\n\t/**\n\t * Returns true if this has the default bounding type that is java.lang.Object (which basically means that there is no bound)\n\t */\n\t@DerivedProperty\n\tboolean isDefaultBoundingType();\n}\n"
    }, {
      "name" : "reflect/CtModel.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect;\n\nimport spoon.SpoonModelBuilder;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtQueryable;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.List;\n\n/** represents a Java program, modeled by a set of compile-time (Ct) objects\n * where each object is a program element (for instance, a CtClass represents a class).\n */\npublic interface CtModel extends Serializable, CtQueryable {\n\n\t/** returns the root package of the unnamed module */\n\tCtPackage getRootPackage();\n\n\t/** returns all top-level types of the model */\n\tCollection<CtType<?>> getAllTypes();\n\n\t/** returns all packages of the model */\n\tCollection<CtPackage> getAllPackages();\n\n\t/**\n\t * Returns the unnamed module.\n\t */\n\tCtModule getUnnamedModule();\n\n\t/**\n\t * returns all modules of the model\n\t */\n\tCollection<CtModule> getAllModules();\n\n\t/** process this model with the given processor */\n\tvoid processWith(Processor<?> processor);\n\n\t/** Returns all the model elements matching the filter. */\n\t<E extends CtElement> List<E> getElements(Filter<E> filter);\n\n\t/**\n\t * If true, the first build model has been finished.\n\t * This value should be false at the beginning of {@link SpoonModelBuilder#build()} and true at this end.\n\t */\n\tboolean isBuildModelFinished();\n\n\t/**\n\t * Set to true to flag that a build model has been finished.\n\t * By default, this method is called with a true value at the end of {@link SpoonModelBuilder#build()}\n\t */\n\t<T extends CtModel> T setBuildModelIsFinished(boolean buildModelFinished);\n\n}\n"
    }, {
      "name" : "reflect/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * \t<p>This package defines the Spoon's compile-time meta-model of Java programs.\n * <p>The meta-model defines a read/write compile-time meta-representation of Java 5 programs.\n * The programmers should instantiate or resolve the meta-elements by using {@link spoon.reflect.factory.Factory}'s sub-factories because it ensures\n * the model consistency. The {@link spoon.reflect.factory.CoreFactory} is the raw factory for program elements and is the\n * only factory to be implemented when wanting to provide an alternative implementation of the Spoon meta-model.\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect;\n"
    }, {
      "name" : "reflect/meta/impl/AbstractRoleHandler.java",
      "weight" : 70.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * common implementation of {@link RoleHandler}\n * @param <T> the type of node whose attribute has to be manipulated\n * @param <U> the type of container value of the attribute\n * @param <V> the type of item value of the attribute\n */\nabstract class AbstractRoleHandler<T, U, V> implements RoleHandler {\n\n\tprivate final CtRole role;\n\tprivate final Class<T> targetClass;\n\tprivate final Class<V> valueClass;\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected AbstractRoleHandler(CtRole role, Class<T> targetType, Class<?> valueType) {\n\t\tthis.role = role;\n\t\tthis.targetClass = targetType;\n\t\tthis.valueClass = (Class) valueType;\n\t}\n\n\t@Override\n\tpublic CtRole getRole() {\n\t\treturn role;\n\t}\n\n\t@Override\n\tpublic Class<?> getTargetType() {\n\t\treturn targetClass;\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tprotected T castTarget(Object element) {\n\t\treturn (T) element;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tprotected U castValue(Object value) {\n\t\treturn (U) value;\n\t}\n\n\tprotected void checkItemsClass(Iterable<?> iterable) {\n\t\t//check that each item has expected class\n\t\tfor (Object value : iterable) {\n\t\t\tcastItemValue(value);\n\t\t}\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tprotected V castItemValue(Object value) {\n\t\t//check that item has expected class\n\t\tif (value != null && valueClass.isInstance(value) == false) {\n\t\t\tthrow new ClassCastException(value.getClass().getName() + \" cannot be cast to \" + valueClass.getName());\n\t\t}\n\t\treturn (V) value;\n\t}\n\n\t@Override\n\tpublic <W, X> void setValue(W element, X value) {\n\t\tthrow new SpoonException(\"Setting of CtRole.\" + role.name() + \" is not supported for \" + element.getClass().getSimpleName());\n\t}\n\n\t@Override\n\tpublic Class<?> getValueClass() {\n\t\treturn valueClass;\n\t}\n\n\t@Override\n\tpublic <W, X> List<X> asList(W element) {\n\t\tthrow new SpoonException(\"The value of CtRole.\" + getRole().name() + \" cannot be adapted to List for \" + element.getClass().getSimpleName());\n\t}\n\n\t@Override\n\tpublic <W, X> Set<X> asSet(W element) {\n\t\tthrow new SpoonException(\"The value of CtRole.\" + getRole().name() + \" cannot be adapted to Set for \" + element.getClass().getSimpleName());\n\t}\n\n\t@Override\n\tpublic <W, X> Map<String, X> asMap(W element) {\n\t\tthrow new SpoonException(\"The value of CtRole.\" + getRole().name() + \" cannot be adapted to Map for \" + element.getClass().getSimpleName());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getTargetType().getName() + \"#\" + getRole().getCamelCaseName();\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/impl/ListHandler.java",
      "weight" : 98.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * implementation of {@link RoleHandler}, which handles attributes of type List&lt;V&gt;\n * @param <T> the type of node whose attribute has to be manipulated\n * @param <V> the type of item value of the attribute\n */\nabstract class ListHandler<T, V> extends AbstractRoleHandler<T, List<V>, V> {\n\n\tprotected ListHandler(CtRole role, Class<T> targetType, Class<?> valueClass) {\n\t\tsuper(role, targetType, valueClass);\n\t}\n\n\t@Override\n\tpublic ContainerKind getContainerKind() {\n\t\treturn ContainerKind.LIST;\n\t}\n\n\t@Override\n\tprotected List<V> castValue(Object value) {\n\t\tList<V> list = super.castValue(value);\n\t\t//check that each item has expected class\n\t\tcheckItemsClass(list);\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic <W, X> java.util.Collection<X> asCollection(W element) {\n\t\treturn asList(element);\n\t}\n\n\t@Override\n\tpublic <W, X> java.util.List<X> asList(W e) {\n\t\treturn new AbstractList<X>() {\n\t\t\tT element = castTarget(e);\n\n\t\t\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t\t\t@Override\n\t\t\tpublic Iterator<X> iterator() {\n\t\t\t\treturn (Iterator) ListHandler.this.iterator(element);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn ListHandler.this.size(element);\n\t\t\t}\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic X get(int index) {\n\t\t\t\treturn (X) ListHandler.this.get(element, index);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic X set(int index, X value) {\n\t\t\t\treturn (X) ListHandler.this.set(element, index, castItemValue(value));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic X remove(int index) {\n\t\t\t\treturn (X) ListHandler.this.remove(element, index);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean add(X value) {\n\t\t\t\treturn ListHandler.this.add(element, castItemValue(value));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean remove(Object value) {\n\t\t\t\treturn ListHandler.this.remove(element, value);\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected boolean remove(T element, Object value) {\n\t\tList<V> values = new ArrayList<>(this.<T, List<V>>getValue(element));\n\t\tboolean ret = values.remove(value);\n\t\tif (ret) {\n\t\t\tsetValue(element, values);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprotected V remove(T element, int index) {\n\t\tList<V> values = new ArrayList<>(this.<T, List<V>>getValue(element));\n\t\tV ret = values.remove(index);\n\t\tsetValue(element, values);\n\t\treturn ret;\n\t}\n\n\tprotected boolean add(T element, V value) {\n\t\tList<V> values = new ArrayList<>(this.<T, List<V>>getValue(element));\n\t\tboolean ret = values.add(value);\n\t\tsetValue(element, values);\n\t\treturn ret;\n\t}\n\n\tprotected V get(T element, int index) {\n\t\treturn this.<T, List<V>>getValue(element).get(index);\n\t}\n\n\tprotected V set(T element, int index, V value) {\n\t\tList<V> values = new ArrayList<>(this.<T, List<V>>getValue(element));\n\t\tV ret = values.set(index, value);\n\t\tsetValue(element, values);\n\t\treturn ret;\n\t}\n\n\tprotected int size(T element) {\n\t\treturn this.<T, List<V>>getValue(element).size();\n\t}\n\n\tprotected Iterator<V> iterator(T element) {\n\t\treturn this.<T, List<V>>getValue(element).iterator();\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/impl/ModelRoleHandlers.java",
      "weight" : 1928.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\n\nimport java.lang.annotation.Annotation;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtAbstractInvocation;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLabelledFlowBreak;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.code.UnaryOperatorKind;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleDirective;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtMultiTypedElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\n\n\n/**\n * Contains implementations of {@link RoleHandler}s for all {@link CtRole}s of all model elements\n */\nclass ModelRoleHandlers {\n\tstatic class CtTypeAccess_ACCESSED_TYPE_RoleHandler extends SingleHandler<CtTypeAccess, CtTypeReference<?>> {\n\t\tprivate CtTypeAccess_ACCESSED_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.ACCESSED_TYPE, CtTypeAccess.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAccessedType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAccessedType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtClass_ANNONYMOUS_EXECUTABLE_RoleHandler extends ListHandler<CtClass, CtAnonymousExecutable> {\n\t\tprivate CtClass_ANNONYMOUS_EXECUTABLE_RoleHandler() {\n\t\t\tsuper(CtRole.ANNONYMOUS_EXECUTABLE, CtClass.class, CtAnonymousExecutable.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAnonymousExecutables())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAnonymousExecutables(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtElement_ANNOTATION_RoleHandler extends ListHandler<CtElement, CtAnnotation<? extends Annotation>> {\n\t\tprivate CtElement_ANNOTATION_RoleHandler() {\n\t\t\tsuper(CtRole.ANNOTATION, CtElement.class, CtAnnotation.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAnnotations())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAnnotations(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAnnotation_ANNOTATION_TYPE_RoleHandler extends SingleHandler<CtAnnotation, CtTypeReference<? extends Annotation>> {\n\t\tprivate CtAnnotation_ANNOTATION_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.ANNOTATION_TYPE, CtAnnotation.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAnnotationType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAnnotationType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAbstractInvocation_ARGUMENT_RoleHandler extends ListHandler<CtAbstractInvocation, CtExpression<?>> {\n\t\tprivate CtAbstractInvocation_ARGUMENT_RoleHandler() {\n\t\t\tsuper(CtRole.ARGUMENT, CtAbstractInvocation.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getArguments())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setArguments(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutableReference_ARGUMENT_TYPE_RoleHandler extends ListHandler<CtExecutableReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtExecutableReference_ARGUMENT_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.ARGUMENT_TYPE, CtExecutableReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getParameters())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setParameters(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAssignment_ASSIGNED_RoleHandler extends SingleHandler<CtAssignment, CtExpression<?>> {\n\t\tprivate CtAssignment_ASSIGNED_RoleHandler() {\n\t\t\tsuper(CtRole.ASSIGNED, CtAssignment.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAssigned())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAssigned(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtRHSReceiver_ASSIGNMENT_RoleHandler extends SingleHandler<CtRHSReceiver, CtExpression<?>> {\n\t\tprivate CtRHSReceiver_ASSIGNMENT_RoleHandler() {\n\t\t\tsuper(CtRole.ASSIGNMENT, CtRHSReceiver.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAssignment())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAssignment(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtBodyHolder_BODY_RoleHandler extends SingleHandler<CtBodyHolder, CtStatement> {\n\t\tprivate CtBodyHolder_BODY_RoleHandler() {\n\t\t\tsuper(CtRole.BODY, CtBodyHolder.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getBody())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setBody(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtSynchronized_BODY_RoleHandler extends SingleHandler<CtSynchronized, CtBlock<? extends Object>> {\n\t\tprivate CtSynchronized_BODY_RoleHandler() {\n\t\t\tsuper(CtRole.BODY, CtSynchronized.class, CtBlock.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getBlock())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setBlock(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtIntersectionTypeReference_BOUND_RoleHandler extends ListHandler<CtIntersectionTypeReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtIntersectionTypeReference_BOUND_RoleHandler() {\n\t\t\tsuper(CtRole.BOUND, CtIntersectionTypeReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getBounds())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setBounds(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtWildcardReference_BOUNDING_TYPE_RoleHandler extends SingleHandler<CtWildcardReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtWildcardReference_BOUNDING_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.BOUNDING_TYPE, CtWildcardReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getBoundingType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setBoundingType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtSwitch_CASE_RoleHandler extends ListHandler<CtSwitch, CtCase<?>> {\n\t\tprivate CtSwitch_CASE_RoleHandler() {\n\t\t\tsuper(CtRole.CASE, CtSwitch.class, CtCase.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCases())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCases(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExpression_CAST_RoleHandler extends ListHandler<CtExpression, CtTypeReference<? extends Object>> {\n\t\tprivate CtExpression_CAST_RoleHandler() {\n\t\t\tsuper(CtRole.CAST, CtExpression.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTypeCasts())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTypeCasts(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTry_CATCH_RoleHandler extends ListHandler<CtTry, CtCatch> {\n\t\tprivate CtTry_CATCH_RoleHandler() {\n\t\t\tsuper(CtRole.CATCH, CtTry.class, CtCatch.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCatchers())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCatchers(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtElement_COMMENT_RoleHandler extends ListHandler<CtElement, CtComment> {\n\t\tprivate CtElement_COMMENT_RoleHandler() {\n\t\t\tsuper(CtRole.COMMENT, CtElement.class, CtComment.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getComments())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setComments(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtComment_COMMENT_CONTENT_RoleHandler extends SingleHandler<CtComment, String> {\n\t\tprivate CtComment_COMMENT_CONTENT_RoleHandler() {\n\t\t\tsuper(CtRole.COMMENT_CONTENT, CtComment.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getContent())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setContent(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtJavaDocTag_COMMENT_CONTENT_RoleHandler extends SingleHandler<CtJavaDocTag, String> {\n\t\tprivate CtJavaDocTag_COMMENT_CONTENT_RoleHandler() {\n\t\t\tsuper(CtRole.COMMENT_CONTENT, CtJavaDocTag.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getContent())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setContent(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtJavaDoc_COMMENT_TAG_RoleHandler extends ListHandler<CtJavaDoc, CtJavaDocTag> {\n\t\tprivate CtJavaDoc_COMMENT_TAG_RoleHandler() {\n\t\t\tsuper(CtRole.COMMENT_TAG, CtJavaDoc.class, CtJavaDocTag.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTags())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTags(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtComment_COMMENT_TYPE_RoleHandler extends SingleHandler<CtComment, CtComment.CommentType> {\n\t\tprivate CtComment_COMMENT_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.COMMENT_TYPE, CtComment.class, CtComment.CommentType.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCommentType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCommentType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAssert_CONDITION_RoleHandler extends SingleHandler<CtAssert, CtExpression<Boolean>> {\n\t\tprivate CtAssert_CONDITION_RoleHandler() {\n\t\t\tsuper(CtRole.CONDITION, CtAssert.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAssertExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAssertExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtConditional_CONDITION_RoleHandler extends SingleHandler<CtConditional, CtExpression<Boolean>> {\n\t\tprivate CtConditional_CONDITION_RoleHandler() {\n\t\t\tsuper(CtRole.CONDITION, CtConditional.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCondition())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCondition(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtIf_CONDITION_RoleHandler extends SingleHandler<CtIf, CtExpression<Boolean>> {\n\t\tprivate CtIf_CONDITION_RoleHandler() {\n\t\t\tsuper(CtRole.CONDITION, CtIf.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCondition())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCondition(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtClass_CONSTRUCTOR_RoleHandler extends SetHandler<CtClass, CtConstructor<?>> {\n\t\tprivate CtClass_CONSTRUCTOR_RoleHandler() {\n\t\t\tsuper(CtRole.CONSTRUCTOR, CtClass.class, CtConstructor.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getConstructors())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setConstructors(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackage_CONTAINED_TYPE_RoleHandler extends SetHandler<CtPackage, CtType<? extends Object>> {\n\t\tprivate CtPackage_CONTAINED_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.CONTAINED_TYPE, CtPackage.class, CtType.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTypes())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTypes(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_DECLARED_IMPORT_RoleHandler extends ListHandler<CtCompilationUnit, CtImport> {\n\t\tprivate CtCompilationUnit_DECLARED_IMPORT_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARED_IMPORT, CtCompilationUnit.class, CtImport.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getImports())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setImports(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_DECLARED_MODULE_RoleHandler extends SingleHandler<CtCompilationUnit, CtModule> {\n\t\tprivate CtCompilationUnit_DECLARED_MODULE_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARED_MODULE, CtCompilationUnit.class, CtModule.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaredModule())));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_DECLARED_MODULE_REF_RoleHandler extends SingleHandler<CtCompilationUnit, CtModuleReference> {\n\t\tprivate CtCompilationUnit_DECLARED_MODULE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARED_MODULE_REF, CtCompilationUnit.class, CtModuleReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaredModuleReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDeclaredModuleReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_DECLARED_TYPE_RoleHandler extends ListHandler<CtCompilationUnit, CtType<? extends Object>> {\n\t\tprivate CtCompilationUnit_DECLARED_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARED_TYPE, CtCompilationUnit.class, CtType.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaredTypes())));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_DECLARED_TYPE_REF_RoleHandler extends ListHandler<CtCompilationUnit, CtTypeReference<? extends Object>> {\n\t\tprivate CtCompilationUnit_DECLARED_TYPE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARED_TYPE_REF, CtCompilationUnit.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaredTypeReferences())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDeclaredTypeReferences(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutableReference_DECLARING_TYPE_RoleHandler extends SingleHandler<CtExecutableReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtExecutableReference_DECLARING_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARING_TYPE, CtExecutableReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaringType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDeclaringType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFieldReference_DECLARING_TYPE_RoleHandler extends SingleHandler<CtFieldReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtFieldReference_DECLARING_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARING_TYPE, CtFieldReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaringType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDeclaringType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeReference_DECLARING_TYPE_RoleHandler extends SingleHandler<CtTypeReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtTypeReference_DECLARING_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.DECLARING_TYPE, CtTypeReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDeclaringType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDeclaringType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAnnotationMethod_DEFAULT_EXPRESSION_RoleHandler extends SingleHandler<CtAnnotationMethod, CtExpression<?>> {\n\t\tprivate CtAnnotationMethod_DEFAULT_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.DEFAULT_EXPRESSION, CtAnnotationMethod.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDefaultExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDefaultExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtVariable_DEFAULT_EXPRESSION_RoleHandler extends SingleHandler<CtVariable, CtExpression<?>> {\n\t\tprivate CtVariable_DEFAULT_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.DEFAULT_EXPRESSION, CtVariable.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDefaultExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDefaultExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtNewArray_DIMENSION_RoleHandler extends ListHandler<CtNewArray, CtExpression<Integer>> {\n\t\tprivate CtNewArray_DIMENSION_RoleHandler() {\n\t\t\tsuper(CtRole.DIMENSION, CtNewArray.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getDimensionExpressions())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDimensionExpressions(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtJavaDocTag_DOCUMENTATION_TYPE_RoleHandler extends SingleHandler<CtJavaDocTag, CtJavaDocTag.TagType> {\n\t\tprivate CtJavaDocTag_DOCUMENTATION_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.DOCUMENTATION_TYPE, CtJavaDocTag.class, CtJavaDocTag.TagType.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtConditional_ELSE_RoleHandler extends SingleHandler<CtConditional, CtExpression<?>> {\n\t\tprivate CtConditional_ELSE_RoleHandler() {\n\t\t\tsuper(CtRole.ELSE, CtConditional.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getElseExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setElseExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtIf_ELSE_RoleHandler extends SingleHandler<CtIf, CtStatement> {\n\t\tprivate CtIf_ELSE_RoleHandler() {\n\t\t\tsuper(CtRole.ELSE, CtIf.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getElseStatement())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setElseStatement(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAbstractInvocation_EXECUTABLE_REF_RoleHandler extends SingleHandler<CtAbstractInvocation, CtExecutableReference<?>> {\n\t\tprivate CtAbstractInvocation_EXECUTABLE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.EXECUTABLE_REF, CtAbstractInvocation.class, CtExecutableReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExecutable())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExecutable(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutableReferenceExpression_EXECUTABLE_REF_RoleHandler extends SingleHandler<CtExecutableReferenceExpression, CtExecutableReference<?>> {\n\t\tprivate CtExecutableReferenceExpression_EXECUTABLE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.EXECUTABLE_REF, CtExecutableReferenceExpression.class, CtExecutableReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExecutable())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExecutable(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_EXPORTED_PACKAGE_RoleHandler extends ListHandler<CtModule, CtPackageExport> {\n\t\tprivate CtModule_EXPORTED_PACKAGE_RoleHandler() {\n\t\t\tsuper(CtRole.EXPORTED_PACKAGE, CtModule.class, CtPackageExport.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExportedPackages())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExportedPackages(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtArrayAccess_EXPRESSION_RoleHandler extends SingleHandler<CtArrayAccess, CtExpression<Integer>> {\n\t\tprivate CtArrayAccess_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtArrayAccess.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getIndexExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setIndexExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAssert_EXPRESSION_RoleHandler extends SingleHandler<CtAssert, CtExpression<?>> {\n\t\tprivate CtAssert_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtAssert.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCase_EXPRESSION_RoleHandler extends SingleHandler<CtCase, CtExpression<?>> {\n\t\tprivate CtCase_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtCase.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getCaseExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setCaseExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtDo_EXPRESSION_RoleHandler extends SingleHandler<CtDo, CtExpression<Boolean>> {\n\t\tprivate CtDo_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtDo.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getLoopingExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setLoopingExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFor_EXPRESSION_RoleHandler extends SingleHandler<CtFor, CtExpression<Boolean>> {\n\t\tprivate CtFor_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtFor.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtForEach_EXPRESSION_RoleHandler extends SingleHandler<CtForEach, CtExpression<? extends Object>> {\n\t\tprivate CtForEach_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtForEach.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtLambda_EXPRESSION_RoleHandler extends SingleHandler<CtLambda, CtExpression<?>> {\n\t\tprivate CtLambda_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtLambda.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtNewArray_EXPRESSION_RoleHandler extends ListHandler<CtNewArray, CtExpression<? extends Object>> {\n\t\tprivate CtNewArray_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtNewArray.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getElements())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setElements(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtReturn_EXPRESSION_RoleHandler extends SingleHandler<CtReturn, CtExpression<?>> {\n\t\tprivate CtReturn_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtReturn.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getReturnedExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setReturnedExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtSwitch_EXPRESSION_RoleHandler extends SingleHandler<CtSwitch, CtExpression<?>> {\n\t\tprivate CtSwitch_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtSwitch.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSelector())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setSelector(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtSynchronized_EXPRESSION_RoleHandler extends SingleHandler<CtSynchronized, CtExpression<? extends Object>> {\n\t\tprivate CtSynchronized_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtSynchronized.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtThrow_EXPRESSION_RoleHandler extends SingleHandler<CtThrow, CtExpression<? extends Throwable>> {\n\t\tprivate CtThrow_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtThrow.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getThrownExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setThrownExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtUnaryOperator_EXPRESSION_RoleHandler extends SingleHandler<CtUnaryOperator, CtExpression<?>> {\n\t\tprivate CtUnaryOperator_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtUnaryOperator.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getOperand())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setOperand(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtWhile_EXPRESSION_RoleHandler extends SingleHandler<CtWhile, CtExpression<Boolean>> {\n\t\tprivate CtWhile_EXPRESSION_RoleHandler() {\n\t\t\tsuper(CtRole.EXPRESSION, CtWhile.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getLoopingExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setLoopingExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_FIELD_RoleHandler extends ListHandler<CtType, CtField<? extends Object>> {\n\t\tprivate CtType_FIELD_RoleHandler() {\n\t\t\tsuper(CtRole.FIELD, CtType.class, CtField.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getFields())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setFields(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTry_FINALIZER_RoleHandler extends SingleHandler<CtTry, CtBlock<? extends Object>> {\n\t\tprivate CtTry_FINALIZER_RoleHandler() {\n\t\t\tsuper(CtRole.FINALIZER, CtTry.class, CtBlock.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getFinalizer())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setFinalizer(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtForEach_FOREACH_VARIABLE_RoleHandler extends SingleHandler<CtForEach, CtLocalVariable<? extends Object>> {\n\t\tprivate CtForEach_FOREACH_VARIABLE_RoleHandler() {\n\t\t\tsuper(CtRole.FOREACH_VARIABLE, CtForEach.class, CtLocalVariable.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getVariable())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setVariable(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFor_FOR_INIT_RoleHandler extends ListHandler<CtFor, CtStatement> {\n\t\tprivate CtFor_FOR_INIT_RoleHandler() {\n\t\t\tsuper(CtRole.FOR_INIT, CtFor.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getForInit())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setForInit(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFor_FOR_UPDATE_RoleHandler extends ListHandler<CtFor, CtStatement> {\n\t\tprivate CtFor_FOR_UPDATE_RoleHandler() {\n\t\t\tsuper(CtRole.FOR_UPDATE, CtFor.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getForUpdate())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setForUpdate(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtProvidedService_IMPLEMENTATION_TYPE_RoleHandler extends ListHandler<CtProvidedService, CtTypeReference> {\n\t\tprivate CtProvidedService_IMPLEMENTATION_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.IMPLEMENTATION_TYPE, CtProvidedService.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getImplementationTypes())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setImplementationTypes(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtImport_IMPORT_REFERENCE_RoleHandler extends SingleHandler<CtImport, CtReference> {\n\t\tprivate CtImport_IMPORT_REFERENCE_RoleHandler() {\n\t\t\tsuper(CtRole.IMPORT_REFERENCE, CtImport.class, CtReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_INTERFACE_RoleHandler extends SetHandler<CtType, CtTypeReference<? extends Object>> {\n\t\tprivate CtType_INTERFACE_RoleHandler() {\n\t\t\tsuper(CtRole.INTERFACE, CtType.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSuperInterfaces())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setSuperInterfaces(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeInformation_INTERFACE_RoleHandler extends SetHandler<CtTypeInformation, CtTypeReference<?>> {\n\t\tprivate CtTypeInformation_INTERFACE_RoleHandler() {\n\t\t\tsuper(CtRole.INTERFACE, CtTypeInformation.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSuperInterfaces())));\n\t\t}\n\t}\n\n\tstatic class CtMethod_IS_DEFAULT_RoleHandler extends SingleHandler<CtMethod, Boolean> {\n\t\tprivate CtMethod_IS_DEFAULT_RoleHandler() {\n\t\t\tsuper(CtRole.IS_DEFAULT, CtMethod.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isDefaultMethod())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setDefaultMethod(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFieldReference_IS_FINAL_RoleHandler extends SingleHandler<CtFieldReference, Boolean> {\n\t\tprivate CtFieldReference_IS_FINAL_RoleHandler() {\n\t\t\tsuper(CtRole.IS_FINAL, CtFieldReference.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isFinal())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setFinal(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtElement_IS_IMPLICIT_RoleHandler extends SingleHandler<CtElement, Boolean> {\n\t\tprivate CtElement_IS_IMPLICIT_RoleHandler() {\n\t\t\tsuper(CtRole.IS_IMPLICIT, CtElement.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isImplicit())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setImplicit(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtLocalVariable_IS_INFERRED_RoleHandler extends SingleHandler<CtLocalVariable, Boolean> {\n\t\tprivate CtLocalVariable_IS_INFERRED_RoleHandler() {\n\t\t\tsuper(CtRole.IS_INFERRED, CtLocalVariable.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isInferred())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setInferred(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtShadowable_IS_SHADOW_RoleHandler extends SingleHandler<CtShadowable, Boolean> {\n\t\tprivate CtShadowable_IS_SHADOW_RoleHandler() {\n\t\t\tsuper(CtRole.IS_SHADOW, CtShadowable.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isShadow())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setShadow(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutableReference_IS_STATIC_RoleHandler extends SingleHandler<CtExecutableReference, Boolean> {\n\t\tprivate CtExecutableReference_IS_STATIC_RoleHandler() {\n\t\t\tsuper(CtRole.IS_STATIC, CtExecutableReference.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isStatic())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setStatic(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFieldReference_IS_STATIC_RoleHandler extends SingleHandler<CtFieldReference, Boolean> {\n\t\tprivate CtFieldReference_IS_STATIC_RoleHandler() {\n\t\t\tsuper(CtRole.IS_STATIC, CtFieldReference.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isStatic())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setStatic(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtWildcardReference_IS_UPPER_RoleHandler extends SingleHandler<CtWildcardReference, Boolean> {\n\t\tprivate CtWildcardReference_IS_UPPER_RoleHandler() {\n\t\t\tsuper(CtRole.IS_UPPER, CtWildcardReference.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isUpper())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setUpper(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtParameter_IS_VARARGS_RoleHandler extends SingleHandler<CtParameter, Boolean> {\n\t\tprivate CtParameter_IS_VARARGS_RoleHandler() {\n\t\t\tsuper(CtRole.IS_VARARGS, CtParameter.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isVarArgs())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setVarArgs(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtJavaDocTag_JAVADOC_TAG_VALUE_RoleHandler extends SingleHandler<CtJavaDocTag, String> {\n\t\tprivate CtJavaDocTag_JAVADOC_TAG_VALUE_RoleHandler() {\n\t\t\tsuper(CtRole.JAVADOC_TAG_VALUE, CtJavaDocTag.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getParam())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setParam(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtStatement_LABEL_RoleHandler extends SingleHandler<CtStatement, String> {\n\t\tprivate CtStatement_LABEL_RoleHandler() {\n\t\t\tsuper(CtRole.LABEL, CtStatement.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getLabel())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setLabel(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtBinaryOperator_LEFT_OPERAND_RoleHandler extends SingleHandler<CtBinaryOperator, CtExpression<? extends Object>> {\n\t\tprivate CtBinaryOperator_LEFT_OPERAND_RoleHandler() {\n\t\t\tsuper(CtRole.LEFT_OPERAND, CtBinaryOperator.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getLeftHandOperand())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setLeftHandOperand(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_METHOD_RoleHandler extends SetHandler<CtType, CtMethod<? extends Object>> {\n\t\tprivate CtType_METHOD_RoleHandler() {\n\t\t\tsuper(CtRole.METHOD, CtType.class, CtMethod.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getMethods())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setMethods(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModifiable_MODIFIER_RoleHandler extends SetHandler<CtModifiable, ModifierKind> {\n\t\tprivate CtModifiable_MODIFIER_RoleHandler() {\n\t\t\tsuper(CtRole.MODIFIER, CtModifiable.class, ModifierKind.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getModifiers())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setModifiers(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_MODIFIER_RoleHandler extends SingleHandler<CtModule, Boolean> {\n\t\tprivate CtModule_MODIFIER_RoleHandler() {\n\t\t\tsuper(CtRole.MODIFIER, CtModule.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isOpenModule())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setIsOpenModule(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModuleRequirement_MODIFIER_RoleHandler extends SetHandler<CtModuleRequirement, CtModuleRequirement.RequiresModifier> {\n\t\tprivate CtModuleRequirement_MODIFIER_RoleHandler() {\n\t\t\tsuper(CtRole.MODIFIER, CtModuleRequirement.class, CtModuleRequirement.RequiresModifier.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getRequiresModifiers())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setRequiresModifiers(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeInformation_MODIFIER_RoleHandler extends SetHandler<CtTypeInformation, ModifierKind> {\n\t\tprivate CtTypeInformation_MODIFIER_RoleHandler() {\n\t\t\tsuper(CtRole.MODIFIER, CtTypeInformation.class, ModifierKind.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getModifiers())));\n\t\t}\n\t}\n\n\tstatic class CtModule_MODULE_DIRECTIVE_RoleHandler extends ListHandler<CtModule, CtModuleDirective> {\n\t\tprivate CtModule_MODULE_DIRECTIVE_RoleHandler() {\n\t\t\tsuper(CtRole.MODULE_DIRECTIVE, CtModule.class, CtModuleDirective.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getModuleDirectives())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setModuleDirectives(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModuleRequirement_MODULE_REF_RoleHandler extends SingleHandler<CtModuleRequirement, CtModuleReference> {\n\t\tprivate CtModuleRequirement_MODULE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.MODULE_REF, CtModuleRequirement.class, CtModuleReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getModuleReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setModuleReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackageExport_MODULE_REF_RoleHandler extends ListHandler<CtPackageExport, CtModuleReference> {\n\t\tprivate CtPackageExport_MODULE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.MODULE_REF, CtPackageExport.class, CtModuleReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTargetExport())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTargetExport(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtMultiTypedElement_MULTI_TYPE_RoleHandler extends ListHandler<CtMultiTypedElement, CtTypeReference<?>> {\n\t\tprivate CtMultiTypedElement_MULTI_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.MULTI_TYPE, CtMultiTypedElement.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getMultiTypes())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setMultiTypes(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtNamedElement_NAME_RoleHandler extends SingleHandler<CtNamedElement, String> {\n\t\tprivate CtNamedElement_NAME_RoleHandler() {\n\t\t\tsuper(CtRole.NAME, CtNamedElement.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSimpleName())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setSimpleName(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtReference_NAME_RoleHandler extends SingleHandler<CtReference, String> {\n\t\tprivate CtReference_NAME_RoleHandler() {\n\t\t\tsuper(CtRole.NAME, CtReference.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSimpleName())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setSimpleName(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtNewClass_NESTED_TYPE_RoleHandler extends SingleHandler<CtNewClass, CtClass<? extends Object>> {\n\t\tprivate CtNewClass_NESTED_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.NESTED_TYPE, CtNewClass.class, CtClass.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getAnonymousClass())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setAnonymousClass(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_NESTED_TYPE_RoleHandler extends SetHandler<CtType, CtType<? extends Object>> {\n\t\tprivate CtType_NESTED_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.NESTED_TYPE, CtType.class, CtType.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getNestedTypes())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setNestedTypes(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_OPENED_PACKAGE_RoleHandler extends ListHandler<CtModule, CtPackageExport> {\n\t\tprivate CtModule_OPENED_PACKAGE_RoleHandler() {\n\t\t\tsuper(CtRole.OPENED_PACKAGE, CtModule.class, CtPackageExport.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getOpenedPackages())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setOpenedPackages(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackageExport_OPENED_PACKAGE_RoleHandler extends SingleHandler<CtPackageExport, Boolean> {\n\t\tprivate CtPackageExport_OPENED_PACKAGE_RoleHandler() {\n\t\t\tsuper(CtRole.OPENED_PACKAGE, CtPackageExport.class, Boolean.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).isOpenedPackage())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setOpenedPackage(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtBinaryOperator_OPERATOR_KIND_RoleHandler extends SingleHandler<CtBinaryOperator, BinaryOperatorKind> {\n\t\tprivate CtBinaryOperator_OPERATOR_KIND_RoleHandler() {\n\t\t\tsuper(CtRole.OPERATOR_KIND, CtBinaryOperator.class, BinaryOperatorKind.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getKind())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setKind(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtOperatorAssignment_OPERATOR_KIND_RoleHandler extends SingleHandler<CtOperatorAssignment, BinaryOperatorKind> {\n\t\tprivate CtOperatorAssignment_OPERATOR_KIND_RoleHandler() {\n\t\t\tsuper(CtRole.OPERATOR_KIND, CtOperatorAssignment.class, BinaryOperatorKind.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getKind())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setKind(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtUnaryOperator_OPERATOR_KIND_RoleHandler extends SingleHandler<CtUnaryOperator, UnaryOperatorKind> {\n\t\tprivate CtUnaryOperator_OPERATOR_KIND_RoleHandler() {\n\t\t\tsuper(CtRole.OPERATOR_KIND, CtUnaryOperator.class, UnaryOperatorKind.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getKind())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setKind(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCompilationUnit_PACKAGE_DECLARATION_RoleHandler extends SingleHandler<CtCompilationUnit, CtPackageDeclaration> {\n\t\tprivate CtCompilationUnit_PACKAGE_DECLARATION_RoleHandler() {\n\t\t\tsuper(CtRole.PACKAGE_DECLARATION, CtCompilationUnit.class, CtPackageDeclaration.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getPackageDeclaration())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setPackageDeclaration(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackageDeclaration_PACKAGE_REF_RoleHandler extends SingleHandler<CtPackageDeclaration, CtPackageReference> {\n\t\tprivate CtPackageDeclaration_PACKAGE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.PACKAGE_REF, CtPackageDeclaration.class, CtPackageReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackageExport_PACKAGE_REF_RoleHandler extends SingleHandler<CtPackageExport, CtPackageReference> {\n\t\tprivate CtPackageExport_PACKAGE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.PACKAGE_REF, CtPackageExport.class, CtPackageReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getPackageReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setPackageReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeReference_PACKAGE_REF_RoleHandler extends SingleHandler<CtTypeReference, CtPackageReference> {\n\t\tprivate CtTypeReference_PACKAGE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.PACKAGE_REF, CtTypeReference.class, CtPackageReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getPackage())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setPackage(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCatch_PARAMETER_RoleHandler extends SingleHandler<CtCatch, CtCatchVariable<? extends Throwable>> {\n\t\tprivate CtCatch_PARAMETER_RoleHandler() {\n\t\t\tsuper(CtRole.PARAMETER, CtCatch.class, CtCatchVariable.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getParameter())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setParameter(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutable_PARAMETER_RoleHandler extends ListHandler<CtExecutable, CtParameter<? extends Object>> {\n\t\tprivate CtExecutable_PARAMETER_RoleHandler() {\n\t\t\tsuper(CtRole.PARAMETER, CtExecutable.class, CtParameter.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getParameters())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setParameters(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtElement_POSITION_RoleHandler extends SingleHandler<CtElement, SourcePosition> {\n\t\tprivate CtElement_POSITION_RoleHandler() {\n\t\t\tsuper(CtRole.POSITION, CtElement.class, SourcePosition.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getPosition())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setPosition(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_PROVIDED_SERVICE_RoleHandler extends ListHandler<CtModule, CtProvidedService> {\n\t\tprivate CtModule_PROVIDED_SERVICE_RoleHandler() {\n\t\t\tsuper(CtRole.PROVIDED_SERVICE, CtModule.class, CtProvidedService.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getProvidedServices())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setProvidedServices(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_REQUIRED_MODULE_RoleHandler extends ListHandler<CtModule, CtModuleRequirement> {\n\t\tprivate CtModule_REQUIRED_MODULE_RoleHandler() {\n\t\t\tsuper(CtRole.REQUIRED_MODULE, CtModule.class, CtModuleRequirement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getRequiredModules())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setRequiredModules(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtBinaryOperator_RIGHT_OPERAND_RoleHandler extends SingleHandler<CtBinaryOperator, CtExpression<? extends Object>> {\n\t\tprivate CtBinaryOperator_RIGHT_OPERAND_RoleHandler() {\n\t\t\tsuper(CtRole.RIGHT_OPERAND, CtBinaryOperator.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getRightHandOperand())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setRightHandOperand(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_SERVICE_TYPE_RoleHandler extends ListHandler<CtModule, CtUsedService> {\n\t\tprivate CtModule_SERVICE_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.SERVICE_TYPE, CtModule.class, CtUsedService.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getUsedServices())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setUsedServices(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtProvidedService_SERVICE_TYPE_RoleHandler extends SingleHandler<CtProvidedService, CtTypeReference> {\n\t\tprivate CtProvidedService_SERVICE_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.SERVICE_TYPE, CtProvidedService.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getServiceType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setServiceType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtUsedService_SERVICE_TYPE_RoleHandler extends SingleHandler<CtUsedService, CtTypeReference> {\n\t\tprivate CtUsedService_SERVICE_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.SERVICE_TYPE, CtUsedService.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getServiceType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setServiceType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtCodeSnippet_SNIPPET_RoleHandler extends SingleHandler<CtCodeSnippet, String> {\n\t\tprivate CtCodeSnippet_SNIPPET_RoleHandler() {\n\t\t\tsuper(CtRole.SNIPPET, CtCodeSnippet.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getValue())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setValue(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtStatementList_STATEMENT_RoleHandler extends ListHandler<CtStatementList, CtStatement> {\n\t\tprivate CtStatementList_STATEMENT_RoleHandler() {\n\t\t\tsuper(CtRole.STATEMENT, CtStatementList.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getStatements())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setStatements(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtModule_SUB_PACKAGE_RoleHandler extends SingleHandler<CtModule, CtPackage> {\n\t\tprivate CtModule_SUB_PACKAGE_RoleHandler() {\n\t\t\tsuper(CtRole.SUB_PACKAGE, CtModule.class, CtPackage.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getRootPackage())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setRootPackage(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtPackage_SUB_PACKAGE_RoleHandler extends SetHandler<CtPackage, CtPackage> {\n\t\tprivate CtPackage_SUB_PACKAGE_RoleHandler() {\n\t\t\tsuper(CtRole.SUB_PACKAGE, CtPackage.class, CtPackage.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getPackages())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setPackages(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_SUPER_TYPE_RoleHandler extends SingleHandler<CtType, CtTypeReference<? extends Object>> {\n\t\tprivate CtType_SUPER_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.SUPER_TYPE, CtType.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSuperclass())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setSuperclass(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeInformation_SUPER_TYPE_RoleHandler extends SingleHandler<CtTypeInformation, CtTypeReference<?>> {\n\t\tprivate CtTypeInformation_SUPER_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.SUPER_TYPE, CtTypeInformation.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getSuperclass())));\n\t\t}\n\t}\n\n\tstatic class CtTargetedExpression_TARGET_RoleHandler extends SingleHandler<CtTargetedExpression, CtExpression<?>> {\n\t\tprivate CtTargetedExpression_TARGET_RoleHandler() {\n\t\t\tsuper(CtRole.TARGET, CtTargetedExpression.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTarget())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTarget(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtLabelledFlowBreak_TARGET_LABEL_RoleHandler extends SingleHandler<CtLabelledFlowBreak, String> {\n\t\tprivate CtLabelledFlowBreak_TARGET_LABEL_RoleHandler() {\n\t\t\tsuper(CtRole.TARGET_LABEL, CtLabelledFlowBreak.class, String.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTargetLabel())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTargetLabel(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtConditional_THEN_RoleHandler extends SingleHandler<CtConditional, CtExpression<?>> {\n\t\tprivate CtConditional_THEN_RoleHandler() {\n\t\t\tsuper(CtRole.THEN, CtConditional.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getThenExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setThenExpression(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtIf_THEN_RoleHandler extends SingleHandler<CtIf, CtStatement> {\n\t\tprivate CtIf_THEN_RoleHandler() {\n\t\t\tsuper(CtRole.THEN, CtIf.class, CtStatement.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getThenStatement())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setThenStatement(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutable_THROWN_RoleHandler extends SetHandler<CtExecutable, CtTypeReference<? extends Throwable>> {\n\t\tprivate CtExecutable_THROWN_RoleHandler() {\n\t\t\tsuper(CtRole.THROWN, CtExecutable.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getThrownTypes())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setThrownTypes(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTryWithResource_TRY_RESOURCE_RoleHandler extends ListHandler<CtTryWithResource, CtLocalVariable<? extends Object>> {\n\t\tprivate CtTryWithResource_TRY_RESOURCE_RoleHandler() {\n\t\t\tsuper(CtRole.TRY_RESOURCE, CtTryWithResource.class, CtLocalVariable.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getResources())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setResources(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtArrayTypeReference_TYPE_RoleHandler extends SingleHandler<CtArrayTypeReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtArrayTypeReference_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE, CtArrayTypeReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getComponentType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setComponentType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtExecutableReference_TYPE_RoleHandler extends SingleHandler<CtExecutableReference, CtTypeReference<?>> {\n\t\tprivate CtExecutableReference_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE, CtExecutableReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypedElement_TYPE_RoleHandler extends SingleHandler<CtTypedElement, CtTypeReference<?>> {\n\t\tprivate CtTypedElement_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE, CtTypedElement.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtVariableReference_TYPE_RoleHandler extends SingleHandler<CtVariableReference, CtTypeReference<?>> {\n\t\tprivate CtVariableReference_TYPE_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE, CtVariableReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getType())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setType(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtActualTypeContainer_TYPE_ARGUMENT_RoleHandler extends ListHandler<CtActualTypeContainer, CtTypeReference<?>> {\n\t\tprivate CtActualTypeContainer_TYPE_ARGUMENT_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE_ARGUMENT, CtActualTypeContainer.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getActualTypeArguments())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setActualTypeArguments(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtType_TYPE_MEMBER_RoleHandler extends ListHandler<CtType, CtTypeMember> {\n\t\tprivate CtType_TYPE_MEMBER_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE_MEMBER, CtType.class, CtTypeMember.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTypeMembers())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTypeMembers(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtFormalTypeDeclarer_TYPE_PARAMETER_RoleHandler extends ListHandler<CtFormalTypeDeclarer, CtTypeParameter> {\n\t\tprivate CtFormalTypeDeclarer_TYPE_PARAMETER_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE_PARAMETER, CtFormalTypeDeclarer.class, CtTypeParameter.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getFormalCtTypeParameters())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setFormalCtTypeParameters(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtTypeMemberWildcardImportReference_TYPE_REF_RoleHandler extends SingleHandler<CtTypeMemberWildcardImportReference, CtTypeReference<? extends Object>> {\n\t\tprivate CtTypeMemberWildcardImportReference_TYPE_REF_RoleHandler() {\n\t\t\tsuper(CtRole.TYPE_REF, CtTypeMemberWildcardImportReference.class, CtTypeReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getTypeReference())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setTypeReference(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtAnnotation_VALUE_RoleHandler extends MapHandler<CtAnnotation, CtExpression> {\n\t\tprivate CtAnnotation_VALUE_RoleHandler() {\n\t\t\tsuper(CtRole.VALUE, CtAnnotation.class, CtExpression.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getValues())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setValues(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtEnum_VALUE_RoleHandler extends ListHandler<CtEnum, CtEnumValue<? extends Object>> {\n\t\tprivate CtEnum_VALUE_RoleHandler() {\n\t\t\tsuper(CtRole.VALUE, CtEnum.class, CtEnumValue.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getEnumValues())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setEnumValues(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtLiteral_VALUE_RoleHandler extends SingleHandler<CtLiteral, Object> {\n\t\tprivate CtLiteral_VALUE_RoleHandler() {\n\t\t\tsuper(CtRole.VALUE, CtLiteral.class, Object.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getValue())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setValue(castValue(value));\n\t\t}\n\t}\n\n\tstatic class CtVariableAccess_VARIABLE_RoleHandler extends SingleHandler<CtVariableAccess, CtVariableReference<?>> {\n\t\tprivate CtVariableAccess_VARIABLE_RoleHandler() {\n\t\t\tsuper(CtRole.VARIABLE, CtVariableAccess.class, CtVariableReference.class);\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic <T, U> U getValue(T element) {\n\t\t\treturn ((U) ((Object) (castTarget(element).getVariable())));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, U> void setValue(T element, U value) {\n\t\t\tcastTarget(element).setVariable(castValue(value));\n\t\t}\n\t}\n\n\tprivate ModelRoleHandlers() {\n\t}\n\n\tstatic final RoleHandler[] roleHandlers = new RoleHandler[]{ new CtTypeAccess_ACCESSED_TYPE_RoleHandler(), new CtClass_ANNONYMOUS_EXECUTABLE_RoleHandler(), new CtElement_ANNOTATION_RoleHandler(), new CtAnnotation_ANNOTATION_TYPE_RoleHandler(), new CtAbstractInvocation_ARGUMENT_RoleHandler(), new CtExecutableReference_ARGUMENT_TYPE_RoleHandler(), new CtAssignment_ASSIGNED_RoleHandler(), new CtRHSReceiver_ASSIGNMENT_RoleHandler(), new CtBodyHolder_BODY_RoleHandler(), new CtSynchronized_BODY_RoleHandler(), new CtIntersectionTypeReference_BOUND_RoleHandler(), new CtWildcardReference_BOUNDING_TYPE_RoleHandler(), new CtSwitch_CASE_RoleHandler(), new CtExpression_CAST_RoleHandler(), new CtTry_CATCH_RoleHandler(), new CtElement_COMMENT_RoleHandler(), new CtComment_COMMENT_CONTENT_RoleHandler(), new CtJavaDocTag_COMMENT_CONTENT_RoleHandler(), new CtJavaDoc_COMMENT_TAG_RoleHandler(), new CtComment_COMMENT_TYPE_RoleHandler(), new CtAssert_CONDITION_RoleHandler(), new CtConditional_CONDITION_RoleHandler(), new CtIf_CONDITION_RoleHandler(), new CtClass_CONSTRUCTOR_RoleHandler(), new CtPackage_CONTAINED_TYPE_RoleHandler(), new CtCompilationUnit_DECLARED_IMPORT_RoleHandler(), new CtCompilationUnit_DECLARED_MODULE_RoleHandler(), new CtCompilationUnit_DECLARED_MODULE_REF_RoleHandler(), new CtCompilationUnit_DECLARED_TYPE_RoleHandler(), new CtCompilationUnit_DECLARED_TYPE_REF_RoleHandler(), new CtExecutableReference_DECLARING_TYPE_RoleHandler(), new CtFieldReference_DECLARING_TYPE_RoleHandler(), new CtTypeReference_DECLARING_TYPE_RoleHandler(), new CtAnnotationMethod_DEFAULT_EXPRESSION_RoleHandler(), new CtVariable_DEFAULT_EXPRESSION_RoleHandler(), new CtNewArray_DIMENSION_RoleHandler(), new CtJavaDocTag_DOCUMENTATION_TYPE_RoleHandler(), new CtConditional_ELSE_RoleHandler(), new CtIf_ELSE_RoleHandler(), new CtAbstractInvocation_EXECUTABLE_REF_RoleHandler(), new CtExecutableReferenceExpression_EXECUTABLE_REF_RoleHandler(), new CtModule_EXPORTED_PACKAGE_RoleHandler(), new CtArrayAccess_EXPRESSION_RoleHandler(), new CtAssert_EXPRESSION_RoleHandler(), new CtCase_EXPRESSION_RoleHandler(), new CtDo_EXPRESSION_RoleHandler(), new CtFor_EXPRESSION_RoleHandler(), new CtForEach_EXPRESSION_RoleHandler(), new CtLambda_EXPRESSION_RoleHandler(), new CtNewArray_EXPRESSION_RoleHandler(), new CtReturn_EXPRESSION_RoleHandler(), new CtSwitch_EXPRESSION_RoleHandler(), new CtSynchronized_EXPRESSION_RoleHandler(), new CtThrow_EXPRESSION_RoleHandler(), new CtUnaryOperator_EXPRESSION_RoleHandler(), new CtWhile_EXPRESSION_RoleHandler(), new CtType_FIELD_RoleHandler(), new CtTry_FINALIZER_RoleHandler(), new CtForEach_FOREACH_VARIABLE_RoleHandler(), new CtFor_FOR_INIT_RoleHandler(), new CtFor_FOR_UPDATE_RoleHandler(), new CtProvidedService_IMPLEMENTATION_TYPE_RoleHandler(), new CtImport_IMPORT_REFERENCE_RoleHandler(), new CtType_INTERFACE_RoleHandler(), new CtTypeInformation_INTERFACE_RoleHandler(), new CtMethod_IS_DEFAULT_RoleHandler(), new CtFieldReference_IS_FINAL_RoleHandler(), new CtElement_IS_IMPLICIT_RoleHandler(), new CtLocalVariable_IS_INFERRED_RoleHandler(), new CtShadowable_IS_SHADOW_RoleHandler(), new CtExecutableReference_IS_STATIC_RoleHandler(), new CtFieldReference_IS_STATIC_RoleHandler(), new CtWildcardReference_IS_UPPER_RoleHandler(), new CtParameter_IS_VARARGS_RoleHandler(), new CtJavaDocTag_JAVADOC_TAG_VALUE_RoleHandler(), new CtStatement_LABEL_RoleHandler(), new CtBinaryOperator_LEFT_OPERAND_RoleHandler(), new CtType_METHOD_RoleHandler(), new CtModifiable_MODIFIER_RoleHandler(), new CtModule_MODIFIER_RoleHandler(), new CtModuleRequirement_MODIFIER_RoleHandler(), new CtTypeInformation_MODIFIER_RoleHandler(), new CtModule_MODULE_DIRECTIVE_RoleHandler(), new CtModuleRequirement_MODULE_REF_RoleHandler(), new CtPackageExport_MODULE_REF_RoleHandler(), new CtMultiTypedElement_MULTI_TYPE_RoleHandler(), new CtNamedElement_NAME_RoleHandler(), new CtReference_NAME_RoleHandler(), new CtNewClass_NESTED_TYPE_RoleHandler(), new CtType_NESTED_TYPE_RoleHandler(), new CtModule_OPENED_PACKAGE_RoleHandler(), new CtPackageExport_OPENED_PACKAGE_RoleHandler(), new CtBinaryOperator_OPERATOR_KIND_RoleHandler(), new CtOperatorAssignment_OPERATOR_KIND_RoleHandler(), new CtUnaryOperator_OPERATOR_KIND_RoleHandler(), new CtCompilationUnit_PACKAGE_DECLARATION_RoleHandler(), new CtPackageDeclaration_PACKAGE_REF_RoleHandler(), new CtPackageExport_PACKAGE_REF_RoleHandler(), new CtTypeReference_PACKAGE_REF_RoleHandler(), new CtCatch_PARAMETER_RoleHandler(), new CtExecutable_PARAMETER_RoleHandler(), new CtElement_POSITION_RoleHandler(), new CtModule_PROVIDED_SERVICE_RoleHandler(), new CtModule_REQUIRED_MODULE_RoleHandler(), new CtBinaryOperator_RIGHT_OPERAND_RoleHandler(), new CtModule_SERVICE_TYPE_RoleHandler(), new CtProvidedService_SERVICE_TYPE_RoleHandler(), new CtUsedService_SERVICE_TYPE_RoleHandler(), new CtCodeSnippet_SNIPPET_RoleHandler(), new CtStatementList_STATEMENT_RoleHandler(), new CtModule_SUB_PACKAGE_RoleHandler(), new CtPackage_SUB_PACKAGE_RoleHandler(), new CtType_SUPER_TYPE_RoleHandler(), new CtTypeInformation_SUPER_TYPE_RoleHandler(), new CtTargetedExpression_TARGET_RoleHandler(), new CtLabelledFlowBreak_TARGET_LABEL_RoleHandler(), new CtConditional_THEN_RoleHandler(), new CtIf_THEN_RoleHandler(), new CtExecutable_THROWN_RoleHandler(), new CtTryWithResource_TRY_RESOURCE_RoleHandler(), new CtArrayTypeReference_TYPE_RoleHandler(), new CtExecutableReference_TYPE_RoleHandler(), new CtTypedElement_TYPE_RoleHandler(), new CtVariableReference_TYPE_RoleHandler(), new CtActualTypeContainer_TYPE_ARGUMENT_RoleHandler(), new CtType_TYPE_MEMBER_RoleHandler(), new CtFormalTypeDeclarer_TYPE_PARAMETER_RoleHandler(), new CtTypeMemberWildcardImportReference_TYPE_REF_RoleHandler(), new CtAnnotation_VALUE_RoleHandler(), new CtEnum_VALUE_RoleHandler(), new CtLiteral_VALUE_RoleHandler(), new CtVariableAccess_VARIABLE_RoleHandler() };\n}\n\n"
    }, {
      "name" : "reflect/meta/impl/SetHandler.java",
      "weight" : 80.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * implementation of {@link RoleHandler}, which handles attributes of type Set&lt;V&gt;\n * @param <T> the type of node whose attribute has to be manipulated\n * @param <V> the type of item value of the attribute\n */\nabstract class SetHandler<T, V> extends AbstractRoleHandler<T, Set<V>, V> {\n\n\tprotected SetHandler(CtRole role, Class<T> targetType, Class<?> valueClass) {\n\t\tsuper(role, targetType, valueClass);\n\t}\n\n\t@Override\n\tpublic ContainerKind getContainerKind() {\n\t\treturn ContainerKind.SET;\n\t}\n\n\t@Override\n\tprotected Set<V> castValue(Object value) {\n\t\tSet<V> set = super.castValue(value);\n\t\t//check that each item has expected class\n\t\tcheckItemsClass(set);\n\t\treturn set;\n\t}\n\n\t@Override\n\tpublic <W, X> Collection<X> asCollection(W element) {\n\t\treturn asSet(element);\n\t}\n\n\t@Override\n\tpublic <W, X> Set<X> asSet(W e) {\n\t\treturn new AbstractSet<X>() {\n\t\t\tT element = castTarget(e);\n\n\t\t\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t\t\t@Override\n\t\t\tpublic Iterator<X> iterator() {\n\t\t\t\treturn (Iterator) SetHandler.this.iterator(element);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn SetHandler.this.size(element);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean contains(Object o) {\n\t\t\t\treturn SetHandler.this.contains(element, o);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean add(X value) {\n\t\t\t\treturn SetHandler.this.add(element, castItemValue(value));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean remove(Object value) {\n\t\t\t\treturn SetHandler.this.remove(element, value);\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected boolean remove(T element, Object value) {\n\t\tSet<V> values = new HashSet<>(this.<T, Set<V>>getValue(element));\n\t\tboolean ret = values.remove(value);\n\t\tif (ret) {\n\t\t\tsetValue(element, values);\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected boolean add(T element, V value) {\n\t\tSet<V> values = new HashSet<>(this.<T, Set<V>>getValue(element));\n\t\tboolean ret = values.add(value);\n\t\tif (ret) {\n\t\t\tsetValue(element, values);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprotected boolean contains(T element, Object o) {\n\t\treturn this.<T, Set<V>>getValue(element).contains(o);\n\t}\n\n\tprotected int size(T element) {\n\t\treturn this.<T, Set<V>>getValue(element).size();\n\t}\n\n\tprotected Iterator<V> iterator(T element) {\n\t\treturn this.<T, Set<V>>getValue(element).iterator();\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/impl/MapHandler.java",
      "weight" : 62.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.AbstractMap;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * implementation of {@link RoleHandler}, which handles attributes of type Map&lt;String, V&gt;\n * @param <T> the type of node whose attribute has to be manipulated\n * @param <V> the type of item value of the attribute\n */\nabstract class MapHandler<T, V> extends AbstractRoleHandler<T, Map<String, V>, V> {\n\n\tprotected MapHandler(CtRole role, Class<T> targetType, Class<?> valueClass) {\n\t\tsuper(role, targetType, valueClass);\n\t}\n\n\t@Override\n\tpublic ContainerKind getContainerKind() {\n\t\treturn ContainerKind.MAP;\n\t}\n\n\t@Override\n\tprotected Map<String, V> castValue(Object value) {\n\t\tMap<String, V> map = super.castValue(value);\n\t\t//check that each item has expected class\n\t\tcheckItemsClass(map.values());\n\t\treturn map;\n\t}\n\n\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic <W, X> java.util.Collection<X> asCollection(W element) {\n\t\treturn (Collection) asMap(element).values();\n\t}\n\n\t@Override\n\tpublic <W, X> Map<String, X> asMap(W e) {\n\t\t// TODO Auto-generated method stub\n\t\treturn new AbstractMap<String, X>() {\n\t\t\tT element = castTarget(e);\n\n\t\t\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t\t\t@Override\n\t\t\tpublic Set<Map.Entry<String, X>> entrySet() {\n\t\t\t\treturn (Set) MapHandler.this.entrySet(element);\n\t\t\t}\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic X get(Object key) {\n\t\t\t\treturn (X) MapHandler.this.get(element, key);\n\t\t\t}\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic X put(String key, X value) {\n\t\t\t\treturn (X) MapHandler.this.put(element, key, castItemValue(value));\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected V get(T element, Object key) {\n\t\treturn this.<T, Map<String, V>>getValue(element).get(key);\n\t}\n\n\tprotected V put(T element, String key, V value) {\n\t\tMap<String, V> values = new LinkedHashMap<>(this.<T, Map<String, V>>getValue(element));\n\t\tV ret = values.put(key, value);\n\t\tsetValue(element, values);\n\t\treturn ret;\n\t}\n\n\tprotected Set<Map.Entry<String, V>> entrySet(T element) {\n\t\treturn this.<T, Map<String, V>>getValue(element).entrySet();\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/impl/RoleHandlerHelper.java",
      "weight" : 80.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * Provides a {@link RoleHandler} implementation for the pair of {@link CtElement} implementation and {@link CtRole}\n * The returned {@link RoleHandler} can be then used to manipulate value of attribute represented by {@link CtRole} on the {@link CtElement} instance\n */\npublic class RoleHandlerHelper {\n\tprivate RoleHandlerHelper() {\n\t}\n\n\tprivate static Map<Class<?>, List<RoleHandler>> roleHandlersByClass = new HashMap<>();\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static final List<RoleHandler>[] roleHandlers = new List[CtRole.values().length];\n\tstatic {\n\t\tfor (int i = 0; i < roleHandlers.length; i++) {\n\t\t\troleHandlers[i] = new ArrayList<>();\n\t\t}\n\t\tfor (RoleHandler rh : ModelRoleHandlers.roleHandlers) {\n\t\t\troleHandlers[rh.getRole().ordinal()].add(rh);\n\t\t}\n\t\tComparator<RoleHandler> cmp = (a, b) -> a.getTargetType().isAssignableFrom(b.getTargetType()) ? 1 : -1;\n\t\tfor (RoleHandler rh : ModelRoleHandlers.roleHandlers) {\n\t\t\troleHandlers[rh.getRole().ordinal()].sort(cmp);\n\t\t}\n\t}\n\n\t/**\n\t * @param targetClass the class of the to be manipulated node\n\t * @param role defines the to be manipulated attribute\n\t * @return {@link RoleHandler} implementation which knows how to manipulate the attribute of {@link CtRole} on `targetClass`\n\t * or throws exception if such role doesn't exist on the `targetClass`\n\t */\n\tpublic static RoleHandler getRoleHandler(Class<? extends CtElement> targetClass, CtRole role) {\n\t\tRoleHandler rh = getOptionalRoleHandler(targetClass, role);\n\t\tif (rh == null) {\n\t\t\tthrow new SpoonException(\"The element of class \" + targetClass + \" does not have CtRole.\" + role.name());\n\t\t}\n\t\treturn rh;\n\t}\n\n\t/**\n\t * @param targetClass the Class of the to be manipulated node\n\t * @param role defines the to be manipulated attribute\n\t * @return {@link RoleHandler} implementation, which knows how to manipulate the attribute of {@link CtRole} on `targetClass`\n\t * or returns null if such role doesn't exist on the `targetClass`\n\t */\n\tpublic static RoleHandler getOptionalRoleHandler(Class<? extends CtElement> targetClass, CtRole role) {\n\t\tList<RoleHandler> handlers = roleHandlers[role.ordinal()];\n\t\tfor (RoleHandler ctRoleHandler : handlers) {\n\t\t\tif (ctRoleHandler.getTargetType().isAssignableFrom(targetClass)) {\n\t\t\t\treturn ctRoleHandler;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @param targetClass a Class whose handlers we are looking for\n\t * @return all {@link RoleHandler}s available for the `targetClass`\n\t */\n\tpublic static List<RoleHandler> getRoleHandlers(Class<? extends CtElement> targetClass) {\n\t\tList<RoleHandler> handlers = roleHandlersByClass.get(targetClass);\n\t\tif (handlers == null) {\n\t\t\tList<RoleHandler> modifiableHandlers = new ArrayList<>();\n\t\t\tfor (CtRole role : CtRole.values()) {\n\t\t\t\tRoleHandler roleHandler = getOptionalRoleHandler(targetClass, role);\n\t\t\t\tif (roleHandler != null) {\n\t\t\t\t\tmodifiableHandlers.add(roleHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t\thandlers = Collections.unmodifiableList(modifiableHandlers);\n\t\t\troleHandlersByClass.put(targetClass, handlers);\n\t\t}\n\t\treturn handlers;\n\t}\n\n\t/**\n\t * @param consumer is called for each {@link RoleHandler} of SpoonModel\n\t */\n\tpublic static void forEachRoleHandler(Consumer<RoleHandler> consumer) {\n\t\tfor (List<RoleHandler> list : roleHandlers) {\n\t\t\tfor (RoleHandler roleHandler : list) {\n\t\t\t\tconsumer.accept(roleHandler);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param element the {@link CtElement} whose relation from `element.getParent()` to `element` is needed.\n\t * @return {@link RoleHandler} handling relation from `element.getParent()` to `element`\n\t */\n\tpublic static RoleHandler getRoleHandlerWrtParent(CtElement element) {\n\t\tif (element.isParentInitialized() == false) {\n\t\t\treturn null;\n\t\t}\n\t\tCtElement parent = element.getParent();\n\t\tCtRole roleInParent = element.getRoleInParent();\n\t\tif (roleInParent == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getRoleHandler(parent.getClass(), roleInParent);\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/impl/SingleHandler.java",
      "weight" : 97.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta.impl;\n\nimport java.util.AbstractList;\nimport java.util.Collections;\n\nimport spoon.SpoonException;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.path.CtRole;\n\n/**\n * implementation of {@link RoleHandler}\n * @param <T> the type of node whose attribute has to be manipulated\n * @param <U> the type of value of the attribute\n */\nabstract class SingleHandler<T, U> extends AbstractRoleHandler<T, U, U> {\n\n\tprotected SingleHandler(CtRole role, Class<T> targetType, Class<?> valueClass) {\n\t\tsuper(role, targetType, valueClass);\n\t}\n\n\t@Override\n\tpublic ContainerKind getContainerKind() {\n\t\treturn ContainerKind.SINGLE;\n\t}\n\n\t@Override\n\tpublic <W, X> java.util.Collection<X> asCollection(W element) {\n\t\treturn asList(element);\n\t}\n\n\t@Override\n\tpublic <W, X> java.util.List<X> asList(W e) {\n\t\treturn new AbstractList<X>() {\n\t\t\tT element = castTarget(e);\n\t\t\tboolean hasValue = SingleHandler.this.getValue(element) != null;\n\n\t\t\t@Override\n\t\t\tpublic int size() {\n\t\t\t\treturn hasValue ? 1 : 0;\n\t\t\t}\n\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@Override\n\t\t\tpublic X get(int index) {\n\t\t\t\tif (index < 0 || index >= size()) {\n\t\t\t\t\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size());\n\t\t\t\t}\n\t\t\t\treturn (X) SingleHandler.this.getValue(element);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic X set(int index, X value) {\n\t\t\t\tif (index < 0 || index >= size()) {\n\t\t\t\t\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size());\n\t\t\t\t}\n\t\t\t\tX oldValue = get(0);\n\t\t\t\tSingleHandler.this.setValue(element, value);\n\t\t\t\treturn oldValue;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean add(X value) {\n\t\t\t\tif (hasValue) {\n\t\t\t\t\t//single value cannot have more then one value\n\t\t\t\t\tthrow new SpoonException(\"Single value attribute cannot have more then one value\");\n\t\t\t\t}\n\t\t\t\tSingleHandler.this.setValue(element, value);\n\t\t\t\thasValue = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic X remove(int index) {\n\t\t\t\tif (index < 0 || index >= size()) {\n\t\t\t\t\tthrow new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size());\n\t\t\t\t}\n\t\t\t\tX oldValue = get(0);\n\t\t\t\tif (oldValue != null) {\n\t\t\t\t\tSingleHandler.this.setValue(element, null);\n\t\t\t\t}\n\t\t\t\thasValue = false;\n\t\t\t\treturn oldValue;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean remove(Object value) {\n\t\t\t\tif (hasValue == false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tX oldValue = get(0);\n\t\t\t\tif (equals(oldValue, value)) {\n\t\t\t\t\tif (oldValue != null) {\n\t\t\t\t\t\tSingleHandler.this.setValue(element, null);\n\t\t\t\t\t}\n\t\t\t\t\thasValue = false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tprivate boolean equals(Object v1, Object v2) {\n\t\t\t\tif (v1 == v2) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (v1 == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn v1.equals(v2);\n\t\t\t}\n\t\t};\n\t}\n\n\t@Override\n\tpublic <W, X> java.util.Set<X> asSet(W element) {\n\t\treturn Collections.<X>singleton(getValue(element));\n\t}\n}\n"
    }, {
      "name" : "reflect/meta/ContainerKind.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta;\n\n/**\n * Represents a kind of data, which is used in an field or in a role in the Spoon metamodel.\n * See also {@link spoon.metamodel.MetamodelProperty}.\n */\npublic enum ContainerKind {\n\t/**\n\t * It is a single value field\n\t * Example: {@link spoon.support.reflect.declaration.CtClassImpl#simpleName}\n\t */\n\tSINGLE,\n\n\n\t/**\n\t * It is a list of values\n\t * Example: {@link spoon.support.reflect.declaration.CtClassImpl#typeMembers}\n\t */\n\tLIST,\n\n\n\t/**\n\t * It is a set of values\n\t * Example: {@link spoon.support.reflect.declaration.CtPackageImpl#types}\n\t */\n\tSET,\n\n\n\t/**\n\t * It is a map&lt;String, T&gt; of values\n\t * Example: {@link spoon.support.reflect.declaration.CtAnnotationImpl#elementValues}\n\t */\n\tMAP;\n}\n"
    }, {
      "name" : "reflect/meta/RoleHandler.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.meta;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.reflect.path.CtRole;\n\n/**\n * Enables client code to get and set a field based on a role for a CtElement.\n *\n * One obtains instances of {@link RoleHandler} using the methods of {@link spoon.reflect.meta.impl.RoleHandlerHelper}.\n *\n * There is one role handler per role of {@link CtRole}, they are set by {@link spoon.reflect.meta.impl.RoleHandlerHelper}.\n */\npublic interface RoleHandler {\n\t// the main methods, responsible to get and set the field corresponding to this role\n\t/**\n\t * @param element a element from which the value will be get for this role\n\t * @return a value of the element on the role defined by {@link #getRole()}\n\t */\n\t<T, U> U getValue(T element);\n\t/**\n\t * @param element a element whose value will be set for this role\n\t * @param value new value, which will be assigned to the element's attribute defined by role defined by {@link #getRole()}\n\t */\n\t<T, U> void setValue(T element, U value);\n\n\t// introspection methods\n\t/**\n\t * @return the role handled by this handler\n\t */\n\tCtRole getRole();\n\n\t/**\n\t * @return the type of the class, which this handler can be applied to (eg CtMethod)\n\t */\n\tClass<?> getTargetType();\n\n\t/**\n\t * @return the type of returned value defined by {@link #getRole()}\n\t */\n\tClass<?> getValueClass();\n\n\t/**\n\t * @return the container kind, to know whether an element, a list, a map, etc is returned.\n\t */\n\tContainerKind getContainerKind();\n\n\t// utility methods\n\t/**\n\t * @return a value for this role adapted as a modifiable Collection\n\t */\n\t<T, U> Collection<U> asCollection(T element);\n\n\t/**\n\t * @return a value for this role adapted as a modifiable Set\n\t */\n\t<T, U> Set<U> asSet(T element);\n\n\t/**\n\t * @return a value for this role adapted as a modifiable List\n\t */\n\t<T, U> List<U> asList(T element);\n\n\t/**\n\t * @return a value for this role adapted as a modifiable Map\n\t */\n\t<T, U> Map<String, U> asMap(T element);\n}\n"
    }, {
      "name" : "reflect/Changes.java",
      "weight" : 38.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This class is a container for a list changes that may have occurred on a model\n * because of a transformation.\n */\npublic class Changes {\n\n\tList<CtElement> added;\n\n\tList<CtElement> modified;\n\n\tList<CtElement> removed;\n\n\t/**\n\t * Creates an instance to be further initialized.\n\t */\n\tpublic Changes() {\n\t}\n\n\t/**\n\t * Gets the list of elements added in the model.\n\t */\n\tpublic List<CtElement> getAdded() {\n\t\tif (added == null) {\n\t\t\tadded = new ArrayList<>();\n\t\t}\n\t\treturn added;\n\t}\n\n\t/**\n\t * Gets the list of elements removed from the model.\n\t */\n\tpublic List<CtElement> getRemoved() {\n\t\tif (removed == null) {\n\t\t\tremoved = new ArrayList<>();\n\t\t}\n\t\treturn removed;\n\t}\n\n\t/**\n\t * Gets the list of updated elements.\n\t */\n\tpublic List<CtElement> getModified() {\n\t\tif (modified == null) {\n\t\t\tmodified = new ArrayList<>();\n\t\t}\n\t\treturn modified;\n\t}\n\n\t/**\n\t * Returns true if elements are added.\n\t */\n\tpublic boolean hasAdded() {\n\t\treturn added != null && !added.isEmpty();\n\t}\n\n\t/**\n\t * Returns true if elements are modified.\n\t */\n\tpublic boolean hasModified() {\n\t\treturn modified != null && !modified.isEmpty();\n\t}\n\n\t/**\n\t * Returns true if elements are removed.\n\t */\n\tpublic boolean hasRemoved() {\n\t\treturn removed != null && !removed.isEmpty();\n\t}\n\n}\n"
    }, {
      "name" : "reflect/path/CtRole.java",
      "weight" : 171.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.function.Predicate;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.support.Internal;\n\n/**\n * Identifies the roles of attributes of spoon model.\n */\npublic enum CtRole {\n\tNAME,\n\tTYPE,\n\tMULTI_TYPE,\n\tDECLARING_TYPE,\n\tDECLARED_TYPE,\n\tDECLARED_TYPE_REF,\n\tDECLARED_MODULE,\n\tDECLARED_MODULE_REF,\n\tPACKAGE_DECLARATION,\n\tDECLARED_IMPORT,\n\tCONTAINED_TYPE,\n\tBODY,\n\tIS_SHADOW,\n\tBOUND, // in reference only\n\tBOUNDING_TYPE, // in reference only\n\tIS_FINAL, // in reference only\n\tIS_STATIC, // in reference only\n\tIS_UPPER, // in reference only\n\tIS_IMPLICIT,\n\tIS_DEFAULT,\n\tIS_VARARGS,\n\tDEFAULT_EXPRESSION,\n\tTHEN,\n\tELSE,\n\tPACKAGE_REF,\n\tSUB_PACKAGE,\n\tCONDITION,\n\tRIGHT_OPERAND,\n\tLEFT_OPERAND,\n\tLABEL,\n\tCASE,\n\tOPERATOR_KIND,\n\tPARAMETER,\n\tARGUMENT_TYPE,\n\tEXPRESSION,\n\tTARGET,\n\tVARIABLE,\n\tFINALIZER,\n\tTHROWN,\n\tASSIGNMENT,\n\tASSIGNED,\n\tMODIFIER,\n\tCOMMENT,\n\tANNOTATION_TYPE,\n\tINTERFACE,\n\tANNOTATION,\n\tSTATEMENT,\n\tARGUMENT,\n\tSUPER_TYPE,\n\tTYPE_MEMBER,\n\tNESTED_TYPE(TYPE_MEMBER, obj -> obj instanceof CtType),\n\tCONSTRUCTOR(TYPE_MEMBER, obj -> obj instanceof CtConstructor),\n\tMETHOD(TYPE_MEMBER, obj -> obj instanceof CtMethod),\n\tANNONYMOUS_EXECUTABLE(TYPE_MEMBER, obj -> obj instanceof CtAnonymousExecutable),\n\tFIELD(TYPE_MEMBER, obj -> obj instanceof CtField),\n\tEXECUTABLE_REF,\n\tCAST,\n\tVALUE,\n\tFOR_UPDATE,\n\tFOR_INIT,\n\tFOREACH_VARIABLE,\n\tTRY_RESOURCE,\n\tDIMENSION,\n\tCATCH,\n\tTARGET_LABEL,\n\tTYPE_PARAMETER,\n\tTYPE_ARGUMENT,\n\tCOMMENT_TAG,\n\tCOMMENT_CONTENT,\n\tCOMMENT_TYPE,\n\tDOCUMENTATION_TYPE,\n\tJAVADOC_TAG_VALUE,\n\tPOSITION,\n\tSNIPPET,\n\tACCESSED_TYPE,\n\tIMPORT_REFERENCE,\n\tMODULE_DIRECTIVE,\n\tREQUIRED_MODULE(MODULE_DIRECTIVE, obj -> obj instanceof CtModuleRequirement),\n\tMODULE_REF,\n\tEXPORTED_PACKAGE(MODULE_DIRECTIVE, obj -> obj instanceof CtPackageExport && !((CtPackageExport) obj).isOpenedPackage()),\n\tOPENED_PACKAGE(MODULE_DIRECTIVE, obj -> obj instanceof CtPackageExport && ((CtPackageExport) obj).isOpenedPackage()),\n\tSERVICE_TYPE(MODULE_DIRECTIVE, obj -> obj instanceof CtUsedService),\n\tIMPLEMENTATION_TYPE,\n\tPROVIDED_SERVICE(MODULE_DIRECTIVE, obj -> obj instanceof CtProvidedService),\n\tIS_INFERRED,\n\tTYPE_REF;\n\n\tprivate final CtRole superRole;\n\tprivate final List<CtRole> subRoles;\n\tprivate final Predicate<Object> predicate;\n\tprivate List<CtRole> initSubRoles;\n\n\tCtRole() {\n\t\tthis(null, null);\n\t}\n\tCtRole(CtRole superRole, Predicate<Object> predicate) {\n\t\tthis.superRole = superRole;\n\t\tthis.initSubRoles = new ArrayList<>(0);\n\t\tthis.subRoles = Collections.unmodifiableList(this.initSubRoles);\n\t\tthis.predicate = predicate;\n\t\tif (superRole != null) {\n\t\t\tsuperRole.initSubRoles.add(this);\n\t\t}\n\t}\n\n\tstatic {\n\t\t//after all are initialized, avoid further modification\n\t\tfor (CtRole role : CtRole.values()) {\n\t\t\trole.initSubRoles = null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link CtRole} associated to the field name\n\t * @param name\n\t * @return\n\t */\n\tpublic static CtRole fromName(String name) {\n\t\tfor (CtRole role : CtRole.values()) {\n\t\t\tif (role.getCamelCaseName().toLowerCase().equals(name.toLowerCase()) || role.name().equals(name)) {\n\t\t\t\treturn role;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the camel case representation of the name\n\t * @return the name in camel case\n\t */\n\tpublic String getCamelCaseName() {\n\t\tString s = name().toLowerCase();\n\t\tString[] tokens = s.split(\"_\");\n\t\tif (tokens.length == 1) {\n\t\t\treturn s;\n\t\t} else {\n\t\t\tStringBuilder buffer = new StringBuilder(tokens[0]);\n\t\t\tfor (int i = 1; i < tokens.length; i++) {\n\t\t\t\tString t = tokens[i];\n\t\t\t\tbuffer.append(Character.toUpperCase(t.charAt(0)));\n\t\t\t\tbuffer.append(t.substring(1));\n\t\t\t}\n\t\t\treturn buffer.toString();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getCamelCaseName();\n\t}\n\n\t/**\n\t * @return the CtRole which is the real holder of this virtual CtRole or null if there is no super role.\n\t * \tFor example {@link #TYPE_MEMBER} is super role of {@link #CONSTRUCTOR}, {@link #FIELD}, {@link #METHOD}, {@link #NESTED_TYPE}\n\t */\n\tpublic CtRole getSuperRole() {\n\t\treturn superRole;\n\t}\n\n\t/**\n\t * @return sub roles of this super role or empty array if there is no sub role.\n\t * \tFor example {@link #TYPE_MEMBER} is super role of {@link #CONSTRUCTOR}, {@link #FIELD}, {@link #METHOD}, {@link #NESTED_TYPE}\n\t *\n\t */\n\tpublic List<CtRole> getSubRoles() {\n\t\treturn subRoles;\n\t}\n\n\t/**\n\t * @return sub role of this role, which match `item`.\n\t *\n\t * <pre><code>\n\t * CtMethod method = ...\n\t * CtRole role = CtRole.TYPE_MEMBER.getMatchingSubRoleFor(method);\n\t * </code></pre>\n\t */\n\t@Internal\n\tpublic CtRole getMatchingSubRoleFor(CtElement item) {\n\t\tif (item == null) {\n\t\t\tthrow new SpoonException(\"Cannot detect sub role for null.\");\n\t\t}\n\t\tfor (CtRole subRole : this.subRoles) {\n\t\t\tif (subRole.predicate.test(item)) {\n\t\t\t\treturn subRole;\n\t\t\t}\n\t\t}\n\t\tthrow new SpoonException(\"There is no sub role of CtRole.\" + name() + \" for item class \" + item.getClass());\n\t}\n}\n"
    }, {
      "name" : "reflect/path/impl/AbstractPathElement.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.CtScanner;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Partial implementation for CtPathElement\n */\npublic abstract class AbstractPathElement<P extends CtElement, T extends CtElement> implements CtPathElement<P, T> {\n\tpublic static final String ARGUMENT_START = \"[\";\n\tpublic static final String ARGUMENT_END = \"]\";\n\tpublic static final String ARGUMENT_NAME_SEPARATOR = \"=\";\n\n\tprivate Map<String, String> arguments = new TreeMap<>();\n\n\tpublic Map<String, String> getArguments() {\n\t\treturn arguments;\n\t}\n\n\t@Override\n\tpublic <C extends CtPathElement<P, T>> C addArgument(String key, String value) {\n\t\targuments.put(key, value);\n\t\treturn (C) this;\n\t}\n\n\tCollection<CtElement> getChildren(CtElement element) {\n\t\tfinal Collection<CtElement> elements = new ArrayList<>();\n\t\tif (element != null) {\n\t\t\telement.accept(new CtScanner() {\n\t\t\t\t@Override\n\t\t\t\tpublic void scan(CtElement element) {\n\t\t\t\t\telements.add(element);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn elements;\n\t}\n\n\tprotected String getParamString() {\n\t\tif (arguments.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder builder = new StringBuilder(\"[\");\n\n\t\tfor (Iterator<Map.Entry<String, String>> iter = arguments.entrySet().iterator(); iter.hasNext();) {\n\t\t\tMap.Entry<String, String> value = iter.next();\n\t\t\tbuilder.append(value.getKey() + \"=\" + value.getValue());\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tbuilder.append(\";\");\n\t\t\t}\n\t\t}\n\n\t\treturn builder.append(\"]\").toString();\n\t}\n}\n"
    }, {
      "name" : "reflect/path/impl/CtRolePathElement.java",
      "weight" : 108.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.CtPathException;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtReference;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\n\n/**\n * A CtPathElement that define some roles for matching.\n * <p>\n * Differents roles are define :\n * <ul>\n * <li>statement: match on all statements define in the body of an executable</li>\n * <li>parameter: match on parameter of an executable</li>\n * <li>defaultValue: for value of ctFields</li>\n * </ul>\n */\npublic class CtRolePathElement extends AbstractPathElement<CtElement, CtElement> {\n\n\tpublic static final String STRING = \"#\";\n\n\tprivate final CtRole role;\n\n\tpublic CtRolePathElement(CtRole role) {\n\t\tthis.role = role;\n\t}\n\n\tpublic CtRole getRole() {\n\t\treturn role;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn STRING + getRole().toString() + getParamString();\n\t}\n\n\tprivate CtElement getFromSet(Collection<?> set, String name) throws CtPathException {\n\t\tfor (Object o: set) {\n\t\t\tif (o instanceof CtNamedElement) {\n\t\t\t\tif (((CtNamedElement) o).getSimpleName().equals(name)) {\n\t\t\t\t\treturn (CtElement) o;\n\t\t\t\t}\n\t\t\t} else if (o instanceof CtReference) {\n\t\t\t\tif (((CtReference) o).getSimpleName().equals(name)) {\n\t\t\t\t\treturn (CtElement) o;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new CtPathException();\n\t\t\t}\n\t\t}\n\t\t//Element is not found in set.\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Collection<CtElement> getElements(Collection<CtElement> roots) {\n\t\tCollection<CtElement> matchs = new LinkedList<>();\n\t\tfor (CtElement root : roots) {\n\t\t\tRoleHandler roleHandler = RoleHandlerHelper.getOptionalRoleHandler(root.getClass(), getRole());\n\t\t\tif (roleHandler != null) {\n\t\t\t\tswitch (roleHandler.getContainerKind()) {\n\t\t\t\t\tcase SINGLE:\n\t\t\t\t\t\tif (roleHandler.getValue(root) != null) {\n\t\t\t\t\t\t\tmatchs.add(roleHandler.getValue(root));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LIST: {\n\t\t\t\t\t\tCollection<CtElement> subMatches;\n\t\t\t\t\t\tif (getArguments().containsKey(\"name\")) {\n\t\t\t\t\t\t\tString name = getArguments().get(\"name\");\n\t\t\t\t\t\t\tsubMatches = new CtNamedPathElement(name).scanElements(roleHandler.asList(root));\n\t\t\t\t\t\t} else if (getArguments().containsKey(\"signature\")) {\n\t\t\t\t\t\t\tString sign = getArguments().get(\"signature\");\n\t\t\t\t\t\t\tsubMatches = new CtNamedPathElement(sign).scanElements(roleHandler.asList(root));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsubMatches = roleHandler.asList(root);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (getArguments().containsKey(\"index\")) {\n\t\t\t\t\t\t\tint index = Integer.parseInt(getArguments().get(\"index\"));\n\t\t\t\t\t\t\tif (index < subMatches.size()) {\n\t\t\t\t\t\t\t\tmatchs.add(new ArrayList<>(subMatches).get(index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatchs.addAll(subMatches);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase SET:\n\t\t\t\t\t\tif (getArguments().containsKey(\"signature\")) {\n\t\t\t\t\t\t\tString sign = getArguments().get(\"signature\");\n\t\t\t\t\t\t\tmatchs.addAll(new CtNamedPathElement(sign).scanElements(roleHandler.asSet(root)));\n\t\t\t\t\t\t} else if (getArguments().containsKey(\"name\")) {\n\t\t\t\t\t\t\tString name = getArguments().get(\"name\");\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tCtElement match = getFromSet(roleHandler.asSet(root), name);\n\t\t\t\t\t\t\t\tif (match != null) {\n\t\t\t\t\t\t\t\t\tmatchs.add(match);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (CtPathException e) {\n\t\t\t\t\t\t\t\t//No element found for name.\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatchs.addAll(roleHandler.asSet(root));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MAP:\n\t\t\t\t\t\tif (getArguments().containsKey(\"key\")) {\n\t\t\t\t\t\t\tString name = getArguments().get(\"key\");\n\t\t\t\t\t\t\tif (roleHandler.asMap(root).containsKey(name)) {\n\t\t\t\t\t\t\t\tmatchs.add((CtElement) roleHandler.asMap(root).get(name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tMap<String, CtElement> map = roleHandler.asMap(root);\n\t\t\t\t\t\t\tmatchs.addAll(map.values());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn matchs;\n\t}\n}\n"
    }, {
      "name" : "reflect/path/impl/CtTypedNameElement.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * spoon.reflect.path.impl.CtPathElement that match on CtNamedElement\n */\npublic class CtTypedNameElement<P extends CtElement, T extends CtElement> extends AbstractPathElement<P, T> {\n\tpublic static final String STRING = \"/\";\n\tprivate final Class<T> type;\n\n\tpublic CtTypedNameElement(Class<T> type) {\n\t\tthis.type = type;\n\t}\n\n\tpublic Class<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn STRING + type.getSimpleName() + getParamString();\n\t}\n\n\t@Override\n\tpublic Collection<T> getElements(Collection<P> roots) {\n\t\tCollection<T> elements = new ArrayList<>();\n\t\tfor (CtElement root : roots) {\n\t\t\tfor (CtElement child : getChildren(root)) {\n\t\t\t\tif (match(child)) {\n\t\t\t\t\telements.add((T) child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t}\n\n\tprivate boolean match(CtElement element) {\n\t\treturn element != null && type.isAssignableFrom(element.getClass());\n\t}\n}\n"
    }, {
      "name" : "reflect/path/impl/CtPathElement.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.Collection;\n\n/**\n * A single path element from a CtPath.\n * <p>\n * Internal interface, not meant to be used by client code.\n *\n * @param <P> the type of the queried elements\n * @param <T> the type of the returned elements\n */\npublic interface CtPathElement<P extends CtElement, T extends CtElement> {\n\n\t/**\n\t * Get elements childs of roots that match with this path.\n\t */\n\tCollection<T> getElements(Collection<P> roots);\n\n\t/**\n\t * Add a path argument.\n\t *\n\t * For instance, addArgument(\"index\",3) will select only the third element in an indexed list.\n\t */\n\t<C extends CtPathElement<P, T>> C addArgument(String key, String value);\n\n}\n"
    }, {
      "name" : "reflect/path/impl/CtPathImpl.java",
      "weight" : 53.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtPath;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Default implementation for a CtPath\n */\npublic class CtPathImpl implements CtPath {\n\n\tprivate LinkedList<CtPathElement> elements = new LinkedList<>();\n\n\tpublic List<CtPathElement> getElements() {\n\t\treturn elements;\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> List<T> evaluateOn(CtElement... startNode) {\n\t\tCollection<CtElement> filtered = Arrays.asList(startNode);\n\t\tfor (CtPathElement element : elements) {\n\t\t\tfiltered = element.getElements(filtered);\n\t\t}\n\t\treturn (List<T>) filtered;\n\t}\n\n\t@Override\n\tpublic CtPath relativePath(CtElement parent) {\n\t\tList<CtElement> roots = new ArrayList<>();\n\t\troots.add(parent);\n\n\t\tint index = 0;\n\t\tfor (CtPathElement pathEl : getElements()) {\n\t\t\tif (pathEl.getElements(roots).size() > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tCtPathImpl result = new CtPathImpl();\n\t\tresult.elements = new LinkedList<>(elements.subList(index, elements.size()));\n\t\treturn result;\n\t}\n\n\tpublic CtPathImpl addFirst(CtPathElement element) {\n\t\telements.addFirst(element);\n\t\treturn this;\n\t}\n\n\tpublic CtPathImpl addLast(CtPathElement element) {\n\t\telements.addLast(element);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder str = new StringBuilder();\n\t\tfor (CtPathElement element : elements) {\n\t\t\tstr.append(element.toString());\n\t\t}\n\t\treturn str.toString();\n\t}\n}\n"
    }, {
      "name" : "reflect/path/impl/CtNamedPathElement.java",
      "weight" : 104.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path.impl;\n\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Set;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\n/**\n * A CtPathElement that match on CtNamedElement#getSimpleName\n */\npublic class CtNamedPathElement extends AbstractPathElement<CtElement, CtElement> {\n\tpublic static final String STRING = \".\";\n\tpublic static final String WILDCARD = \"*\";\n\tpublic static final String RECURSIVE_WILDCARD = \"**\";\n\n\tprivate final String pattern;\n\tprivate final Pattern rePattern;\n\n\tpublic CtNamedPathElement(String pattern) {\n\t\tthis(pattern, true);\n\t}\n\n\tprivate static Set<String> failingPatterns = new HashSet<>();\n\n\tpublic CtNamedPathElement(String pattern, boolean canBeRegexp) {\n\t\tthis.pattern = pattern;\n\t\tPattern p = null;\n\t\tif (canBeRegexp && canBeRegExpPattern(pattern) && !failingPatterns.contains(pattern)) {\n\t\t\ttry {\n\t\t\t\tp = Pattern.compile(pattern);\n\t\t\t} catch (PatternSyntaxException e) {\n\t\t\t\tfailingPatterns.add(pattern);\n\t\t\t}\n\t\t}\n\t\tthis.rePattern = p;\n\t}\n\n\tprivate boolean canBeRegExpPattern(String str) {\n\t\t// if there is \"()\", it refers to a method signature\n\t\t// so it cannot be a RegExp\n\t\treturn !str.contains(\"()\");\n\t}\n\n\tpublic String getPattern() {\n\t\treturn pattern;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn STRING + getPattern() + getParamString();\n\t}\n\n\t@Override\n\tpublic Collection<CtElement> getElements(Collection<CtElement> roots) {\n\t\tCollection<CtElement> results = new ArrayList<>();\n\t\tfor (CtElement element : roots) {\n\t\t\tresults.addAll(scanElements(getChildren(element)));\n\t\t}\n\t\treturn results;\n\t}\n\n\tpublic Collection<CtElement> scanElements(Collection<? extends CtElement> roots) {\n\t\tNameScanner nameScanner = new NameScanner();\n\t\tif (RECURSIVE_WILDCARD.equals(pattern)) {\n\t\t\tnameScanner.recurse(roots);\n\t\t} else {\n\t\t\tnameScanner.scan(roots);\n\t\t}\n\t\treturn nameScanner.getResults();\n\t}\n\n\tprivate class NameScanner extends CtInheritanceScanner {\n\t\tprivate Collection<CtElement> results = new LinkedList<>();\n\n\t\tNameScanner() {\n\t\t}\n\n\t\t@Override\n\t\tpublic void scanCtElement(CtElement e) {\n\t\t\tif (WILDCARD.equals(pattern) || RECURSIVE_WILDCARD.equals(pattern)) {\n\t\t\t\tresults.add(e);\n\t\t\t} else if (e instanceof CtExecutable && matchPattern(getSignature((CtExecutable) e))) {\n\t\t\t\tresults.add(e);\n\t\t\t} else if (e instanceof CtNamedElement && matchPattern(((CtNamedElement) e).getSimpleName())) {\n\t\t\t\tresults.add(e);\n\t\t\t} else if (e instanceof CtReference && matchPattern(((CtReference) e).getSimpleName())) {\n\t\t\t\tresults.add(e);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean matchPattern(String str) {\n\t\t\tif (str.equals(pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn rePattern != null && rePattern.matcher(str).matches();\n\t\t}\n\n\t\tprivate void recurse(Collection<? extends CtElement> elements) {\n\t\t\tscan(elements);\n\t\t\tfor (CtElement element : elements) {\n\t\t\t\trecurse(getChildren(element));\n\t\t\t}\n\t\t}\n\n\t\tpublic Collection<CtElement> getResults() {\n\t\t\treturn results;\n\t\t}\n\t}\n\n\tprivate static String getSignature(CtExecutable exec) {\n\t\tString sign = exec.getSignature();\n\t\tif (exec instanceof CtConstructor) {\n\t\t\tint idx = sign.indexOf('(');\n\t\t\treturn sign.substring(idx);\n\t\t}\n\t\treturn sign;\n\t}\n}\n"
    }, {
      "name" : "reflect/path/CtPathBuilder.java",
      "weight" : 55.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.impl.CtNamedPathElement;\nimport spoon.reflect.path.impl.CtPathElement;\nimport spoon.reflect.path.impl.CtPathImpl;\nimport spoon.reflect.path.impl.CtRolePathElement;\nimport spoon.reflect.path.impl.CtTypedNameElement;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * This builder allow to create some CtPath.\n * <p>\n * Some examples:\n * <p>\n * To create a CtPath that match with any method in fr.spoon.Launcher:\n * <pre>\n * {@code\n * new CtPathBuilder().name(\"fr\").name(\"spoon\").name(\"Launcher\").type(\"method\");\n * }\n * </pre>\n * Created by nicolas on 10/06/2015.\n */\npublic class CtPathBuilder {\n\n\tprivate List<CtPathElement> elements = new LinkedList<>();\n\n\t/**\n\t * Add a name matcher to this path.\n\t *\n\t * @param name\n\t * @param args\n\t * @return\n\t */\n\tpublic CtPathBuilder name(String name, String[]... args) {\n\t\tCtNamedPathElement e = new CtNamedPathElement(name);\n\t\tif (args != null) {\n\t\t\tfor (String[] arg : args) {\n\t\t\t\te.addArgument(arg[0], arg[1]);\n\t\t\t}\n\t\t}\n\t\telements.add(e);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a simple wildcard. Match only on elements child of current one.\n\t */\n\tpublic CtPathBuilder wildcard() {\n\t\treturn name(CtNamedPathElement.WILDCARD);\n\t}\n\n\t/**\n\t * Add a recursive wildcard. It match on any child and sub-childs.\n\t */\n\tpublic CtPathBuilder recursiveWildcard() {\n\t\treturn name(CtNamedPathElement.RECURSIVE_WILDCARD);\n\t}\n\n\t/**\n\t * Match on element of a given type.\n\t */\n\tpublic <T extends CtElement> CtPathBuilder type(Class<T> type, String[]... args) {\n\t\tCtTypedNameElement e = new CtTypedNameElement(type);\n\t\tif (args != null) {\n\t\t\tfor (String[] arg : args) {\n\t\t\t\te.addArgument(arg[0], arg[1]);\n\t\t\t}\n\t\t}\n\t\telements.add(e);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Match on elements by their role.\n\t *\n\t * @see CtRole\n\t */\n\tpublic CtPathBuilder role(CtRole role, String[]... args) {\n\t\tCtRolePathElement e = new CtRolePathElement(role);\n\t\tif (args != null) {\n\t\t\tfor (String[] arg : args) {\n\t\t\t\te.addArgument(arg[0], arg[1]);\n\t\t\t}\n\t\t}\n\t\telements.add(e);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the CtPath\n\t */\n\tpublic CtPath build() {\n\t\tCtPathImpl path = new CtPathImpl();\n\t\tfor (CtPathElement el : elements) {\n\t\t\tpath.addLast(el);\n\t\t}\n\t\treturn path;\n\t}\n}\n"
    }, {
      "name" : "reflect/path/CtPath.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.List;\n\n/**\n * A CtPath allows to define the path to a CtElement in the Spoon model, eg \".spoon.test.path.Foo.foo#body#statement[index=0]\"\n */\npublic interface CtPath {\n\n\t/**\n\t * Search for elements matching this CtPatch from start nodes given as parameters.\n\t */\n\t<T extends CtElement> List<T> evaluateOn(CtElement... startNode);\n\n\t/**\n\t *\n\t * Returns the path that is relative to the given element (subpath from it to the end of the path).\n\t * This is used to have relative paths, instead of absolute path from the root package.\n\t *\n\t * For example,\n\t * \"#typeMember[index=2]#body#statement[index=2]#else\"\n\t * is a relative path to the class of absolute path\n\t * \"#subPackage[name=spoon]#subPackage[name=test]#subPackage[name=path]#subPackage[name=testclasses]#containedType[name=Foo]#typeMember[index=2]#body#statement[index=2]#else\"\n\t */\n\tCtPath relativePath(CtElement parent);\n\n}\n"
    }, {
      "name" : "reflect/path/CtPathException.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\nimport spoon.SpoonException;\n\n/**\n *  This exception is throw when there are errors during a CtPath building or evaluation.\n */\npublic class CtPathException extends SpoonException {\n\tpublic CtPathException() {\n\t}\n\n\tpublic CtPathException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\tpublic CtPathException(String message) {\n\t\tsuper(message);\n\t}\n}\n"
    }, {
      "name" : "reflect/path/CtElementPathBuilder.java",
      "weight" : 140.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\nimport spoon.reflect.CtModelImpl;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.impl.CtPathElement;\nimport spoon.reflect.path.impl.CtPathImpl;\nimport spoon.reflect.path.impl.CtRolePathElement;\nimport spoon.reflect.reference.CtReference;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * This builder allow to create some CtPath from CtElements\n *\n * Created by nharrand on 21/02/2018.\n */\npublic class CtElementPathBuilder {\n\tprivate boolean useNamesInPath = true;\n\n\t/**\n\t * Build absolute path to a CtElement el.\n\t *\n\t * @throws CtPathException is thrown when root is not a parent of el.\n\t *\n\t * @param el : the element to which the CtPath leads to\n\t * @return CtPath from model root package to el\n\t */\n\tpublic CtPath fromElement(CtElement el) throws CtPathException {\n\t\treturn fromElement(el, el.getParent(CtModelImpl.CtRootPackage.class));\n\t}\n\t/**\n\t * Build path to a CtElement el, from one of its parent.\n\t *\n\t * @throws CtPathException is thrown when root is not a parent of el.\n\t *\n\t * @param el : the element to which the CtPath leads to\n\t * @param root : Starting point of the CtPath\n\t * @return CtPath from root to el\n\t */\n\tpublic CtPath fromElement(CtElement el, CtElement root) throws CtPathException {\n\t\tCtPathImpl path = new CtPathImpl();\n\t\tCtElement cur = el;\n\t\twhile (cur != root) {\n\t\t\tCtElement parent = cur.getParent();\n\t\t\tCtRole role = cur.getRoleInParent();\n\t\t\tif (role == null) {\n\t\t\t\tthrow new CtPathException();\n\t\t\t}\n\t\t\tRoleHandler roleHandler = RoleHandlerHelper.getOptionalRoleHandler(parent.getClass(), role);\n\t\t\tif (roleHandler == null) {\n\t\t\t\tthrow new CtPathException();\n\t\t\t}\n\t\t\tCtPathElement pathElement = new CtRolePathElement(role);\n\t\t\tswitch (roleHandler.getContainerKind()) {\n\t\t\t\tcase SINGLE:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LIST: {\n\t\t\t\t\t//Element needs to be differentiated from its brothers\n\t\t\t\t\tif (useNamesInPath) {\n\t\t\t\t\t\tString[] pair = getArg(cur);\n\t\t\t\t\t\tString attrName = pair[0];\n\t\t\t\t\t\tString name = pair[1];\n\t\t\t\t\t\tif (name != null) {\n\t\t\t\t\t\t\t//the path with name is more readable, so prefer name instead of index\n\t\t\t\t\t\t\tif (role.getSubRoles().size() > 0) {\n\t\t\t\t\t\t\t\t//there are subroles.\n\t\t\t\t\t\t\t\trole = role.getMatchingSubRoleFor(cur);\n\t\t\t\t\t\t\t\tpathElement = new CtRolePathElement(role);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpathElement.addArgument(attrName, name);\n\t\t\t\t\t\t\t//check list to check if argument is unique\n\t\t\t\t\t\t\tList<CtElement> list = roleHandler.asList(parent);\n\t\t\t\t\t\t\t//Assumes that List's order is deterministic.\n\t\t\t\t\t\t\tList<CtElement> filteredList = new ArrayList<>();\n\t\t\t\t\t\t\tint index = -1;\n\t\t\t\t\t\t\tfor (CtElement item : list) {\n\t\t\t\t\t\t\t\tString[] pair2 = getArg(item);\n\t\t\t\t\t\t\t\tString attrName2 = pair2[0];\n\t\t\t\t\t\t\t\tString name2 = pair2[1];\n\t\t\t\t\t\t\t\tif (Objects.equals(name, name2) && Objects.equals(attrName, attrName2)) {\n\t\t\t\t\t\t\t\t\t//we found an element with same name\n\t\t\t\t\t\t\t\t\tif (item == cur) {\n\t\t\t\t\t\t\t\t\t\t//we found cur element. Remember it's index\n\t\t\t\t\t\t\t\t\t\tindex = filteredList.size();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfilteredList.add(item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (filteredList.size() > 1 && index >= 0) {\n\t\t\t\t\t\t\t\t//there is more then one element with that name. Use index too\n\t\t\t\t\t\t\t\tpathElement.addArgument(\"index\", String.valueOf(index));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tList list = roleHandler.asList(parent);\n\t\t\t\t\t//Assumes that List's order is deterministic.\n\t\t\t\t\t//Can't be replaced by list.indexOf(cur)\n\t\t\t\t\t//Because objects must be the same (and not just equals)\n\t\t\t\t\tint index = 0;\n\t\t\t\t\tfor (Object o : list) {\n\t\t\t\t\t\tif (o == cur) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\tpathElement.addArgument(\"index\", index + \"\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SET: {\n\t\t\t\t\tString name;\n\t\t\t\t\tif (cur instanceof CtNamedElement) {\n\t\t\t\t\t\tname = ((CtNamedElement) cur).getSimpleName();\n\t\t\t\t\t} else if (cur instanceof CtReference) {\n\t\t\t\t\t\tname = ((CtReference) cur).getSimpleName();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new CtPathException();\n\t\t\t\t\t}\n\t\t\t\t\tpathElement.addArgument(\"name\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase MAP: {\n\t\t\t\t\tMap map = roleHandler.asMap(parent);\n\t\t\t\t\tString key = null;\n\t\t\t\t\tfor (Object o : map.keySet()) {\n\t\t\t\t\t\tif (map.get(o) == cur) {\n\t\t\t\t\t\t\tkey = (String) o;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (key == null) {\n\t\t\t\t\t\tthrow new CtPathException();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpathElement.addArgument(\"key\", key);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = parent;\n\t\t\tpath.addFirst(pathElement);\n\t\t}\n\t\treturn path;\n\t}\n\n\tprivate String[] getArg(CtElement item) {\n\t\tString name = null;\n\t\tString attrName = \"name\";\n\t\tif (item instanceof CtExecutable) {\n\t\t\tname = getSignature((CtExecutable) item);\n\t\t\tattrName = \"signature\";\n\t\t} else if (item instanceof CtNamedElement) {\n\t\t\tname = ((CtNamedElement) item).getSimpleName();\n\t\t} else if (item instanceof CtReference) {\n\t\t\tname = ((CtReference) item).getSimpleName();\n\t\t}\n\t\treturn new String[]{attrName, name};\n\t}\n\n\tprivate static String getSignature(CtExecutable exec) {\n\t\tString sign = exec.getSignature();\n\t\tif (exec instanceof CtConstructor) {\n\t\t\tint idx = sign.indexOf('(');\n\t\t\treturn sign.substring(idx);\n\t\t}\n\t\treturn sign;\n\t}\n\n\t/**\n\t * Configures what kind of path is generated for List based attributes<br>\n\t * A) #superRole[index=x] - always use index to identify item of List. For example `#typeMember[index=7]`. Such paths are fast.\n\t * B) #subRole[name=x] - use simpleName or signature of List item if possible. Use the most specific role too.\n\t * \tFor example `#field[name=counter]` or `#method[signature=getCounter()]`. Such paths are more readable but slower.\n\t * @param useNamesInPath if true then names are used instead of index\n\t * @return this to support fluent API\n\t */\n\tpublic CtElementPathBuilder setUseNamesInPath(boolean useNamesInPath) {\n\t\tthis.useNamesInPath = useNamesInPath;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "reflect/path/CtPathStringBuilder.java",
      "weight" : 128.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.path;\n\n\nimport spoon.SpoonException;\nimport spoon.reflect.path.impl.AbstractPathElement;\nimport spoon.reflect.path.impl.CtNamedPathElement;\nimport spoon.reflect.path.impl.CtPathElement;\nimport spoon.reflect.path.impl.CtPathImpl;\nimport spoon.reflect.path.impl.CtTypedNameElement;\nimport spoon.reflect.path.impl.CtRolePathElement;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\n\n/**\n * Created by nicolas on 27/08/2015.\n */\npublic class CtPathStringBuilder {\n\n\tprivate final Pattern pathPattern = Pattern.compile(\"([/.#])([^/.#\\\\[]+)(\\\\[([^/.#]*)\\\\])?\");\n\tprivate final Pattern argumentPattern = Pattern.compile(\"(\\\\w+)=([^=\\\\]]+)\");\n\n\n\tprivate Class load(String name) throws CtPathException {\n\t\t// try without name\n\t\ttry {\n\t\t\treturn Class.forName(name);\n\t\t} catch (ClassNotFoundException ex) {\n\t\t}\n\n\t\t// search in spoon.reflect.declaration\n\t\ttry {\n\t\t\treturn Class.forName(\"spoon.reflect.declaration.\" + name);\n\t\t} catch (ClassNotFoundException ex) {\n\t\t}\n\t\t// search in\n\t\ttry {\n\t\t\treturn Class.forName(\"spoon.reflect.code.\" + name);\n\t\t} catch (ClassNotFoundException ex) {\n\t\t\tthrow new CtPathException(\n\t\t\t\t\tString.format(\"Unable to locate element with type %s in Spoon model\", name));\n\t\t}\n\t}\n\n\tprivate static final String MAIN_DELIMITERS = \".#/\";\n\tprivate static final String PATH_DELIMITERS = \".#/[\";\n\tprivate static final String ARG_NAME_DELIMITERS = \"=\";\n\n\tprivate static final Pattern NAME_MATCHER = Pattern.compile(\"\\\\w+\");\n\n\t/**\n\t * Build path from a string representation.\n\t *\n\t * for example:\n\t * new CtPathBuilder().fromString(\".spoon.test.path.Foo.foo#statement[index=0]\")\n\t * Match the first statement of method foo from class spoon.test.path.Foo.\n\t *\n\t * Some specials characters\n\t * . :  match with the given name\n\t * # : match with a CtPathRole\n\t * / : match with a element type (for example, to match all classes, use /CtClass\n\t */\n\tpublic CtPath fromString(String pathStr) throws CtPathException {\n\t\tCtPathImpl path = new CtPathImpl();\n\n\t\tTokenizer tokenizer = new Tokenizer(pathStr);\n\t\tString token = tokenizer.getNextToken(MAIN_DELIMITERS);\n\t\twhile (token != null) {\n\t\t\tString kind = token;\n\t\t\tCtPathElement pathElement;\n\t\t\ttoken = tokenizer.getNextToken(PATH_DELIMITERS);\n\t\t\tif (token != null && token.length() == 1 && PATH_DELIMITERS.contains(token)) {\n\t\t\t\t//nextToken is again path delimiter. It means there is no token value in between\n\t\t\t\tthrow new CtPathException(\"Path value is missing\");\n\t\t\t}\n\t\t\tif (CtNamedPathElement.STRING.equals(kind)) {\n\t\t\t\t//reg exp cannot be used in string, because `.` and `[` are reserved characters for CtPath\n\t\t\t\tpathElement = new CtNamedPathElement(token, false);\n\t\t\t} else if (CtTypedNameElement.STRING.equals(kind)) {\n\t\t\t\tpathElement = new CtTypedNameElement(load(token));\n\t\t\t} else if (CtRolePathElement.STRING.equals(kind)) {\n\t\t\t\tpathElement = new CtRolePathElement(CtRole.fromName(token));\n\t\t\t} else {\n\t\t\t\tthrow new CtPathException(\"Unexpected token \" + kind);\n\t\t\t}\n\t\t\ttoken = tokenizer.getNextToken(PATH_DELIMITERS);\n\t\t\tif (AbstractPathElement.ARGUMENT_START.equals(token)) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tString argName = tokenizer.getNextToken(ARG_NAME_DELIMITERS);\n\t\t\t\t\tif (!NAME_MATCHER.matcher(argName).matches()) {\n\t\t\t\t\t\tthrow new CtPathException(\"Argument name must be a word, but is: \" + argName);\n\t\t\t\t\t}\n\t\t\t\t\ttoken = tokenizer.getNextToken(ARG_NAME_DELIMITERS);\n\t\t\t\t\tif (!AbstractPathElement.ARGUMENT_NAME_SEPARATOR.equals(token)) {\n\t\t\t\t\t\tthrow new CtPathException(\"Expects \" + AbstractPathElement.ARGUMENT_NAME_SEPARATOR);\n\t\t\t\t\t}\n\t\t\t\t\ttoken = parseArgumentValue(tokenizer, argName, pathElement);\n\t\t\t\t\tif (\"]\".equals(token)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//read next argument\n\t\t\t\t}\n\t\t\t\ttoken = tokenizer.getNextToken(MAIN_DELIMITERS);\n\t\t\t}\n\t\t\tpath.addLast(pathElement);\n\t\t}\n\t\treturn path;\n\t}\n\n\tprivate static final String ARG_VALUE_DELIMITERS = \"[];()\";\n\n\t/**\n\t * @return last token\n\t */\n\tprivate String parseArgumentValue(Tokenizer tokenizer, String argName, CtPathElement pathElement) {\n\t\tStringBuilder argValue = new StringBuilder();\n\t\tDeque<String> stack = new ArrayDeque<>();\n\t\twhile (true) {\n\t\t\tString token = tokenizer.getNextToken(ARG_VALUE_DELIMITERS);\n\t\t\tif (\"(\".equals(token) || \"[\".equals(token)) {\n\t\t\t\t//starts bracket\n\t\t\t\tstack.push(token);\n\t\t\t} else if (stack.size() > 0) {\n\t\t\t\t//we are in some brackets. Just wait for end of bracket\n\t\t\t\tif (\")\".equals(token)) {\n\t\t\t\t\t//closing bracket\n\t\t\t\t\tString kind = stack.pop();\n\t\t\t\t\tif (!\"(\".equals(kind)) {\n\t\t\t\t\t\tthrow new CtPathException(\"Unexpected end of bracket \" + token);\n\t\t\t\t\t}\n\t\t\t\t} else if (\"]\".equals(token)) {\n\t\t\t\t\t//closing bracket\n\t\t\t\t\tString kind = stack.pop();\n\t\t\t\t\tif (!\"[\".equals(kind)) {\n\t\t\t\t\t\tthrow new CtPathException(\"Unexpected end of bracket \" + token);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (\"]\".equals(token) || \";\".equals(token)) {\n\t\t\t\t//finished reading of argument value\n\t\t\t\tpathElement.addArgument(argName, argValue.toString());\n\t\t\t\treturn token;\n\t\t\t}\n\t\t\targValue.append(token);\n\t\t}\n\t}\n\n\tprivate static class Tokenizer {\n\t\tStringTokenizer tokenizer;\n\t\tint length;\n\t\tint off;\n\t\tTokenizer(String str) {\n\t\t\tlength = str.length();\n\t\t\toff = 0;\n\t\t\ttokenizer = new StringTokenizer(str, MAIN_DELIMITERS, true);\n\t\t}\n\n\t\tString getNextToken(String delimiters) {\n\t\t\ttry {\n\t\t\t\tif (off >= length) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tString token = tokenizer.nextToken(delimiters);\n\t\t\t\toff += token.length();\n\t\t\t\treturn token;\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new SpoonException(\"Unexpected error\", e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/ModelStreamer.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.CompressionType;\n\n/**\n * This interface defines the protocol to save and load a factory and it's\n * associated model through output and input streams.\n */\npublic interface ModelStreamer {\n\n\t/**\n\t * Saves a factory (and all its associated Java program elements).\n\t * Stream is GZIP compressed by default, see {@link Environment#setCompressionType(spoon.support.CompressionType)}\n\t *\n\t * @param f\n\t * \t\tthe factory to be save\n\t * @param out\n\t * \t\tthe used output stream\n\t * @throws IOException\n\t * \t\tif some IO error occurs\n\t */\n\tvoid save(Factory f, OutputStream out) throws IOException;\n\n\t/**\n\t * Loads a factory (and all its associated Java program elements).\n\t * Tries to decompress the file given the available {@link CompressionType}\n\t *\n\t * @param in\n\t * \t\tthe used input stream\n\t * @return the loaded factory\n\t * @throws IOException\n\t * \t\tif some IO error occurs\n\t */\n\tFactory load(InputStream in) throws IOException;\n\n}\n"
    }, {
      "name" : "reflect/CtModelImpl.java",
      "weight" : 109.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect;\n\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.ModuleFactory;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtFunction;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.QueueProcessingManager;\nimport spoon.support.reflect.declaration.CtPackageImpl;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CtModelImpl implements CtModel {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate boolean buildModelFinished = false;\n\n\t@Override\n\tpublic <R extends CtElement> CtQuery filterChildren(Filter<R> filter) {\n\t\treturn getUnnamedModule().getFactory().Query().createQuery(this.getAllModules().toArray()).filterChildren(filter);\n\t}\n\n\t@Override\n\tpublic <I, R> CtQuery map(CtFunction<I, R> function) {\n\t\treturn getUnnamedModule().getFactory().Query().createQuery(this.getAllModules().toArray()).map(function);\n\t}\n\n\t@Override\n\tpublic <I> CtQuery map(CtConsumableFunction<I> queryStep) {\n\t\treturn getUnnamedModule().getFactory().Query().createQuery(this.getAllModules().toArray()).map(queryStep);\n\t}\n\n\tpublic static class CtRootPackage extends CtPackageImpl {\n\t\t{\n\t\t\tthis.setSimpleName(CtPackage.TOP_LEVEL_PACKAGE_NAME);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends CtNamedElement> T setSimpleName(String name) {\n\t\t\tif (name == null) {\n\t\t\t\treturn (T) this;\n\t\t\t}\n\n\t\t\tif (name.equals(CtPackage.TOP_LEVEL_PACKAGE_NAME)) {\n\t\t\t\treturn super.setSimpleName(name);\n\t\t\t}\n\n\t\t\treturn (T) this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getQualifiedName() {\n\t\t\treturn \"\";\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn TOP_LEVEL_PACKAGE_NAME;\n\t\t}\n\t}\n\n\tprivate final CtModule unnamedModule;\n\n\tpublic CtModelImpl(Factory f) {\n\t\tthis.unnamedModule = new ModuleFactory.CtUnnamedModule();\n\t\tthis.unnamedModule.setFactory(f);\n\t\tthis.unnamedModule.setRootPackage(new CtModelImpl.CtRootPackage());\n\t\tgetRootPackage().setFactory(f);\n\t}\n\n\t@Override\n\tpublic CtPackage getRootPackage() {\n\t\treturn getUnnamedModule().getRootPackage();\n\t}\n\n\n\t@Override\n\tpublic Collection<CtType<?>> getAllTypes() {\n\t\tfinal List<CtType<?>> result = new ArrayList<>();\n\t\tgetAllPackages().forEach(ctPackage -> {\n\t\t\tresult.addAll(ctPackage.getTypes());\n\t\t});\n\t\treturn result;\n\t}\n\n\n\t@Override\n\tpublic Collection<CtPackage> getAllPackages() {\n\t\treturn Collections.unmodifiableCollection(getElements(new TypeFilter<>(CtPackage.class)));\n\t}\n\n\t@Override\n\tpublic CtModule getUnnamedModule() {\n\t\treturn this.unnamedModule;\n\t}\n\n\t@Override\n\tpublic Collection<CtModule> getAllModules() {\n\t\treturn ((ModuleFactory.CtUnnamedModule) this.unnamedModule).getAllModules();\n\t}\n\n\n\t@Override\n\tpublic void processWith(Processor<?> processor) {\n\t\tQueueProcessingManager processingManager = new QueueProcessingManager(getUnnamedModule().getFactory());\n\t\tprocessingManager.addProcessor(processor);\n\t\tprocessingManager.process(getAllModules());\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> List<E> getElements(Filter<E> filter) {\n\t\treturn filterChildren(filter).list();\n\t}\n\n\n\t@Override\n\tpublic boolean isBuildModelFinished() {\n\t\treturn this.buildModelFinished;\n\t}\n\n\t@Override\n\tpublic <T extends CtModel> T setBuildModelIsFinished(boolean buildModelFinished) {\n\t\tthis.buildModelFinished = buildModelFinished;\n\t\treturn (T) this;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/annotations/PropertySetter.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.annotations;\n\nimport spoon.reflect.path.CtRole;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Specifies that a method is an official metamodel setter in the Spoon metamodel.\n * @see PropertyGetter\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD })\npublic @interface PropertySetter {\n\tCtRole role();\n}\n"
    }, {
      "name" : "reflect/annotations/PropertyGetter.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.annotations;\n\nimport spoon.reflect.path.CtRole;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Specifies that a method is an official metamodel getter in the Spoon metamodel.\n * @see PropertySetter\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD })\npublic @interface PropertyGetter {\n\tCtRole role();\n}\n"
    }, {
      "name" : "reflect/annotations/MetamodelPropertyField.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.annotations;\n\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.path.CtRole;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Tells that a field is a property of the metamodel\n * For instance {@link spoon.support.reflect.declaration.CtNamedElementImpl#getSimpleName} is the property name of {@link CtNamedElement}\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.FIELD })\npublic @interface MetamodelPropertyField {\n\tCtRole[] role();\n}\n"
    }, {
      "name" : "reflect/code/BinaryOperatorKind.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This enumeration defines all the kinds of binary operators.\n */\npublic enum BinaryOperatorKind {\n\n\t/**\n\t * Logical or.\n\t */\n\tOR, // ||\n\t/**\n\t * Logical and.\n\t */\n\tAND, // &&\n\t/**\n\t * Bit to bit or.\n\t */\n\tBITOR, // |\n\t/**\n\t * Bit to bit xor.\n\t */\n\tBITXOR, // ^\n\t/**\n\t * Bit to bit and.\n\t */\n\tBITAND, // &\n\t/**\n\t * Equality.\n\t */\n\tEQ, // ==\n\t/**\n\t * Inequality.\n\t */\n\tNE, // !=\n\t/**\n\t * Lower than comparison.\n\t */\n\tLT, // <\n\t/**\n\t * Greater than comparison.\n\t */\n\tGT, // >\n\t/**\n\t * Lower or equal comparison.\n\t */\n\tLE, // <=\n\t/**\n\t * Greater or equal comparison.\n\t */\n\tGE, // >=\n\t/**\n\t * Shift left.\n\t */\n\tSL, // <<\n\t/**\n\t * Shift right.\n\t */\n\tSR, // >>\n\t/**\n\t * Unsigned shift right.\n\t */\n\tUSR, // >>>\n\t/**\n\t * Addition.\n\t */\n\tPLUS, // +\n\t/**\n\t * Substraction.\n\t */\n\tMINUS, // -\n\t/**\n\t * Multiplication.\n\t */\n\tMUL, // *\n\t/**\n\t * Division.\n\t */\n\tDIV, // /\n\t/**\n\t * Modulo.\n\t */\n\tMOD, // %\n\t/**\n\t * Instanceof (OO specific).\n\t */\n\tINSTANCEOF\n\t// instanceof\n\n}\n"
    }, {
      "name" : "reflect/code/CtCodeElement.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface is the root interface of the code elements.\n */\npublic interface CtCodeElement extends CtElement {\n\n\t/**\n\t * Partially evaluates an element and all its sub-elements.\n\t *\n\t * @param <R>\n\t * \t\tthe returned element\n\t * @return the result of the partial evaluation\n\t */\n\t<R extends CtCodeElement> R partiallyEvaluate();\n\n\t@Override\n\tCtCodeElement clone();\n}\n"
    }, {
      "name" : "reflect/code/CtThrow.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.template.TemplateParameter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a <code>throw</code> statement.\n *\n * Example:\n * <pre>\n *     throw new RuntimeException(\"oops\")\n * </pre>\n */\npublic interface CtThrow extends CtCFlowBreak, TemplateParameter<Void> {\n\n\t/**\n\t * Returns the thrown expression (must be a throwable).\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<? extends Throwable> getThrownExpression();\n\n\t/**\n\t * Sets the thrown expression (must be a throwable).\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtThrow> T setThrownExpression(CtExpression<? extends Throwable> thrownExpression);\n\n\t@Override\n\tCtThrow clone();\n}\n"
    }, {
      "name" : "reflect/code/CtLocalVariable.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.IS_INFERRED;\n\n/**\n * This code element defines a local variable definition (within an executable\n * body).\n *\n * Example:\n * <pre>\n *     // defines a local variable x\n *     int x = 0;\n * </pre>\n *\n * With Java 10, the local variable inference is now authorized, then the following code is valid too in a block scope:\n *\n * <pre>\n *     // local variable in Java 10\n *     var x = 0;\n * </pre>\n *\n * @param <T>\n * \t\ttype of the variable\n * @see spoon.reflect.declaration.CtExecutable\n */\npublic interface CtLocalVariable<T> extends CtStatement, CtVariable<T>, CtRHSReceiver<T> {\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtLocalVariableReference<T> getReference();\n\n\t/**\n\t * Useful proxy to {@link #getDefaultExpression()}.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtExpression<T> getAssignment();\n\n\t@Override\n\tCtLocalVariable<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<U extends CtRHSReceiver<T>> U setAssignment(CtExpression<T> assignment);\n\n\t/**\n\t * Return true if this variable's type is not explicitely defined in the source code, but was using the `var` keyword of Java 10.\n\t */\n\t@PropertyGetter(role = IS_INFERRED)\n\tboolean isInferred();\n\n\t/**\n\t * Set true if the variable must be inferred.\n\t * Warning: this method should only be used if compliance level is set to 10 or more.\n\t */\n\t@PropertySetter(role = IS_INFERRED)\n\t<U extends CtLocalVariable<T>> U setInferred(boolean inferred);\n\n}\n"
    }, {
      "name" : "reflect/code/CtForEach.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.FOREACH_VARIABLE;\n\n\n/**\n * This code element defines a foreach statement.\n * Example:\n * <pre>\n *     java.util.List l = new java.util.ArrayList();\n *     for(Object o : l) { // &lt;-- foreach loop\n *     \tSystem.out.println(o);\n *     }\n * </pre>\n */\npublic interface CtForEach extends CtLoop {\n\t/**\n\t * Gets the iterated expression (an iterable of an array).\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<?> getExpression();\n\n\t/**\n\t * Gets the variable that references the currently iterated element.\n\t */\n\t@PropertyGetter(role = FOREACH_VARIABLE)\n\tCtLocalVariable<?> getVariable();\n\n\t/**\n\t * Sets the iterated expression (an iterable of an array).\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtForEach> T setExpression(CtExpression<?> expression);\n\n\t/**\n\t * Sets the variable that references the currently iterated element.\n\t */\n\t@PropertySetter(role = FOREACH_VARIABLE)\n\t<T extends CtForEach> T setVariable(CtLocalVariable<?> variable);\n\n\t@Override\n\tCtForEach clone();\n}\n"
    }, {
      "name" : "reflect/code/CtConditional.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.ELSE;\nimport static spoon.reflect.path.CtRole.THEN;\n\n\n/**\n * This code element defines conditional expressions using the ? (ternary expressions).\n *\n * Example:\n * <pre>\n *     System.out.println(\n *        1==0 ? \"foo\" : \"bar\" // &lt;-- ternary conditional\n *     );\n * </pre>\n */\npublic interface CtConditional<T> extends CtExpression<T> {\n\n\t/**\n\t * Gets the \"false\" expression.\n\t */\n\t@PropertyGetter(role = ELSE)\n\tCtExpression<T> getElseExpression();\n\n\t/**\n\t * Gets the \"true\" expression.\n\t */\n\t@PropertyGetter(role = THEN)\n\tCtExpression<T> getThenExpression();\n\n\t/**\n\t * Gets the condition expression.\n\t */\n\t@PropertyGetter(role = CONDITION)\n\tCtExpression<Boolean> getCondition();\n\n\t/**\n\t * Sets the \"false\" expression.\n\t */\n\t@PropertySetter(role = ELSE)\n\t<C extends CtConditional<T>> C setElseExpression(CtExpression<T> elseExpression);\n\n\t/**\n\t * Sets the \"true\" expression.\n\t */\n\t@PropertySetter(role = THEN)\n\t<C extends CtConditional<T>> C setThenExpression(CtExpression<T> thenExpression);\n\n\t/**\n\t * Sets the condition expression.\n\t */\n\t@PropertySetter(role = CONDITION)\n\t<C extends CtConditional<T>> C setCondition(CtExpression<Boolean> condition);\n\n\t@Override\n\tCtConditional<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtBlock.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.template.TemplateParameter;\n\n/**\n * This code element represents a block of code, that is to say a list of\n * statements enclosed in curly brackets.\n *\n * Example: <pre>\n *  { // &lt;-- block start\n *   System.out.println(\"foo\");\n *  }\n *\t</pre>\n *\n * When the context calls for a return\n * value, the block should contain a return statement as a lastly reachable\n * statement. The returned type if any is given by R.\n */\npublic interface CtBlock<R> extends CtStatement, CtStatementList, TemplateParameter<R> {\n\n\t@Override\n\tCtBlock<R> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtBodyHolder.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.BODY;\n\n/**\n * This abstract code element defines an element, which contains a body\n */\npublic interface CtBodyHolder extends CtElement {\n\n\t/**\n\t * Gets the body of this element\n\t */\n\t@PropertyGetter(role = BODY)\n\tCtStatement getBody();\n\n\t/**\n\t * Sets the body of this element.\n\t * If body is not a block, it is wrapped in a CtBlock which is semantically equivalent and eases transformation afterwards if required.\n\t */\n\t@PropertySetter(role = BODY)\n\t<T extends CtBodyHolder> T setBody(CtStatement body);\n}\n"
    }, {
      "name" : "reflect/code/CtCodeSnippetExpression.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.support.compiler.SnippetCompilationError;\n\n/**\n * This element is a code snippet that must represent an expression and can thus\n * be inserted in the program's model as is. Code snippets should be avoided\n * since no controls can be performed on them.\n */\npublic interface CtCodeSnippetExpression<T> extends CtExpression<T>, CtCodeSnippet {\n\n\t/**\n\t * Compiles this expression snippet to produce the corresponding AST expression.\n\t *\n\t * @throws SnippetCompilationError\n\t * \t\twhen the current snippet is not valid Java code expression\n\t */\n\t<E extends CtExpression<T>> E compile() throws SnippetCompilationError;\n\n\t@Override\n\tCtCodeSnippetExpression<T> clone();\n\n}\n"
    }, {
      "name" : "reflect/code/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * \t<p>This package contains the meta-model part that models the executable code (methods and constructors' bodies, field initializers).\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.code;\n"
    }, {
      "name" : "reflect/code/CtWhile.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a <code>while</code> loop.\n *\n * Example:\n * <pre>\n *     int x = 0;\n *     while (x!=10) {\n *         x=x+1;\n *     };\n * </pre>\n *\n */\npublic interface CtWhile extends CtLoop {\n\t/**\n\t * Gets the looping boolean test expression.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<Boolean> getLoopingExpression();\n\n\t/**\n\t * Sets the looping boolean test expression.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtWhile> T setLoopingExpression(CtExpression<Boolean> expression);\n\n\t@Override\n\tCtWhile clone();\n}\n"
    }, {
      "name" : "reflect/code/CtTryWithResource.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TRY_RESOURCE;\n\n/**\n * This code element defines a <code>try</code> with resource statement.\n *\n * Example:\n * <pre>\n *    // br is the resource\n *    try (java.io.BufferedReader br = new java.io.BufferedReader(new java.io.FileReader(\"/foo\"))) {\n *    \tbr.readLine();\n *   }\n * </pre>\n */\npublic interface CtTryWithResource extends CtTry {\n\n\t/**\n\t * Gets the auto-closeable resources of this <code>try</code>. Available\n\t * from Java 7 with the <i>try-with-resource</i> statement.\n\t */\n\t@PropertyGetter(role = TRY_RESOURCE)\n\tList<CtLocalVariable<?>> getResources();\n\n\t/**\n\t * Sets the auto-closeable resources of this <code>try</code>. Available\n\t * from Java 7 with the <i>try-with-resource</i> statement.\n\t */\n\t@PropertySetter(role = TRY_RESOURCE)\n\t<T extends CtTryWithResource> T setResources(List<CtLocalVariable<?>> resources);\n\n\t/**\n\t * Adds a resource.\n\t */\n\t@PropertySetter(role = TRY_RESOURCE)\n\t<T extends CtTryWithResource> T addResource(CtLocalVariable<?> resource);\n\n\t/**\n\t * Removes a resource.\n\t */\n\t@PropertySetter(role = TRY_RESOURCE)\n\tboolean removeResource(CtLocalVariable<?> resource);\n\n\t@Override\n\tCtTryWithResource clone();\n}\n"
    }, {
      "name" : "reflect/code/CtExecutableReferenceExpression.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXECUTABLE_REF;\n\n/**\n * This abstract code element defines an expression which represents an executable reference.\n *\n * * Example:\n * <pre>\n *     java.util.function.Supplier p =\n *       Object::new;\n * </pre>\n *\n * @param <T>\n * \t\tEach executable references are typed by an interface with one method. This generic type\n * \t\tcorrespond to this concept.\n * @param <E>\n * \t\tCorrespond of <code>Type</code> in <code>Type::method</code>.\n */\npublic interface CtExecutableReferenceExpression<T, E extends CtExpression<?>> extends CtTargetedExpression<T, E> {\n\t/**\n\t * Gets the executable referenced by the expression.\n\t */\n\t@PropertyGetter(role = EXECUTABLE_REF)\n\tCtExecutableReference<T> getExecutable();\n\n\t/**\n\t * Sets the executable will be referenced by the expression.\n\t */\n\t@PropertySetter(role = EXECUTABLE_REF)\n\t<C extends CtExecutableReferenceExpression<T, E>> C setExecutable(CtExecutableReference<T> executable);\n\n\t@Override\n\tCtExecutableReferenceExpression<T, E> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtLoop.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.template.TemplateParameter;\n\nimport static spoon.reflect.path.CtRole.BODY;\n\n/**\n * This abstract code element defines a loop.\n */\npublic interface CtLoop extends CtStatement, TemplateParameter<Void>, CtBodyHolder {\n\n\t/**\n\t * Gets the body of this loop.\n\t */\n\t@Override\n\t@PropertyGetter(role = BODY)\n\tCtStatement getBody();\n\n\t@Override\n\tCtLoop clone();\n}\n"
    }, {
      "name" : "reflect/code/CtSwitch.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.CASE;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a switch statement.\n *\n * Example: <pre>\n * int x = 0;\n * switch(x) { // &lt;-- switch statement\n *     case 1:\n *       System.out.println(\"foo\");\n * }</pre>\n\n * @param <S>\n * \t\tthe type of the selector expression (it would be better to be able\n * \t\tto define an upper bound, but it is not possible because of Java's\n * \t\ttype hierarchy, especially since the enums that make things even\n * \t\tworse!)\n */\npublic interface CtSwitch<S> extends CtStatement {\n\t/**\n\t * Gets the selector. The type of the Expression must be <code>char</code>,\n\t * <code>byte</code>, <code>short</code>, <code>int</code>,\n\t * <code>Character</code>, <code>Byte</code>, <code>Short</code>,\n\t * <code>Integer</code>, or an <code>enum</code> type\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<S> getSelector();\n\n\t/**\n\t * Sets the selector. The type of the Expression must be <code>char</code>,\n\t * <code>byte</code>, <code>short</code>, <code>int</code>,\n\t * <code>Character</code>, <code>Byte</code>, <code>Short</code>,\n\t * <code>Integer</code>, or an <code>enum</code> type\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtSwitch<S>> T setSelector(CtExpression<S> selector);\n\n\t/**\n\t * Gets the list of cases defined for this switch.\n\t */\n\t@PropertyGetter(role = CASE)\n\tList<CtCase<? super S>> getCases();\n\n\t/**\n\t * Sets the list of cases defined for this switch.\n\t */\n\t@PropertySetter(role = CASE)\n\t<T extends CtSwitch<S>> T setCases(List<CtCase<? super S>> cases);\n\n\t/**\n\t * Adds a case;\n\t */\n\t@PropertySetter(role = CASE)\n\t<T extends CtSwitch<S>> T addCase(CtCase<? super S> c);\n\n\t/**\n\t * Removes a case;\n\t */\n\t@PropertySetter(role = CASE)\n\tboolean removeCase(CtCase<? super S> c);\n\n\t@Override\n\tCtSwitch<S> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtBinaryOperator.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\nimport static spoon.reflect.path.CtRole.LEFT_OPERAND;\nimport static spoon.reflect.path.CtRole.RIGHT_OPERAND;\n\n/**\n * This interface defines a binary operator.\n *\n * Example:\n * <pre>\n *     // 3+4 is the binary expression\n *     int x = 3 + 4;\n * </pre>\n * @param <T>\n * \t\tType of this expression\n */\npublic interface CtBinaryOperator<T> extends CtExpression<T> {\n\n\t/**\n\t * Returns the left-hand operand.\n\t */\n\t@PropertyGetter(role = LEFT_OPERAND)\n\tCtExpression<?> getLeftHandOperand();\n\n\t/**\n\t * Returns the right-hand operand.\n\t */\n\t@PropertyGetter(role = RIGHT_OPERAND)\n\tCtExpression<?> getRightHandOperand();\n\n\t/**\n\t * Sets the left-hand operand.\n\t */\n\t@PropertySetter(role = LEFT_OPERAND)\n\t<C extends CtBinaryOperator<T>> C setLeftHandOperand(CtExpression<?> expression);\n\n\t/**\n\t * Sets the right-hand operand.\n\t */\n\t@PropertySetter(role = RIGHT_OPERAND)\n\t<C extends CtBinaryOperator<T>> C setRightHandOperand(CtExpression<?> expression);\n\n\t/**\n\t * Sets the kind of this binary operator.\n\t */\n\t@PropertySetter(role = OPERATOR_KIND)\n\t<C extends CtBinaryOperator<T>> C setKind(BinaryOperatorKind kind);\n\n\t/**\n\t * Gets the kind of this binary operator.\n\t */\n\t@PropertyGetter(role = OPERATOR_KIND)\n\tBinaryOperatorKind getKind();\n\n\t@Override\n\tCtBinaryOperator<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtNewClass.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.NESTED_TYPE;\nimport static spoon.reflect.path.CtRole.TYPE_ARGUMENT;\n\n/**\n * This code element represents the creation of a anonymous class.\n *\n* Example:\n * <pre>\n *    // an anonymous class creation\n *    Runnable r = new Runnable() {\n *     \t&#64;Override\n *     \tpublic void run() {\n *     \t  System.out.println(\"foo\");\n *     \t}\n *    };\n * </pre>\n * @param <T>\n * \t\tcreated type\n */\npublic interface CtNewClass<T> extends CtConstructorCall<T> {\n\t/**\n\t * Delegate to the executable reference of the new class.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@DerivedProperty\n\t@PropertyGetter(role = TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> getActualTypeArguments();\n\n\t/**\n\t * Delegate to the executable reference of the new class.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments);\n\n\t/**\n\t * Delegate to the executable reference of the new class.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);\n\n\t/**\n\t * Gets the created class.\n\t */\n\t@PropertyGetter(role = NESTED_TYPE)\n\tCtClass<?> getAnonymousClass();\n\n\t/**\n\t * Sets the created class.\n\t */\n\t@PropertySetter(role = NESTED_TYPE)\n\t<N extends CtNewClass> N setAnonymousClass(CtClass<?> anonymousClass);\n\n\t@Override\n\tCtNewClass<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtFieldWrite.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a write access to a field.\n *\n * In Java, it is a usage of a field inside an assignment.\n *\n * For example:\n * <pre>\n *     class Foo { int field; }\n *     Foo x = new Foo();\n *     x.field = 0;\n * </pre>\n *\n * If you process this element, keep in mind that you won't process field++.\n *\n * @param <T>\n * \t\ttype of the field\n */\npublic interface CtFieldWrite<T> extends CtFieldAccess<T>, CtVariableWrite<T> {\n\t@Override\n\tCtFieldWrite<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtAssignment.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.ASSIGNED;\n\n\n/**\n * This code element defines an assignment.\n *\n * Example:\n * <pre>\n *     int x;\n *     x = 4; // &lt;-- an assignment\n * </pre>\n * @param <T>\n * \t\ttype of assigned expression\n * @param <A>\n * \t\ttype of expression to assign, it should extends &lt;T&gt;\n */\npublic interface CtAssignment<T, A extends T> extends CtStatement, CtExpression<T>, CtRHSReceiver<A> {\n\t/**\n\t * Returns the assigned expression on the left-hand side (where the value is stored,\n\t * e.g. in a variable, in an array, in a field ...).\n\t */\n\t@PropertyGetter(role = ASSIGNED)\n\tCtExpression<T> getAssigned();\n\n\t/**\n\t * Sets the assigned expression (left hand side - LHS).\n\t */\n\t@PropertySetter(role = ASSIGNED)\n\t<C extends CtAssignment<T, A>> C setAssigned(CtExpression<T> assigned);\n\n\t@Override\n\tCtAssignment<T, A> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtArrayAccess.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a one-dimensional array access. When\n * multi-dimensional, array accesses are applied to other one-dimensional array\n * accesses. The target of {@link spoon.reflect.code.CtTargetedExpression}\n * defines the expression that represents the accessed array.\n *\n * @param <T>\n * \t\t\"Return\" type of this access (not a array type)\n * @param <E>\n * \t\tType of the target expression\n */\npublic interface CtArrayAccess<T, E extends CtExpression<?>> extends CtTargetedExpression<T, E> {\n\t/**\n\t * Sets the expression that defines the index.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<C extends CtArrayAccess<T, E>> C setIndexExpression(CtExpression<Integer> expression);\n\n\t/**\n\t * Returns the expression that defines the index.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<Integer> getIndexExpression();\n\n\t@Override\n\tCtArrayAccess<T, E> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtAbstractInvocation.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.ARGUMENT;\nimport static spoon.reflect.path.CtRole.EXECUTABLE_REF;\n\n/**\n * This code element defines an abstract invocation on a\n * {@link spoon.reflect.declaration.CtExecutable}.\n *\n * @param <T>\n * \t\tReturn type of this invocation\n */\npublic interface CtAbstractInvocation<T> extends CtElement {\n\t/**\n\t * The arguments of the invocation.\n\t *\n\t * @return the expressions that define the values of the arguments\n\t */\n\t@PropertyGetter(role = ARGUMENT)\n\tList<CtExpression<?>> getArguments();\n\n\t/**\n\t * Adds an argument expression to the invocation.\n\t */\n\t@PropertySetter(role = ARGUMENT)\n\t<C extends CtAbstractInvocation<T>> C addArgument(CtExpression<?> argument);\n\n\t/**\n\t * Removes an argument expression from the invocation.\n\t */\n\t@PropertySetter(role = ARGUMENT)\n\tvoid removeArgument(CtExpression<?> argument);\n\n\t/**\n\t * Sets the invocation's arguments.\n\t */\n\t@PropertySetter(role = ARGUMENT)\n\t<C extends CtAbstractInvocation<T>> C setArguments(List<CtExpression<?>> arguments);\n\n\t/**\n\t * Returns the invoked executable.\n\t */\n\t@PropertyGetter(role = EXECUTABLE_REF)\n\tCtExecutableReference<T> getExecutable();\n\n\t/**\n\t * Sets the invoked executable.\n\t */\n\t@PropertySetter(role = EXECUTABLE_REF)\n\t<C extends CtAbstractInvocation<T>> C setExecutable(CtExecutableReference<T> executable);\n}\n"
    }, {
      "name" : "reflect/code/CtContinue.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines the continue statement.\n * Example:\n * <pre>\n *     for(int i=0; i&lt;10; i++) {\n *         if (i&gt;3) {\n *\t\t\t\tcontinue; // &lt;-- continue statement\n *         }\n *     }\n * </pre>\n */\npublic interface CtContinue extends CtLabelledFlowBreak {\n\n\t@Override\n\tCtContinue clone();\n}\n"
    }, {
      "name" : "reflect/code/CtCase.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a case within a switch-case.\n *\n * Example: <pre>\n * int x = 0;\n * switch(x) {\n *     case 1: // &lt;-- case statement\n *       System.out.println(\"foo\");\n * }</pre>\n *\n * @param <S>\n * \t\tThis type must be assignable from the switch type\n * @see spoon.reflect.code.CtSwitch\n */\npublic interface CtCase<S> extends CtStatement, CtStatementList {\n\t/**\n\t * Gets the case expression.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<S> getCaseExpression();\n\n\t/**\n\t * Sets the case expression.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtCase<S>> T setCaseExpression(CtExpression<S> caseExpression);\n\n\t@Override\n\tCtCase<S> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtTypeAccess.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.ACCESSED_TYPE;\n\n/**\n * This code element represents a type reference usable as an expression.\n * It is used in particular for static accesses, Java 8 method references, instanceof binary expressions and \".class\".\n * <pre>\n *     // access to static field\n *     java.io.PrintStream ps = System.out;\n * </pre>\n * <pre>\n *     // call to static method\n *     Class.forName(\"Foo\")\n * </pre>\n * <pre>\n *     // method reference\n *     java.util.function.Supplier p =\n *       Object::new;\n * </pre>\n * <pre>\n *     // instanceof test\n *     boolean x = new Object() instanceof Integer // Integer is represented as an access to type Integer\n * </pre>\n * <pre>\n *     // fake field \"class\"\n *     Class x = Number.class\n * </pre>\n *\n * @param <A>\n * \t\tAccess type of the expression.\n */\npublic interface CtTypeAccess<A> extends CtExpression<Void> {\n\t/**\n\t * Returns type represented and contained in the type access.\n\t *\n\t * @return CtTypeReference.\n\t */\n\t@PropertyGetter(role = ACCESSED_TYPE)\n\tCtTypeReference<A> getAccessedType();\n\n\t/**\n\t * Set the accessed type.\n\t *\n\t * @param accessedType\n\t * \t\tCtTypeReference.\n\t */\n\t@PropertySetter(role = ACCESSED_TYPE)\n\t<C extends CtTypeAccess<A>> C setAccessedType(CtTypeReference<A> accessedType);\n\n\t/**\n\t * Returns always VOID.\n\t *\n\t * @see #getAccessedType() to get the accessed type.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<Void> getType();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtTypedElement> C setType(CtTypeReference<Void> type);\n\n\t/**\n\t * @return {@link #getAccessedType()}.isImplicit()\n\t */\n\t@Override\n\t@DerivedProperty\n\tboolean isImplicit();\n\n\t/**\n\t * Calls {@link #getAccessedType()}.setImplicit()\n\t */\n\t@Override\n\t@DerivedProperty\n\t<E extends CtElement> E setImplicit(boolean implicit);\n\n\t@Override\n\tCtTypeAccess<A> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtFieldRead.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a read access to a field.\n *\n * In Java, it is a usage of a field outside an assignment. For example,\n * <pre>\n *     class Foo { int field; }\n *     Foo x = new Foo();\n *     System.out.println(x.field);\n * </pre>\n *\n * If you process this element, keep in mind that you will process field++ too.\n *\n * @param <T>\n * \t\ttype of the field\n */\npublic interface CtFieldRead<T> extends CtFieldAccess<T>, CtVariableRead<T> {\n\t@Override\n\tCtFieldRead<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtOperatorAssignment.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\n\n\n/**\n * This code element defines an self-operated assignment such as += or *=.\n *\n * Example:\n * <pre>\n *     int x = 0;\n *     x *= 3; // &lt;-- a CtOperatorAssignment\n * </pre>\n *\n */\npublic interface CtOperatorAssignment<T, A extends T> extends CtAssignment<T, A> {\n\t/**\n\t * Sets the operator kind.\n\t */\n\t@PropertySetter(role = OPERATOR_KIND)\n\t<C extends CtOperatorAssignment<T, A>> C setKind(BinaryOperatorKind kind);\n\n\t/**\n\t * Gets the operator kind.\n\t */\n\t@PropertyGetter(role = OPERATOR_KIND)\n\tBinaryOperatorKind getKind();\n\n\t@Override\n\tCtOperatorAssignment<T, A> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtJavaDoc.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.javadoc.internal.JavadocDescriptionElement;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.COMMENT_TAG;\n\n/**\n * This code element defines a javadoc comment\n *\n * Example:\n * <pre>\n * &#x2F;**\n *  * Description\n *  * @tag a tag in the javadoc\n * *&#x2F;\n * </pre>\n */\npublic interface CtJavaDoc extends CtComment {\n\t/**\n\t * Get all the tag of the javadoc\n\t * @return the tag list\n\t */\n\t@PropertyGetter(role = COMMENT_TAG)\n\tList<CtJavaDocTag> getTags();\n\n\t/**\n\t * Define the list of tags\n\t * @param tags the new list of tags\n\t */\n\t@PropertySetter(role = COMMENT_TAG)\n\t<E extends CtJavaDoc> E setTags(List<CtJavaDocTag> tags);\n\n\t/**\n\t * Add a new tag at the end of the list\n\t * @param tag the new tag\n\t */\n\t@PropertySetter(role = COMMENT_TAG)\n\t<E extends CtJavaDoc> E addTag(CtJavaDocTag tag);\n\n\t/**\n\t * Add a new tag at the index position\n\t * @param index the index of the new tag\n\t * @param tag the new tag\n\t */\n\t@PropertySetter(role = COMMENT_TAG)\n\t<E extends CtJavaDoc> E addTag(int index, CtJavaDocTag tag);\n\n\t/**\n\t * Remove a tag from the index\n\t * @param index the position of the tag to remove\n\t */\n\t@PropertySetter(role = COMMENT_TAG)\n\t<E extends CtJavaDoc> E removeTag(int index);\n\n\t/**\n\t * Remove a specific tag\n\t * @param tag the tag to remove\n\t */\n\t@PropertySetter(role = COMMENT_TAG)\n\t<E extends CtJavaDoc> E removeTag(CtJavaDocTag tag);\n\n\t/**\n\t * Get the short summary of the javadoc (first sentence of the javadoc)\n\t * @return the summary of the javadoc\n\t */\n\t@DerivedProperty\n\tString getShortDescription();\n\n\t/**\n\t * Get the long description of the javadoc\n\t * @return the long description of the javadoc\n\t */\n\t@DerivedProperty\n\tString getLongDescription();\n\n\t@Override\n\tCtJavaDoc clone();\n\n\t/** Returns the list of parsed Javadoc elements */\n\t@DerivedProperty\n\tList<JavadocDescriptionElement> getJavadocElements();\n}\n"
    }, {
      "name" : "reflect/code/CtLiteral.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.VALUE;\n\n/**\n * This code element defines a literal value (an int, a string, etc).\n *\n * <pre>\n *     int x = 4; // 4 is a literal\n * </pre>\n * A null literal, as in s = null\", is represented by a CtLiteral whose value is null.\n *\n * @param <T>\n * \t\ttype of literal's value\n */\npublic interface CtLiteral<T> extends CtExpression<T> {\n\n\t/**\n\t * Gets the actual value of the literal (statically known).\n\t */\n\t@PropertyGetter(role = VALUE)\n\tT getValue();\n\n\t/**\n\t * Sets the actual value of the literal.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<C extends CtLiteral<T>> C setValue(T value);\n\n\t/** Overriding return type, a clone of a CtLiteral returns a CtLiteral */\n\t@Override\n\tCtLiteral<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/UnaryOperatorKind.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This enumeration defines all the kinds of unary operators.\n */\npublic enum UnaryOperatorKind {\n\t/**\n\t * Positivation.\n\t */\n\tPOS, // +\n\t/**\n\t * Negation.\n\t */\n\tNEG, // -\n\t/**\n\t * Logical inversion.\n\t */\n\tNOT, // !\n\t/**\n\t * Binary complement.\n\t */\n\tCOMPL, // ~\n\t/**\n\t * Incrementation pre assignment.\n\t */\n\tPREINC, // ++ _\n\t/**\n\t * Decrementation pre assignment.\n\t */\n\tPREDEC, // -- _\n\t/**\n\t * Incrementation post assignment.\n\t */\n\tPOSTINC, // _ ++\n\t/**\n\t * Decrementation post assignment.\n\t */\n\tPOSTDEC\n\t// _ --\n}\n"
    }, {
      "name" : "reflect/code/CtArrayWrite.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a write access to an array.\n *\n * In Java, it is a usage of an array inside an assignment.\n *\n * For example:\n * <pre>\n *     Object[] array = new Object[10];\n *     // array write\n *     array[0] = \"new value\";\n * </pre>\n *\n * If you process this element, keep in mind that you won't process array[0]++.\n *\n * @param <T>\n * \t\ttype of the array\n */\npublic interface CtArrayWrite<T> extends CtArrayAccess<T, CtExpression<?>> {\n\t@Override\n\tCtArrayWrite<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtInvocation.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TYPE;\nimport static spoon.reflect.path.CtRole.TYPE_ARGUMENT;\n\n/**\n * This code element defines a concrete invocation.\n *\n * Example:\n * <pre>\n *     // invocation of method println\n *     // the target is \"System.out\"\n *     System.out.println(\"foo\");\n * </pre>\n *\n * @param <T>\n * \t\tReturn type of this invocation\n */\npublic interface CtInvocation<T> extends CtAbstractInvocation<T>, CtStatement, CtTargetedExpression<T, CtExpression<?>>, CtActualTypeContainer {\n\t/**\n\t * Delegate to the executable reference of the invocation.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@DerivedProperty\n\t@PropertyGetter(role = TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> getActualTypeArguments();\n\n\t/**\n\t * Delegate to the executable reference of the invocation.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments);\n\n\t/**\n\t * Delegate to the executable reference of the invocation.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);\n\n\t/**\n\t * Return the type returned by the invocation. If the invocation is to a\n\t * method where the returned type is a generic type, this method returns\n\t * the actual type bound to this particular invocation.\n\t */\n\t@Override\n\t@DerivedProperty\n\t@PropertyGetter(role = TYPE)\n\tCtTypeReference<T> getType();\n\n\t@Override\n\tCtInvocation<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtArrayRead.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a read access to an array.\n *\n * In Java, it is a usage of an array outside an assignment. For example,\n * <pre>\n *     int[] array = new int[10];\n *     System.out.println(\n *     array[0] // &lt;-- array read\n *     );\n * </pre>\n *\n * If you process this element, keep in mind that you will process array[0]++ too.\n *\n * @param <T>\n * \t\ttype of the array\n */\npublic interface CtArrayRead<T> extends CtArrayAccess<T, CtExpression<?>> {\n\t@Override\n\tCtArrayRead<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtIf.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.template.TemplateParameter;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.ELSE;\nimport static spoon.reflect.path.CtRole.THEN;\n\n/**\n * This code element represents an <code>if</code> statement.\n * Example:\n * <pre>\n *     if (1==0) {\n *     \tSystem.out.println(\"foo\");\n *     } else {\n *     \tSystem.out.println(\"bar\");\n *     }\n * </pre>\n */\npublic interface CtIf extends CtStatement, TemplateParameter<Void> {\n\n\t/**\n\t * Gets the boolean expression that represents the <code>if</code>'s\n\t * condition.\n\t */\n\t@PropertyGetter(role = CONDITION)\n\tCtExpression<Boolean> getCondition();\n\n\t/**\n\t * Gets the statement executed when the condition is false.\n\t */\n\t@PropertyGetter(role = ELSE)\n\t<S extends CtStatement> S getElseStatement();\n\n\t/**\n\t * Gets the statement executed when the condition is true.\n\t */\n\t@PropertyGetter(role = THEN)\n\t<S extends CtStatement> S getThenStatement();\n\n\t/**\n\t * Sets the boolean expression that represents the <code>if</code>'s\n\t * condition.\n\t */\n\t@PropertySetter(role = CONDITION)\n\t<T extends CtIf> T setCondition(CtExpression<Boolean> expression);\n\n\t/**\n\t * Sets the statement executed when the condition is false.\n\t */\n\t@PropertySetter(role = ELSE)\n\t<T extends CtIf> T setElseStatement(CtStatement elseStatement);\n\n\t/**\n\t * Sets the statement executed when the condition is true.\n\t */\n\t@PropertySetter(role = THEN)\n\t<T extends CtIf> T setThenStatement(CtStatement thenStatement);\n\n\t@Override\n\tCtIf clone();\n}\n"
    }, {
      "name" : "reflect/code/CtCFlowBreak.java",
      "weight" : 3.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This abstract code element represents all the statements that break the\n * control flow of the program.\n */\npublic interface CtCFlowBreak extends CtStatement {\n}\n"
    }, {
      "name" : "reflect/code/CtStatement.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.LABEL;\n\n/**\n * This abstract code element represents all the statements, which can be part\n * of a block.\n *\n * @see spoon.reflect.code.CtBlock\n */\npublic interface CtStatement extends CtCodeElement {\n\n\t/**\n\t * Inserts a statement after the current statement.\n\t */\n\t<T extends CtStatement> T insertAfter(CtStatement statement) throws ParentNotInitializedException;\n\n\t/**\n\t * Inserts a statement list before the current statement.\n\t */\n\t<T extends CtStatement> T insertAfter(CtStatementList statements) throws ParentNotInitializedException;\n\n\t/**\n\t * Inserts a statement given as parameter before the current statement\n\t * (this).\n\t */\n\t<T extends CtStatement> T insertBefore(CtStatement statement) throws ParentNotInitializedException;\n\n\t/**\n\t * Inserts a statement list before the current statement.\n\t */\n\t<T extends CtStatement> T insertBefore(CtStatementList statements) throws ParentNotInitializedException;\n\n\t/**\n\t * Gets the label of this statement if defined.\n\t *\n\t * @return the label's name (null if undefined)\n\t */\n\t@PropertyGetter(role = LABEL)\n\tString getLabel();\n\n\t/**\n\t * Sets the label of this statement.\n\t */\n\t@PropertySetter(role = LABEL)\n\t<T extends CtStatement> T setLabel(String label);\n\n\t@Override\n\tCtStatement clone();\n}\n"
    }, {
      "name" : "reflect/code/CtCatchVariable.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtMultiTypedElement;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\n/**\n * This code element defines an exception variable in a catch.\n *\n * @param <T>\n * \t\ttype of the variable\n */\npublic interface CtCatchVariable<T> extends CtVariable<T>, CtMultiTypedElement, CtCodeElement {\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtCatchVariableReference<T> getReference();\n\n\t@Override\n\tCtCatchVariable<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> assignedExpression);\n\n\t/**\n\t * Returns type reference of the exception variable in a catch.\n\t * If type is unknown, or any of the types in a multi-catch is unknown, returns null.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<T> getType();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtTypedElement> C setType(CtTypeReference<T> type);\n}\n"
    }, {
      "name" : "reflect/code/CtLambda.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element represents the creation of a lambda. A lambda\n * can have two sorts of body : an simple expression or a block of\n * statements. The usage of this concept in this class is:\n *\n * <pre>\n *     java.util.List l = new java.util.ArrayList();\n *     l.stream().map(\n *       x -&gt; { return x.toString(); } // a lambda\n *     );\n * </pre>\n *\n * <ul>\n * <li>\n * If your lambda has an expression, getBody method will\n * return null and getExpression method will return a\n * CtExpression.\n * </li>\n * <li>\n * If your lambda has a block of statement, getExpression\n * method will return null and getBody will returns a CtBlock\n * with all statements.\n * </li>\n * </ul>\n *\n * So keep this in mind when you would like the body of a CtLambda.\n *\n * @param <T>\n * \t\tcreated type\n */\npublic interface CtLambda<T> extends CtExpression<T>, CtExecutable<T> {\n\t/**\n\t * Gets the expression in the body. Null if the body is a list\n\t * of statements.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<T> getExpression();\n\n\t/**\n\t * @return the method that this lambda expression implements.\n\t * Must be defined as a non-default method in an interface, e.g. Consumer.accept().\n\t */\n\t@DerivedProperty\n\t<R> CtMethod<R> getOverriddenMethod();\n\n\t/**\n\t * Sets the expression in the body of the lambda. Nothing will change\n\t * if the lambda already has a value in the body attribute.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<C extends CtLambda<T>> C setExpression(CtExpression<T> expression);\n\n\t@Override\n\tCtLambda<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T1 extends CtExecutable<T>> T1 setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes);\n}\n"
    }, {
      "name" : "reflect/code/CtComment.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.DerivedProperty;\n\nimport static spoon.reflect.path.CtRole.COMMENT_TYPE;\nimport static spoon.reflect.path.CtRole.COMMENT_CONTENT;\n\n/**\n * This code element defines a comment\n *\n * Example:\n * <code>\n * int x = 0;\n * // a comment\n * </code>\n */\npublic interface CtComment extends CtStatement {\n\tenum CommentType {\n\t\t/**\n\t\t * before the package line (typically the license)\n\t\t */\n\t\tFILE,\n\t\t/**\n\t\t * JavaDoc comment: before methods, fields, types\n\t\t */\n\t\tJAVADOC,\n\t\t/**\n\t\t * Inline comment (//)\n\t\t */\n\t\tINLINE,\n\t\t/**\n\t\t * Block comment (/* *\\/)\n\t\t */\n\t\tBLOCK\n\t}\n\n\t/**\n\t * This line separator is used in comments returned by {@link #getContent()}.\n\t * It is OS independent.\n\t * It has no influence to pretty printed comments, which uses by default OS dependent line separator\n\t */\n\tString LINE_SEPARATOR = \"\\n\";\n\n\t/**\n\t * Get the content of the comment\n\t * @return the content of the comment\n\t */\n\t@PropertyGetter(role = COMMENT_CONTENT)\n\tString getContent();\n\n\t@PropertySetter(role = COMMENT_CONTENT)\n\t<E extends CtComment> E setContent(String content);\n\n\t/**\n\t * @return the original raw comment from the source file including comment prefix and suffix, indentation (including TABs) original EOLs,\n\t * based on the attached position object (the returned value is \"derived\" from the position).\n\t * If the file pointed to in the position object does not exist on disk anymore,\n\t * then the empty string \"\" is returned\n\t * Note: the call of {@link #setContent(String)} doesn't influence the returned value, only the value of the position object.\n\t */\n\t@DerivedProperty\n\tString getRawContent();\n\n\t/**\n\t * Get the type of the comment\n \t * @return the comment type\n\t */\n\t@PropertyGetter(role = COMMENT_TYPE)\n\tCommentType getCommentType();\n\n\t@PropertySetter(role = COMMENT_TYPE)\n\t<E extends CtComment> E setCommentType(CommentType commentType);\n\n\t@Override\n\tCtComment clone();\n\n\t/** Utility method to for casting the object, throws an exception if not of the correct type */\n\tCtJavaDoc asJavaDoc();\n}\n"
    }, {
      "name" : "reflect/code/CtTry.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.template.TemplateParameter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.CATCH;\nimport static spoon.reflect.path.CtRole.FINALIZER;\n\n/**\n * This code element defines a <code>try</code> statement.\n *\n * Example:\n * <pre>\n *     try {\n *     \tSystem.out.println(\"foo\");\n *     } catch (Exception ignore) {}\n * </pre>\n */\npublic interface CtTry extends CtStatement, TemplateParameter<Void>, CtBodyHolder {\n\n\t/**\n\t * Gets the <i>catchers</i> of this <code>try</code>.\n\t */\n\t@PropertyGetter(role = CATCH)\n\tList<CtCatch> getCatchers();\n\n\t/**\n\t * Sets the <i>catchers</i> of this <code>try</code>.\n\t */\n\t@PropertySetter(role = CATCH)\n\t<T extends CtTry> T setCatchers(List<CtCatch> catchers);\n\n\t/**\n\t * Adds a catch block.\n\t */\n\t@PropertySetter(role = CATCH)\n\t<T extends CtTry> T addCatcher(CtCatch catcher);\n\n\t/**\n\t * Removes a catch block.\n\t */\n\t@PropertySetter(role = CATCH)\n\tboolean removeCatcher(CtCatch catcher);\n\n\t/**\n\t * Gets the try body.\n\t */\n\t@Override\n\t@PropertyGetter(role = BODY)\n\tCtBlock<?> getBody();\n\n\t/**\n\t * Gets the <i>finalizer</i> block of this <code>try</code> (\n\t * <code>finally</code> part).\n\t */\n\t@PropertyGetter(role = FINALIZER)\n\tCtBlock<?> getFinalizer();\n\n\t/**\n\t * Sets the <i>finalizer</i> block of this <code>try</code> (\n\t * <code>finally</code> part).\n\t */\n\t@PropertySetter(role = FINALIZER)\n\t<T extends CtTry> T setFinalizer(CtBlock<?> finalizer);\n\n\t@Override\n\tCtTry clone();\n}\n"
    }, {
      "name" : "reflect/code/CtNewArray.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.DIMENSION;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines the inline creation of a new array.\n *\n * Example:\n * <pre>\n *     // inline creation of array content\n *     int[] x = new int[] { 0, 1, 42}\n * </pre>\n * @param <T>\n * \t\ttype of this array (should be a array...)\n */\npublic interface CtNewArray<T> extends CtExpression<T> {\n\n\t/**\n\t * Gets the expressions that define the array's dimensions.\n\t */\n\t@PropertyGetter(role = DIMENSION)\n\tList<CtExpression<Integer>> getDimensionExpressions();\n\n\t/**\n\t * Sets the expressions that define the array's dimensions.\n\t */\n\t@PropertySetter(role = DIMENSION)\n\t<C extends CtNewArray<T>> C setDimensionExpressions(List<CtExpression<Integer>> dimensions);\n\n\t/**\n\t * Adds a dimension expression.\n\t */\n\t@PropertySetter(role = DIMENSION)\n\t<C extends CtNewArray<T>> C addDimensionExpression(CtExpression<Integer> dimension);\n\n\t/**\n\t * Removes a dimension expression.\n\t */\n\t@PropertySetter(role = DIMENSION)\n\tboolean removeDimensionExpression(CtExpression<Integer> dimension);\n\n\t/**\n\t * Gets the initialization expressions.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tList<CtExpression<?>> getElements();\n\n\t/**\n\t * Sets the initialization expressions.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<C extends CtNewArray<T>> C setElements(List<CtExpression<?>> expression);\n\n\t/**\n\t * Adds an element.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<C extends CtNewArray<T>> C addElement(CtExpression<?> expression);\n\n\t/**\n\t * Removes an element.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\tboolean removeElement(CtExpression<?> expression);\n\n\t@Override\n\tCtNewArray<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtAssert.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n\n/**\n * This code element defines an assert clause.\n * Example: <pre>assert 1+1==2</pre>\n */\npublic interface CtAssert<T> extends CtStatement {\n\t/**\n\t * Gets the assert expression.\n\t */\n\t@PropertyGetter(role = CONDITION)\n\tCtExpression<Boolean> getAssertExpression();\n\n\t/**\n\t * Sets the assert expression.\n\t */\n\t@PropertySetter(role = CONDITION)\n\t<A extends CtAssert<T>> A setAssertExpression(CtExpression<Boolean> asserted);\n\n\t/**\n\t * Gets the expression of the assertion if defined.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<T> getExpression();\n\n\t/**\n\t * Sets the expression of the assertion.\n\t *\n\t * For instance assert.setExpression(factory.createCodeSnippetExpression(\"param != null\"))\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<A extends CtAssert<T>> A setExpression(CtExpression<T> expression);\n\n\t@Override\n\tCtAssert<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtStatementList.java",
      "weight" : 41.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.visitor.Filter;\nimport spoon.support.DerivedProperty;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.STATEMENT;\n\n/**\n * This code element represents a list of statements. It is not a valid Java\n * program element and is never used directly, on contrary to\n * a {@link spoon.reflect.code.CtBlock}.\n */\npublic interface CtStatementList extends CtCodeElement, Iterable<CtStatement> {\n\t/**\n\t * Returns the statement list.\n\t */\n\t@PropertyGetter(role = STATEMENT)\n\tList<CtStatement> getStatements();\n\n\t/**\n\t * Sets the statement list.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T setStatements(List<CtStatement> statements);\n\n\t/**\n\t * Adds a statement at the end of the list.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T addStatement(CtStatement statement);\n\n\t/**\n\t * Inserts the given statement at a specific position in the list of statements\n\t * Shifts the statement currently at that position (if any) and any subsequent statements to the right (adds one to their indices).\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T addStatement(int index, CtStatement statement);\n\n\t/**\n\t * Inserts the given statement at the beginning of the block.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T insertBegin(CtStatement statement);\n\n\t/**\n\t * Inserts the given statement list at the beginning of the block.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T insertBegin(CtStatementList statements);\n\n\t/**\n\t * Inserts the given statement at the end of the block.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T insertEnd(CtStatement statement);\n\n\t/**\n\t * Inserts the given statements at the end of the block.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\t<T extends CtStatementList> T insertEnd(CtStatementList statements);\n\n\t/**\n\t * Inserts the given statement before a set of insertion points given by a\n\t * filter.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatement statement);\n\n\t/**\n\t * Inserts the given statement list before a set of insertion points given\n\t * by a filter.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatementList statements);\n\n\t/**\n\t * Inserts the given statement after a set of insertion points given by a\n\t * filter.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatement statement);\n\n\t/**\n\t * Inserts the given statement list after a set of insertion points given by\n\t * a filter.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatementList statements);\n\n\t/**\n\t * Gets the ith statement of this block.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatement> T getStatement(int i);\n\n\t/**\n\t * Gets the last statement of this block.\n\t */\n\t@DerivedProperty\n\t<T extends CtStatement> T getLastStatement();\n\n\t/**\n\t * Removes a statement.\n\t */\n\t@PropertySetter(role = STATEMENT)\n\tvoid removeStatement(CtStatement statement);\n\n\t@Override\n\tCtStatementList clone();\n}\n"
    }, {
      "name" : "reflect/code/CtReturn.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.template.TemplateParameter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element represents a <code>return</code> statement.\n *\n * Example:\n * <pre>\n *    Runnable r = new Runnable() {\n *     \t&#64;Override\n *     \tpublic void run() {\n *     \t  return; // &lt;-- CtReturn statement\n *     \t}\n *    };\n * </pre>\n\n */\npublic interface CtReturn<R> extends CtCFlowBreak, TemplateParameter<Void> {\n\n\t/**\n\t * Gets the returned expression.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<R> getReturnedExpression();\n\n\t/**\n\t * Sets the returned expression.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtReturn<R>> T setReturnedExpression(CtExpression<R> returnedExpression);\n\n\t@Override\n\tCtReturn<R> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtUnaryOperator.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\n\n\n/**\n * This code element represents a unary operator.\n * For example :\n * <pre>\n *     int x=3;\n *     --x; // &lt;-- unary --\n * </pre>\n *\n * @param <T>\n * \t\t\"Return\" type of this expression\n */\npublic interface CtUnaryOperator<T> extends CtExpression<T>, CtStatement {\n\n\t/**\n\t * Gets the expression to which the operator is applied.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<T> getOperand();\n\n\t/**\n\t * Sets the expression to which the operator is applied.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<C extends CtUnaryOperator> C setOperand(CtExpression<T> expression);\n\n\t/**\n\t * Sets the kind of this operator.\n\t */\n\t@PropertySetter(role = OPERATOR_KIND)\n\t<C extends CtUnaryOperator> C setKind(UnaryOperatorKind kind);\n\n\t/**\n\t * Gets the kind of this operator.\n\t */\n\t@PropertyGetter(role = OPERATOR_KIND)\n\tUnaryOperatorKind getKind();\n\n\t@Override\n\tCtUnaryOperator<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtSuperAccess.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\n\n/**\n * This code element defines an access to super.\n *\n * Example:\n * <pre>\n *     class Foo { int foo() { return 42;}};\n *     class Bar extends Foo {\n *     int foo() {\n *       return super.foo(); // &lt;-- access to super\n *     }\n *     };\n * </pre>\n *\n * The target is used when one writes `SuperClass.super.foo()`.\n *\n * @param <T>\n * \t\tType of super\n */\npublic interface CtSuperAccess<T> extends CtVariableRead<T>, CtTargetedExpression<T, CtExpression<?>> {\n\t@Override\n\tCtSuperAccess<T> clone();\n\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<T> getType();\n}\n"
    }, {
      "name" : "reflect/code/CtBreak.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a break statement.\n * Example:\n * <pre>\n *     for(int i=0; i&lt;10; i++) {\n *         if (i&gt;3) {\n *\t\t\t\tbreak; // &lt;-- break statement\n *         }\n *     }\n * </pre>\n */\npublic interface CtBreak extends CtLabelledFlowBreak {\n\n\t@Override\n\tCtBreak clone();\n}\n"
    }, {
      "name" : "reflect/code/CtCodeSnippetStatement.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.compiler.SnippetCompilationError;\n\n/**\n * This element is a code snippet that must represent a statement and can thus\n * be inserted in the program's model as is. Code snippets should be avoided\n * since no controls can be performed on them.\n */\n\npublic interface CtCodeSnippetStatement extends CtStatement, CtCodeSnippet {\n\n\t/**\n\t * Compiles this statement code snippet to produce the corresponding AST\n\t * statement.\n\t *\n\t * If you want to compile a non-void return or a snippet that uses a non-void  return,\n\t * use, {@link spoon.support.compiler.SnippetCompilationHelper#compileStatement(CtCodeSnippetStatement, CtTypeReference)}\n\t *\n\t * @return a statement\n\t * @throws SnippetCompilationError\n\t * \t\twhen the current snippet is not valid Java code\n\t */\n\t<S extends CtStatement> S compile() throws SnippetCompilationError;\n\n\t@Override\n\tCtCodeSnippetStatement clone();\n}\n"
    }, {
      "name" : "reflect/code/CtVariableAccess.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.VARIABLE;\n\n/**\n * This code element defines an access to a variable (read and write).\n *\n * If you process this element, keep in mind that you will process var++ too.\n *\n * @param <T>\n * \t\ttype of the variable\n */\npublic interface CtVariableAccess<T> extends CtExpression<T> {\n\t/**\n\t * Gets the reference to the accessed variable.\n\t */\n\t@PropertyGetter(role = VARIABLE)\n\tCtVariableReference<T> getVariable();\n\n\t/**\n\t * Sets the reference to the accessed variable.\n\t */\n\t@PropertySetter(role = VARIABLE)\n\t<C extends CtVariableAccess<T>> C setVariable(CtVariableReference<T> variable);\n\n\t@Override\n\tCtVariableAccess<T> clone();\n\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<T> getType();\n}\n"
    }, {
      "name" : "reflect/code/CtVariableRead.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines an read access to a variable.\n *\n * In Java, it is a usage of a variable outside an assignment. For example,\n * <pre>\n *     String variable = \"\";\n *     System.out.println(\n *       variable // &lt;-- a variable read\n *     );\n * </pre>\n *\n * @param <T>\n * \t\ttype of the variable\n */\npublic interface CtVariableRead<T> extends CtVariableAccess<T> {\n\t@Override\n\tCtVariableRead<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtCatch.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.PARAMETER;\n\n\n/**\n * This code element defines a <code>catch</code> of a <code>try</code>.\n *\n * @see spoon.reflect.code.CtTry\n */\npublic interface CtCatch extends CtCodeElement, CtBodyHolder {\n\n\t/**\n\t * Gets the catch's parameter (a throwable).\n\t */\n\t@PropertyGetter(role = PARAMETER)\n\tCtCatchVariable<? extends Throwable> getParameter();\n\n\t/**\n\t * Sets the catch's parameter (a throwable).\n\t */\n\t@PropertySetter(role = PARAMETER)\n\t<T extends CtCatch> T setParameter(CtCatchVariable<? extends Throwable> parameter);\n\n\t/**\n\t * Gets the catch's body.\n\t */\n\t@Override\n\t@PropertyGetter(role = BODY)\n\tCtBlock<?> getBody();\n\n\t@Override\n\tCtCatch clone();\n}\n"
    }, {
      "name" : "reflect/code/CtDo.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n/**\n * This code element defines a <code>do</code> loop.\n *\n * Example:\n * <pre>\n *     int x = 0;\n *     do {\n *         x=x+1;\n *     } while (x&lt;10);\n * </pre>\n *\n */\npublic interface CtDo extends CtLoop {\n\t/**\n\t * Returns the looping test as a boolean expression.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<Boolean> getLoopingExpression();\n\n\t/**\n\t * Sets the looping test as a boolean expression.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtDo> T setLoopingExpression(CtExpression<Boolean> expression);\n\n\t@Override\n\tCtDo clone();\n}\n"
    }, {
      "name" : "reflect/code/CtJavaDocTag.java",
      "weight" : 56.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.COMMENT_CONTENT;\nimport static spoon.reflect.path.CtRole.JAVADOC_TAG_VALUE;\nimport static spoon.reflect.path.CtRole.DOCUMENTATION_TYPE;\n\n/**\n * This code element defines a javadoc tag\n *\n * Example:\n * <code>\n * @since name description\n * </code>\n */\npublic interface CtJavaDocTag extends CtElement {\n\n\t/**\n\t * The tag prefix\n\t */\n\tString JAVADOC_TAG_PREFIX = \"@\";\n\n\t/**\n\t * Define the possible type for a tag\n\t */\n\tenum TagType {\n\t\tAUTHOR,\n\t\tDEPRECATED,\n\t\tEXCEPTION,\n\t\tPARAM,\n\t\tRETURN,\n\t\tSEE,\n\t\tSERIAL,\n\t\tSERIAL_DATA,\n\t\tSERIAL_FIELD,\n\t\tSINCE,\n\t\tTHROWS,\n\t\tVERSION,\n\t\tUNKNOWN;\n\n\t\t/**\n\t\t * Return true if the tag can have a parameter\n\t\t * @return true if the tag can have a parameter\n\t\t */\n\t\tpublic boolean hasParam() {\n\t\t\treturn this == PARAM || this == THROWS;\n\t\t}\n\n\t\t/**\n\t\t * Get the tag type associated to a name\n\t\t * @param tagName the tag name\n\t\t * @return the tag type\n\t\t */\n\t\tpublic static TagType tagFromName(String tagName) {\n\t\t\tfor (TagType t : TagType.values()) {\n\t\t\t\tif (t.name().toLowerCase().equals(tagName.toLowerCase())) {\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn UNKNOWN;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn JAVADOC_TAG_PREFIX + name().toLowerCase();\n\t\t}\n\t}\n\n\t/**\n\t * The type of the tag\n\t * @return the type of the tag\n\t */\n\t@PropertyGetter(role = DOCUMENTATION_TYPE)\n\tTagType getType();\n\n\t/**\n\t * Define the type of the tag\n\t * @param type the type name\n\t */\n\t@PropertySetter(role = DOCUMENTATION_TYPE)\n\t<E extends CtJavaDocTag> E setType(String type);\n\n\t/**\n\t * Define the type of the tag\n\t * @param type the new type\n\t */\n\t@PropertySetter(role = DOCUMENTATION_TYPE)\n\t<E extends CtJavaDocTag> E setType(TagType type);\n\n\t/**\n\t * Get the content of the atg\n\t * @return the content of the tag\n\t */\n\t@PropertyGetter(role = COMMENT_CONTENT)\n\tString getContent();\n\n\t/**\n\t * Define the content of the tag\n\t * @param content the new content of the tag\n\t */\n\t@PropertySetter(role = COMMENT_CONTENT)\n\t<E extends CtJavaDocTag> E setContent(String content);\n\n\t/**\n\t * Get the parameter of the tag return null when none is specified (only for @param and @throws)\n\t * @return the parameter\n\t */\n\t@PropertyGetter(role = JAVADOC_TAG_VALUE)\n\tString getParam();\n\n\t/**\n\t * Define a parameter\n\t * @param param the parameter\n\t */\n\t@PropertySetter(role = JAVADOC_TAG_VALUE)\n\t<E extends CtJavaDocTag> E setParam(String param);\n\n\t@Override\n\tCtJavaDocTag clone();\n}\n"
    }, {
      "name" : "reflect/code/CtLabelledFlowBreak.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.DerivedProperty;\n\nimport static spoon.reflect.path.CtRole.TARGET_LABEL;\n\n/**\n * This abstract code element represents all the statements that break the\n * control flow of the program and which can support a label.\n */\npublic interface CtLabelledFlowBreak extends CtCFlowBreak {\n\t/**\n\t * Gets the label from which the control flow breaks (null if no label\n\t * defined).\n\t */\n\t@PropertyGetter(role = TARGET_LABEL)\n\tString getTargetLabel();\n\n\t/**\n\t * Sets the label from which the control flow breaks (null if no label\n\t * defined).\n\t */\n\t@PropertySetter(role = TARGET_LABEL)\n\t<T extends CtLabelledFlowBreak> T setTargetLabel(String targetLabel);\n\n\t@DerivedProperty\n\tCtStatement getLabelledStatement();\n}\n"
    }, {
      "name" : "reflect/code/CtThisAccess.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines an access to this.\n *\n * Example:\n * <pre>\n *     class Foo {\n *     int value = 42;\n *     int foo() {\n *       return this.value; // &lt;-- access to this\n *     }\n *     };\n\n * </pre>\n * @param <T>\n * \t\tType of this\n */\npublic interface CtThisAccess<T> extends CtTargetedExpression<T, CtExpression<?>> {\n\t@Override\n\tCtThisAccess<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtVariableWrite.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\n/**\n * This code element defines a write to a variable.\n *\n * In Java, it is a usage of a variable inside an assignment.\n *\n * For example:\n * <pre>\n *     String variable = \"\";\n *     variable = \"new value\"; // variable write\n * </pre>\n * <pre>\n *     String variable = \"\";\n *     variable += \"\";\n * </pre>\n *\n * If you process this element, keep in mind that you won't process var++.\n *\n * @param <T>\n * \t\ttype of the variable\n */\npublic interface CtVariableWrite<T> extends CtVariableAccess<T> {\n\t@Override\n\tCtVariableWrite<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtSynchronized.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\n\n/**\n * This code element defines a <code>synchronized</code> statement.\n *\n * Example:\n * <pre>\n *    java.util.List l = new java.util.ArrayList();\n *    synchronized(l) {\n *     \tSystem.out.println(\"foo\");\n *    }\n * </pre>\n */\npublic interface CtSynchronized extends CtStatement {\n\t/**\n\t * Gets the expression that defines the monitored object if any.\n\t *\n\t * @return the monitored object if defined, null otherwise\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<?> getExpression();\n\n\t/**\n\t * Sets the expression that defines the monitored.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtSynchronized> T setExpression(CtExpression<?> expression);\n\n\t/**\n\t * Gets the synchronized block.\n\t */\n\t@PropertyGetter(role = BODY)\n\tCtBlock<?> getBlock();\n\n\t/**\n\t * Sets the synchronized block.\n\t */\n\t@PropertySetter(role = BODY)\n\t<T extends CtSynchronized> T setBlock(CtBlock<?> block);\n\n\t@Override\n\tCtSynchronized clone();\n}\n"
    }, {
      "name" : "reflect/code/CtExpression.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.template.TemplateParameter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.CAST;\n\n/**\n * This abstract code element defines a typed expression.\n *\n * @param <T>\n * \t\tthe \"return type\" of this expression\n */\npublic interface CtExpression<T> extends CtCodeElement, CtTypedElement<T>, TemplateParameter<T> {\n\n\t/**\n\t * Returns the type casts if any.\n\t */\n\t@PropertyGetter(role = CAST)\n\tList<CtTypeReference<?>> getTypeCasts();\n\n\t/**\n\t * Sets the type casts.\n\t */\n\t@PropertySetter(role = CAST)\n\t<C extends CtExpression<T>> C setTypeCasts(List<CtTypeReference<?>> types);\n\n\t/**\n\t * Adds a type cast.\n\t */\n\t@PropertySetter(role = CAST)\n\t<C extends CtExpression<T>> C addTypeCast(CtTypeReference<?> type);\n\n\t@Override\n\tCtExpression<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtFor.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.FOR_INIT;\nimport static spoon.reflect.path.CtRole.FOR_UPDATE;\n\n/**\n * This code element defines a for loop.\n * Example:\n * <pre>\n *     // a for statement\n *     for(int i=0; i&lt;10; i++) {\n *     \tSystem.out.println(\"foo\");\n *     }\n * </pre>\n */\npublic interface CtFor extends CtLoop {\n\n\t/**\n\t * Gets the end-loop test expression.\n\t */\n\t@PropertyGetter(role = EXPRESSION)\n\tCtExpression<Boolean> getExpression();\n\n\t/**\n\t * Sets the end-loop test expression.\n\t */\n\t@PropertySetter(role = EXPRESSION)\n\t<T extends CtFor> T setExpression(CtExpression<Boolean> expression);\n\n\t/**\n\t * Gets the <i>init</i> statements.\n\t */\n\t@PropertyGetter(role = FOR_INIT)\n\tList<CtStatement> getForInit();\n\n\t/**\n\t * Adds an <i>init</i> statement.\n\t */\n\t@PropertySetter(role = FOR_INIT)\n\t<T extends CtFor> T addForInit(CtStatement statement);\n\n\t/**\n\t * Sets the <i>init</i> statements.\n\t */\n\t@PropertySetter(role = FOR_INIT)\n\t<T extends CtFor> T setForInit(List<CtStatement> forInit);\n\n\t/**\n\t * Removes an <i>init</i> statement.\n\t */\n\t@PropertySetter(role = FOR_INIT)\n\tboolean removeForInit(CtStatement statement);\n\n\t/**\n\t * Gets the <i>update</i> statements.\n\t */\n\t@PropertyGetter(role = FOR_UPDATE)\n\tList<CtStatement> getForUpdate();\n\n\t/**\n\t * Adds an <i>update</i> statement.\n\t */\n\t@PropertySetter(role = FOR_UPDATE)\n\t<T extends CtFor> T addForUpdate(CtStatement statement);\n\n\t/**\n\t * Sets the <i>update</i> statements.\n\t */\n\t@PropertySetter(role = FOR_UPDATE)\n\t<T extends CtFor> T setForUpdate(List<CtStatement> forUpdate);\n\n\t/**\n\t * Removes an <i>update</i> statement.\n\t */\n\t@PropertySetter(role = FOR_UPDATE)\n\tboolean removeForUpdate(CtStatement statement);\n\n\t@Override\n\tCtFor clone();\n}\n"
    }, {
      "name" : "reflect/code/CtRHSReceiver.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.ASSIGNMENT;\n\n/**\n * Represents the right hand side of an assignment\n *\n * See {@link CtAssignment}, {@link CtLocalVariable}, {@link CtField}\n */\npublic interface CtRHSReceiver<A> {\n\t/**\n\t * Returns the right-hand side of the \"=\" operator.\n\t */\n\t@PropertyGetter(role = ASSIGNMENT)\n\tCtExpression<A> getAssignment();\n\n\t/**\n\t * Sets the right-hand side expression (RHS) of the \"=\" operator.\n\t */\n\t@PropertySetter(role = ASSIGNMENT)\n\t<T extends CtRHSReceiver<A>> T setAssignment(CtExpression<A> assignment);\n}\n"
    }, {
      "name" : "reflect/code/CtAnnotationFieldAccess.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.annotations.PropertyGetter;\n\nimport static spoon.reflect.path.CtRole.VARIABLE;\n\n/**\n * This code element defines an access to a annotation parameter variable.\n *\n * @param <T>\n * \t\tType of this field\n */\npublic interface CtAnnotationFieldAccess<T> extends CtVariableRead<T>, CtTargetedExpression<T, CtExpression<?>> {\n\t@Override\n\t@PropertyGetter(role = VARIABLE)\n\tCtFieldReference<T> getVariable();\n\n\t@Override\n\tCtAnnotationFieldAccess<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtFieldAccess.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.annotations.PropertyGetter;\n\nimport static spoon.reflect.path.CtRole.VARIABLE;\n\n/**\n * This code element defines an access to a field variable (read and write)\n *\n * @param <T>\n * \t\tType of this field\n */\npublic interface CtFieldAccess<T> extends CtVariableAccess<T>, CtTargetedExpression<T, CtExpression<?>> {\n\t@Override\n\t@PropertyGetter(role = VARIABLE)\n\tCtFieldReference<T> getVariable();\n\n\t@Override\n\tCtFieldAccess<T> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtTargetedExpression.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.TARGET;\n\n\n/**\n * This abstract code element defines an expression which contains a target\n * expression. In Java, it is generally of the form:\n * <code>targetExpr.targetedExpr</code>.\n *\n * @param <T>\n * \t\t\"Return\" type of this expression\n * @param <E>\n * \t\tType of the target\n */\npublic interface CtTargetedExpression<T, E extends CtExpression<?>> extends CtExpression<T> {\n\t/**\n\t * Gets the target expression. The target is a `CtTypeAccess` for static methods and a sub type of `CtExpression` for everything else.\n\t */\n\t@PropertyGetter(role = TARGET)\n\tE getTarget();\n\n\t/**\n\t * Sets the target expression.\n\t */\n\t@PropertySetter(role = TARGET)\n\t<C extends CtTargetedExpression<T, E>> C setTarget(E target);\n\n\t@Override\n\tCtTargetedExpression<T, E> clone();\n}\n"
    }, {
      "name" : "reflect/code/CtConstructorCall.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.code;\n\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TYPE;\nimport static spoon.reflect.path.CtRole.TYPE_ARGUMENT;\n\n/**\n * This code element represents a constructor call.\n *\n * Example:<pre>\n *     new Object();\n * </pre>\n *\n * To build a constructor call, see {@link DefaultCoreFactory#createConstructorCall()}.\n *\n * @param <T>\n * \t\tcreated type\n */\npublic interface CtConstructorCall<T> extends CtTargetedExpression<T, CtExpression<?>>, CtAbstractInvocation<T>, CtStatement, CtActualTypeContainer {\n\t/**\n\t * Delegate to the executable reference of the constructor call.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@DerivedProperty\n\t@PropertyGetter(role = TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> getActualTypeArguments();\n\n\t/**\n\t * Delegate to the executable reference of the constructor call.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments);\n\n\t/**\n\t * Delegate to the executable reference of the constructor call.\n\t *\n\t * @see CtExecutableReference#getActualTypeArguments()\n\t */\n\t@Override\n\t@PropertySetter(role = TYPE_ARGUMENT)\n\t<T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument);\n\n\t@Override\n\tCtConstructorCall<T> clone();\n\n\t@Override\n\t@DerivedProperty\n\t@PropertyGetter(role = TYPE)\n\tCtTypeReference<T> getType();\n}\n"
    }, {
      "name" : "reflect/cu/SourcePositionHolder.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu;\n\nimport spoon.support.sniper.internal.ElementSourceFragment;\nimport spoon.support.Experimental;\n\n/**\n * This interface represents an element which knows its position in a source file.\n */\npublic interface SourcePositionHolder {\n\t/** If the element comes from a Java source file (hence has not created during transformation), returns the position in the original source file */\n\tSourcePosition getPosition();\n\n\t/**\n\t * Returns the original source code (maybe different from toString() if a transformation has been applied.\n\t * Or {@link ElementSourceFragment#NO_SOURCE_FRAGMENT} if this element has no original source fragment.\n\t *\n\t * Warning: this is a advanced method which cannot be considered as part of the stable API\n\t *\n\t */\n\t@Experimental\n\tdefault ElementSourceFragment getOriginalSourceFragment() {\n\t\treturn ElementSourceFragment.NO_SOURCE_FRAGMENT;\n\t}\n}\n"
    }, {
      "name" : "reflect/cu/position/BodyHolderSourcePosition.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu.position;\n\n/**\n * This interface represents the position of a Method or Type declaration in a source file.\n * The start/end represents range of whole program element including children element and comments\n * The nameStart/End represents range of name of program element.\n * The modifierSourceStart/End represents range of modifiers and annotations of the element\n * The bodyStart/End represents range of body of the element\n */\npublic interface BodyHolderSourcePosition extends DeclarationSourcePosition {\n\n\tint getBodyStart();\n\n\tint getBodyEnd();\n\n}\n"
    }, {
      "name" : "reflect/cu/position/DeclarationSourcePosition.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu.position;\n\n/**\n * This interface represents the position of a program element in a source file.\n * The start/end represents range of whole program element including children element and comments\n * The nameStart/End represents range of name of program element.\n * The modifierSourceStart/End represents range of modifiers and annotations of the element\n */\npublic interface DeclarationSourcePosition extends CompoundSourcePosition {\n\n\tint getModifierSourceStart();\n\n\tint getModifierSourceEnd();\n\n}\n"
    }, {
      "name" : "reflect/cu/position/NoSourcePosition.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu.position;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\n\nimport java.io.File;\nimport java.io.Serializable;\n\n/**\n * This class represents the position of a program element in a source file.\n */\npublic class NoSourcePosition implements SourcePosition, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic File getFile() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CompilationUnit getCompilationUnit() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isValidPosition() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int getLine() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic int getEndLine() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic int getColumn() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic int getEndColumn() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic int getSourceEnd() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic int getSourceStart() {\n\t\tthrow new UnsupportedOperationException(\"PartialSourcePosition only contains a CompilationUnit\");\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(unknown file)\";\n\t}\n}\n"
    }, {
      "name" : "reflect/cu/position/CompoundSourcePosition.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu.position;\n\nimport spoon.reflect.cu.SourcePosition;\n\n/**\n * This interface represents the position of a program element like an expression in a source file.\n * The start/end represents range of whole program element including children element and comments\n * The nameStart/End represents range of core part of program element.\n */\npublic interface CompoundSourcePosition extends SourcePosition {\n\n\tint getNameStart();\n\n\tint getNameEnd();\n\n}\n"
    }, {
      "name" : "reflect/cu/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines compilation units that hold the source code and some classes around them (in most cases, these features should be ignored by the programmers).</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.cu;\n"
    }, {
      "name" : "reflect/cu/CompilationUnit.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu;\n\nimport spoon.reflect.declaration.CtCompilationUnit;\n\n/**\n * Defines a compilation unit. In Java, a compilation unit can contain only one\n * public type declaration and other secondary types declarations (not public).\n */\npublic interface CompilationUnit extends CtCompilationUnit {\n\n\n\t/**\n\t * Helper method to get the begin index of the line that corresponds to the\n\t * given index.\n\t *\n\t * @param index\n\t * \t\tan arbitrary index in the source code\n\t * @return the index where the line starts\n\t */\n\t@Deprecated\n\tint beginOfLineIndex(int index);\n\n\t/**\n\t * Helper method to get the begin index of the line that corresponds to the\n\t * next line of the given index.\n\t *\n\t * @param index\n\t * \t\tan arbitrary index in the source code\n\t * @return the index where the next line starts\n\t */\n\t@Deprecated\n\tint nextLineIndex(int index);\n\n\t/**\n\t * Gets the number of tabulations for a given line.\n\t *\n\t * @param index\n\t * \t\tthe index where the line starts in the source code\n\t * @return the number of tabs for this line\n\t */\n\t@Deprecated\n\tint getTabCount(int index);\n}\n"
    }, {
      "name" : "reflect/cu/SourcePosition.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.cu;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.cu.position.NoSourcePosition;\n\nimport java.io.File;\nimport java.io.Serializable;\n\n/**\n * This interface represents the position of a program element in a source file.\n */\npublic interface SourcePosition extends Serializable {\n\n\tSourcePosition NOPOSITION = new NoSourcePosition();\n\n\t/**\n\t * @return true if this instance holds start/end indexes of related sources.\n\t * false if they are unknown\n\t */\n\tboolean isValidPosition();\n\n\t/**\n\t * Returns a string representation of this position in the form\n\t * \"sourcefile:line\", or \"sourcefile\" if no line number is available.\n\t */\n\tString toString();\n\n\t/**\n\t * Gets the file for this position.\n\t */\n\tFile getFile();\n\n\t/**\n\t * Gets the compilation unit for this position.\n\t */\n\tCompilationUnit getCompilationUnit();\n\n\t/**\n\t * Gets the line in the source file (1 indexed). Prefer using\n\t * {@link #getSourceStart()}}.\n\t * For CtNamedElement the line is where the name is declared.\n\t */\n\tint getLine();\n\n\t/**\n\t * Gets the end line in the source file (1 indexed). Prefer using\n\t * {@link #getSourceEnd()}}.\n\t */\n\tint getEndLine();\n\n\t/**\n\t * Gets the column in the source file (1 indexed). This method is slow\n\t * because it has to calculate the column number depending on\n\t * {@link Environment#getTabulationSize()} and\n\t * {@link CompilationUnit#getOriginalSourceCode()}. Prefer {@link #getSourceStart()}.\n\t */\n\tint getColumn();\n\n\t/**\n\t * Gets the end column in the source file (1 indexed). This method is slow\n\t * because it has to calculate the column number depending on\n\t * {@link Environment#getTabulationSize()} and\n\t * {@link CompilationUnit#getOriginalSourceCode()}. Prefer {@link #getSourceEnd()}.\n\t */\n\tint getEndColumn();\n\n\t/**\n\t * Gets the index at which the position ends in the source file.\n\t */\n\tint getSourceEnd();\n\n\t/**\n\t * Gets the index at which the position starts in the source file.\n\t */\n\tint getSourceStart();\n}\n"
    }, {
      "name" : "reflect/factory/ClassFactory.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtPackage;\n\n/**\n * The {@link CtClass} sub-factory.\n */\npublic class ClassFactory extends TypeFactory {\n\n\t/**\n\t * Creates a class sub-factory.\n\t *\n\t * @param factory\n\t *            the parent factory\n\t */\n\tpublic ClassFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates an inner class.\n\t *\n\t * @param declaringClass\n\t *            declaring class\n\t * @param simpleName\n\t *            simple name of inner class (without . or $)\n\t */\n\tpublic <T> CtClass<T> create(CtClass<?> declaringClass, String simpleName) {\n\t\tCtClass<T> c = factory.Core().createClass();\n\t\tc.setSimpleName(simpleName);\n\t\tdeclaringClass.addNestedType(c);\n\t\treturn c;\n\t}\n\n\t/**\n\t * Creates a top-level class.\n\t *\n\t * @param owner\n\t *            the declaring package\n\t * @param simpleName\n\t *            the simple name\n\t */\n\tpublic <T> CtClass<T> create(CtPackage owner, String simpleName) {\n\t\tCtClass<T> c = factory.Core().createClass();\n\t\tc.setSimpleName(simpleName);\n\t\towner.addType(c);\n\t\treturn c;\n\t}\n\n\t/**\n\t * Creates a class from its qualified name.\n\t *\n\t * @param <T>\n\t *            type of created class\n\t * @param qualifiedName\n\t *            full name of class to create. Name can contain . or $ for\n\t *            inner types\n\t */\n\tpublic <T> CtClass<T> create(String qualifiedName) {\n\t\tif (hasInnerType(qualifiedName) > 0) {\n\t\t\tCtClass<?> declaringClass = create(getDeclaringTypeName(qualifiedName));\n\t\t\treturn create(declaringClass, getSimpleName(qualifiedName));\n\t\t}\n\t\treturn create(factory.Package().getOrCreate(\n\t\t\t\tgetPackageName(qualifiedName)), getSimpleName(qualifiedName));\n\t}\n\n\t/**\n\t * Gets a class from its runtime Java class.\n\t *\n\t * @param <T>\n\t *            type of created class\n\t * @param cl\n\t *            the java class: note that this class should be Class&lt;T&gt; but\n\t *            it then poses problem when T is a generic type itself\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtClass<T> get(Class<?> cl) {\n\t\ttry {\n\t\t\treturn (CtClass<T>) super.get(cl);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Searches for a class from his qualified name.\n\t *\n\t * @param <T>\n\t *            the type of the class\n\t * @param qualifiedName\n\t *            to search\n\t * @return found class or null\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtClass<T> get(String qualifiedName) {\n\t\ttry {\n\t\t\treturn (CtClass<T>) super.get(qualifiedName);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * \t<p>This package defines all the sub-factories for the Spoon meta-model.\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.factory;\n"
    }, {
      "name" : "reflect/factory/CodeFactory.java",
      "weight" : 326.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This sub-factory contains utility methods to create code elements. To avoid\n * over-using reflection, consider using {@link spoon.template.Template}.\n */\npublic class CodeFactory extends SubFactory {\n\n\t/**\n\t * Creates a {@link spoon.reflect.code.CtCodeElement} sub-factory.\n\t */\n\tpublic CodeFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a binary operator.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the expression\n\t * @param left\n\t * \t\tthe left operand\n\t * @param right\n\t * \t\tthe right operand\n\t * @param kind\n\t * \t\tthe operator kind\n\t * @return a binary operator expression\n\t */\n\tpublic <T> CtBinaryOperator<T> createBinaryOperator(CtExpression<?> left, CtExpression<?> right, BinaryOperatorKind kind) {\n\t\treturn factory.Core().<T>createBinaryOperator().setLeftHandOperand(left).setKind(kind).setRightHandOperand(right);\n\t}\n\n\t/**\n\t * Creates a accessed type.\n\t *\n\t * <p>This method sets a <i>clone</i> of the given {@code accessedType} object to the\n\t * {@linkplain CtTypeAccess#getAccessedType() accessedType} field of the returned {@link CtTypeAccess}. If the\n\t * given {@code accessedType} is unique and cloning is not needed, use\n\t * {@link #createTypeAccessWithoutCloningReference(CtTypeReference)} instead of this method.</p>\n\t * @param accessedType a type reference to the accessed type.\n\t * @param <T> the type of the expression.\n\t * @return a accessed type expression.\n\t */\n\tpublic <T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType) {\n\t\tif (accessedType == null) {\n\t\t\treturn factory.Core().createTypeAccess();\n\t\t}\n\t\tCtTypeReference<T> access = accessedType.clone();\n\t\t// a type access doesn't contain actual type parameters\n\t\taccess.setActualTypeArguments(null);\n\t\treturn createTypeAccessWithoutCloningReference(access);\n\t}\n\n\t/**\n\t * Creates a accessed type.\n\t *\n\t * <p>This method sets a <i>clone</i> of the given {@code accessedType} object to the\n\t * {@linkplain CtTypeAccess#getAccessedType() accessedType} field of the returned {@link CtTypeAccess}. If the\n\t * given {@code accessedType} is unique and cloning is not needed, use\n\t * {@link #createTypeAccessWithoutCloningReference(CtTypeReference)} instead of this method.</p>\n\t *\n\t * @param accessedType\n\t * \t\ta type reference to the accessed type.\n\t * @param isImplicit\n\t * \t\ttype of the type access is implicit or not.\n\t * @param <T>\n\t * \t\tthe type of the expression.\n\t * @return a accessed type expression.\n\t */\n\tpublic <T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType, boolean isImplicit) {\n\t\treturn createTypeAccess(accessedType).setImplicit(isImplicit);\n\t}\n\n\t/**\n\t * Creates a accessed type, see {@link #createTypeAccess(CtTypeReference)} for details.\n\t * @param accessedType a type reference to the accessed type.\n\t * @param <T> the type of the expression.\n\t * @return a accessed type expression.\n\t */\n\tpublic <T> CtTypeAccess<T> createTypeAccessWithoutCloningReference(CtTypeReference<T> accessedType) {\n\t\tfinal CtTypeAccess<T> typeAccess = factory.Core().createTypeAccess();\n\t\ttypeAccess.setAccessedType(accessedType);\n\t\treturn typeAccess;\n\t}\n\n\t/**\n\t * Creates a class access expression of the form <code>C.class</code>.\n\t *\n\t * @param <T>\n\t * \t\tthe actual type of the accessed class if available\n\t * @param type\n\t * \t\ta type reference to the accessed class\n\t * @return the class access expression.\n\t */\n\tpublic <T> CtFieldAccess<Class<T>> createClassAccess(CtTypeReference<T> type) {\n\t\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) CtTypeReference<Class<T>> classType = (CtTypeReference) factory.Type().createReference(Class.class);\n\t\tCtTypeAccess<T> typeAccess = factory.Code().createTypeAccess(type);\n\n\t\tCtFieldReference<Class<T>> fieldReference = factory.Core().createFieldReference();\n\t\tfieldReference.setSimpleName(\"class\");\n\t\tfieldReference.setType(classType);\n\t\tfieldReference.setDeclaringType(type);\n\n\t\tCtFieldRead<Class<T>> fieldRead = factory.Core().createFieldRead();\n\t\tfieldRead.setType(classType.clone());\n\t\tfieldRead.setVariable(fieldReference);\n\t\tfieldRead.setTarget(typeAccess);\n\t\treturn fieldRead;\n\t}\n\n\t/**\n\t * Creates a constructor call. The correct constructor is inferred based on parameters\n\t *\n\t * @param type the decelerating type of the constructor\n\t * @param parameters the arguments of the constructor call\n\t * @param <T> the actual type of the decelerating type of the constructor if available\n\t * @return the constructor call\n\t */\n\tpublic <T> CtConstructorCall<T> createConstructorCall(CtTypeReference<T> type, CtExpression<?>...parameters) {\n\t\tCtConstructorCall<T> constructorCall = factory.Core()\n\t\t\t\t.createConstructorCall();\n\t\tCtExecutableReference<T> executableReference = factory.Core()\n\t\t\t\t.createExecutableReference();\n\t\texecutableReference.setType(type);\n\t\texecutableReference.setDeclaringType(type == null ? type : type.clone());\n\t\texecutableReference.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\t\tList<CtTypeReference<?>> typeReferences = new ArrayList<>();\n\t\tfor (CtExpression<?> parameter : parameters) {\n\t\t\ttypeReferences.add(parameter.getType());\n\t\t}\n\t\texecutableReference.setParameters(typeReferences);\n\t\tconstructorCall.setArguments(Arrays.asList(parameters));\n\t\tconstructorCall.setExecutable(executableReference);\n\t\treturn constructorCall;\n\t}\n\n\t/**\n\t * Creates a new anonymous class.\n\t */\n\tpublic <T> CtNewClass<T> createNewClass(CtType<T> superClass, CtExpression<?>...parameters) {\n\t\tCtNewClass<T> ctNewClass = factory.Core().createNewClass();\n\t\tCtConstructor<T> constructor = ((CtClass) superClass).getConstructor(Arrays.stream(parameters).map(x -> x.getType()).toArray(CtTypeReference[]::new));\n\t\tif (constructor == null) {\n\t\t\tthrow new SpoonException(\"no appropriate constructor for these parameters \" + parameters.toString());\n\t\t}\n\t\tCtExecutableReference<T> executableReference = constructor.getReference();\n\t\tctNewClass.setArguments(Arrays.asList(parameters));\n\t\tctNewClass.setExecutable(executableReference);\n\t\tCtClass c = superClass.getFactory().createClass();\n\t\tc.setSuperclass(superClass.getReference());\n\t\tc.setSimpleName(\"0\");\n\t\tctNewClass.setAnonymousClass(c);\n\t\treturn ctNewClass;\n\t}\n\n\t/**\n\t * Creates an invocation (can be a statement or an expression).\n\t *\n\t * @param <T>\n\t * \t\tthe return type of the invoked method\n\t * @param target\n\t * \t\tthe target expression\n\t * @param executable\n\t * \t\tthe invoked executable\n\t * @param arguments\n\t * \t\tthe argument list\n\t * @return the new invocation\n\t */\n\tpublic <T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, CtExpression<?>... arguments) {\n\t\tList<CtExpression<?>> ext = new ArrayList<>(arguments.length);\n\t\tCollections.addAll(ext, arguments);\n\t\treturn createInvocation(target, executable, ext);\n\t}\n\n\t/**\n\t * Creates an invocation (can be a statement or an expression).\n\t *\n\t * @param <T>\n\t * \t\tthe return type of the invoked method\n\t * @param target\n\t * \t\tthe target expression (may be null for static methods)\n\t * @param executable\n\t * \t\tthe invoked executable\n\t * @param arguments\n\t * \t\tthe argument list\n\t * @return the new invocation\n\t */\n\tpublic <T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, List<CtExpression<?>> arguments) {\n\t\treturn factory.Core().<T>createInvocation().<CtInvocation<T>>setTarget(target).<CtInvocation<T>>setExecutable(executable).setArguments(arguments);\n\t}\n\n\t/**\n\t * Creates a literal with a given value.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the literal\n\t * @param value\n\t * \t\tthe value of the literal\n\t * @return a new literal\n\t */\n\tpublic <T> CtLiteral<T> createLiteral(T value) {\n\t\tCtLiteral<T> literal = factory.Core().<T>createLiteral();\n\t\tliteral.setValue(value);\n\t\tif (value != null) {\n\t\t\tliteral.setType((CtTypeReference<T>) factory.Type().<T>createReference((Class<T>) value.getClass()).unbox());\n\t\t} else {\n\t\t\tliteral.setType((CtTypeReference<T>) factory.Type().nullType());\n\t\t}\n\t\treturn literal;\n\t}\n\n\t/**\n\t * Creates a one-dimension array that must only contain literals.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtNewArray<T[]> createLiteralArray(T[] value) {\n\t\tif (!value.getClass().isArray()) {\n\t\t\tthrow new RuntimeException(\"value is not an array\");\n\t\t}\n\t\tif (value.getClass().getComponentType().isArray()) {\n\t\t\tthrow new RuntimeException(\"can only create one-dimension arrays\");\n\t\t}\n\t\tfinal CtTypeReference<T> componentTypeRef = factory.Type().createReference((Class<T>) value.getClass().getComponentType());\n\t\tfinal CtArrayTypeReference<T[]> arrayReference = factory.Type().createArrayReference(componentTypeRef);\n\t\tCtNewArray<T[]> array = factory.Core().<T[]>createNewArray().setType(arrayReference);\n\t\tfor (T e : value) {\n\t\t\tCtLiteral<T> l = factory.Core().createLiteral();\n\t\t\tl.setValue(e);\n\t\t\tarray.addElement(l);\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * Creates a local variable declaration.\n\t *\n\t * @param <T>\n\t * \t\tthe local variable type\n\t * @param type\n\t * \t\tthe reference to the type\n\t * @param name\n\t * \t\tthe name of the variable\n\t * @param defaultExpression\n\t * \t\tthe assigned default expression\n\t * @return a new local variable declaration\n\t */\n\tpublic <T> CtLocalVariable<T> createLocalVariable(CtTypeReference<T> type, String name, CtExpression<T> defaultExpression) {\n\t\treturn factory.Core().<T>createLocalVariable().<CtLocalVariable<T>>setSimpleName(name).<CtLocalVariable<T>>setType(type).setDefaultExpression(defaultExpression);\n\t}\n\n\t/**\n\t * Creates a local variable reference that points to an existing local\n\t * variable (strong referencing).\n\t */\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference(CtLocalVariable<T> localVariable) {\n\t\tCtLocalVariableReference<T> ref = factory.Core().createLocalVariableReference();\n\t\tref.setType(localVariable.getType() == null ? null : localVariable.getType().clone());\n\t\tref.setSimpleName(localVariable.getSimpleName());\n\t\tref.setParent(localVariable);\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Creates a local variable reference with its name an type (weak\n\t * referencing).\n\t */\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference(CtTypeReference<T> type, String name) {\n\t\treturn factory.Core().<T>createLocalVariableReference().setType(type).setSimpleName(name);\n\t}\n\n\t/**\n\t * Creates a catch variable declaration.\n\t *\n\t * @param <T>\n\t * \t\tthe catch variable type\n\t * @param type\n\t * \t\tthe reference to the type\n\t * @param name\n\t * \t\tthe name of the variable\n\t * @param modifierKinds\n\t * \t\tModifiers of the catch variable\n\t * @return a new catch variable declaration\n\t */\n\tpublic <T> CtCatchVariable<T> createCatchVariable(CtTypeReference<T> type, String name, ModifierKind...modifierKinds) {\n\t\treturn factory.Core().<T>createCatchVariable().<CtCatchVariable<T>>setSimpleName(name).<CtCatchVariable<T>>setType(type).setModifiers(new HashSet<>(Arrays.asList(modifierKinds)));\n\t}\n\n\t/**\n\t * Creates a catch variable reference that points to an existing catch\n\t * variable (strong referencing).\n\t */\n\tpublic <T> CtCatchVariableReference<T> createCatchVariableReference(CtCatchVariable<T> catchVariable) {\n\t\treturn factory.Core().<T>createCatchVariableReference().setType(catchVariable.getType()).<CtCatchVariableReference<T>>setSimpleName(catchVariable.getSimpleName());\n\t}\n\n\t/**\n\t * Creates a new statement list from an existing block.\n\t */\n\tpublic <R> CtStatementList createStatementList(CtBlock<R> block) {\n\t\tCtStatementList l = factory.Core().createStatementList();\n\t\tfor (CtStatement s : block.getStatements()) {\n\t\t\tl.addStatement(s.clone());\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * Creates an explicit access to a <code>this</code> variable (of the form\n\t * <code>type.this</code>).\n\t *\n\t * @param <T>\n\t * \t\tthe actual type of <code>this</code>\n\t * @param type\n\t * \t\tthe reference to the type that holds the <code>this</code>\n\t * \t\tvariable\n\t * @return a <code>type.this</code> expression\n\t */\n\tpublic <T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type) {\n\t\treturn createThisAccess(type, false);\n\t}\n\n\t/**\n\t * Creates an access to a <code>this</code> variable (of the form\n\t * <code>type.this</code>).\n\t *\n\t * @param <T>\n\t * \t\tthe actual type of <code>this</code>\n\t * @param type\n\t * \t\tthe reference to the type that holds the <code>this</code>\n\t * \t\tvariable\n\t * @param isImplicit\n\t * \t\ttype of the this access is implicit or not.\n\t * @return a <code>type.this</code> expression\n\t */\n\tpublic <T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type, boolean isImplicit) {\n\t\tCtThisAccess<T> thisAccess = factory.Core().<T>createThisAccess();\n\t\tthisAccess.setImplicit(isImplicit);\n\t\tthisAccess.setType(type);\n\t\tCtTypeAccess<T> typeAccess = factory.Code().createTypeAccess(type);\n\t\tthisAccess.setTarget(typeAccess);\n\t\treturn thisAccess;\n\t}\n\n\t/**\n\t * Creates a variable access.\n\t */\n\tpublic <T> CtVariableAccess<T> createVariableRead(CtVariableReference<T> variable, boolean isStatic) {\n\t\tCtVariableAccess<T> va;\n\t\tif (variable instanceof CtFieldReference) {\n\t\t\tva = factory.Core().createFieldRead();\n\t\t\t// creates a this target for non-static fields to avoid name conflicts...\n\t\t\tif (!isStatic) {\n\t\t\t\t((CtFieldAccess<T>) va).setTarget(createThisAccess(((CtFieldReference<T>) variable).getDeclaringType()));\n\t\t\t}\n\t\t} else {\n\t\t\tva = factory.Core().createVariableRead();\n\t\t}\n\t\treturn va.setVariable(variable);\n\t}\n\n\t/**\n\t * Creates a list of variable accesses.\n\t *\n\t * @param variables\n\t * \t\tthe variables to be accessed\n\t */\n\tpublic List<CtExpression<?>> createVariableReads(List<? extends CtVariable<?>> variables) {\n\t\tList<CtExpression<?>> result = new ArrayList<>(variables.size());\n\t\tfor (CtVariable<?> v : variables) {\n\t\t\tresult.add(createVariableRead(v.getReference(), v.getModifiers().contains(ModifierKind.STATIC)));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a variable assignment (can be an expression or a statement).\n\t *\n\t * @param <T>\n\t * \t\tthe type of the assigned variable\n\t * @param variable\n\t * \t\ta reference to the assigned variable\n\t * @param isStatic\n\t * \t\ttells if the assigned variable is static or not\n\t * @param expression\n\t * \t\tthe assigned expression\n\t * @return a variable assignment\n\t */\n\tpublic <A, T extends A> CtAssignment<A, T> createVariableAssignment(CtVariableReference<A> variable, boolean isStatic, CtExpression<T> expression) {\n\t\tCtVariableAccess<A> vaccess = createVariableRead(variable, isStatic);\n\t\treturn factory.Core().<A, T>createAssignment().<CtAssignment<A, T>>setAssignment(expression).setAssigned(vaccess);\n\t}\n\n\t/**\n\t * Creates a list of statements that contains the assignments of a set of\n\t * variables.\n\t *\n\t * @param variables\n\t * \t\tthe variables to be assigned\n\t * @param expressions\n\t * \t\tthe assigned expressions\n\t * @return a list of variable assignments\n\t */\n\tpublic <T> CtStatementList createVariableAssignments(List<? extends CtVariable<T>> variables, List<? extends CtExpression<T>> expressions) {\n\t\tCtStatementList result = factory.Core().createStatementList();\n\t\tfor (int i = 0; i < variables.size(); i++) {\n\t\t\tresult.addStatement(createVariableAssignment(variables.get(i).getReference(), variables.get(i).getModifiers().contains(ModifierKind.STATIC), expressions.get(i)));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a field.\n\t *\n\t * @param name\n\t * \t\tName of the field.\n\t * @param type\n\t * \t\tType of the field.\n\t * @param exp\n\t * \t\tDefault expression of the field.\n\t * @param visibilities\n\t * \t\tAll visibilities of the field.\n\t * @param <T>\n\t * \t\tGeneric type for the type of the field.\n\t * @return a field\n\t */\n\tpublic <T> CtField<T> createCtField(String name, CtTypeReference<T> type, String exp, ModifierKind... visibilities) {\n\t\treturn factory.Core().createField().<CtField<T>>setModifiers(modifiers(visibilities)).<CtField<T>>setSimpleName(name).<CtField<T>>setType(type)\n\t\t\t\t.setDefaultExpression(this.<T>createCodeSnippetExpression(exp));\n\t}\n\n\t/**\n\t * Creates a block.\n\t *\n\t * @param element\n\t * \t\tStatement of the block.\n\t * @param <T>\n\t * \t\tSubclasses of CtStatement.\n\t * @return a block.\n\t */\n\tpublic <T extends CtStatement> CtBlock<?> createCtBlock(T element) {\n\t\treturn factory.Core().createBlock().addStatement(element);\n\t}\n\n\t/**\n\t * Accepts instance of CtStatement or CtBlock.\n\t * If element is CtStatement, then it creates wrapping CtBlock, which contains the element\n\t * If element is CtBlock, then it directly returns that element\n\t * If element is null, then it returns null.\n\t * note: It must not create empty CtBlock - as expected in CtCatch, CtExecutable, CtLoop and CtTry setBody implementations\n\t * @param element\n\t * @return CtBlock instance\n\t */\n\tpublic <T extends CtStatement> CtBlock<?> getOrCreateCtBlock(T element) {\n\t\tif (element == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (element instanceof CtBlock<?>) {\n\t\t\treturn (CtBlock<?>) element;\n\t\t}\n\t\treturn this.createCtBlock(element);\n\t}\n\n\t/**\n\t * Creates a throw.\n\t *\n\t * @param thrownExp\n\t * \t\tExpression of the throw.\n\t * @return a throw.\n\t */\n\tpublic CtThrow createCtThrow(String thrownExp) {\n\t\treturn factory.Core().createThrow().setThrownExpression(this.<Throwable>createCodeSnippetExpression(thrownExp));\n\t}\n\n\t/**\n\t * Creates a catch element.\n\t *\n\t * @param nameCatch\n\t * \t\tName of the variable in the catch.\n\t * @param exception\n\t * \t\tType of the exception.\n\t * @param ctBlock\n\t * \t\tContent of the catch.\n\t * @return a catch.\n\t */\n\tpublic CtCatch createCtCatch(String nameCatch, Class<? extends Throwable> exception, CtBlock<?> ctBlock) {\n\t\tfinal CtCatchVariable<Throwable> catchVariable = factory.Core().<Throwable>createCatchVariable().<CtCatchVariable<Throwable>>setType(this.<Throwable>createCtTypeReference(exception))\n\t\t\t\t.setSimpleName(nameCatch);\n\t\treturn factory.Core().createCatch().setParameter(catchVariable).setBody(ctBlock);\n\t}\n\n\t/**\n\t * Creates a type reference.\n\t *\n\t * @param originalClass\n\t * \t\tOriginal class of the reference.\n\t * @param <T>\n\t * \t\tType of the reference.\n\t * @return a type reference.\n\t */\n\tpublic <T> CtTypeReference<T> createCtTypeReference(Class<?> originalClass) {\n\t\tif (originalClass == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<T> typeReference = factory.Core().<T>createTypeReference();\n\t\ttypeReference.setSimpleName(originalClass.getSimpleName());\n\t\tif (originalClass.isPrimitive()) {\n\t\t\treturn typeReference;\n\t\t}\n\t\tif (originalClass.getDeclaringClass() != null) {\n\t\t\t// the inner class reference does not have package\n\t\t\treturn typeReference.setDeclaringType(createCtTypeReference(originalClass.getDeclaringClass()));\n\t\t}\n\t\treturn typeReference.setPackage(createCtPackageReference(originalClass.getPackage()));\n\t}\n\n\t/**\n\t * Creates a package reference.\n\t *\n\t * @param originalPackage\n\t * \t\tOriginal package of the reference.\n\t * @return a package reference.\n\t */\n\tpublic CtPackageReference createCtPackageReference(Package originalPackage) {\n\t\treturn factory.Core().createPackageReference().setSimpleName(originalPackage.getName());\n\t}\n\n\t/**\n\t * Creates an annotation.\n\t *\n\t * @param annotationType\n\t * \t\tType of the annotation.\n\t * @return an annotation.\n\t */\n\tpublic <A extends Annotation> CtAnnotation<A> createAnnotation(CtTypeReference<A> annotationType) {\n\t\tfinal CtAnnotation<A> a = factory.Core().createAnnotation();\n\t\ta.setAnnotationType(annotationType);\n\t\treturn a;\n\t}\n\n\t/**\n\t * Gets a list of references from a list of elements.\n\t *\n\t * @param <R>\n\t * \t\tthe expected reference type\n\t * @param <E>\n\t * \t\tthe element type\n\t * @param elements\n\t * \t\tthe element list\n\t * @return the corresponding list of references\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <R extends CtReference, E extends CtNamedElement> List<R> getReferences(List<E> elements) {\n\t\tList<R> refs = new ArrayList<>(elements.size());\n\t\tfor (E e : elements) {\n\t\t\trefs.add((R) e.getReference());\n\t\t}\n\t\treturn refs;\n\t}\n\n\t/**\n\t * Creates a modifier set.\n\t *\n\t * @param modifiers\n\t * \t\tto put in set\n\t * @return Set of given modifiers\n\t */\n\tpublic Set<ModifierKind> modifiers(ModifierKind... modifiers) {\n\t\tSet<ModifierKind> ret = EnumSet.noneOf(ModifierKind.class);\n\t\tCollections.addAll(ret, modifiers);\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Creates a Code Snippet expression.\n\t *\n\t * @param <T>\n\t * \t\tThe type of the expression represented by the CodeSnippet\n\t * @param expression\n\t * \t\tThe string that contains the expression.\n\t * @return a new CtCodeSnippetExpression.\n\t */\n\tpublic <T> CtCodeSnippetExpression<T> createCodeSnippetExpression(String expression) {\n\t\tCtCodeSnippetExpression<T> e = factory.Core().createCodeSnippetExpression();\n\t\te.setValue(expression);\n\t\treturn e;\n\t}\n\n\t/**\n\t * Creates a Code Snippet statement.\n\t *\n\t * @param statement\n\t * \t\tThe String containing the statement.\n\t * @return a new CtCodeSnippetStatement\n\t */\n\tpublic CtCodeSnippetStatement createCodeSnippetStatement(String statement) {\n\t\tCtCodeSnippetStatement e = factory.Core().createCodeSnippetStatement();\n\t\te.setValue(statement);\n\t\treturn e;\n\t}\n\n\t/**\n\t * Creates a comment\n\t *\n\t * @param content The content of the comment\n\t * @param type The comment type\n\t * @return a new CtComment\n\t */\n\tpublic CtComment createComment(String content, CtComment.CommentType type) {\n\t\tif (type == CtComment.CommentType.JAVADOC) {\n\t\t\treturn factory.Core().createJavaDoc().setContent(content);\n\t\t}\n\t\treturn factory.Core().createComment().setContent(content).setCommentType(type);\n\t}\n\n\t/**\n\t * Creates an inline comment\n\t *\n\t * @param content The content of the comment\n\t * @return a new CtComment\n\t */\n\tpublic CtComment createInlineComment(String content) {\n\t\tif (content.contains(CtComment.LINE_SEPARATOR)) {\n\t\t\tthrow new SpoonException(\"The content of your comment contain at least one line separator. \"\n\t\t\t\t\t+ \"Please consider using a block comment by calling createComment(\\\"your content\\\", CtComment.CommentType.BLOCK).\");\n\t\t}\n\t\treturn createComment(content, CtComment.CommentType.INLINE);\n\t}\n\n\t/**\n\t * Creates a javadoc tag\n\t *\n\t * @param content The content of the javadoc tag with a possible paramater\n\t * @param type The tag type\n\t * @return a new CtJavaDocTag\n\t */\n\tpublic CtJavaDocTag createJavaDocTag(String content, CtJavaDocTag.TagType type) {\n\t\tif (content == null) {\n\t\t\tcontent = \"\";\n\t\t}\n\t\tCtJavaDocTag docTag = factory.Core().createJavaDocTag();\n\t\tif (type != null && type.hasParam()) {\n\t\t\tint firstWord = content.indexOf(' ');\n\t\t\tint firstLine = content.indexOf('\\n');\n\t\t\tif (firstLine < firstWord && firstLine >= 0) {\n\t\t\t\tfirstWord = firstLine;\n\t\t\t}\n\t\t\tif (firstWord == -1) {\n\t\t\t\tfirstWord = content.length();\n\t\t\t}\n\t\t\tString param = content.substring(0, firstWord);\n\t\t\tcontent = content.substring(firstWord);\n\t\t\tdocTag.setParam(param);\n\t\t}\n\t\treturn docTag.setContent(content.trim()).setType(type);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/SubFactory.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\n/**\n * This class is the superclass for all the sub-factories of\n * {@link spoon.reflect.factory.Factory}.\n */\npublic abstract class SubFactory {\n\n\tprotected Factory factory;\n\n\t/**\n\t * The sub-factory constructor takes an instance of the parent factory.\n\t */\n\tpublic SubFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n}\n\n"
    }, {
      "name" : "reflect/factory/QueryFactory.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryImpl;\n\n/**\n * A factory to create some queries on the Spoon metamodel.\n */\npublic class QueryFactory extends SubFactory {\n\n\t/**\n\t * Creates the evaluation factory.\n\t */\n\tpublic QueryFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a unbound query. Use {@link CtQuery#setInput(Object...)}\n\t * before {@link CtQuery#forEach(spoon.reflect.visitor.chain.CtConsumer)}\n\t * or {@link CtQuery#list()} is called\n\t */\n\tpublic CtQuery createQuery() {\n\t\treturn new CtQueryImpl();\n\t}\n\n\t/**\n\t * Creates a bound query. Use directly\n\t * {@link CtQuery#forEach(spoon.reflect.visitor.chain.CtConsumer)}\n\t * or {@link CtQuery#list()} to evaluate the query\n\t */\n\tpublic CtQuery createQuery(Object input) {\n\t\treturn new CtQueryImpl(input);\n\t}\n\n\t/**\n\t * Creates a bound query. Use directly\n\t * {@link CtQuery#forEach(spoon.reflect.visitor.chain.CtConsumer)}\n\t * or {@link CtQuery#list()} to evaluate the query\n\t */\n\tpublic CtQuery createQuery(Iterable<?> inputs) {\n\t\treturn new CtQueryImpl().addInput(inputs);\n\t}\n\n\t/**\n\t * Creates a bound query with an optional number\n\t * of inputs elements to the query (see {@link CtQuery#setInput(Object...)})\n\t */\n\tpublic CtQuery createQuery(Object... input) {\n\t\treturn new CtQueryImpl(input);\n\t}\n}\n"
    }, {
      "name" : "reflect/factory/ExecutableFactory.java",
      "weight" : 133.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\n\n/**\n * The {@link CtExecutable} sub-factory.\n */\npublic class ExecutableFactory extends SubFactory {\n\n\t/**\n\t * Creates a new executable sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic ExecutableFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates an anonymous executable (initializer block) in a target class).\n\t */\n\tpublic CtAnonymousExecutable createAnonymous(CtClass<?> target, CtBlock<Void> body) {\n\t\tCtAnonymousExecutable a = factory.Core().createAnonymousExecutable();\n\t\ttarget.addAnonymousExecutable(a);\n\t\ta.setBody(body);\n\t\treturn a;\n\t}\n\n\t/**\n\t * Creates a new parameter.\n\t */\n\tpublic <T> CtParameter<T> createParameter(CtExecutable<?> parent, CtTypeReference<T> type, String name) {\n\t\tCtParameter<T> parameter = factory.Core().createParameter();\n\t\tparameter.setType(type);\n\t\tparameter.setSimpleName(name);\n\t\tif (parent != null) {\n\t\t\tparent.addParameter(parameter);\n\t\t}\n\t\treturn parameter;\n\t}\n\n\t/**\n\t * Creates a parameter reference from an existing parameter.\n\t *\n\t * @param <T>\n\t * \t\tthe parameter's type\n\t * @param parameter\n\t * \t\tthe parameter\n\t */\n\tpublic <T> CtParameterReference<T> createParameterReference(CtParameter<T> parameter) {\n\t\tCtParameterReference<T> ref = factory.Core().createParameterReference();\n\t\tref.setSimpleName(parameter.getSimpleName());\n\t\tref.setType(parameter.getType());\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Creates an executable reference from an existing executable.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtExecutable<T> e) {\n\t\tCtExecutableReference<T> er = createReferenceInternal(e);\n\t\ter.setParent(e);\n\t\treturn er;\n\t}\n\n\tprivate <T> CtExecutableReference<T> createReferenceInternal(CtExecutable<T> e) {\n\t\tCtTypeReference<?>[] refs = new CtTypeReference[e.getParameters().size()];\n\t\tint i = 0;\n\t\tfor (CtParameter<?> param : e.getParameters()) {\n\t\t\trefs[i++] = getMethodParameterType(param.getType());\n\t\t}\n\t\tString executableName = e.getSimpleName();\n\t\tif (e instanceof CtMethod) {\n\t\t\tboolean isStatic = ((CtMethod) e).hasModifier(ModifierKind.STATIC);\n\t\t\treturn createReference(((CtMethod<T>) e).getDeclaringType().getReference(), isStatic, ((CtMethod<T>) e).getType().clone(), executableName, refs);\n\t\t} else if (e instanceof CtLambda) {\n\t\t\tCtMethod<T> lambdaMethod = ((CtLambda) e).getOverriddenMethod();\n\t\t\treturn createReference(e.getParent(CtType.class).getReference(), lambdaMethod == null ? null : lambdaMethod.getType().clone(), executableName, refs);\n\t\t} else if (e instanceof CtAnonymousExecutable) {\n\t\t\treturn createReference(((CtAnonymousExecutable) e).getDeclaringType().getReference(), e.getType().clone(), executableName);\n\t\t}\n\t\t// constructor\n\t\treturn createReference(((CtConstructor<T>) e).getDeclaringType().getReference(), ((CtConstructor<T>) e).getType().clone(), CtExecutableReference.CONSTRUCTOR_NAME, refs);\n\t}\n\n\tprivate CtTypeReference<?> getMethodParameterType(CtTypeReference<?> paramType) {\n\t\tif (paramType instanceof CtTypeParameterReference) {\n\t\t\treturn getMethodParameterType(((CtTypeParameterReference) paramType).getBoundingType());\n\t\t}\n\t\tif (paramType instanceof CtArrayTypeReference) {\n\t\t\tCtArrayTypeReference atr = (CtArrayTypeReference) paramType;\n\t\t\tCtTypeReference<?> originCT = atr.getComponentType();\n\t\t\tCtTypeReference<?> erasedCT = getMethodParameterType(originCT);\n\t\t\tif (originCT != erasedCT) {\n\t\t\t\tCtArrayTypeReference<?> erased = atr.clone();\n\t\t\t\terased.setComponentType(erasedCT);\n\t\t\t\treturn erased;\n\t\t\t}\n\t\t}\n\t\tif (paramType == null) {\n\t\t\tparamType = factory.Type().OBJECT;\n\t\t}\n\t\treturn paramType.clone();\n\t}\n\n\t/**\n\t * Creates an executable reference.\n\t *\n\t * @param declaringType\n\t * \t\treference to the declaring type\n\t * @param type\n\t * \t\tthe executable's type\n\t * @param methodName\n\t * \t\tsimple name\n\t * @param parameterTypes\n\t * \t\tlist of parameter's types\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtTypeReference<?> declaringType, CtTypeReference<T> type, String methodName, CtTypeReference<?>... parameterTypes) {\n\t\treturn createReference(declaringType, false, type, methodName, parameterTypes);\n\t}\n\n\t/**\n\t * Creates an executable reference.\n\t *\n\t * @param declaringType\n\t * \t\treference to the declaring type\n\t * @param isStatic\n\t * \t\tif this reference references a static executable\n\t * @param type\n\t * \t\tthe return type of the executable\n\t * @param methodName\n\t * \t\tsimple name\n\t * @param parameterTypes\n\t * \t\tlist of parameter's types\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtTypeReference<?> declaringType, boolean isStatic, CtTypeReference<T> type, String methodName, CtTypeReference<?>... parameterTypes) {\n\t\treturn createReference(declaringType, isStatic, type, methodName, Arrays.asList(parameterTypes));\n\t}\n\n\t/**\n\t * Creates an executable reference.\n\t *\n\t * @param declaringType\n\t * \t\treference to the declaring type\n\t * @param isStatic\n\t * \t\tif this reference references a static executable\n\t * @param type\n\t * \t\tthe return type of the executable\n\t * @param methodName\n\t * \t\tsimple name\n\t * @param parameterTypes\n\t * \t\tlist of parameter's types\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtTypeReference<?> declaringType, boolean isStatic, CtTypeReference<T> type, String methodName, List<CtTypeReference<?>> parameterTypes) {\n\t\tCtExecutableReference<T> methodRef = factory.Core().createExecutableReference();\n\t\tmethodRef.setStatic(isStatic);\n\t\tmethodRef.setDeclaringType(declaringType);\n\t\tmethodRef.setSimpleName(methodName);\n\t\tmethodRef.setType(type);\n\t\tList<CtTypeReference<?>> l = new ArrayList<>(parameterTypes);\n\t\tmethodRef.setParameters(l);\n\t\treturn methodRef;\n\t}\n\n\t/**\n\t * Creates an executable reference.\n\t *\n\t * @param declaringType\n\t * \t\treference to the declaring type\n\t * @param type\n\t * \t\tthe return type of the executable\n\t * @param methodName\n\t * \t\tsimple name\n\t * @param parameterTypes\n\t * \t\tlist of parameter's types\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtTypeReference<?> declaringType, CtTypeReference<T> type, String methodName, List<CtTypeReference<?>> parameterTypes) {\n\t\tCtExecutableReference<T> methodRef = factory.Core().createExecutableReference();\n\t\tmethodRef.setDeclaringType(declaringType);\n\t\tmethodRef.setSimpleName(methodName);\n\t\tmethodRef.setType(type);\n\t\tList<CtTypeReference<?>> l = new ArrayList<>(parameterTypes);\n\t\tmethodRef.setParameters(l);\n\t\treturn methodRef;\n\t}\n\n\t/**\n\t * Creates an executable reference from its signature, as defined by the\n\t * executable reference's toString.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(String signature) {\n\t\tCtExecutableReference<T> executableRef = factory.Core().createExecutableReference();\n\t\tString type = signature.substring(0, signature.indexOf(' '));\n\t\tString declaringType = signature.substring(signature.indexOf(' ') + 1, signature.indexOf(CtExecutable.EXECUTABLE_SEPARATOR));\n\t\tString executableName = signature.substring(signature.indexOf(CtExecutable.EXECUTABLE_SEPARATOR) + 1, signature.indexOf('('));\n\t\texecutableRef.setSimpleName(executableName);\n\t\texecutableRef.setDeclaringType(factory.Type().createReference(declaringType));\n\t\tCtTypeReference<T> typeRef = factory.Type().createReference(type);\n\t\texecutableRef.setType(typeRef);\n\t\tString parameters = signature.substring(signature.indexOf('(') + 1, signature.indexOf(')'));\n\t\tList<CtTypeReference<?>> params = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\tStringTokenizer t = new StringTokenizer(parameters, \",\");\n\t\twhile (t.hasMoreTokens()) {\n\t\t\tString paramType = t.nextToken();\n\t\t\tparams.add(factory.Type().createReference(paramType));\n\t\t}\n\t\texecutableRef.setParameters(params);\n\t\treturn executableRef;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/FieldFactory.java",
      "weight" : 69.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.reflect.Field;\nimport java.util.Set;\n\n/**\n * The {@link CtField} sub-factory.\n */\npublic class FieldFactory extends SubFactory {\n\n\t/**\n\t * Creates a new field sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic FieldFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a field.\n\t *\n\t * @param target\n\t * \t\tthe target type to which the field is added\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param type\n\t * \t\tthe field's type\n\t * @param name\n\t * \t\tthe field's name\n\t */\n\tpublic <T> CtField<T> create(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference<T> type, String name) {\n\t\tCtField<T> field = factory.Core().createField();\n\t\tfield.setModifiers(modifiers);\n\t\tfield.setType(type);\n\t\tfield.setSimpleName(name);\n\t\tif (target != null) {\n\t\t\ttarget.addField(field);\n\t\t}\n\t\treturn field;\n\t}\n\n\t/**\n\t * Creates a field.\n\t *\n\t * @param target\n\t * \t\tthe target type to which the field is added\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param type\n\t * \t\tthe field's type\n\t * @param name\n\t * \t\tthe field's name\n\t * @param defaultExpression\n\t * \t\tthe initializing expression\n\t */\n\tpublic <T> CtField<T> create(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference<T> type, String name, CtExpression<T> defaultExpression) {\n\t\tCtField<T> field = create(target, modifiers, type, name);\n\t\tfield.setDefaultExpression(defaultExpression);\n\t\treturn field;\n\t}\n\n\t/**\n\t * Creates a field by copying an existing field.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the field\n\t * @param target\n\t * \t\tthe target type where the new field has to be inserted to\n\t * @param source\n\t * \t\tthe source field to be copied\n\t * @return the newly created field\n\t */\n\tpublic <T> CtField<T> create(CtType<?> target, CtField<T> source) {\n\t\tCtField<T> newField = source.clone();\n\t\tif (target != null) {\n\t\t\ttarget.addField(newField);\n\t\t}\n\t\treturn newField;\n\t}\n\n\t/**\n\t * Creates a field reference from an existing field.\n\t */\n\tpublic <T> CtFieldReference<T> createReference(CtField<T> field) {\n\t\tfinal CtFieldReference<T> reference = createReference(factory.Type().createReference(field.getDeclaringType()), field.getType().clone(), field.getSimpleName());\n\t\treference.setFinal(field.hasModifier(ModifierKind.FINAL));\n\t\treference.setStatic(field.hasModifier(ModifierKind.STATIC));\n\t\treturn reference;\n\t}\n\n\t/**\n\t * Creates a field reference.\n\t */\n\tpublic <T> CtFieldReference<T> createReference(CtTypeReference<?> declaringType, CtTypeReference<T> type, String fieldName) {\n\t\tCtFieldReference<T> fieldRef = factory.Core().createFieldReference();\n\t\tfieldRef.setSimpleName(fieldName);\n\t\tfieldRef.setDeclaringType(declaringType);\n\t\tfieldRef.setType(type);\n\t\treturn fieldRef;\n\t}\n\n\t/**\n\t * Creates a field reference from a <code>java.lang.reflect</code> field.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtFieldReference<T> createReference(Field field) {\n\t\tCtFieldReference<T> fieldRef = factory.Core().createFieldReference();\n\t\tfieldRef.setSimpleName(field.getName());\n\t\tfieldRef.setDeclaringType(factory.Type().createReference(field.getDeclaringClass()));\n\t\tCtTypeReference<T> t = factory.Type().createReference((Class<T>) field.getType());\n\t\tfieldRef.setType(t);\n\t\treturn fieldRef;\n\t}\n\n\t/**\n\t * Creates a field reference from its signature, as defined by the field\n\t * reference's toString.\n\t */\n\tpublic <T> CtFieldReference<T> createReference(String signature) {\n\t\tCtFieldReference<T> fieldRef = factory.Core().createFieldReference();\n\t\tString type = signature.substring(0, signature.indexOf(' '));\n\t\tString declaringType = signature.substring(signature.indexOf(' ') + 1, signature.indexOf(CtField.FIELD_SEPARATOR));\n\t\tString fieldName = signature.substring(signature.indexOf(CtField.FIELD_SEPARATOR) + 1);\n\t\tfieldRef.setSimpleName(fieldName);\n\t\tfieldRef.setDeclaringType(factory.Type().createReference(declaringType));\n\t\tCtTypeReference<T> typeRef = factory.Type().createReference(type);\n\t\tfieldRef.setType(typeRef);\n\t\treturn fieldRef;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/AnnotationFactory.java",
      "weight" : 76.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Repeatable;\nimport java.lang.reflect.Method;\n\n/**\n * The {@link CtAnnotationType} sub-factory.\n */\npublic class AnnotationFactory extends TypeFactory {\n\n\t/**\n\t * Creates an annotation sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic AnnotationFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates an annotation type.\n\t *\n\t * @param owner\n\t * \t\tthe package of the annotation type\n\t * @param simpleName\n\t * \t\tthe name of annotation\n\t */\n\tpublic <T extends Annotation> CtAnnotationType<?> create(CtPackage owner, String simpleName) {\n\t\tCtAnnotationType<T> t = factory.Core().createAnnotationType();\n\t\tt.setSimpleName(simpleName);\n\t\towner.addType(t);\n\t\treturn t;\n\t}\n\n\t/**\n\t * Creates an annotation type.\n\t *\n\t * @param qualifiedName\n\t * \t\tthe fully qualified name of the annotation type.\n\t */\n\tpublic CtAnnotationType<?> create(String qualifiedName) {\n\t\treturn create(factory.Package().getOrCreate(getPackageName(qualifiedName)), getSimpleName(qualifiedName));\n\t}\n\n\t/**\n\t * Gets a annotation type from its name.\n\t */\n\tpublic <T extends Annotation> CtType<T> getAnnotationType(String qualifiedName) {\n\t\treturn get(qualifiedName);\n\t}\n\n\t/**\n\t * Creates/updates an element's annotation value.\n\t *\n\t * @param element\n\t * \t\tthe program element to annotate\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @param annotationElementName\n\t * \t\tthe annotation element name\n\t * @param value\n\t * \t\tthe value of the annotation element\n\t * @return the created/updated annotation\n\t */\n\tpublic <A extends Annotation> CtAnnotation<A> annotate(CtElement element, Class<A> annotationType,\n\t\t\tString annotationElementName, Object value) {\n\t\treturn annotate(element, factory.Type().createReference(annotationType), annotationElementName, value);\n\t}\n\n\t/**\n\t * Creates/updates an element's annotation value.\n\t *\n\t * @param element\n\t * \t\tthe program element to annotate\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @param annotationElementName\n\t * \t\tthe annotation element name\n\t * @param value\n\t * \t\tthe value of the annotation element\n\t * @return the created/updated annotation\n\t */\n\tpublic <A extends Annotation> CtAnnotation<A> annotate(CtElement element, CtTypeReference<A> annotationType, String annotationElementName, Object value) {\n\t\tfinal CtAnnotation<A> annotation = annotate(element, annotationType);\n\t\tboolean isArray;\n\t\t// try with CT reflection\n\t\tCtAnnotationType<A> ctAnnotationType = ((CtAnnotationType<A>) annotation.getAnnotationType().getDeclaration());\n\t\tboolean hasAlreadyValue = annotation.getValues().containsKey(annotationElementName);\n\t\tif (ctAnnotationType != null) {\n\t\t\tCtMethod<?> e = ctAnnotationType.getMethod(annotationElementName);\n\t\t\tisArray = (e.getType() instanceof CtArrayTypeReference);\n\t\t} else {\n\t\t\tMethod m;\n\t\t\ttry {\n\t\t\t\tm = annotation.getAnnotationType().getActualClass().getMethod(annotationElementName, new Class[0]);\n\t\t\t} catch (Exception ex) {\n\t\t\t\tannotation.addValue(annotationElementName, value);\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t\tisArray = m.getReturnType().isArray();\n\t\t}\n\t\tif (isArray || !hasAlreadyValue) {\n\t\t\tannotation.addValue(annotationElementName, value);\n\t\t} else {\n\t\t\tthrow new SpoonException(\"cannot assign an array to a non-array annotation element\");\n\t\t}\n\t\treturn annotation;\n\t}\n\n\t/**\n\t * Adds an annotation to an element.\n\t *\n\t * @param element\n\t * \t\tthe program element to annotate\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @return the concerned annotation\n\t */\n\tpublic <A extends Annotation> CtAnnotation<A> annotate(CtElement element, Class<A> annotationType) {\n\t\treturn annotate(element, factory.Type().createReference(annotationType));\n\t}\n\n\t/**\n\t * Adds an annotation to an element.\n\t *\n\t * @param element\n\t * \t\tthe program element to annotate\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @return the concerned annotation\n\t */\n\tpublic <A extends Annotation> CtAnnotation<A> annotate(CtElement element, CtTypeReference<A> annotationType) {\n\t\tCtAnnotationType<A> ctAnnotationType = ((CtAnnotationType<A>) annotationType.getDeclaration());\n\t\tboolean isRepeatable = false;\n\t\tif (ctAnnotationType != null) {\n\t\t\tisRepeatable = (ctAnnotationType.getAnnotation(factory.Type().createReference(Repeatable.class)) != null);\n\t\t}\n\t\tCtAnnotation<A> annotation = element.getAnnotation(annotationType);\n\t\tif (annotation == null || isRepeatable) {\n\t\t\tannotation = factory.Core().createAnnotation();\n\t\t\tannotation.setAnnotationType(factory.Core().clone(annotationType));\n\t\t\telement.addAnnotation(annotation);\n\t\t}\n\t\treturn annotation;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/InterfaceFactory.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * The {@link CtInterface} sub-factory.\n */\npublic class InterfaceFactory extends TypeFactory {\n\n\t/**\n\t * Creates a new interface sub-factory.\n\t *\n\t * @param factory\n\t *            the parent factory\n\t */\n\tpublic InterfaceFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates an interface.\n\t */\n\tpublic <T> CtInterface<T> create(CtPackage owner, String simpleName) {\n\t\tCtInterface<T> i = factory.Core().createInterface();\n\t\ti.setSimpleName(simpleName);\n\t\towner.addType(i);\n\t\treturn i;\n\t}\n\n\t/**\n\t * Creates an inner interface\n\t */\n\tpublic <T> CtInterface<T> create(CtType<T> owner, String simpleName) {\n\t\tCtInterface<T> ctInterface = factory.Core().createInterface();\n\t\tctInterface.setSimpleName(simpleName);\n\t\towner.addNestedType(ctInterface);\n\t\treturn ctInterface;\n\t}\n\n\t/**\n\t * Creates an interface.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtInterface<T> create(String qualifiedName) {\n\t\tif (hasInnerType(qualifiedName) > 0) {\n\t\t\treturn create(\n\t\t\t\t\tcreate(getDeclaringTypeName(qualifiedName)),\n\t\t\t\t\tgetSimpleName(qualifiedName));\n\t\t}\n\t\treturn create(factory.Package().getOrCreate(\n\t\t\t\tgetPackageName(qualifiedName)), getSimpleName(qualifiedName));\n\t}\n\n\t/**\n\t * Gets a created interface\n\t *\n\t * @return the interface or null if does not exist\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtInterface<T> get(String qualifiedName) {\n\t\ttry {\n\t\t\treturn (CtInterface<T>) super.get(qualifiedName);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a interface from its runtime Java class.\n\t *\n\t * @param <T>\n\t *            type of created class\n\t * @param cl\n\t *            the java class: note that this class should be Class&lt;T&gt; but\n\t *            it then poses problem when T is a generic type itself\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtInterface<T> get(Class<?> cl) {\n\t\ttry {\n\t\t\treturn (CtInterface<T>) super.get(cl);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/Factory.java",
      "weight" : 290.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.CtModel;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.eval.PartialEvaluator;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.support.visitor.GenericTypeAdapter;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Provides the sub-factories required by Spoon.\n *\n * Most classes provides a method getFactory() that returns the current factory.\n *\n * Otherwise FactoryImpl is a default implementation.\n */\npublic interface Factory {\n\n\t/** returns the Spoon model that has been built with this factory or one of its subfactories */\n\tCtModel getModel();\n\n\t/** Access to {@link CoreFactory} subfactory */\n\tCoreFactory Core();\n\n\t/** Access to {@link TypeFactory} subfactory */\n\tTypeFactory Type(); // used 107 times\n\n\t/** Access to {@link EnumFactory} subfactory */\n\tEnumFactory Enum();\n\n\t/** Access to the {@link Environment} */\n\tEnvironment getEnvironment();\n\n\t/** Access to {@link PackageFactory} subfactory */\n\tPackageFactory Package();\n\n\t/** Access to {@link CodeFactory} subfactory */\n\tCodeFactory Code();\n\n\t/** Access to {@link ClassFactory} subfactory */\n\tClassFactory Class();\n\n\t/** Access to {@link FieldFactory} subfactory */\n\tFieldFactory Field();\n\n\t/** Access to {@link ExecutableFactory} subfactory */\n\tExecutableFactory Executable();\n\n\t/** Access to {@link CompilationUnitFactory} subfactory */\n\tCompilationUnitFactory CompilationUnit();\n\n\t/** Access to {@link InterfaceFactory} subfactory */\n\tInterfaceFactory Interface();\n\n\t/** Access to {@link MethodFactory} subfactory */\n\tMethodFactory Method();\n\n\t/** Access to {@link AnnotationFactory} subfactory */\n\tAnnotationFactory Annotation();\n\n\t/** Access to {@link EvalFactory} subfactory */\n\tEvalFactory Eval();\n\n\t/** Access to {@link ConstructorFactory} subfactory */\n\tConstructorFactory Constructor();\n\n\t/** Access to {@link QueryFactory} subfactory */\n\tQueryFactory Query();\n\n\t/** Access to {@link ModuleFactory} subfactory for Java 9 modules */\n\tModuleFactory Module();\n\n\t/**\n\t *  @see CodeFactory#createAnnotation(CtTypeReference)\n\t */\n\t<A extends Annotation> CtAnnotation<A> createAnnotation(CtTypeReference<A> annotationType);\n\n\t/**\n\t *  @see CodeFactory#createVariableAssignment(CtVariableReference,boolean, CtExpression)\n\t */\n\t<A, T extends A> CtAssignment<A, T> createVariableAssignment(CtVariableReference<A> variable, boolean isStatic, CtExpression<T> expression);\n\n\t/**\n\t *  @see CodeFactory#createStatementList(CtBlock)\n\t */\n\t<R> CtStatementList createStatementList(CtBlock<R> block);\n\n\t/**\n\t *  @see CodeFactory#createCtBlock(CtStatement)\n\t */\n\t<T extends CtStatement> CtBlock<?> createCtBlock(T element);\n\n\t/**\n\t *  @see CodeFactory#createBinaryOperator(CtExpression,CtExpression, BinaryOperatorKind)\n\t */\n\t<T> CtBinaryOperator<T> createBinaryOperator(CtExpression<?> left, CtExpression<?> right, BinaryOperatorKind kind);\n\n\t/**\n\t *  @see CodeFactory#createCatchVariable(CtTypeReference,String, ModifierKind[])\n\t */\n\t<T> CtCatchVariable<T> createCatchVariable(CtTypeReference<T> type, String name, ModifierKind... modifierKinds);\n\n\t/**\n\t *  @see CodeFactory#createCodeSnippetExpression(String)\n\t */\n\t<T> CtCodeSnippetExpression<T> createCodeSnippetExpression(String expression);\n\n\t/**\n\t *  @see CodeFactory#createConstructorCall(CtTypeReference,CtExpression[])\n\t */\n\t<T> CtConstructorCall<T> createConstructorCall(CtTypeReference<T> type, CtExpression<?>... parameters);\n\n\t/**\n\t *  @see CodeFactory#createClassAccess(CtTypeReference)\n\t */\n\t<T> CtFieldAccess<Class<T>> createClassAccess(CtTypeReference<T> type);\n\n\t/**\n\t *  @see CodeFactory#createInvocation(CtExpression, CtExecutableReference, List)\n\t */\n\t<T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, List<CtExpression<?>> arguments);\n\n\t/**\n\t *  @see CodeFactory#createInvocation(CtExpression,CtExecutableReference,CtExpression[])\n\t */\n\t<T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, CtExpression<?>... arguments);\n\n\t/**\n\t *  @see CodeFactory#createLiteral(Object)\n\t */\n\t<T> CtLiteral<T> createLiteral(T value);\n\n\t/**\n\t *  @see CodeFactory#createLocalVariable(CtTypeReference,String,CtExpression)\n\t */\n\t<T> CtLocalVariable<T> createLocalVariable(CtTypeReference<T> type, String name, CtExpression<T> defaultExpression);\n\n\t/**\n\t *  @see CodeFactory#createLiteralArray(Object[])\n\t */\n\t@SuppressWarnings(value = \"unchecked\")\n\t<T> CtNewArray<T[]> createLiteralArray(T[] value);\n\n\t/**\n\t * Creates an anonymous class\n\t *\n\t * @param superClass Anonymous class in the new class.\n\t * @param parameters the arguments of the constructor call.\n\t */\n\tCtNewClass<?> createNewClass(CtType<?> superClass, CtExpression<?>... parameters);\n\n\t/**\n\t *  @see CodeFactory#createVariableAssignments(List,List)\n\t */\n\t<T> CtStatementList createVariableAssignments(List<? extends CtVariable<T>> variables, List<? extends CtExpression<T>> expressions);\n\n\t/**\n\t *  @see CodeFactory#createThisAccess(CtTypeReference)\n\t */\n\t<T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type);\n\n\t/**\n\t *  @see CodeFactory#createThisAccess(CtTypeReference,boolean)\n\t */\n\t<T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type, boolean isImplicit);\n\n\t/**\n\t *  @see CodeFactory#createTypeAccess(CtTypeReference)\n\t */\n\t<T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType);\n\n\t/**\n\t *  @see CodeFactory#createTypeAccess(CtTypeReference,boolean)\n\t */\n\t<T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType, boolean isImplicit);\n\n\t/**\n\t *  @see CodeFactory#createTypeAccessWithoutCloningReference(CtTypeReference)\n\t */\n\t<T> CtTypeAccess<T> createTypeAccessWithoutCloningReference(CtTypeReference<T> accessedType);\n\n\t/**\n\t *  @see CodeFactory#createVariableRead(CtVariableReference,boolean)\n\t */\n\t<T> CtVariableAccess<T> createVariableRead(CtVariableReference<T> variable, boolean isStatic);\n\n\t/**\n\t *  @see CodeFactory#createCtField(String,CtTypeReference,String,ModifierKind[])\n\t */\n\t<T> CtField<T> createCtField(String name, CtTypeReference<T> type, String exp, ModifierKind... visibilities);\n\n\t/**\n\t *  @see CodeFactory#createCatchVariableReference(CtCatchVariable)\n\t */\n\t<T> CtCatchVariableReference<T> createCatchVariableReference(CtCatchVariable<T> catchVariable);\n\n\t/**\n\t *  @see CodeFactory#createLocalVariableReference(CtLocalVariable)\n\t */\n\t<T> CtLocalVariableReference<T> createLocalVariableReference(CtLocalVariable<T> localVariable);\n\n\t/**\n\t *  @see CodeFactory#createLocalVariableReference(CtTypeReference,String)\n\t */\n\t<T> CtLocalVariableReference<T> createLocalVariableReference(CtTypeReference<T> type, String name);\n\n\t/**\n\t *  @see CodeFactory#createCtTypeReference(Class)\n\t */\n\t<T> CtTypeReference<T> createCtTypeReference(Class<?> originalClass);\n\n\t/**\n\t *  @see CodeFactory#createVariableReads(List)\n\t */\n\tList<CtExpression<?>> createVariableReads(List<? extends CtVariable<?>> variables);\n\n\t/**\n\t *  @see CodeFactory#createCtCatch(String,Class,CtBlock)\n\t */\n\tCtCatch createCtCatch(String nameCatch, Class<? extends Throwable> exception, CtBlock<?> ctBlock);\n\n\t/**\n\t *  @see CodeFactory#createCodeSnippetStatement(String)\n\t */\n\tCtCodeSnippetStatement createCodeSnippetStatement(String statement);\n\n\t/**\n\t *  @see CodeFactory#createComment(String,CtComment.CommentType)\n\t */\n\tCtComment createComment(String content, CtComment.CommentType type);\n\n\n\t/**\n\t *  @see CodeFactory#createJavaDocTag(String,CtJavaDocTag.TagType)\n\t */\n\tCtJavaDocTag createJavaDocTag(String content, CtJavaDocTag.TagType type);\n\n\t/**\n\t *  @see CodeFactory#createInlineComment(String)\n\t */\n\tCtComment createInlineComment(String content);\n\n\t/**\n\t *  @see CodeFactory#createCtThrow(String)\n\t */\n\tCtThrow createCtThrow(String thrownExp);\n\n\t/**\n\t *  @see CodeFactory#createCtPackageReference(Package)\n\t */\n\tCtPackageReference createCtPackageReference(Package originalPackage);\n\n\t/**\n\t *  @see ConstructorFactory#createDefault(CtClass)\n\t */\n\t<T> CtConstructor<T> createDefault(CtClass<T> target);\n\n\t/**\n\t *  @see CoreFactory#createAnnotation()\n\t */\n\t<A extends Annotation> CtAnnotation<A> createAnnotation();\n\n\t/**\n\t *  @see CoreFactory#createBlock()\n\t */\n\t<R> CtBlock<R> createBlock();\n\n\t/**\n\t *  @see CoreFactory#createReturn()\n\t */\n\t<R> CtReturn<R> createReturn();\n\n\t/**\n\t *  @see CoreFactory#createStatementList()\n\t */\n\t<R> CtStatementList createStatementList();\n\n\t/**\n\t *  @see CoreFactory#createCase()\n\t */\n\t<S> CtCase<S> createCase();\n\n\t/**\n\t *  @see CoreFactory#createSwitch()\n\t */\n\t<S> CtSwitch<S> createSwitch();\n\n\t/**\n\t *  @see CoreFactory#createEnum()\n\t */\n\t<T extends Enum<?>> CtEnum<T> createEnum();\n\n\t/**\n\t *  @see CoreFactory#createAnnotationType()\n\t */\n\t<T extends Annotation> CtAnnotationType<T> createAnnotationType();\n\n\t/**\n\t *  @see CoreFactory#createAssignment()\n\t */\n\t<T, A extends T> CtAssignment<T, A> createAssignment();\n\n\t/**\n\t *  @see CoreFactory#createOperatorAssignment()\n\t */\n\t<T, A extends T> CtOperatorAssignment<T, A> createOperatorAssignment();\n\n\t/**\n\t *  @see CoreFactory#createExecutableReferenceExpression()\n\t */\n\t<T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression();\n\n\t/**\n\t *  @see CoreFactory#createAnnotationFieldAccess()\n\t */\n\t<T> CtAnnotationFieldAccess<T> createAnnotationFieldAccess();\n\n\t/**\n\t *  @see CoreFactory#createArrayRead()\n\t */\n\t<T> CtArrayRead<T> createArrayRead();\n\n\t/**\n\t *  @see CoreFactory#createArrayWrite()\n\t */\n\t<T> CtArrayWrite<T> createArrayWrite();\n\n\t/**\n\t *  @see CoreFactory#createAssert()\n\t */\n\t<T> CtAssert<T> createAssert();\n\n\t/**\n\t *  @see CoreFactory#createBinaryOperator()\n\t */\n\t<T> CtBinaryOperator<T> createBinaryOperator();\n\n\t/**\n\t *  @see CoreFactory#createCatchVariable()\n\t */\n\t<T> CtCatchVariable<T> createCatchVariable();\n\n\t/**\n\t *  @see CoreFactory#createCodeSnippetExpression()\n\t */\n\t<T> CtCodeSnippetExpression<T> createCodeSnippetExpression();\n\n\t/**\n\t *  @see CoreFactory#createConditional()\n\t */\n\t<T> CtConditional<T> createConditional();\n\n\t/**\n\t *  @see CoreFactory#createConstructorCall()\n\t */\n\t<T> CtConstructorCall<T> createConstructorCall();\n\n\t/**\n\t *  @see CoreFactory#createFieldRead()\n\t */\n\t<T> CtFieldRead<T> createFieldRead();\n\n\t/**\n\t *  @see CoreFactory#createFieldWrite()\n\t */\n\t<T> CtFieldWrite<T> createFieldWrite();\n\n\t/**\n\t *  @see CoreFactory#createInvocation()\n\t */\n\t<T> CtInvocation<T> createInvocation();\n\n\t/**\n\t *  @see CoreFactory#createLambda()\n\t */\n\t<T> CtLambda<T> createLambda();\n\n\t/**\n\t *  @see CoreFactory#createLiteral()\n\t */\n\t<T> CtLiteral<T> createLiteral();\n\n\t/**\n\t *  @see CoreFactory#createLocalVariable()\n\t */\n\t<T> CtLocalVariable<T> createLocalVariable();\n\n\t/**\n\t *  @see CoreFactory#createNewArray()\n\t */\n\t<T> CtNewArray<T> createNewArray();\n\n\t/**\n\t *  @see CoreFactory#createNewClass()\n\t */\n\t<T> CtNewClass<T> createNewClass();\n\n\t/**\n\t *  @see CoreFactory#createSuperAccess()\n\t */\n\t<T> CtSuperAccess<T> createSuperAccess();\n\n\t/**\n\t *  @see CoreFactory#createThisAccess()\n\t */\n\t<T> CtThisAccess<T> createThisAccess();\n\n\t/**\n\t *  @see CoreFactory#createTypeAccess()\n\t */\n\t<T> CtTypeAccess<T> createTypeAccess();\n\n\t/**\n\t *  @see CoreFactory#createUnaryOperator()\n\t */\n\t<T> CtUnaryOperator<T> createUnaryOperator();\n\n\t/**\n\t *  @see CoreFactory#createVariableRead()\n\t */\n\t<T> CtVariableRead<T> createVariableRead();\n\n\t/**\n\t *  @see CoreFactory#createVariableWrite()\n\t */\n\t<T> CtVariableWrite<T> createVariableWrite();\n\n\t/**\n\t *  @see CoreFactory#createAnnotationMethod()\n\t */\n\t<T> CtAnnotationMethod<T> createAnnotationMethod();\n\n\t/**\n\t *  @see CoreFactory#createClass()\n\t */\n\t<T> CtClass<T> createClass();\n\n\t/**\n\t *  @see CoreFactory#createConstructor()\n\t */\n\t<T> CtConstructor<T> createConstructor();\n\n\t/**\n\t *  @see CoreFactory#createInvisibleArrayConstructor() ()\n\t */\n\t<T> CtConstructor<T> createInvisibleArrayConstructor();\n\n\t/**\n\t *  @see CoreFactory#createEnumValue()\n\t */\n\t<T> CtEnumValue<T> createEnumValue();\n\n\t/**\n\t *  @see CoreFactory#createField()\n\t */\n\t<T> CtField<T> createField();\n\n\t/**\n\t *  @see CoreFactory#createInterface()\n\t */\n\t<T> CtInterface<T> createInterface();\n\n\t/**\n\t *  @see CoreFactory#createMethod()\n\t */\n\t<T> CtMethod<T> createMethod();\n\n\t/**\n\t *  @see CoreFactory#createParameter()\n\t */\n\t<T> CtParameter<T> createParameter();\n\n\t/**\n\t *  @see CoreFactory#createArrayTypeReference()\n\t */\n\t<T> CtArrayTypeReference<T> createArrayTypeReference();\n\n\t/**\n\t *  @see CoreFactory#createCatchVariableReference()\n\t */\n\t<T> CtCatchVariableReference<T> createCatchVariableReference();\n\n\t/**\n\t *  @see CoreFactory#createExecutableReference()\n\t */\n\t<T> CtExecutableReference<T> createExecutableReference();\n\n\t/**\n\t *  @see CoreFactory#createFieldReference()\n\t */\n\t<T> CtFieldReference<T> createFieldReference();\n\n\t/**\n\t *  @see CoreFactory#createIntersectionTypeReference()\n\t */\n\t<T> CtIntersectionTypeReference<T> createIntersectionTypeReference();\n\n\t/**\n\t *  @see CoreFactory#createLocalVariableReference()\n\t */\n\t<T> CtLocalVariableReference<T> createLocalVariableReference();\n\n\t/**\n\t *  @see CoreFactory#createParameterReference()\n\t */\n\t<T> CtParameterReference<T> createParameterReference();\n\n\t/**\n\t *  @see CoreFactory#createTypeReference()\n\t */\n\t<T> CtTypeReference<T> createTypeReference();\n\n\t/**\n\t *  @see CoreFactory#createUnboundVariableReference()\n\t */\n\t<T> CtUnboundVariableReference<T> createUnboundVariableReference();\n\n\t/**\n\t *  @see CoreFactory#createBreak()\n\t */\n\tCtBreak createBreak();\n\n\t/**\n\t *  @see CoreFactory#createCatch()\n\t */\n\tCtCatch createCatch();\n\n\t/**\n\t *  @see CoreFactory#createCodeSnippetStatement()\n\t */\n\tCtCodeSnippetStatement createCodeSnippetStatement();\n\n\t/**\n\t *  @see CoreFactory#createComment()\n\t */\n\tCtComment createComment();\n\n\t/**\n\t *  @see CoreFactory#createContinue()\n\t */\n\tCtContinue createContinue();\n\n\t/**\n\t *  @see CoreFactory#createDo()\n\t */\n\tCtDo createDo();\n\n\t/**\n\t *  @see CoreFactory#createFor()\n\t */\n\tCtFor createFor();\n\n\t/**\n\t *  @see CoreFactory#createForEach()\n\t */\n\tCtForEach createForEach();\n\n\t/**\n\t *  @see CoreFactory#createIf()\n\t */\n\tCtIf createIf();\n\n\t/**\n\t *  @see CoreFactory#createSynchronized()\n\t */\n\tCtSynchronized createSynchronized();\n\n\t/**\n\t *  @see CoreFactory#createThrow()\n\t */\n\tCtThrow createThrow();\n\n\t/**\n\t *  @see CoreFactory#createTry()\n\t */\n\tCtTry createTry();\n\n\t/**\n\t *  @see CoreFactory#createTryWithResource()\n\t */\n\tCtTryWithResource createTryWithResource();\n\n\t/**\n\t *  @see CoreFactory#createWhile()\n\t */\n\tCtWhile createWhile();\n\n\t/**\n\t *  @see CoreFactory#createCompilationUnit()\n\t */\n\tCompilationUnit createCompilationUnit();\n\n\t/**\n\t *  @see CoreFactory#createSourcePosition(CompilationUnit,int,int,int[])\n\t */\n\tSourcePosition createSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int[] lineSeparatorPositions);\n\n\t/**\n\t *  @see CoreFactory#createBodyHolderSourcePosition(CompilationUnit,int,int,int,int,int,int,int,int,int[])\n\t */\n\tBodyHolderSourcePosition createBodyHolderSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int bodyStart, int bodyEnd, int[] lineSeparatorPositions);\n\n\t/**\n\t *  @see CoreFactory#createDeclarationSourcePosition(CompilationUnit,int,int,int,int,int,int,int[])\n\t */\n\tDeclarationSourcePosition createDeclarationSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int[] lineSeparatorPositions);\n\n\t/**\n\t *  @see CoreFactory#createAnonymousExecutable()\n\t */\n\tCtAnonymousExecutable createAnonymousExecutable();\n\n\t/**\n\t *  @see CoreFactory#createPackage()\n\t */\n\tCtPackage createPackage();\n\n\t/**\n\t *  @see CoreFactory#createTypeParameter()\n\t */\n\tCtTypeParameter createTypeParameter();\n\n\t/**\n\t *  @see CoreFactory#createPackageReference()\n\t */\n\tCtPackageReference createPackageReference();\n\n\t/**\n\t *  @see CoreFactory#createTypeParameterReference()\n\t */\n\tCtTypeParameterReference createTypeParameterReference();\n\n\t/**\n\t *  @see CoreFactory#createWildcardReference()\n\t */\n\tCtWildcardReference createWildcardReference();\n\n\t/**\n\t *  @see EvalFactory#createPartialEvaluator()\n\t */\n\tPartialEvaluator createPartialEvaluator();\n\n\t/**\n\t *  @see ExecutableFactory#createParameter(CtExecutable,CtTypeReference,String)\n\t */\n\t<T> CtParameter<T> createParameter(CtExecutable<?> parent, CtTypeReference<T> type, String name);\n\n\t/**\n\t *  @see ExecutableFactory#createParameterReference(CtParameter)\n\t */\n\t<T> CtParameterReference<T> createParameterReference(CtParameter<T> parameter);\n\n\t/**\n\t *  @see ExecutableFactory#createAnonymous(CtClass,CtBlock)\n\t */\n\tCtAnonymousExecutable createAnonymous(CtClass<?> target, CtBlock<Void> body);\n\n\t/**\n\t *  @see TypeFactory#createArrayReference(String)\n\t */\n\t<T> CtArrayTypeReference<T> createArrayReference(String qualifiedName);\n\n\t/**\n\t *  @see TypeFactory#createArrayReference(CtType)\n\t */\n\t<T> CtArrayTypeReference<T[]> createArrayReference(CtType<T> type);\n\n\t/**\n\t *  @see TypeFactory#createArrayReference(CtTypeReference)\n\t */\n\t<T> CtArrayTypeReference<T[]> createArrayReference(CtTypeReference<T> reference);\n\n\t/**\n\t *  @see TypeFactory#createIntersectionTypeReferenceWithBounds(List)\n\t */\n\t<T> CtIntersectionTypeReference<T> createIntersectionTypeReferenceWithBounds(List<CtTypeReference<?>> bounds);\n\n\t/**\n\t * @see TypeFactory#createTypeAdapter(CtFormalTypeDeclarer)\n\t */\n\tGenericTypeAdapter createTypeAdapter(CtFormalTypeDeclarer formalTypeDeclarer);\n\n\t/**\n\t *  @see TypeFactory#createReferences(List)\n\t */\n\tList<CtTypeReference<?>> createReferences(List<Class<?>> classes);\n\n\t/**\n\t *  @see TypeFactory#createArrayReference(CtTypeReference,int)\n\t */\n\tCtArrayTypeReference<?> createArrayReference(CtTypeReference<?> reference, int n);\n\n\t/**\n\t *  @see TypeFactory#createTypeParameterReference(String)\n\t */\n\tCtTypeParameterReference createTypeParameterReference(String name);\n\n\t/**\n\t *  @see QueryFactory#createQuery()\n\t */\n\tCtQuery createQuery();\n\n\t/**\n\t *  @see QueryFactory#createQuery(Object)\n\t */\n\tCtQuery createQuery(Object input);\n\n\t/**\n\t * @see QueryFactory#createQuery(Object...)\n\t */\n\tCtQuery createQuery(Object... input);\n\n\t/**\n\t * @see QueryFactory#createQuery(Iterable)\n\t */\n\tCtQuery createQuery(Iterable<?> input);\n\n\t/**\n\t *\n\t * @see AnnotationFactory#create(String)\n\t */\n\tCtAnnotationType createAnnotationType(String qualifiedName);\n\n\t/**\n\t *\n\t * @see AnnotationFactory#create(CtPackage, String)\n\t */\n\tCtAnnotationType createAnnotationType(CtPackage owner, String simpleName);\n\n\t/**\n\t *\n\t * @see ClassFactory#create(String)\n\t */\n\tCtClass createClass(String qualifiedName);\n\n\t/**\n\t *\n\t * @see ClassFactory#create(CtClass, String)\n\t */\n\tCtClass createClass(CtClass<?> declaringClass, String simpleName);\n\n\t/**\n\t *\n\t * @see ClassFactory#create(CtPackage, String)\n\t */\n\tCtClass createClass(CtPackage owner, String simpleName);\n\n\t/**\n\t *\n\t * @see ConstructorFactory#create(CtClass, CtConstructor)\n\t */\n\tCtConstructor createConstructor(CtClass target, CtConstructor<?> source);\n\n\t/**\n\t *\n\t * @see ConstructorFactory#create(CtClass, CtMethod)\n\t */\n\tCtConstructor createConstructor(CtClass target, CtMethod<?> source);\n\n\t/**\n\t *\n\t * @see ConstructorFactory#create(CtClass, Set, List, Set)\n\t */\n\tCtConstructor createConstructor(CtClass target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes);\n\n\t/**\n\t *\n\t * @see ConstructorFactory#create(CtClass, Set, List, Set, CtBlock)\n\t */\n\tCtConstructor createConstructor(CtClass target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock body);\n\n\t/**\n\t *\n\t * @see EnumFactory#create(String)\n\t */\n\tCtEnum<?> createEnum(String qualifiedName);\n\n\t/**\n\t *\n\t * @see EnumFactory#create(CtPackage, String)\n\t */\n\tCtEnum<?> createEnum(CtPackage owner, String simpleName);\n\n\t/**\n\t *\n\t * @see FieldFactory#create(CtType, Set, CtTypeReference, String)\n\t */\n\tCtField createField(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference type, String name);\n\n\t/**\n\t *\n\t * @see FieldFactory#create(CtType, Set, CtTypeReference, String, CtExpression)\n\t */\n\tCtField createField(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference type, String name, CtExpression defaultExpression);\n\n\t/**\n\t *\n\t * @see FieldFactory#create(CtType, CtField)\n\t */\n\tCtField createField(CtType<?> target, CtField source);\n\n\t/**\n\t *\n\t * @see InterfaceFactory#create(CtPackage, String)\n\t */\n\tCtInterface createInterface(CtPackage owner, String simpleName);\n\n\t/**\n\t *\n\t * @see InterfaceFactory#create(CtType, String)\n\t */\n\tCtInterface createInterface(CtType owner, String simpleName);\n\n\t/**\n\t *\n\t * @see InterfaceFactory#create(String)\n\t */\n\tCtInterface createInterface(String qualifiedName);\n\n\t/**\n\t *\n\t * @see MethodFactory#create(CtClass, Set, CtTypeReference, String, List, Set, CtBlock)\n\t */\n\tCtMethod createMethod(CtClass<?> target, Set<ModifierKind> modifiers, CtTypeReference returnType, String name, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock body);\n\n\t/**\n\t *\n\t * @see MethodFactory#create(CtType, CtMethod, boolean)\n\t */\n\tCtMethod createMethod(CtType<?> target, CtMethod source, boolean redirectReferences);\n\n\t/**\n\t *\n\t * @see MethodFactory#create(CtType, Set, CtTypeReference, String, List, Set)\n\t */\n\tCtMethod createMethod(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference returnType, String name, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes);\n\n\t/**\n\t *\n\t * @see PackageFactory#create(CtPackage, String)\n\t */\n\tCtPackage createPackage(CtPackage parent, String simpleName);\n\n\t/**\n\t * @see CoreFactory#create(Class)\n\t */\n\tCtElement createElement(Class<? extends CtElement> klass);\n\n\t/**\n\t * @see TypeFactory#createImport(CtReference)\n\t */\n\tCtImport createImport(CtReference reference);\n\n\t/**\n\t * @see TypeFactory#createUnresolvedImport(String,boolean)\n\t */\n\tCtImport createUnresolvedImport(String reference, boolean isStatic);\n\n\t/**\n\t * @see TypeFactory#createTypeMemberWildcardImportReference(CtTypeReference)\n\t */\n\tCtTypeMemberWildcardImportReference createTypeMemberWildcardImportReference(CtTypeReference<?> typeReference);\n\n\t/**\n\t * @see ModuleFactory#createPackageExport(CtPackageReference)\n\t */\n\tCtPackageExport createPackageExport(CtPackageReference ctPackageReference);\n\n\t/**\n\t * @see ModuleFactory#createProvidedService(CtTypeReference)\n\t */\n\tCtProvidedService createProvidedService(CtTypeReference ctTypeReference);\n\n\t/**\n\t * @see ModuleFactory#createModuleRequirement(CtModuleReference)\n\t */\n\tCtModuleRequirement createModuleRequirement(CtModuleReference ctModuleReference);\n\n\t/**\n\t * @see ModuleFactory#getOrCreate(String)\n\t */\n\tCtModule createModule(String moduleName);\n\n\t/**\n\t * @see ModuleFactory#createReference(CtModule)\n\t */\n\tCtModuleReference createModuleReference(CtModule ctModule);\n\n\t/**\n\t * @see ModuleFactory#createUsedService(CtTypeReference)\n\t */\n\tCtUsedService createUsedService(CtTypeReference typeReference);\n\n\t/**\n\t * @see CoreFactory#createPartialSourcePosition(CompilationUnit)\n\t */\n\tSourcePosition createPartialSourcePosition(CompilationUnit compilationUnit);\n\n\t/**\n\t * @see PackageFactory#createPackageDeclaration(CtPackageReference)\n\t */\n\tCtPackageDeclaration createPackageDeclaration(CtPackageReference packageRef);\n\n\t/**\n\t * @see TypeFactory#createReference(String)\n\t */\n\t<T> CtTypeReference<T> createReference(String qualifiedName);\n}\n"
    }, {
      "name" : "reflect/factory/FactoryImpl.java",
      "weight" : 956.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.CtModel;\nimport spoon.reflect.CtModelImpl;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.eval.PartialEvaluator;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.visitor.GenericTypeAdapter;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ThreadLocalRandom;\n\n/**\n * Implements {@link Factory}\n */\npublic class FactoryImpl implements Factory, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate transient Factory parentFactory;\n\n\t/**\n\t * Returns the parent of this factory. When an element is not found in a\n\t * factory, it can be looked up in its parent factory using a delegation\n\t * model.\n\t */\n\tpublic Factory getParentFactory() {\n\t\treturn parentFactory;\n\t}\n\n\tprivate transient AnnotationFactory annotation;\n\n\t/**\n\t * The {@link CtAnnotationType} sub-factory.\n\t */\n\t@Override\n\tpublic AnnotationFactory Annotation() {\n\t\tif (annotation == null) {\n\t\t\tannotation = new AnnotationFactory(this);\n\t\t}\n\t\treturn annotation;\n\t}\n\n\tprivate transient ClassFactory clazz;\n\n\t/**\n\t * The {@link CtClass} sub-factory.\n\t */\n\t@Override\n\tpublic ClassFactory Class() {\n\t\tif (clazz == null) {\n\t\t\tclazz = new ClassFactory(this);\n\t\t}\n\t\treturn clazz;\n\t}\n\n\tprivate transient CodeFactory code;\n\n\t/**\n\t * The {@link spoon.reflect.code.CtCodeElement} sub-factory.\n\t */\n\t@Override\n\tpublic CodeFactory Code() {\n\t\tif (code == null) {\n\t\t\tcode = new CodeFactory(this);\n\t\t}\n\t\treturn code;\n\t}\n\n\tprivate transient ConstructorFactory constructor;\n\n\t/**\n\t * The {@link CtConstructor} sub-factory.\n\t */\n\t@Override\n\tpublic ConstructorFactory Constructor() {\n\t\tif (constructor == null) {\n\t\t\tconstructor = new ConstructorFactory(this);\n\t\t}\n\t\treturn constructor;\n\t}\n\n\tprivate transient CoreFactory core;\n\n\t/**\n\t * The core factory.\n\t */\n\t@Override\n\tpublic CoreFactory Core() {\n\t\tif (core == null) {\n\t\t\t//During deserialization, the transient field core, is null\n\t\t\tcore = new DefaultCoreFactory();\n\t\t\tcore.setMainFactory(this);\n\t\t}\n\t\treturn core;\n\t}\n\n\tprivate transient EnumFactory enumF;\n\n\t/**\n\t * The {@link CtEnum} sub-factory.\n\t */\n\t@Override\n\tpublic EnumFactory Enum() {\n\t\tif (enumF == null) {\n\t\t\tenumF = new EnumFactory(this);\n\t\t}\n\t\treturn enumF;\n\t}\n\n\tprivate transient Environment environment;\n\n\t/**\n\t * Gets the Spoon environment that encloses this factory.\n\t */\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\tif (environment == null) {\n\t\t\tenvironment = new StandardEnvironment();\n\t\t}\n\t\treturn environment;\n\t}\n\n\tprivate transient ExecutableFactory executable;\n\n\t/**\n\t * The {@link CtExecutable} sub-factory.\n\t */\n\t@Override\n\tpublic ExecutableFactory Executable() {\n\t\tif (executable == null) {\n\t\t\texecutable = new ExecutableFactory(this);\n\t\t}\n\t\treturn executable;\n\t}\n\n\tprivate transient EvalFactory eval;\n\n\t/**\n\t * The evaluators sub-factory.\n\t */\n\t@Override\n\tpublic EvalFactory Eval() {\n\t\tif (eval == null) {\n\t\t\teval = new EvalFactory(this);\n\t\t}\n\t\treturn eval;\n\t}\n\n\tprivate transient FieldFactory field;\n\n\t/**\n\t * The {@link CtField} sub-factory.\n\t */\n\t@Override\n\tpublic FieldFactory Field() {\n\t\tif (field == null) {\n\t\t\tfield = new FieldFactory(this);\n\t\t}\n\t\treturn field;\n\t}\n\n\t/**\n\t * The {@link CtInterface} sub-factory.\n\t */\n\tprivate transient InterfaceFactory interfaceF;\n\n\t/**\n\t * The {@link CtInterface} sub-factory.\n\t */\n\t@Override\n\tpublic InterfaceFactory Interface() {\n\t\tif (interfaceF == null) {\n\t\t\tinterfaceF = new InterfaceFactory(this);\n\t\t}\n\t\treturn interfaceF;\n\t}\n\n\tprivate transient MethodFactory methodF;\n\n\t/**\n\t * The {@link CtMethod} sub-factory.\n\t */\n\t@Override\n\tpublic MethodFactory Method() {\n\t\tif (methodF == null) {\n\t\t\tmethodF = new MethodFactory(this);\n\t\t}\n\t\treturn methodF;\n\t}\n\n\tprivate transient PackageFactory packageF;\n\n\t/**\n\t * The {@link CtPackage} sub-factory.\n\t */\n\t@Override\n\tpublic PackageFactory Package() {\n\t\tif (packageF == null) {\n\t\t\tpackageF = new PackageFactory(this);\n\t\t}\n\t\treturn packageF;\n\t}\n\n\tprivate transient CompilationUnitFactory compilationUnit;\n\n\t/**\n\t * The {@link CompilationUnit} sub-factory.\n\t */\n\t@Override\n\tpublic CompilationUnitFactory CompilationUnit() {\n\t\tif (compilationUnit == null) {\n\t\t\tcompilationUnit = new CompilationUnitFactory(this);\n\t\t}\n\t\treturn compilationUnit;\n\t}\n\n\tprivate transient TypeFactory type;\n\n\t/**\n\t * The {@link CtType} sub-factory.\n\t */\n\t@Override\n\tpublic TypeFactory Type() {\n\t\tif (type == null) {\n\t\t\ttype = new TypeFactory(this);\n\t\t}\n\t\treturn type;\n\t}\n\n\tprivate transient QueryFactory query;\n\n\t/**\n\t * The query sub-factory.\n\t */\n\t@Override\n\tpublic QueryFactory Query() {\n\t\tif (query == null) {\n\t\t\tquery = new QueryFactory(this);\n\t\t}\n\t\treturn query;\n\t}\n\n\tprivate transient ModuleFactory module;\n\n\t/**\n\t * The module sub-factory\n\t */\n\t@Override\n\tpublic ModuleFactory Module() {\n\t\tif (module == null) {\n\t\t\tmodule = new ModuleFactory(this);\n\t\t}\n\t\treturn module;\n\t}\n\n\n\t/**\n\t * A constructor that takes the parent factory\n\t */\n\tpublic FactoryImpl(CoreFactory coreFactory, Environment environment, Factory parentFactory) {\n\t\tthis.environment = environment;\n\t\tthis.core = coreFactory;\n\t\tthis.core.setMainFactory(this);\n\t\tthis.parentFactory = parentFactory;\n\t}\n\n\t/**\n\t * Should not be called directly. Use {@link spoon.Launcher#createFactory()} instead.\n\t */\n\tpublic FactoryImpl(CoreFactory coreFactory, Environment environment) {\n\t\tthis(coreFactory, environment, null);\n\t}\n\n\t// Deduplication\n\t// See http://shipilev.net/talks/joker-Oct2014-string-catechism.pdf\n\n\tprivate static class Dedup {\n\t\tMap<String, String> cache = new HashMap<>();\n\t\tRandom random = ThreadLocalRandom.current();\n\t}\n\n\t/**\n\t * Note this is an instance field. To avoid memory leaks and dedup being\n\t * targeted to each Spoon Launching, that could differ a lot by\n\t * frequently used symbols.\n\t */\n\tprivate transient ThreadLocal<Dedup> threadLocalDedup = new ThreadLocal<Dedup>() {\n\t\t@Override\n\t\tprotected Dedup initialValue() {\n\t\t\treturn new Dedup();\n\t\t}\n\t};\n\n\t/**\n\t * Returns a String equal to the given symbol. Performs probablilistic\n\t * deduplication.\n\t */\n\tpublic String dedup(String symbol) {\n\t\tDedup dedup = threadLocalDedup.get();\n\t\tMap<String, String> cache = dedup.cache;\n\t\tString cached;\n\t\tif ((cached = cache.get(symbol)) != null) {\n\t\t\treturn cached;\n\t\t} else {\n\t\t\t// Puts the symbol into cache with 20% probability\n\t\t\tint prob = (int) (Integer.MIN_VALUE + (0.2 * (1L << 32)));\n\t\t\tif (dedup.random.nextInt() < prob) {\n\t\t\t\tcache.put(symbol, symbol);\n\t\t\t}\n\t\t\treturn symbol;\n\t\t}\n\t}\n\n\t/**\n\t * Needed to restore state of transient fields during reading from stream\n\t */\n\tprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t\tthreadLocalDedup = new ThreadLocal<Dedup>() {\n\t\t\t@Override\n\t\t\tprotected Dedup initialValue() {\n\t\t\t\treturn new Dedup();\n\t\t\t}\n\t\t};\n\t\tin.defaultReadObject();\n\t}\n\n\tprivate final CtModel model = new CtModelImpl(this);\n\n\t@Override\n\tpublic CtModel getModel() {\n\t\treturn model;\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> CtAnnotation<A> createAnnotation(CtTypeReference<A> annotationType) {\n\t\treturn Code().createAnnotation(annotationType);\n\t}\n\n\t@Override\n\tpublic <A, T extends A> CtAssignment<A, T> createVariableAssignment(CtVariableReference<A> variable, boolean isStatic, CtExpression<T> expression) {\n\t\treturn Code().createVariableAssignment(variable, isStatic, expression);\n\t}\n\n\t@Override\n\tpublic <R> CtStatementList createStatementList(CtBlock<R> block) {\n\t\treturn Code().createStatementList(block);\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> CtBlock<?> createCtBlock(T element) {\n\t\treturn Code().createCtBlock(element);\n\t}\n\n\t@Override\n\tpublic <T> CtBinaryOperator<T> createBinaryOperator(CtExpression<?> left, CtExpression<?> right, BinaryOperatorKind kind) {\n\t\treturn Code().createBinaryOperator(left, right, kind);\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariable<T> createCatchVariable(CtTypeReference<T> type, String name, ModifierKind... modifierKinds) {\n\t\treturn Code().createCatchVariable(type, name, modifierKinds);\n\t}\n\n\t@Override\n\tpublic <T> CtCodeSnippetExpression<T> createCodeSnippetExpression(String expression) {\n\t\treturn Code().createCodeSnippetExpression(expression);\n\t}\n\n\t@Override\n\tpublic <T> CtConstructorCall<T> createConstructorCall(CtTypeReference<T> type, CtExpression<?>... parameters) {\n\t\treturn Code().createConstructorCall(type, parameters);\n\t}\n\n\t@Override\n\tpublic <T> CtFieldAccess<Class<T>> createClassAccess(CtTypeReference<T> type) {\n\t\treturn Code().createClassAccess(type);\n\t}\n\n\t@Override\n\tpublic <T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, List<CtExpression<?>> arguments) {\n\t\treturn Code().createInvocation(target, executable, arguments);\n\t}\n\n\t@Override\n\tpublic <T> CtInvocation<T> createInvocation(CtExpression<?> target, CtExecutableReference<T> executable, CtExpression<?>... arguments) {\n\t\treturn Code().createInvocation(target, executable, arguments);\n\t}\n\n\t@Override\n\tpublic <T> CtLiteral<T> createLiteral(T value) {\n\t\treturn Code().createLiteral(value);\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariable<T> createLocalVariable(CtTypeReference<T> type, String name, CtExpression<T> defaultExpression) {\n\t\treturn Code().createLocalVariable(type, name, defaultExpression);\n\t}\n\n\t@SuppressWarnings(value = \"unchecked\")\n\t@Override\n\tpublic <T> CtNewArray<T[]> createLiteralArray(T[] value) {\n\t\treturn Code().createLiteralArray(value);\n\t}\n\n\t@Override\n\tpublic CtNewClass<?> createNewClass(CtType<?> superClass, CtExpression<?>... parameters)  {\n\t\treturn Code().createNewClass(superClass, parameters);\n\t}\n\n\t@Override\n\tpublic <T> CtStatementList createVariableAssignments(List<? extends CtVariable<T>> variables, List<? extends CtExpression<T>> expressions) {\n\t\treturn Code().createVariableAssignments(variables, expressions);\n\t}\n\n\t@Override\n\tpublic <T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type) {\n\t\treturn Code().createThisAccess(type);\n\t}\n\n\t@Override\n\tpublic <T> CtThisAccess<T> createThisAccess(CtTypeReference<T> type, boolean isImplicit) {\n\t\treturn Code().createThisAccess(type, isImplicit);\n\t}\n\n\t@Override\n\tpublic <T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType) {\n\t\treturn Code().createTypeAccess(accessedType);\n\t}\n\n\t@Override\n\tpublic <T> CtTypeAccess<T> createTypeAccess(CtTypeReference<T> accessedType, boolean isImplicit) {\n\t\treturn Code().createTypeAccess(accessedType, isImplicit);\n\t}\n\n\t@Override\n\tpublic <T> CtTypeAccess<T> createTypeAccessWithoutCloningReference(CtTypeReference<T> accessedType) {\n\t\treturn Code().createTypeAccessWithoutCloningReference(accessedType);\n\t}\n\n\t@Override\n\tpublic <T> CtVariableAccess<T> createVariableRead(CtVariableReference<T> variable, boolean isStatic) {\n\t\treturn Code().createVariableRead(variable, isStatic);\n\t}\n\n\t@Override\n\tpublic <T> CtField<T> createCtField(String name, CtTypeReference<T> type, String exp, ModifierKind... visibilities) {\n\t\treturn Code().createCtField(name, type, exp, visibilities);\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariableReference<T> createCatchVariableReference(CtCatchVariable<T> catchVariable) {\n\t\treturn Code().createCatchVariableReference(catchVariable);\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference(CtLocalVariable<T> localVariable) {\n\t\treturn Code().createLocalVariableReference(localVariable);\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference(CtTypeReference<T> type, String name) {\n\t\treturn Code().createLocalVariableReference(type, name);\n\t}\n\n\t@Override\n\tpublic <T> CtTypeReference<T> createCtTypeReference(Class<?> originalClass) {\n\t\treturn Code().createCtTypeReference(originalClass);\n\t}\n\n\t@Override\n\tpublic List<CtExpression<?>> createVariableReads(List<? extends CtVariable<?>> variables) {\n\t\treturn Code().createVariableReads(variables);\n\t}\n\n\t@Override\n\tpublic CtCatch createCtCatch(String nameCatch, Class<? extends Throwable> exception, CtBlock<?> ctBlock) {\n\t\treturn Code().createCtCatch(nameCatch, exception, ctBlock);\n\t}\n\n\t@Override\n\tpublic CtCodeSnippetStatement createCodeSnippetStatement(String statement) {\n\t\treturn Code().createCodeSnippetStatement(statement);\n\t}\n\n\t@Override\n\tpublic CtComment createComment(String content, CtComment.CommentType type) {\n\t\treturn Code().createComment(content, type);\n\t}\n\n\t@Override\n\tpublic CtComment createInlineComment(String content) {\n\t\treturn Code().createInlineComment(content);\n\t}\n\n\t@Override\n\tpublic CtJavaDocTag createJavaDocTag(String content, CtJavaDocTag.TagType type) {\n\t\treturn Code().createJavaDocTag(content, type);\n\t}\n\n\t@Override\n\tpublic CtThrow createCtThrow(String thrownExp) {\n\t\treturn Code().createCtThrow(thrownExp);\n\t}\n\n\t@Override\n\tpublic CtPackageReference createCtPackageReference(Package originalPackage) {\n\t\treturn Code().createCtPackageReference(originalPackage);\n\t}\n\n\t@Override\n\tpublic <T> CtConstructor<T> createDefault(CtClass<T> target) {\n\t\treturn Constructor().createDefault(target);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> CtAnnotation<A> createAnnotation() {\n\t\treturn Core().createAnnotation();\n\t}\n\n\t@Override\n\tpublic <R> CtBlock<R> createBlock() {\n\t\treturn Core().createBlock();\n\t}\n\n\t@Override\n\tpublic <R> CtReturn<R> createReturn() {\n\t\treturn Core().createReturn();\n\t}\n\n\t@Override\n\tpublic <R> CtStatementList createStatementList() {\n\t\treturn Core().createStatementList();\n\t}\n\n\t@Override\n\tpublic <S> CtCase<S> createCase() {\n\t\treturn Core().createCase();\n\t}\n\n\t@Override\n\tpublic <S> CtSwitch<S> createSwitch() {\n\t\treturn Core().createSwitch();\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> CtEnum<T> createEnum() {\n\t\treturn Core().createEnum();\n\t}\n\n\t@Override\n\tpublic <T extends Annotation> CtAnnotationType<T> createAnnotationType() {\n\t\treturn Core().createAnnotationType();\n\t}\n\n\t@Override\n\tpublic <T, A extends T> CtAssignment<T, A> createAssignment() {\n\t\treturn Core().createAssignment();\n\t}\n\n\t@Override\n\tpublic <T, A extends T> CtOperatorAssignment<T, A> createOperatorAssignment() {\n\t\treturn Core().createOperatorAssignment();\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression() {\n\t\treturn Core().createExecutableReferenceExpression();\n\t}\n\n\t@Override\n\tpublic <T> CtAnnotationFieldAccess<T> createAnnotationFieldAccess() {\n\t\treturn Core().createAnnotationFieldAccess();\n\t}\n\n\t@Override\n\tpublic <T> CtArrayRead<T> createArrayRead() {\n\t\treturn Core().createArrayRead();\n\t}\n\n\t@Override\n\tpublic <T> CtArrayWrite<T> createArrayWrite() {\n\t\treturn Core().createArrayWrite();\n\t}\n\n\t@Override\n\tpublic <T> CtAssert<T> createAssert() {\n\t\treturn Core().createAssert();\n\t}\n\n\t@Override\n\tpublic <T> CtBinaryOperator<T> createBinaryOperator() {\n\t\treturn Core().createBinaryOperator();\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariable<T> createCatchVariable() {\n\t\treturn Core().createCatchVariable();\n\t}\n\n\t@Override\n\tpublic <T> CtCodeSnippetExpression<T> createCodeSnippetExpression() {\n\t\treturn Core().createCodeSnippetExpression();\n\t}\n\n\t@Override\n\tpublic <T> CtConditional<T> createConditional() {\n\t\treturn Core().createConditional();\n\t}\n\n\t@Override\n\tpublic <T> CtConstructorCall<T> createConstructorCall() {\n\t\treturn Core().createConstructorCall();\n\t}\n\n\t@Override\n\tpublic <T> CtFieldRead<T> createFieldRead() {\n\t\treturn Core().createFieldRead();\n\t}\n\n\t@Override\n\tpublic <T> CtFieldWrite<T> createFieldWrite() {\n\t\treturn Core().createFieldWrite();\n\t}\n\n\t@Override\n\tpublic <T> CtInvocation<T> createInvocation() {\n\t\treturn Core().createInvocation();\n\t}\n\n\t@Override\n\tpublic <T> CtLambda<T> createLambda() {\n\t\treturn Core().createLambda();\n\t}\n\n\t@Override\n\tpublic <T> CtLiteral<T> createLiteral() {\n\t\treturn Core().createLiteral();\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariable<T> createLocalVariable() {\n\t\treturn Core().createLocalVariable();\n\t}\n\n\t@Override\n\tpublic <T> CtNewArray<T> createNewArray() {\n\t\treturn Core().createNewArray();\n\t}\n\n\t@Override\n\tpublic <T> CtNewClass<T> createNewClass() {\n\t\treturn Core().createNewClass();\n\t}\n\n\t@Override\n\tpublic <T> CtSuperAccess<T> createSuperAccess() {\n\t\treturn Core().createSuperAccess();\n\t}\n\n\t@Override\n\tpublic <T> CtThisAccess<T> createThisAccess() {\n\t\treturn Core().createThisAccess();\n\t}\n\n\t@Override\n\tpublic <T> CtTypeAccess<T> createTypeAccess() {\n\t\treturn Core().createTypeAccess();\n\t}\n\n\t@Override\n\tpublic <T> CtUnaryOperator<T> createUnaryOperator() {\n\t\treturn Core().createUnaryOperator();\n\t}\n\n\t@Override\n\tpublic <T> CtVariableRead<T> createVariableRead() {\n\t\treturn Core().createVariableRead();\n\t}\n\n\t@Override\n\tpublic <T> CtVariableWrite<T> createVariableWrite() {\n\t\treturn Core().createVariableWrite();\n\t}\n\n\t@Override\n\tpublic <T> CtAnnotationMethod<T> createAnnotationMethod() {\n\t\treturn Core().createAnnotationMethod();\n\t}\n\n\t@Override\n\tpublic <T> CtClass<T> createClass() {\n\t\treturn Core().createClass();\n\t}\n\n\t@Override\n\tpublic <T> CtConstructor<T> createConstructor() {\n\t\treturn Core().createConstructor();\n\t}\n\n\t@Override\n\tpublic <T> CtConstructor<T> createInvisibleArrayConstructor() {\n\t\treturn Core().createInvisibleArrayConstructor();\n\t}\n\n\t@Override\n\tpublic <T> CtEnumValue<T> createEnumValue() {\n\t\treturn Core().createEnumValue();\n\t}\n\n\t@Override\n\tpublic <T> CtField<T> createField() {\n\t\treturn Core().createField();\n\t}\n\n\t@Override\n\tpublic <T> CtInterface<T> createInterface() {\n\t\treturn Core().createInterface();\n\t}\n\n\t@Override\n\tpublic <T> CtMethod<T> createMethod() {\n\t\treturn Core().createMethod();\n\t}\n\n\t@Override\n\tpublic <T> CtParameter<T> createParameter() {\n\t\treturn Core().createParameter();\n\t}\n\n\t@Override\n\tpublic <T> CtArrayTypeReference<T> createArrayTypeReference() {\n\t\treturn Core().createArrayTypeReference();\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariableReference<T> createCatchVariableReference() {\n\t\treturn Core().createCatchVariableReference();\n\t}\n\n\t@Override\n\tpublic <T> CtExecutableReference<T> createExecutableReference() {\n\t\treturn Core().createExecutableReference();\n\t}\n\n\t@Override\n\tpublic <T> CtFieldReference<T> createFieldReference() {\n\t\treturn Core().createFieldReference();\n\t}\n\n\t@Override\n\tpublic <T> CtIntersectionTypeReference<T> createIntersectionTypeReference() {\n\t\treturn Core().createIntersectionTypeReference();\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference() {\n\t\treturn Core().createLocalVariableReference();\n\t}\n\n\t@Override\n\tpublic <T> CtParameterReference<T> createParameterReference() {\n\t\treturn Core().createParameterReference();\n\t}\n\n\t@Override\n\tpublic <T> CtTypeReference<T> createTypeReference() {\n\t\treturn Core().createTypeReference();\n\t}\n\n\t@Override\n\tpublic <T> CtUnboundVariableReference<T> createUnboundVariableReference() {\n\t\treturn Core().createUnboundVariableReference();\n\t}\n\n\t@Override\n\tpublic CtBreak createBreak() {\n\t\treturn Core().createBreak();\n\t}\n\n\t@Override\n\tpublic CtCatch createCatch() {\n\t\treturn Core().createCatch();\n\t}\n\n\t@Override\n\tpublic CtCodeSnippetStatement createCodeSnippetStatement() {\n\t\treturn Core().createCodeSnippetStatement();\n\t}\n\n\t@Override\n\tpublic CtComment createComment() {\n\t\treturn Core().createComment();\n\t}\n\n\t@Override\n\tpublic CtContinue createContinue() {\n\t\treturn Core().createContinue();\n\t}\n\n\t@Override\n\tpublic CtDo createDo() {\n\t\treturn Core().createDo();\n\t}\n\n\t@Override\n\tpublic CtFor createFor() {\n\t\treturn Core().createFor();\n\t}\n\n\t@Override\n\tpublic CtForEach createForEach() {\n\t\treturn Core().createForEach();\n\t}\n\n\t@Override\n\tpublic CtIf createIf() {\n\t\treturn Core().createIf();\n\t}\n\n\t@Override\n\tpublic CtSynchronized createSynchronized() {\n\t\treturn Core().createSynchronized();\n\t}\n\n\t@Override\n\tpublic CtThrow createThrow() {\n\t\treturn Core().createThrow();\n\t}\n\n\t@Override\n\tpublic CtTry createTry() {\n\t\treturn Core().createTry();\n\t}\n\n\t@Override\n\tpublic CtTryWithResource createTryWithResource() {\n\t\treturn Core().createTryWithResource();\n\t}\n\n\t@Override\n\tpublic CtWhile createWhile() {\n\t\treturn Core().createWhile();\n\t}\n\n\t@Override\n\tpublic CompilationUnit createCompilationUnit() {\n\t\treturn Core().createCompilationUnit();\n\t}\n\n\t@Override\n\tpublic SourcePosition createSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int[] lineSeparatorPositions) {\n\t\treturn Core().createSourcePosition(compilationUnit, startSource, end, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic BodyHolderSourcePosition createBodyHolderSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int bodyStart, int bodyEnd, int[] lineSeparatorPositions) {\n\t\treturn Core().createBodyHolderSourcePosition(compilationUnit, startSource, end, modifierStart, modifierEnd, declarationStart, declarationEnd, bodyStart, bodyEnd, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic DeclarationSourcePosition createDeclarationSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int[] lineSeparatorPositions) {\n\t\treturn Core().createDeclarationSourcePosition(compilationUnit, startSource, end, modifierStart, modifierEnd, declarationStart, declarationEnd, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic CtAnonymousExecutable createAnonymousExecutable() {\n\t\treturn Core().createAnonymousExecutable();\n\t}\n\n\t@Override\n\tpublic CtPackage createPackage() {\n\t\treturn Core().createPackage();\n\t}\n\n\t@Override\n\tpublic CtTypeParameter createTypeParameter() {\n\t\treturn Core().createTypeParameter();\n\t}\n\n\t@Override\n\tpublic CtPackageReference createPackageReference() {\n\t\treturn Core().createPackageReference();\n\t}\n\n\t@Override\n\tpublic CtTypeParameterReference createTypeParameterReference() {\n\t\treturn Core().createTypeParameterReference();\n\t}\n\n\t@Override\n\tpublic CtWildcardReference createWildcardReference() {\n\t\treturn Core().createWildcardReference();\n\t}\n\n\t@Override\n\tpublic PartialEvaluator createPartialEvaluator() {\n\t\treturn Eval().createPartialEvaluator();\n\t}\n\n\t@Override\n\tpublic <T> CtParameter<T> createParameter(CtExecutable<?> parent, CtTypeReference<T> type, String name) {\n\t\treturn Executable().createParameter(parent, type, name);\n\t}\n\n\t@Override\n\tpublic <T> CtParameterReference<T> createParameterReference(CtParameter<T> parameter) {\n\t\treturn Executable().createParameterReference(parameter);\n\t}\n\n\t@Override\n\tpublic CtAnonymousExecutable createAnonymous(CtClass<?> target, CtBlock<Void> body) {\n\t\treturn Executable().createAnonymous(target, body);\n\t}\n\n\t@Override\n\tpublic <T> CtArrayTypeReference<T> createArrayReference(String qualifiedName) {\n\t\treturn Type().createArrayReference(qualifiedName);\n\t}\n\n\t@Override\n\tpublic <T> CtArrayTypeReference<T[]> createArrayReference(CtType<T> type) {\n\t\treturn Type().createArrayReference(type);\n\t}\n\n\t@Override\n\tpublic <T> CtArrayTypeReference<T[]> createArrayReference(CtTypeReference<T> reference) {\n\t\treturn Type().createArrayReference(reference);\n\t}\n\n\t@Override\n\tpublic <T> CtIntersectionTypeReference<T> createIntersectionTypeReferenceWithBounds(List<CtTypeReference<?>> bounds) {\n\t\treturn Type().createIntersectionTypeReferenceWithBounds(bounds);\n\t}\n\n\t@Override\n\tpublic GenericTypeAdapter createTypeAdapter(CtFormalTypeDeclarer formalTypeDeclarer) {\n\t\treturn Type().createTypeAdapter(formalTypeDeclarer);\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> createReferences(List<Class<?>> classes) {\n\t\treturn Type().createReferences(classes);\n\t}\n\n\t@Override\n\tpublic CtArrayTypeReference<?> createArrayReference(CtTypeReference<?> reference, int n) {\n\t\treturn Type().createArrayReference(reference, n);\n\t}\n\n\t@Override\n\tpublic CtTypeParameterReference createTypeParameterReference(String name) {\n\t\treturn Type().createTypeParameterReference(name);\n\t}\n\n\t@Override\n\tpublic CtQuery createQuery() {\n\t\treturn Query().createQuery();\n\t}\n\n\t@Override\n\tpublic CtQuery createQuery(Object input) {\n\t\treturn Query().createQuery(input);\n\t}\n\n\t@Override\n\tpublic CtQuery createQuery(Object[] input) {\n\t\treturn Query().createQuery(input);\n\t}\n\n\t@Override\n\tpublic CtQuery createQuery(Iterable<?> input) {\n\t\treturn Query().createQuery(input);\n\t}\n\n\t@Override\n\tpublic CtAnnotationType createAnnotationType(String qualifiedName) {\n\t\treturn Annotation().create(qualifiedName);\n\t}\n\n\t@Override\n\tpublic CtAnnotationType createAnnotationType(CtPackage owner, String simpleName) {\n\t\treturn Annotation().create(owner, simpleName);\n\t}\n\n\t@Override\n\tpublic CtClass createClass(String qualifiedName) {\n\t\treturn Class().create(qualifiedName);\n\t}\n\n\t@Override\n\tpublic CtClass createClass(CtClass<?> declaringClass, String simpleName) {\n\t\treturn Class().create(declaringClass, simpleName);\n\t}\n\n\t@Override\n\tpublic CtClass createClass(CtPackage owner, String simpleName) {\n\t\treturn Class().create(owner, simpleName);\n\t}\n\n\t@Override\n\tpublic CtConstructor createConstructor(CtClass target, CtConstructor<?> source) {\n\t\treturn Constructor().create(target, source);\n\t}\n\n\t@Override\n\tpublic CtConstructor createConstructor(CtClass target, CtMethod<?> source) {\n\t\treturn Constructor().create(target, source);\n\t}\n\n\t@Override\n\tpublic CtConstructor createConstructor(CtClass target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\treturn Constructor().create(target, modifiers, parameters, thrownTypes);\n\t}\n\n\t@Override\n\tpublic CtConstructor createConstructor(CtClass target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock body) {\n\t\treturn Constructor().create(target, modifiers, parameters, thrownTypes, body);\n\t}\n\n\t@Override\n\tpublic CtEnum<?> createEnum(String qualifiedName) {\n\t\treturn Enum().create(qualifiedName);\n\t}\n\n\t@Override\n\tpublic CtEnum<?> createEnum(CtPackage owner, String simpleName) {\n\t\treturn Enum().create(owner, simpleName);\n\t}\n\n\t@Override\n\tpublic CtField createField(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference type, String name) {\n\t\treturn Field().create(target, modifiers, type, name);\n\t}\n\n\t@Override\n\tpublic CtField createField(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference type, String name, CtExpression defaultExpression) {\n\t\treturn Field().create(target, modifiers, type, name, defaultExpression);\n\t}\n\n\t@Override\n\tpublic CtField createField(CtType<?> target, CtField source) {\n\t\treturn Field().create(target, source);\n\t}\n\n\t@Override\n\tpublic CtInterface createInterface(CtPackage owner, String simpleName) {\n\t\treturn Interface().create(owner, simpleName);\n\t}\n\n\t@Override\n\tpublic CtInterface createInterface(CtType owner, String simpleName) {\n\t\treturn Interface().create(owner, simpleName);\n\t}\n\n\t@Override\n\tpublic CtInterface createInterface(String qualifiedName) {\n\t\treturn Interface().create(qualifiedName);\n\t}\n\n\t@Override\n\tpublic CtMethod createMethod(CtClass<?> target, Set<ModifierKind> modifiers, CtTypeReference returnType, String name, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock body) {\n\t\treturn Method().create(target, modifiers, returnType, name, parameters, thrownTypes, body);\n\t}\n\n\t@Override\n\tpublic CtMethod createMethod(CtType<?> target, CtMethod source, boolean redirectReferences) {\n\t\treturn Method().create(target, source, redirectReferences);\n\t}\n\n\t@Override\n\tpublic CtMethod createMethod(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference returnType, String name, List<CtParameter<?>> parameters, Set<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\treturn Method().create(target, modifiers, returnType, name, parameters, thrownTypes);\n\t}\n\n\t@Override\n\tpublic CtPackage createPackage(CtPackage parent, String simpleName) {\n\t\treturn Package().create(parent, simpleName);\n\t}\n\n\t@Override\n\tpublic CtElement createElement(Class<? extends CtElement> klass) {\n\t\treturn Core().create(klass);\n\t}\n\n\t@Override\n\tpublic CtImport createImport(CtReference reference) {\n\t\treturn Type().createImport(reference);\n\t}\n\n\t@Override\n\tpublic CtImport createUnresolvedImport(String reference, boolean isStatic) {\n\t\treturn Type().createUnresolvedImport(reference, isStatic);\n\t}\n\n\t@Override\n\tpublic CtTypeMemberWildcardImportReference createTypeMemberWildcardImportReference(CtTypeReference typeReference) {\n\t\treturn Type().createTypeMemberWildcardImportReference(typeReference);\n\t}\n\n\t@Override\n\tpublic CtPackageExport createPackageExport(CtPackageReference ctPackageReference) {\n\t\treturn Module().createPackageExport(ctPackageReference);\n\t}\n\n\t@Override\n\tpublic CtProvidedService createProvidedService(CtTypeReference ctTypeReference) {\n\t\treturn Module().createProvidedService(ctTypeReference);\n\t}\n\n\t@Override\n\tpublic CtModuleRequirement createModuleRequirement(CtModuleReference ctModuleReference) {\n\t\treturn Module().createModuleRequirement(ctModuleReference);\n\t}\n\n\t@Override\n\tpublic CtModule createModule(String moduleName) {\n\t\treturn Module().getOrCreate(moduleName);\n\t}\n\n\t@Override\n\tpublic CtModuleReference createModuleReference(CtModule ctModule) {\n\t\treturn Module().createReference(ctModule);\n\t}\n\n\t@Override\n\tpublic CtUsedService createUsedService(CtTypeReference typeReference) {\n\t\treturn Module().createUsedService(typeReference);\n\t}\n\n\t@Override\n\tpublic SourcePosition createPartialSourcePosition(CompilationUnit compilationUnit) {\n\t\treturn Core().createPartialSourcePosition(compilationUnit);\n\t}\n\n\t@Override\n\tpublic CtPackageDeclaration createPackageDeclaration(CtPackageReference packageRef) {\n\t\treturn Package().createPackageDeclaration(packageRef);\n\t}\n\n\t@Override\n\tpublic <T> CtTypeReference<T> createReference(String qualifiedName) {\n\t\treturn Type().createReference(qualifiedName);\n\t}\n}\n"
    }, {
      "name" : "reflect/factory/EvalFactory.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.eval.PartialEvaluator;\nimport spoon.support.reflect.eval.VisitorPartialEvaluator;\n\n/**\n * A factory to create some evaluation utilities on the Spoon metamodel.\n */\npublic class EvalFactory extends SubFactory {\n\n\t/**\n\t * Creates the evaluation factory.\n\t */\n\tpublic EvalFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a partial evaluator on the Spoon meta-model.\n\t */\n\tpublic PartialEvaluator createPartialEvaluator() {\n\t\treturn new VisitorPartialEvaluator();\n\t}\n}\n"
    }, {
      "name" : "reflect/factory/ModuleFactory.java",
      "weight" : 117.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport spoon.reflect.CtModelImpl;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\nimport spoon.support.reflect.declaration.CtModuleImpl;\n\n\npublic class ModuleFactory extends SubFactory {\n\n\tpublic static class CtUnnamedModule extends CtModuleImpl {\n\t\tfinal Set<CtModule> allModules = new HashSet<>();\n\t\tfinal CtElement parent = new CtElementImpl() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtVisitor visitor) {\n\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic CtElement getParent() throws ParentNotInitializedException {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Factory getFactory() {\n\t\t\t\treturn CtUnnamedModule.this.getFactory();\n\t\t\t}\n\t\t};\n\n\n\t\t{\n\t\t\tthis.setSimpleName(CtModule.TOP_LEVEL_MODULE_NAME);\n\t\t\tthis.addModule(this);\n\t\t}\n\n\t\tpublic boolean addModule(CtModule module) {\n\t\t\treturn this.allModules.add(module);\n\t\t}\n\n\t\tpublic CtModule getModule(String name) {\n\t\t\tfor (CtModule module : this.allModules) {\n\t\t\t\tif (module.getSimpleName().equals(name)) {\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic Collection<CtModule> getAllModules() {\n\t\t\treturn Collections.unmodifiableCollection(allModules);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends CtNamedElement> T setSimpleName(String name) {\n\t\t\tif (name == null) {\n\t\t\t\treturn (T) this;\n\t\t\t}\n\n\t\t\tif (name.equals(CtModule.TOP_LEVEL_MODULE_NAME)) {\n\t\t\t\treturn super.setSimpleName(name);\n\t\t\t}\n\n\t\t\treturn (T) this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn CtModule.TOP_LEVEL_MODULE_NAME;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(CtVisitor visitor) {\n\t\t\tvisitor.visitCtModule(this);\n\t\t}\n\n\t\t@Override\n\t\tpublic CtElement getParent() {\n\t\t\treturn this.parent;\n\t\t}\n\t}\n\n\tpublic ModuleFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\tpublic CtUnnamedModule getUnnamedModule() {\n\t\treturn (CtUnnamedModule) factory.getModel().getUnnamedModule();\n\t}\n\n\tpublic Collection<CtModule> getAllModules() {\n\t\treturn getUnnamedModule().getAllModules();\n\t}\n\n\tpublic CtModule getModule(String moduleName) {\n\t\treturn getUnnamedModule().getModule(moduleName);\n\t}\n\n\tpublic CtModule getOrCreate(String moduleName) {\n\t\tif (moduleName == null || moduleName.isEmpty()) {\n\t\t\treturn getUnnamedModule();\n\t\t}\n\n\t\tCtModule ctModule = getUnnamedModule().getModule(moduleName);\n\t\tif (ctModule == null) {\n\t\t\tctModule = factory.Core().createModule().setSimpleName(moduleName);\n\t\t\tctModule.setRootPackage(new CtModelImpl.CtRootPackage());\n\t\t\tctModule.setParent(getUnnamedModule());\n\t\t}\n\n\t\treturn ctModule;\n\t}\n\n\tpublic CtModuleReference createReference(CtModule module) {\n\t\treturn factory.Core().createModuleReference().setSimpleName(module.getSimpleName());\n\t}\n\n\tpublic CtModuleRequirement createModuleRequirement(CtModuleReference moduleReference) {\n\t\treturn factory.Core().createModuleRequirement().setModuleReference(moduleReference);\n\t}\n\n\tpublic CtPackageExport createPackageExport(CtPackageReference ctPackageReference) {\n\t\treturn factory.Core().createPackageExport().setPackageReference(ctPackageReference);\n\t}\n\n\tpublic CtProvidedService createProvidedService(CtTypeReference typeReference) {\n\t\treturn factory.Core().createProvidedService().setServiceType(typeReference);\n\t}\n\n\tpublic CtUsedService createUsedService(CtTypeReference typeReference) {\n\t\treturn factory.Core().createUsedService().setServiceType(typeReference);\n\t}\n}\n\n"
    }, {
      "name" : "reflect/factory/ConstructorFactory.java",
      "weight" : 80.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.reflect.Constructor;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * The {@link CtConstructor} sub-factory.\n */\npublic class ConstructorFactory extends ExecutableFactory {\n\n\t/**\n\t * Creates a new constructor sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic ConstructorFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Copies a constructor into a target class.\n\t *\n\t * @param target\n\t * \t\tthe target class\n\t * @param source\n\t * \t\tthe constructor to be copied\n\t * @return the new constructor\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtConstructor<T> create(CtClass<T> target, CtConstructor<?> source) {\n\t\tCtConstructor<T> newConstructor = (CtConstructor<T>) source.clone();\n\t\ttarget.addConstructor(newConstructor);\n\t\treturn newConstructor;\n\t}\n\n\t/**\n\t * Creates a constructor into a target class by copying it from a source\n\t * method.\n\t *\n\t * @param target\n\t * \t\tthe target class\n\t * @param source\n\t * \t\tthe method to be copied\n\t * @return the new constructor\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtConstructor<T> create(CtClass<T> target, CtMethod<?> source) {\n\t\tCtMethod<T> method = (CtMethod<T>) source.clone();\n\t\tCtConstructor<T> newConstructor = factory.Core().createConstructor();\n\t\tnewConstructor.setAnnotations(method.getAnnotations());\n\t\tnewConstructor.setBody(method.getBody());\n\t\tnewConstructor.setDocComment(method.getDocComment());\n\t\tnewConstructor.setFormalCtTypeParameters(method.getFormalCtTypeParameters());\n\t\tnewConstructor.setModifiers(method.getModifiers());\n\t\tnewConstructor.setParameters(method.getParameters());\n\t\ttarget.addConstructor(newConstructor);\n\t\treturn newConstructor;\n\t}\n\n\t/**\n\t * Creates an empty constructor.\n\t *\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param parameters\n\t * \t\tthe parameters\n\t * @param thrownTypes\n\t * \t\tthe thrown types\n\t */\n\tpublic <T> CtConstructor<T> create(CtClass<T> target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters,\n\t\t\tSet<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\tCtConstructor<T> constructor = factory.Core().createConstructor();\n\t\tconstructor.setModifiers(modifiers);\n\t\tconstructor.setParameters(parameters);\n\t\tconstructor.setThrownTypes(thrownTypes);\n\t\ttarget.addConstructor(constructor);\n\t\treturn constructor;\n\t}\n\n\t/**\n\t * Create the default empty constructor.\n\t *\n\t * @param target\n\t * \t\tthe class to insert the constructor into\n\t * @return the created constructor\n\t */\n\tpublic <T> CtConstructor<T> createDefault(CtClass<T> target) {\n\t\tCtConstructor<T> constructor = factory.Core().createConstructor();\n\t\tconstructor.addModifier(ModifierKind.PUBLIC);\n\t\ttarget.addConstructor(constructor);\n\t\treturn constructor;\n\t}\n\n\t/**\n\t * Creates a constructor.\n\t *\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param parameters\n\t * \t\tthe parameters\n\t * @param thrownTypes\n\t * \t\tthe thrown types\n\t * @param body\n\t * \t\tthe body\n\t */\n\tpublic <T> CtConstructor<T> create(CtClass<T> target, Set<ModifierKind> modifiers, List<CtParameter<?>> parameters,\n\t\t\tSet<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock<T> body) {\n\t\tCtConstructor<T> constructor = create(target, modifiers, parameters, thrownTypes);\n\t\tconstructor.setBody(body);\n\t\treturn constructor;\n\t}\n\n\t/**\n\t * Creates a constructor reference from an existing constructor.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtConstructor<T> c) {\n\t\treturn factory.Executable().createReference(c);\n\t}\n\n\t/**\n\t * Creates a constructor reference from an actual constructor.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(Constructor<T> constructor) {\n\t\tCtTypeReference<T> type = factory.Type().createReference(constructor.getDeclaringClass());\n\t\treturn createReference(type, type.clone(), CtExecutableReference.CONSTRUCTOR_NAME,\n\t\t\t\tfactory.Type().createReferences(Arrays.asList(constructor.getParameterTypes())));\n\t}\n\n\t/**\n\t * Creates a constructor reference.\n\t * @param type Declaring type of the constructor.\n\t * @param parameters Constructor parameters.\n\t * @param <T> Infered type of the constructor.\n\t * @return CtExecutablereference if a constructor.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtTypeReference<T> type, CtExpression<?>...parameters) {\n\t\tfinal CtExecutableReference<T> executableReference = factory.Core().createExecutableReference();\n\t\texecutableReference.setType(type);\n\t\texecutableReference.setDeclaringType(type == null ? null : type.clone());\n\t\texecutableReference.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\t\tList<CtTypeReference<?>> typeReferences = new ArrayList<>();\n\t\tfor (CtExpression<?> parameter : parameters) {\n\t\t\ttypeReferences.add(parameter.getType() == null ? null : parameter.getType().clone());\n\t\t}\n\t\texecutableReference.setParameters(typeReferences);\n\t\treturn executableReference;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/CompilationUnitFactory.java",
      "weight" : 109.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.SpoonException;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.support.compiler.VirtualFile;\nimport spoon.support.compiler.jdt.JDTSnippetCompiler;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * A factory to create some evaluation utilities on the Spoon metamodel.\n */\npublic class CompilationUnitFactory extends SubFactory {\n\n\t/**\n\t * Creates the evaluation factory.\n\t */\n\tpublic CompilationUnitFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\tprivate transient Map<String, CompilationUnit> cachedCompilationUnits = new TreeMap<>();\n\n\t/**\n\t * Gets the compilation unit map.\n\t *\n\t * @return a map (path -&gt; {@link CompilationUnit})\n\t */\n\tpublic Map<String, CompilationUnit> getMap() {\n\t\treturn cachedCompilationUnits;\n\t}\n\n\t/**\n\t * Creates a compilation unit with no associated files.\n\t */\n\tpublic CompilationUnit create() {\n\t\treturn factory.Core().createCompilationUnit();\n\t}\n\n\tpublic CompilationUnit getOrCreate(CtPackage ctPackage) {\n\t\tif (ctPackage.getPosition().getCompilationUnit() != null) {\n\t\t\treturn ctPackage.getPosition().getCompilationUnit();\n\t\t} else {\n\n\t\t\tCtModule module;\n\t\t\tif (factory.getEnvironment().getComplianceLevel() > 8) {\n\t\t\t\tmodule = ctPackage.getParent(CtModule.class);\n\t\t\t} else {\n\t\t\t\tmodule = null;\n\t\t\t}\n\t\t\tFile file = this.factory.getEnvironment().getOutputDestinationHandler().getOutputPath(module, ctPackage, null).toFile();\n\t\t\ttry {\n\t\t\t\tString path = file.getCanonicalPath();\n\t\t\t\tCompilationUnit result = this.getOrCreate(path);\n\t\t\t\tresult.setDeclaredPackage(ctPackage);\n\t\t\t\tctPackage.setPosition(this.factory.createPartialSourcePosition(result));\n\t\t\t\treturn result;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new SpoonException(\"Cannot get path for file: \" + file.getAbsolutePath(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic CompilationUnit getOrCreate(CtType type) {\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type.getPosition().getCompilationUnit() != null) {\n\t\t\treturn type.getPosition().getCompilationUnit();\n\t\t}\n\n\t\tif (type.isTopLevel()) {\n\t\t\tCtModule module;\n\t\t\tif (type.getPackage() != null && factory.getEnvironment().getComplianceLevel() > 8) {\n\t\t\t\tmodule = type.getPackage().getParent(CtModule.class);\n\t\t\t} else {\n\t\t\t\tmodule = null;\n\t\t\t}\n\t\t\tFile file = this.factory.getEnvironment().getOutputDestinationHandler().getOutputPath(module, type.getPackage(), type).toFile();\n\t\t\ttry {\n\t\t\t\tString path = file.getCanonicalPath();\n\t\t\t\tCompilationUnit result = this.getOrCreate(path);\n\t\t\t\tresult.addDeclaredType(type);\n\t\t\t\ttype.setPosition(this.factory.createPartialSourcePosition(result));\n\t\t\t\treturn result;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new SpoonException(\"Cannot get path for file: \" + file.getAbsolutePath(), e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn getOrCreate(type.getTopLevelType());\n\t\t}\n\t}\n\n\tpublic CompilationUnit getOrCreate(CtModule module) {\n\t\tif (module.getPosition().getCompilationUnit() != null) {\n\t\t\treturn module.getPosition().getCompilationUnit();\n\t\t} else {\n\t\t\tFile file = this.factory.getEnvironment().getOutputDestinationHandler().getOutputPath(module, null, null).toFile();\n\t\t\ttry {\n\t\t\t\tString path = file.getCanonicalPath();\n\t\t\t\tCompilationUnit result = this.getOrCreate(path);\n\t\t\t\tresult.setDeclaredModule(module);\n\t\t\t\tmodule.setPosition(this.factory.createPartialSourcePosition(result));\n\t\t\t\treturn result;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new SpoonException(\"Cannot get path for file: \" + file.getAbsolutePath(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates or gets a compilation unit for a given file path.\n\t */\n\tpublic CompilationUnit getOrCreate(String filePath) {\n\t\tCompilationUnit cu = cachedCompilationUnits.get(filePath);\n\t\tif (cu == null) {\n\t\t\tif (filePath.startsWith(JDTSnippetCompiler.SNIPPET_FILENAME_PREFIX)) {\n\t\t\t\tcu = factory.Core().createCompilationUnit();\n\t\t\t\t//put the virtual compilation unit of code snippet into cache too, so the JDTCommentBuilder can found it\n\t\t\t\tcachedCompilationUnits.put(filePath, cu);\n\t\t\t\treturn cu;\n\t\t\t}\n\t\t\tcu = factory.Core().createCompilationUnit();\n\n\t\t\tif (!filePath.equals(VirtualFile.VIRTUAL_FILE_NAME)) {\n\t\t\t\tcu.setFile(new File(filePath));\n\t\t\t}\n\n\t\t\tcachedCompilationUnits.put(filePath, cu);\n\t\t}\n\t\treturn cu;\n\t}\n\n\t/**\n\t * Removes compilation unit from the cache and returns it\n\t * Used by JDTSnippetCompiler to remove processed snippet from the cache\n\t * @param filePath\n\t * @return a cached compilation unit or null\n\t */\n\tpublic CompilationUnit removeFromCache(String filePath) {\n\t\treturn cachedCompilationUnits.remove(filePath);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/EnumFactory.java",
      "weight" : 37.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * The {@link CtEnum} sub-factory.\n */\npublic class EnumFactory extends TypeFactory {\n\n\t/**\n\t * Creates a new enum sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic EnumFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a new enumeration type\n\t *\n\t * @param owner\n\t * \t\tpackage\n\t * @param simpleName\n\t * \t\tthe simple name\n\t */\n\tpublic CtEnum<?> create(CtPackage owner, String simpleName) {\n\t\tCtEnum<?> e = factory.Core().createEnum();\n\t\te.setSimpleName(simpleName);\n\t\towner.addType(e);\n\t\treturn e;\n\t}\n\n\t/**\n\t * Creates an enum from its qualified name.\n\t */\n\tpublic CtEnum<?> create(String qualifiedName) {\n\t\treturn create(\n\t\t\t\tfactory.Package().getOrCreate(getPackageName(qualifiedName)),\n\t\t\t\tgetSimpleName(qualifiedName));\n\t}\n\n\t/**\n\t * Gets an already created enumeration from its qualified name.\n\t *\n\t * @return the enumeration or null if does not exist\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtEnum<?> get(String qualifiedName) {\n\t\ttry {\n\t\t\treturn (CtEnum<?>) super.get(qualifiedName);\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a class from its runtime Java class.\n\t *\n\t * @param <T>\n\t * \t\ttype of created class\n\t * @param cl\n\t * \t\tthe java class: note that this class should be Class&lt;T&gt; but it\n\t * \t\tthen poses problem when T is a generic type itself\n\t */\n\tpublic <T extends Enum<?>> CtEnum<T> getEnum(Class<T> cl) {\n\t\ttry {\n\t\t\tCtType<T> t = super.get(cl);\n\t\t\treturn (CtEnum<T>) t;\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/PackageFactory.java",
      "weight" : 90.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtPackageReference;\n\n\n/**\n * The {@link CtPackage} sub-factory.\n */\npublic class PackageFactory extends SubFactory {\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Creates a new package sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic PackageFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a reference to an existing package.\n\t * The simple name of the reference will be the FQN of the given package\n\t */\n\tpublic CtPackageReference createReference(CtPackage pack) {\n\t\tif (pack == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\treturn createReference(pack.getQualifiedName());\n\t}\n\n\t/**\n\t * Creates a reference to a package by using its Java runtime\n\t * representation. The simple name of the reference will be the FQN of the given package\n\t *\n\t * @param pack\n\t * \t\ta runtime package\n\t * @return reference to the package\n\t */\n\tpublic CtPackageReference createReference(Package pack) {\n\t\treturn createReference(pack.getName());\n\t}\n\n\t/**\n\t * Returns a reference on the top level package.\n\t */\n\tpublic CtPackageReference topLevel() {\n\t\treturn factory.getModel().getRootPackage().getReference();\n\t}\n\n\t/**\n\t * Creates a reference to a package. The given name has to be a fully qualified name.\n\t *\n\t * @param name\n\t * \t\tfull name of the package to reference\n\t */\n\tpublic CtPackageReference createReference(String name) {\n\t\tCtPackageReference ref = factory.Core().createPackageReference();\n\t\tref.setSimpleName(name);\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Creates a package declaration of a package.\n\t *\n\t * @param packageRef a reference to a package\n\t */\n\tpublic CtPackageDeclaration createPackageDeclaration(CtPackageReference packageRef) {\n\t\tCtPackageDeclaration pd = factory.Core().createPackageDeclaration();\n\t\tpd.setReference(packageRef);\n\t\treturn pd;\n\t}\n\n\t/**\n\t * Creates a new package (see also {@link #getOrCreate(String)}).\n\t *\n\t * @param parent\n\t * \t\tthe parent package (can be null)\n\t * @param simpleName\n\t * \t\tthe package's simple name (no dots)\n\t * @return the newly created package\n\t */\n\tpublic CtPackage create(CtPackage parent, String simpleName) {\n\t\treturn getOrCreate(parent.toString() + CtPackage.PACKAGE_SEPARATOR + simpleName);\n\t}\n\n\t/**\n\t * Gets or creates a package for the unnamed module\n\t *\n\t * @param qualifiedName\n\t * \t\tthe full name of the package\n\t *\n\t */\n\tpublic CtPackage getOrCreate(String qualifiedName) {\n\t\treturn this.getOrCreate(qualifiedName, factory.getModel().getUnnamedModule());\n\t}\n\n\t/**\n\t * Gets or creates a package and make its parent the given module\n\t *\n\t * @param qualifiedName\n\t * \t\tthe full name of the package\n\t *\n\t * @param rootModule\n\t * \t\tThe parent module of the package\n\t */\n\tpublic CtPackage getOrCreate(String qualifiedName, CtModule rootModule) {\n\t\tif (qualifiedName.isEmpty()) {\n\t\t\treturn rootModule.getRootPackage();\n\t\t}\n\t\tStringTokenizer token = new StringTokenizer(qualifiedName, CtPackage.PACKAGE_SEPARATOR);\n\t\tCtPackage last = rootModule.getRootPackage();\n\n\t\twhile (token.hasMoreElements()) {\n\t\t\tString name = token.nextToken();\n\t\t\tCtPackage next = last.getPackage(name);\n\t\t\tif (next == null) {\n\t\t\t\tnext = factory.Core().createPackage();\n\t\t\t\tnext.setSimpleName(name);\n\t\t\t\tlast.addPackage(next);\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\treturn last;\n\t}\n\n\t/**\n\t * Gets a package.\n\t *\n\t * @param qualifiedName\n\t * \t\tthe package to search\n\t * @return a found package or null\n\t */\n\tpublic CtPackage get(String qualifiedName) {\n\t\tif (qualifiedName.contains(CtType.INNERTTYPE_SEPARATOR)) {\n\t\t\tthrow new RuntimeException(\"Invalid package name \" + qualifiedName);\n\t\t}\n\t\tStringTokenizer token = new StringTokenizer(qualifiedName, CtPackage.PACKAGE_SEPARATOR);\n\t\tCtPackage current = factory.getModel().getRootPackage();\n\t\tif (token.hasMoreElements()) {\n\t\t\tcurrent = current.getPackage(token.nextToken());\n\t\t\twhile (token.hasMoreElements() && current != null) {\n\t\t\t\tcurrent = current.getPackage(token.nextToken());\n\t\t\t}\n\t\t}\n\n\t\treturn current;\n\t}\n\n\t/**\n\t * Gets the list of all created packages. It includes all the top-level\n\t * packages and their sub-packages.\n\t */\n\tpublic Collection<CtPackage> getAll() {\n\t\treturn factory.getModel().getAllPackages();\n\t}\n\n\t/**\n\t * Return the unnamed top-level package.\n\t */\n\tpublic CtPackage getRootPackage() {\n\t\treturn factory.getModel().getRootPackage();\n\t}\n\n\tprivate List<CtPackage> getSubPackageList(CtPackage pack) {\n\t\tList<CtPackage> packs = new ArrayList<>();\n\t\tpacks.add(pack);\n\t\tfor (CtPackage p : pack.getPackages()) {\n\t\t\tpacks.addAll(getSubPackageList(p));\n\t\t}\n\t\treturn packs;\n\t}\n\n}\n\n"
    }, {
      "name" : "reflect/factory/TypeFactory.java",
      "weight" : 467.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.experimental.CtUnresolvedImport;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.CtAbstractVisitor;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.SpoonClassNotFoundException;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.util.internal.MapUtils;\nimport spoon.support.visitor.ClassTypingContext;\nimport spoon.support.visitor.GenericTypeAdapter;\nimport spoon.support.visitor.MethodTypingContext;\nimport spoon.support.visitor.java.JavaReflectionTreeBuilder;\n\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Supplier;\n\n/**\n * The {@link CtType} sub-factory.\n */\npublic class TypeFactory extends SubFactory {\n\n\tprivate static final Set<String> NULL_PACKAGE_CLASSES = Collections.unmodifiableSet(new HashSet<>(\n\t\t\tArrays.asList(\"void\", \"boolean\", \"byte\", \"short\", \"char\", \"int\", \"float\", \"long\", \"double\",\n\t\t\t\t\t// TODO (leventov) it is questionable to me that nulltype should also be here\n\t\t\t\t\tCtTypeReference.NULL_TYPE_NAME)));\n\n\tpublic final CtTypeReference<?> NULL_TYPE = createReference(CtTypeReference.NULL_TYPE_NAME);\n\tpublic final CtTypeReference<Void> VOID = createReference(Void.class);\n\tpublic final CtTypeReference<String> STRING = createReference(String.class);\n\tpublic final CtTypeReference<Boolean> BOOLEAN = createReference(Boolean.class);\n\tpublic final CtTypeReference<Byte> BYTE = createReference(Byte.class);\n\tpublic final CtTypeReference<Character> CHARACTER = createReference(Character.class);\n\tpublic final CtTypeReference<Integer> INTEGER = createReference(Integer.class);\n\tpublic final CtTypeReference<Long> LONG = createReference(Long.class);\n\tpublic final CtTypeReference<Float> FLOAT = createReference(Float.class);\n\tpublic final CtTypeReference<Double> DOUBLE = createReference(Double.class);\n\tpublic final CtTypeReference<Void> VOID_PRIMITIVE = createReference(void.class);\n\tpublic final CtTypeReference<Boolean> BOOLEAN_PRIMITIVE = createReference(boolean.class);\n\tpublic final CtTypeReference<Byte> BYTE_PRIMITIVE = createReference(byte.class);\n\tpublic final CtTypeReference<Character> CHARACTER_PRIMITIVE = createReference(char.class);\n\tpublic final CtTypeReference<Integer> INTEGER_PRIMITIVE = createReference(int.class);\n\tpublic final CtTypeReference<Long> LONG_PRIMITIVE = createReference(long.class);\n\tpublic final CtTypeReference<Float> FLOAT_PRIMITIVE = createReference(float.class);\n\tpublic final CtTypeReference<Double> DOUBLE_PRIMITIVE = createReference(double.class);\n\tpublic final CtTypeReference<Short> SHORT = createReference(Short.class);\n\tpublic final CtTypeReference<Short> SHORT_PRIMITIVE = createReference(short.class);\n\tpublic final CtTypeReference<Date> DATE = createReference(Date.class);\n\tpublic final CtTypeReference<Object> OBJECT = createReference(Object.class);\n\tpublic final CtTypeReference<Iterable> ITERABLE = createReference(Iterable.class);\n\tpublic final CtTypeReference<Collection> COLLECTION = createReference(Collection.class);\n\tpublic final CtTypeReference<List> LIST = createReference(List.class);\n\tpublic final CtTypeReference<Set> SET = createReference(Set.class);\n\tpublic final CtTypeReference<Map> MAP = createReference(Map.class);\n\tpublic final CtTypeReference<Enum> ENUM = createReference(Enum.class);\n\n\tprivate final Map<Class<?>, CtType<?>> shadowCache = new ConcurrentHashMap<>();\n\n\t/**\n\t * Returns a reference on the null type (type of null).\n\t */\n\tpublic CtTypeReference<?> nullType() {\n\t\treturn NULL_TYPE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the void type.\n\t */\n\tpublic CtTypeReference<Void> voidType() {\n\t\treturn VOID.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the void primitive type.\n\t */\n\tpublic CtTypeReference<Void> voidPrimitiveType() {\n\t\treturn VOID_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the string type.\n\t */\n\tpublic CtTypeReference<String> stringType() {\n\t\treturn STRING.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the boolean type.\n\t */\n\tpublic CtTypeReference<Boolean> booleanType() {\n\t\treturn BOOLEAN.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the boolean primitive type.\n\t */\n\tpublic CtTypeReference<Boolean> booleanPrimitiveType() {\n\t\treturn BOOLEAN_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the byte type.\n\t */\n\tpublic CtTypeReference<Byte> byteType() {\n\t\treturn BYTE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the byte primitive type.\n\t */\n\tpublic CtTypeReference<Byte> bytePrimitiveType() {\n\t\treturn BYTE_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the character type.\n\t */\n\tpublic CtTypeReference<Character> characterType() {\n\t\treturn CHARACTER.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the character primitive type.\n\t */\n\tpublic CtTypeReference<Character> characterPrimitiveType() {\n\t\treturn CHARACTER_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the integer type.\n\t */\n\tpublic CtTypeReference<Integer> integerType() {\n\t\treturn INTEGER.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the integer primitive type.\n\t */\n\tpublic CtTypeReference<Integer> integerPrimitiveType() {\n\t\treturn INTEGER_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the long type.\n\t */\n\tpublic CtTypeReference<Long> longType() {\n\t\treturn LONG.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the long primitive type.\n\t */\n\tpublic CtTypeReference<Long> longPrimitiveType() {\n\t\treturn LONG_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the float type.\n\t */\n\tpublic CtTypeReference<Float> floatType() {\n\t\treturn FLOAT.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the float primitive type.\n\t */\n\tpublic CtTypeReference<Float> floatPrimitiveType() {\n\t\treturn FLOAT_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the double type.\n\t */\n\tpublic CtTypeReference<Double> doubleType() {\n\t\treturn DOUBLE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the double primitive type.\n\t */\n\tpublic CtTypeReference<Double> doublePrimitiveType() {\n\t\treturn DOUBLE_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the short type.\n\t */\n\tpublic CtTypeReference<Short> shortType() {\n\t\treturn SHORT.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the short primitive type.\n\t */\n\tpublic CtTypeReference<Short> shortPrimitiveType() {\n\t\treturn SHORT_PRIMITIVE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the date type.\n\t */\n\tpublic CtTypeReference<Date> dateType() {\n\t\treturn DATE.clone();\n\t}\n\n\t/**\n\t * Returns a reference on the object type.\n\t */\n\tpublic CtTypeReference<Object> objectType() {\n\t\treturn OBJECT.clone();\n\t}\n\n\t/**\n\t * Creates a new type sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic TypeFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\tpublic TypeFactory() {\n\t\tthis(new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment()));\n\t}\n\n\t/**\n\t * Creates a reference to an array of given type.\n\t *\n\t * @param <T>\n\t * \t\ttype of array\n\t * @param type\n\t * \t\ttype of array values\n\t */\n\tpublic <T> CtArrayTypeReference<T[]> createArrayReference(CtType<T> type) {\n\t\tCtArrayTypeReference<T[]> array = factory.Core().createArrayTypeReference();\n\t\tarray.setComponentType(createReference(type));\n\t\treturn array;\n\t}\n\n\t/**\n\t * Creates a reference to a one-dimension array of given type.\n\t */\n\tpublic <T> CtArrayTypeReference<T[]> createArrayReference(CtTypeReference<T> reference) {\n\t\tCtArrayTypeReference<T[]> array = factory.Core().createArrayTypeReference();\n\t\tarray.setComponentType(reference);\n\t\treturn array;\n\t}\n\n\t/**\n\t * Creates a reference to a n-dimension array of given type.\n\t */\n\tpublic CtArrayTypeReference<?> createArrayReference(CtTypeReference<?> reference, int n) {\n\t\tCtTypeReference<?> componentType;\n\t\tif (n == 1) {\n\t\t\treturn createArrayReference(reference);\n\t\t}\n\t\tcomponentType = createArrayReference(reference, n - 1);\n\t\tCtArrayTypeReference<?> array = factory.Core().createArrayTypeReference();\n\t\tarray.setComponentType(componentType);\n\t\treturn array;\n\t}\n\n\t/**\n\t * Creates a reference to an array of given type.\n\t */\n\tpublic <T> CtArrayTypeReference<T> createArrayReference(String qualifiedName) {\n\t\tCtArrayTypeReference<T> array = factory.Core().createArrayTypeReference();\n\t\tarray.setComponentType(createReference(qualifiedName));\n\t\treturn array;\n\t}\n\n\tpublic <T> CtTypeReference<T> createReference(Class<T> type) {\n\t\treturn createReference(type, false);\n\t}\n\n\t/**\n\t * Creates a reference to a simple type\n\t */\n\tpublic <T> CtTypeReference<T> createReference(Class<T> type, boolean includingFormalTypeParameter) {\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (type.isArray()) {\n\t\t\tCtArrayTypeReference<T> array = factory.Core().createArrayTypeReference();\n\t\t\tarray.setComponentType(createReference(type.getComponentType(), includingFormalTypeParameter));\n\t\t\treturn array;\n\t\t}\n\t\tCtTypeReference typeReference = createReference(type.getName());\n\n\t\tif (includingFormalTypeParameter) {\n\t\t\tfor (TypeVariable<Class<T>> generic : type.getTypeParameters()) {\n\t\t\t\ttypeReference.addActualTypeArgument(createTypeParameterReference(generic.getName()));\n\t\t\t}\n\t\t}\n\n\t\treturn typeReference;\n\t}\n\n\t/**\n\t * Create a reference to a simple type\n\t */\n\tpublic <T> CtTypeReference<T> createReference(CtType<T> type) {\n\t\treturn createReference(type, false);\n\t}\n\n\t/**\n\t * Create a wildcard reference to a simple type\n\t */\n\tpublic CtTypeMemberWildcardImportReference createTypeMemberWildcardImportReference(CtTypeReference typeReference) {\n\t\tCtTypeMemberWildcardImportReference ref = factory.Core().createTypeMemberWildcardImportReference();\n\t\tref.setTypeReference(typeReference.clone());\n\t\treturn ref;\n\t}\n\n\t/**\n\t * @param includingFormalTypeParameter if true then references to formal type parameters\n\t * \tare added as actual type arguments of returned {@link CtTypeReference}\n\t */\n\tpublic <T> CtTypeReference<T> createReference(CtType<T> type, boolean includingFormalTypeParameter) {\n\t\tCtTypeReference<T> ref = factory.Core().createTypeReference();\n\n\t\tif (type.getDeclaringType() != null) {\n\t\t\tref.setDeclaringType(createReference(type.getDeclaringType(), includingFormalTypeParameter));\n\t\t} else if (type.getPackage() != null) {\n\t\t\tref.setPackage(factory.Package().createReference(type.getPackage()));\n\t\t}\n\n\t\tref.setSimpleName(type.getSimpleName());\n\n\t\tif (includingFormalTypeParameter) {\n\t\t\tfor (CtTypeParameter formalTypeParam : type.getFormalCtTypeParameters()) {\n\t\t\t\tref.addActualTypeArgument(formalTypeParam.getReference());\n\t\t\t}\n\t\t}\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Create a reference to a simple type\n\t */\n\tpublic CtTypeParameterReference createReference(CtTypeParameter type) {\n\t\tCtTypeParameterReference ref = factory.Core().createTypeParameterReference();\n\t\tref.setSimpleName(type.getSimpleName());\n\t\tref.setParent(type);\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Create a reference to a simple type\n\t */\n\tpublic <T> CtTypeReference<T> createReference(String qualifiedName) {\n\t\tif (qualifiedName.endsWith(\"[]\")) {\n\t\t\treturn createArrayReference(qualifiedName.substring(0, qualifiedName.length() - 2));\n\t\t}\n\t\tCtTypeReference<T> ref = factory.Core().createTypeReference();\n\t\tif (hasInnerType(qualifiedName) > 0) {\n\t\t\tref.setDeclaringType(createReference(getDeclaringTypeName(qualifiedName)));\n\t\t} else if (hasPackage(qualifiedName) > 0) {\n\t\t\tref.setPackage(factory.Package().createReference(getPackageName(qualifiedName)));\n\t\t} else if (!NULL_PACKAGE_CLASSES.contains(qualifiedName)) {\n\t\t\tref.setPackage(factory.Package().topLevel());\n\t\t}\n\t\tref.setSimpleName(getSimpleName(qualifiedName));\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Gets a created type from its qualified name.\n\t *\n\t * @return a found type or null if does not exist\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtType<T> get(final String qualifiedName) {\n\t\tint packageIndex = qualifiedName.lastIndexOf(CtPackage.PACKAGE_SEPARATOR);\n\t\tCtPackage pack;\n\t\tif (packageIndex > 0) {\n\t\t\tpack = factory.Package().get(qualifiedName.substring(0, packageIndex));\n\t\t} else {\n\t\t\tpack = factory.Package().getRootPackage();\n\t\t}\n\n\t\tif (pack != null) {\n\t\t\tCtType<T> type = pack.getType(qualifiedName.substring(packageIndex + 1));\n\t\t\tif (type != null) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\n\t\tint inertTypeIndex = qualifiedName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR);\n\t\tif (inertTypeIndex > 0) {\n\t\t\tString s = qualifiedName.substring(0, inertTypeIndex);\n\t\t\tCtType<T> t = factory.Type().get(s);\n\t\t\tif (t == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString className = qualifiedName.substring(inertTypeIndex + 1);\n\t\t\tfinal CtTypeReference<T> reference = t.getReference();\n\t\t\tif (reference.isLocalType()) {\n\t\t\t\tfinal List<CtClass<T>> enclosingClasses = t.getElements(new TypeFilter<CtClass<T>>(CtClass.class) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean matches(CtClass<T> element) {\n\t\t\t\t\t\treturn super.matches(element) && element.getQualifiedName().equals(qualifiedName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (enclosingClasses.isEmpty()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn enclosingClasses.get(0);\n\t\t\t}\n\t\t\tif (isNumber(className)) {\n\t\t\t\t// If the class name is an integer, the class is an anonymous class, otherwise,\n\t\t\t\t// it is a standard class.\n\t\t\t\t//TODO reset cache when type is modified\n\t\t\t\treturn getFromCache(t, className, () -> {\n\t\t\t\t\t//the searching for declaration of anonymous class is expensive\n\t\t\t\t\t//do that only once and store it in cache of CtType\n\t\t\t\t\tInteger.parseInt(className);\n\t\t\t\t\tfinal List<CtNewClass> anonymousClasses = t.getElements(new TypeFilter<CtNewClass>(CtNewClass.class) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean matches(CtNewClass element) {\n\t\t\t\t\t\t\treturn super.matches(element) && element.getAnonymousClass().getQualifiedName().equals(qualifiedName);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (anonymousClasses.isEmpty()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\treturn anonymousClasses.get(0).getAnonymousClass();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn t.getNestedType(className);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static final String CACHE_KEY = TypeFactory.class.getName() + \"-AnnonymousTypeCache\";\n\n\tprivate <T, K> T getFromCache(CtElement element, K key, Supplier<T> valueResolver) {\n\t\tMap<K, T> cache = (Map<K, T>) element.getMetadata(CACHE_KEY);\n\t\tif (cache == null) {\n\t\t\tcache = new HashMap<>();\n\t\t\telement.putMetadata(CACHE_KEY, cache);\n\t\t}\n\t\treturn MapUtils.getOrCreate(cache, key, valueResolver);\n\t}\n\n\tprivate boolean isNumber(String str) {\n\t\tif (str == null || str.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tint len = str.length();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!Character.isDigit(str.charAt(i))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the list of all top-level created types.\n\t */\n\tpublic List<CtType<?>> getAll() {\n\t\treturn new ArrayList<>(factory.getModel().getAllTypes());\n\t}\n\n\t/**\n\t * Gets the list of all created types.\n\t */\n\tpublic List<CtType<?>> getAll(boolean includeNestedTypes) {\n\t\tif (!includeNestedTypes) {\n\t\t\treturn getAll();\n\t\t}\n\t\tList<CtType<?>> types = new ArrayList<>();\n\t\tfor (CtPackage pack : factory.Package().getAll()) {\n\t\t\tfor (CtType<?> type : pack.getTypes()) {\n\t\t\t\taddNestedType(types, type);\n\t\t\t}\n\t\t}\n\t\treturn types;\n\t}\n\n\tprivate void addNestedType(List<CtType<?>> list, CtType<?> t) {\n\t\tlist.add(t);\n\t\tfor (CtType<?> nt : t.getNestedTypes()) {\n\t\t\taddNestedType(list, nt);\n\t\t}\n\t}\n\n\t/**\n\t * Gets a type from its runtime Java class. If the class isn't in the spoon path,\n\t * the class will be built from the Java reflection and will be marked as\n\t * shadow (see {@link spoon.reflect.declaration.CtShadowable}).\n\t *\n\t * @param <T>\n\t * \t\tactual type of the class\n\t * @param cl\n\t * \t\tthe java class: note that this class should be Class&lt;T&gt; but it\n\t * \t\tthen poses problem when T is a generic type itself\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtType<T> get(Class<?> cl) {\n\t\tfinal CtType<T> aType = get(cl.getName());\n\t\tif (aType == null) {\n\t\t\tfinal CtType<T> shadowClass = (CtType<T>) this.shadowCache.get(cl);\n\t\t\tif (shadowClass == null) {\n\t\t\t\tCtType<T> newShadowClass;\n\t\t\t\ttry {\n\t\t\t\t\tnewShadowClass = new JavaReflectionTreeBuilder(createFactory()).scan((Class<T>) cl);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tthrow new SpoonClassNotFoundException(\"cannot create shadow class: \" + cl.getName(), e);\n\t\t\t\t}\n\t\t\t\tnewShadowClass.setFactory(factory);\n\t\t\t\tnewShadowClass.accept(new CtScanner() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void scan(CtElement element) {\n\t\t\t\t\t\tif (element != null) {\n\t\t\t\t\t\t\telement.setFactory(factory);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.shadowCache.put(cl, newShadowClass);\n\t\t\t\treturn newShadowClass;\n\t\t\t} else {\n\t\t\t\treturn shadowClass;\n\t\t\t}\n\t\t}\n\t\treturn aType;\n\t}\n\n\tprivate Factory createFactory() {\n\t\t//use existing environment to use correct class loader\n\t\treturn new FactoryImpl(new DefaultCoreFactory(), factory.getEnvironment());\n\t}\n\n\t/**\n\t * Gets the declaring type name for a given Java qualified name.\n\t */\n\tprotected String getDeclaringTypeName(String qualifiedName) {\n\t\treturn qualifiedName.substring(0, hasInnerType(qualifiedName));\n\t}\n\n\t/**\n\t * Creates a collection of type references from a collection of classes.\n\t */\n\tpublic List<CtTypeReference<?>> createReferences(List<Class<?>> classes) {\n\t\tList<CtTypeReference<?>> refs = new ArrayList<>(classes.size());\n\t\tfor (Class<?> c : classes) {\n\t\t\trefs.add(createReference(c));\n\t\t}\n\t\treturn refs;\n\t}\n\n\t/**\n\t * Gets the package name for a given Java qualified name.\n\t */\n\tprotected String getPackageName(String qualifiedName) {\n\t\tif (hasPackage(qualifiedName) >= 0) {\n\t\t\treturn qualifiedName.substring(0, hasPackage(qualifiedName));\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the simple name for a given Java qualified name.\n\t */\n\tprotected String getSimpleName(String qualifiedName) {\n\t\tif (hasInnerType(qualifiedName) > 0) {\n\t\t\treturn qualifiedName.substring(hasInnerType(qualifiedName) + 1);\n\t\t} else if (hasPackage(qualifiedName) > 0) {\n\t\t\treturn qualifiedName.substring(hasPackage(qualifiedName) + 1);\n\t\t} else {\n\t\t\treturn qualifiedName;\n\t\t}\n\t}\n\n\t/**\n\t * Tells if a given Java qualified name is that of an inner type.\n\t */\n\tprotected int hasInnerType(String qualifiedName) {\n\t\treturn qualifiedName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR);\n\t}\n\n\t/**\n\t * Tells if a given Java qualified name contains a package name.\n\t */\n\tprotected int hasPackage(String qualifiedName) {\n\t\treturn qualifiedName.lastIndexOf(CtPackage.PACKAGE_SEPARATOR);\n\t}\n\n\t/**\n\t * Creates a type parameter reference with no bounds.\n\t *\n\t * @param name\n\t * \t\tthe name of the formal parameter\n\t */\n\tpublic CtTypeParameterReference createTypeParameterReference(String name) {\n\t\tif (\"?\".equals(name)) {\n\t\t\tthrow new SpoonException(\"the Spoon metamodel has evolved, use Factory.createWildcardReference() instead\");\n\t\t}\n\t\tCtTypeParameterReference typeParam = factory.Core().createTypeParameterReference();\n\t\ttypeParam.setSimpleName(name);\n\t\treturn typeParam;\n\t}\n\n\t/**\n\t * Create a {@link GenericTypeAdapter} for adapting of formal type parameters from any compatible context to the context of provided `formalTypeDeclarer`\n\t *\n\t * @param formalTypeDeclarer\n\t * \t\tthe target scope of the returned {@link GenericTypeAdapter}\n\t */\n\tpublic GenericTypeAdapter createTypeAdapter(CtFormalTypeDeclarer formalTypeDeclarer) {\n\t\tclass Visitor extends CtAbstractVisitor {\n\t\t\tGenericTypeAdapter adapter;\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\t\t\tadapter = new ClassTypingContext(ctClass);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\t\t\t\tadapter = new ClassTypingContext(intrface);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtMethod(CtMethod<T> m) {\n\t\t\t\tadapter = new MethodTypingContext().setMethod(m);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtConstructor(CtConstructor<T> c) {\n\t\t\t\tadapter = new MethodTypingContext().setConstructor(c);\n\t\t\t}\n\t\t}\n\t\tVisitor visitor = new Visitor();\n\t\tformalTypeDeclarer.accept(visitor);\n\t\treturn visitor.adapter;\n\t}\n\n\t/**\n\t * Creates an intersection type reference.\n\t *\n\t * @param bounds\n\t * \t\tList of bounds saved in the intersection type. The first bound will be the intersection type.\n\t * @param <T>\n\t * \t\tType of the first bound.\n\t */\n\tpublic <T> CtIntersectionTypeReference<T> createIntersectionTypeReferenceWithBounds(List<CtTypeReference<?>> bounds) {\n\t\tfinal CtIntersectionTypeReference<T> intersectionRef = factory.Core().createIntersectionTypeReference();\n\t\tCtTypeReference<?> firstBound = bounds.toArray(new CtTypeReference<?>[0])[0].clone();\n\t\tintersectionRef.setSimpleName(firstBound.getSimpleName());\n\t\tintersectionRef.setDeclaringType(firstBound.getDeclaringType());\n\t\tintersectionRef.setPackage(firstBound.getPackage());\n\t\tintersectionRef.setActualTypeArguments(firstBound.getActualTypeArguments());\n\t\tintersectionRef.setBounds(bounds);\n\t\treturn intersectionRef;\n\t}\n\n\t/**\n\t * Returns the default bounding type value\n\t */\n\tpublic CtTypeReference getDefaultBoundingType() {\n\t\treturn OBJECT;\n\t}\n\n\t/**\n\t * Creates an import declaration.\n\t */\n\tpublic CtImport createImport(CtReference reference) {\n\t\tCtImport ctImport = factory.Core().createImport();\n\t\tCtReference importRef = reference.clone();\n\t\t//import reference is always fully qualified and has no generic arguments\n\t\tnew CtScanner() {\n\t\t\t@Override\n\t\t\tprotected void enter(CtElement e) {\n\t\t\t\te.setImplicit(false);\n\t\t\t\tif (e instanceof CtActualTypeContainer) {\n\t\t\t\t\tCtActualTypeContainer atc = (CtActualTypeContainer) e;\n\t\t\t\t\tatc.setActualTypeArguments(Collections.emptyList());\n\t\t\t\t}\n\t\t\t}\n\t\t}.scan(importRef);\n\t\treturn ctImport.setReference(importRef);\n\t}\n\n\tpublic CtImport createUnresolvedImport(String reference, boolean isStatic) {\n\t\tCtUnresolvedImport ctUnresolvedImport = (CtUnresolvedImport) factory.Core().createUnresolvedImport();\n\t\tctUnresolvedImport.setUnresolvedReference(reference);\n\t\tctUnresolvedImport.setStatic(isStatic);\n\t\treturn ctUnresolvedImport;\n\t}\n}\n"
    }, {
      "name" : "reflect/factory/MethodFactory.java",
      "weight" : 74.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.template.Substitution;\n\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/**\n * The {@link CtMethod} sub-factory.\n */\npublic class MethodFactory extends ExecutableFactory {\n\n\tpublic final Set<CtMethod<?>> OBJECT_METHODS = Collections.unmodifiableSet(factory.Class().get(Object.class).getMethods());\n\n\t/**\n\t * Creates a new method sub-factory.\n\t *\n\t * @param factory\n\t * \t\tthe parent factory\n\t */\n\tpublic MethodFactory(Factory factory) {\n\t\tsuper(factory);\n\t}\n\n\t/**\n\t * Creates a method.\n\t *\n\t * @param target\n\t * \t\tthe class where the method is inserted\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param returnType\n\t * \t\tthe method's return type\n\t * @param name\n\t * \t\tthe method's name\n\t * @param parameters\n\t * \t\tthe parameters\n\t * @param thrownTypes\n\t * \t\tthe thrown types\n\t * @param body\n\t * \t\tthe method's body\n\t */\n\tpublic <R, B extends R> CtMethod<R> create(CtClass<?> target, Set<ModifierKind> modifiers, CtTypeReference<R> returnType, String name, List<CtParameter<?>> parameters,\n\t\t\tSet<CtTypeReference<? extends Throwable>> thrownTypes, CtBlock<B> body) {\n\t\tCtMethod<R> method = create(target, modifiers, returnType, name, parameters, thrownTypes);\n\t\tmethod.setBody(body);\n\t\treturn method;\n\t}\n\n\t/**\n\t * Creates a method by copying an existing method.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the method\n\t * @param target\n\t * \t\tthe target type where the new method has to be inserted to\n\t * @param source\n\t * \t\tthe source method to be copied\n\t * @param redirectReferences\n\t * \t\ttells if all the references to the owning type of the source\n\t * \t\tmethod should be redirected to the target type (true is\n\t * \t\trecommended for most uses)\n\t * @return the newly created method\n\t */\n\tpublic <T> CtMethod<T> create(CtType<?> target, CtMethod<T> source, boolean redirectReferences) {\n\t\tCtMethod<T> newMethod = source.clone();\n\t\tif (redirectReferences && (source.getDeclaringType() != null)) {\n\t\t\tSubstitution.redirectTypeReferences(newMethod, source.getDeclaringType().getReference(), target.getReference());\n\t\t}\n\t\ttarget.addMethod(newMethod);\n\t\treturn newMethod;\n\t}\n\n\t/**\n\t * Creates an empty method.\n\t *\n\t * @param target\n\t * \t\tthe class where the method is inserted\n\t * @param modifiers\n\t * \t\tthe modifiers\n\t * @param returnType\n\t * \t\tthe method's return type\n\t * @param name\n\t * \t\tthe method's name\n\t * @param parameters\n\t * \t\tthe parameters\n\t * @param thrownTypes\n\t * \t\tthe thrown types\n\t */\n\tpublic <T> CtMethod<T> create(CtType<?> target, Set<ModifierKind> modifiers, CtTypeReference<T> returnType, String name, List<CtParameter<?>> parameters,\n\t\t\tSet<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\tCtMethod<T> method = factory.Core().createMethod();\n\t\tif (modifiers != null) {\n\t\t\tmethod.setModifiers(modifiers);\n\t\t}\n\t\tmethod.setType(returnType);\n\t\tmethod.setSimpleName(name);\n\t\tif (parameters != null) {\n\t\t\tmethod.setParameters(parameters);\n\t\t}\n\t\tif (thrownTypes != null) {\n\t\t\tmethod.setThrownTypes(thrownTypes);\n\t\t}\n\t\ttarget.addMethod(method);\n\t\treturn method;\n\t}\n\n\t/**\n\t * Creates a method reference.\n\t */\n\tpublic <T> CtExecutableReference<T> createReference(CtMethod<T> m) {\n\t\treturn factory.Executable().createReference(m);\n\t}\n\n\t/**\n\t * Creates a method reference from an actual method.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> CtExecutableReference<T> createReference(Method method) {\n\t\treturn createReference(factory.Type().createReference(method.getDeclaringClass()), (CtTypeReference<T>) factory.Type().createReference(method.getReturnType()), method.getName(),\n\t\t\t\tfactory.Type().createReferences(Arrays.asList(method.getParameterTypes())).toArray(new CtTypeReference<?>[0]));\n\t}\n\n\t/**\n\t * Gets all the main methods stored in this factory.\n\t */\n\tpublic Collection<CtMethod<Void>> getMainMethods() {\n\t\tCollection<CtMethod<Void>> methods = new ArrayList<>();\n\t\tfor (CtType<?> t : factory.Type().getAll()) {\n\t\t\tif (t instanceof CtClass) {\n\t\t\t\tCtMethod<Void> m = ((CtClass<?>) t).getMethod(factory.Type().createReference(void.class), \"main\", factory.Type().createArrayReference(factory.Type().createReference(String.class)));\n\t\t\t\tif ((m != null) && m.getModifiers().contains(ModifierKind.STATIC)) {\n\t\t\t\t\tmethods.add(m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn methods;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/factory/CoreFactory.java",
      "weight" : 203.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.factory;\n\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.CompoundSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * This interface defines the core creation methods for the meta-model (to be\n * implemented so that Spoon can manipulate other meta-model implementations).\n * <p>\n * <b>Important</b>: a required post-condition for all the created elements is\n * that the factory (see {@link spoon.processing.FactoryAccessor#getFactory()})\n * is correctly initialized with the main factory returned by\n * {@link #getMainFactory()}, which cannot be null.\n */\npublic interface CoreFactory {\n\n\t/**\n\t * Recursively clones a given element of the metamodel and all its child\n\t * elements.\n\t *\n\t * @param <T>     the element's type\n\t * @param element the element\n\t * @return a clone of <code>element</code>\n\t * @see spoon.reflect.declaration.CtElement#clone()\n\t */\n\t<T extends CtElement> T clone(T element);\n\n\t/**\n\t * Creates an annotation.\n\t */\n\t<A extends Annotation> CtAnnotation<A> createAnnotation();\n\n\t/**\n\t * Creates an annotation type.\n\t */\n\t<T extends Annotation> CtAnnotationType<T> createAnnotationType();\n\n\t/**\n\t * Creates an anonymous executable.\n\t */\n\tCtAnonymousExecutable createAnonymousExecutable();\n\n\t/**\n\t * Creates an array read access expression.\n\t */\n\t<T> CtArrayRead<T> createArrayRead();\n\n\t/**\n\t * Creates an array write access expression.\n\t */\n\t<T> CtArrayWrite<T> createArrayWrite();\n\n\t/**\n\t * Creates an array type reference.\n\t */\n\t<T> CtArrayTypeReference<T> createArrayTypeReference();\n\n\t/**\n\t * Creates an <code>assert</code> statement.\n\t */\n\t<T> CtAssert<T> createAssert();\n\n\t/**\n\t * Creates an assignment expression.\n\t */\n\t<T, A extends T> CtAssignment<T, A> createAssignment();\n\n\t/**\n\t * Creates a binary operator.\n\t */\n\t<T> CtBinaryOperator<T> createBinaryOperator();\n\n\t/**\n\t * Creates a block.\n\t */\n\t<R> CtBlock<R> createBlock();\n\n\t/**\n\t * Creates a <code>break</code> statement.\n\t */\n\tCtBreak createBreak();\n\n\t/**\n\t * Creates a <code>case</code> clause.\n\t */\n\t<S> CtCase<S> createCase();\n\n\t/**\n\t * Creates a <code>catch</code> clause.\n\t */\n\tCtCatch createCatch();\n\n\t/**\n\t * Creates a class.\n\t */\n\t<T> CtClass<T> createClass();\n\n\t/**\n\t * Creates a type parameter declaration.\n\t */\n\tCtTypeParameter createTypeParameter();\n\n\t/**\n\t * Creates a conditional expression (<code>boolExpr?ifTrue:ifFalse</code>).\n\t */\n\t<T> CtConditional<T> createConditional();\n\n\t/**\n\t * Creates a constructor.\n\t */\n\t<T> CtConstructor<T> createConstructor();\n\n\t/**\n\t * Creates an invisible array constructor.\n\t */\n\t<T> CtConstructor<T> createInvisibleArrayConstructor();\n\n\t/**\n\t * Creates a <code>continue</code> statement.\n\t */\n\tCtContinue createContinue();\n\n\t/**\n\t * Creates a <code>do</code> loop.\n\t */\n\tCtDo createDo();\n\n\t/**\n\t * Creates an enum.\n\t */\n\t<T extends Enum<?>> CtEnum<T> createEnum();\n\n\t/**\n\t * Creates an executable reference.\n\t */\n\t<T> CtExecutableReference<T> createExecutableReference();\n\n\t/**\n\t * Creates a field.\n\t */\n\t<T> CtField<T> createField();\n\n\t/**\n\t * Creates an enum value.\n\t */\n\t<T> CtEnumValue<T> createEnumValue();\n\n\t/**\n\t * Creates a field read access.\n\t */\n\t<T> CtFieldRead<T> createFieldRead();\n\n\t/**\n\t * Creates a field write access.\n\t */\n\t<T> CtFieldWrite<T> createFieldWrite();\n\n\t/**\n\t * Creates an access expression to this.\n\t */\n\t<T> CtThisAccess<T> createThisAccess();\n\n\t/**\n\t * Creates an access expression to super.\n\t */\n\t<T> CtSuperAccess<T> createSuperAccess();\n\n\t/**\n\t * Creates a field reference.\n\t */\n\t<T> CtFieldReference<T> createFieldReference();\n\n\t/**\n\t * Creates a <code>for</code> loop.\n\t */\n\tCtFor createFor();\n\n\t/**\n\t * Creates a <code>foreach</code> loop.\n\t */\n\tCtForEach createForEach();\n\n\t/**\n\t * Creates an <code>if</code> statement.\n\t */\n\tCtIf createIf();\n\n\t/**\n\t * Creates an interface.\n\t */\n\t<T> CtInterface<T> createInterface();\n\n\t/**\n\t * Creates an invocation expression.\n\t */\n\t<T> CtInvocation<T> createInvocation();\n\n\t/**\n\t * Creates a literal expression.\n\t */\n\t<T> CtLiteral<T> createLiteral();\n\n\t/**\n\t * Creates a local variable declaration statement.\n\t */\n\t<T> CtLocalVariable<T> createLocalVariable();\n\n\t/**\n\t * Creates a local variable reference.\n\t */\n\t<T> CtLocalVariableReference<T> createLocalVariableReference();\n\n\t/**\n\t * Creates a catch variable declaration statement.\n\t */\n\t<T> CtCatchVariable<T> createCatchVariable();\n\n\t/**\n\t * Creates a catch variable reference.\n\t */\n\t<T> CtCatchVariableReference<T> createCatchVariableReference();\n\n\t/**\n\t * Creates a method.\n\t */\n\t<T> CtMethod<T> createMethod();\n\n\t/**\n\t * Creates an annotation method.\n\t */\n\t<T> CtAnnotationMethod<T> createAnnotationMethod();\n\n\t/**\n\t * Creates a new array expression.\n\t */\n\t<T> CtNewArray<T> createNewArray();\n\n\t/**\n\t * Creates a constructor call expression.\n\t *\n\t * Example to build \"new Foo()\":\n\t * <pre>\n\t *     CtConstructorCall call = spoon.getFactory().Core().createConstructorCall();\n\t *     call.setType(spoon.getFactory().Core().createTypeReference().setSimpleName(\"Foo\"));\n\t * </pre>\n\t */\n\t<T> CtConstructorCall<T> createConstructorCall();\n\n\t/**\n\t * Creates a new anonymous class expression.\n\t */\n\t<T> CtNewClass<T> createNewClass();\n\n\t/**\n\t * Creates a new anonymous method expression.\n\t */\n\t<T> CtLambda<T> createLambda();\n\n\t/**\n\t * Creates a new executable reference expression.\n\t */\n\t<T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression();\n\n\t/**\n\t * Creates a new operator assignment (like +=).\n\t */\n\t<T, A extends T> CtOperatorAssignment<T, A> createOperatorAssignment();\n\n\t/**\n\t * Creates a package.\n\t */\n\tCtPackage createPackage();\n\n\t/**\n\t * Creates a package reference.\n\t */\n\tCtPackageReference createPackageReference();\n\n\t/**\n\t * Creates a parameter.\n\t */\n\t<T> CtParameter<T> createParameter();\n\n\t/**\n\t * Creates a parameter reference.\n\t */\n\t<T> CtParameterReference<T> createParameterReference();\n\n\t/**\n\t * Creates a <code>return</code> statement.\n\t */\n\t<R> CtReturn<R> createReturn();\n\n\t/**\n\t * Creates a source position.\n\t */\n\tSourcePosition createSourcePosition(\n\t\t\tCompilationUnit compilationUnit,\n\t\t\tint startSource, int end, int[] lineSeparatorPositions);\n\n\t/** Creates a source position that points to the given compilation unit */\n\tSourcePosition createPartialSourcePosition(CompilationUnit compilationUnit);\n\n\t/**\n\t * Creates a compound source position.\n\t */\n\tCompoundSourcePosition createCompoundSourcePosition(\n\t\t\tCompilationUnit compilationUnit,\n\t\t\tint startSource, int end,\n\t\t\tint declarationStart, int declarationEnd,\n\t\t\tint[] lineSeparatorPositions);\n\n\t/**\n\t * Creates a declaration source position.\n\t */\n\tDeclarationSourcePosition createDeclarationSourcePosition(\n\t\t\tCompilationUnit compilationUnit,\n\t\t\tint startSource, int end,\n\t\t\tint modifierStart, int modifierEnd,\n\t\t\tint declarationStart, int declarationEnd,\n\t\t\tint[] lineSeparatorPositions);\n\n\t/**\n\t * Creates a body holder source position.\n\t */\n\tBodyHolderSourcePosition createBodyHolderSourcePosition(\n\t\t\tCompilationUnit compilationUnit,\n\t\t\tint startSource, int end,\n\t\t\tint modifierStart, int modifierEnd,\n\t\t\tint declarationStart, int declarationEnd,\n\t\t\tint bodyStart, int bodyEnd, int[] lineSeparatorPositions);\n\n\t/**\n\t * Creates a statement list.\n\t */\n\t<R> CtStatementList createStatementList();\n\n\t/**\n\t * Creates a <code>switch</code> statement.\n\t */\n\t<S> CtSwitch<S> createSwitch();\n\n\t/**\n\t * Creates a <code>synchronized</code> statement.\n\t */\n\tCtSynchronized createSynchronized();\n\n\t/**\n\t * Creates a <code>throw</code> statement.\n\t */\n\tCtThrow createThrow();\n\n\t/**\n\t * Creates a <code>try</code> block.\n\t */\n\tCtTry createTry();\n\n\t/**\n\t * Creates a <code>try</code> with resource block.\n\t */\n\tCtTryWithResource createTryWithResource();\n\n\t/**\n\t * Creates a type parameter reference.\n\t */\n\tCtTypeParameterReference createTypeParameterReference();\n\n\t/**\n\t * Creates a wildcard reference.\n\t */\n\tCtWildcardReference createWildcardReference();\n\n\t/**\n\t * Creates an intersection type reference.\n\t */\n\t<T> CtIntersectionTypeReference<T> createIntersectionTypeReference();\n\n\t/**\n\t * Creates a type reference.\n\t */\n\t<T> CtTypeReference<T> createTypeReference();\n\n\t/**\n\t * Creates a type access expression.\n\t */\n\t<T> CtTypeAccess<T> createTypeAccess();\n\n\t/**\n\t * Creates a unary operator expression.\n\t */\n\t<T> CtUnaryOperator<T> createUnaryOperator();\n\n\t/**\n\t * Creates a variable read expression.\n\t */\n\t<T> CtVariableRead<T> createVariableRead();\n\n\t/**\n\t * Creates a variable write expression.\n\t */\n\t<T> CtVariableWrite<T> createVariableWrite();\n\n\t/**\n\t * Creates a <code>while</code> loop.\n\t */\n\tCtWhile createWhile();\n\n\t/**\n\t * Creates a code snippet expression.\n\t */\n\t<T> CtCodeSnippetExpression<T> createCodeSnippetExpression();\n\n\t/**\n\t * Creates a code snippet statement.\n\t */\n\tCtCodeSnippetStatement createCodeSnippetStatement();\n\n\t/**\n\t * Creates a comment.\n\t */\n\tCtComment createComment();\n\n\t/**\n\t * Creates a javadoc comment.\n\t */\n\tCtJavaDoc createJavaDoc();\n\n\t/**\n\t * Creates a javadoc tag.\n\t */\n\tCtJavaDocTag createJavaDocTag();\n\n\t/**\n\t * Creates an import.\n\t */\n\tCtImport createImport();\n\n\t/**\n\t * Creates an unresolved import.\n\t * CtUnresolvedImport stores the original content of the imort as a String in order to be able\n\t * to restituate it when pretty printing.\n\t */\n\tCtImport createUnresolvedImport();\n\n\t/**\n\t * Creates a package declaration.\n\t */\n\tCtPackageDeclaration createPackageDeclaration();\n\n\t/**\n\t * Gets the main factory of that core factory (cannot be <code>null</code>).\n\t */\n\tFactory getMainFactory();\n\n\t/**\n\t * Sets the main factory of that core factory.\n\t */\n\tvoid setMainFactory(Factory mainFactory);\n\n\t/**\n\t * Creates a compilation unit.\n\t */\n\tCompilationUnit createCompilationUnit();\n\n\t/**\n\t * Create an access to annotation value\n\t *\n\t * @return\n\t */\n\t<T> CtAnnotationFieldAccess<T> createAnnotationFieldAccess();\n\n\t/**\n\t * Creates an unbound variable used in noclasspath.\n\t */\n\t<T> CtUnboundVariableReference<T> createUnboundVariableReference();\n\n\t/**\n\t * Creates an instance of the concrete metamodel class given as parameter.\n\t *\n\t * This is in particular useful when one uses reflection.\n\t */\n\tCtElement create(Class<? extends CtElement> klass);\n\n\t/**\n\t * Create a wildcard reference to a type member, used in a static import\n\t */\n\tCtTypeMemberWildcardImportReference createTypeMemberWildcardImportReference();\n\n\t/** Creates a Java 9 module */\n\tCtModule createModule();\n\n\t/** Creates a reference to a Java 9 module */\n\tCtModuleReference createModuleReference();\n\n\t/** Creates a \"requires\" directive for a Java 9 module file */\n\tCtModuleRequirement createModuleRequirement();\n\n\t/** Creates a \"export\" directive for a Java 9 module file */\n\tCtPackageExport createPackageExport();\n\n\t/** Creates a \"provides\" directive for a Java 9 module file */\n\tCtProvidedService createProvidedService();\n\n\t/** Creates a \"uses\" directive for a Java 9 module file */\n\tCtUsedService createUsedService();\n}\n"
    }, {
      "name" : "reflect/declaration/CtModifiable.java",
      "weight" : 36.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.DerivedProperty;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.MODIFIER;\n\n/**\n * This interface defines an element that accepts modifiers.\n */\npublic interface CtModifiable extends CtElement {\n\t/**\n\t * Returns the modifiers of this element, excluding annotations. Implicit\n\t * modifiers, such as the {@code public} and {@code static} modifiers of\n\t * interface members, are included.\n\t *\n\t * @return the modifiers of this declaration in undefined order; an empty\n\t * set if there are none\n\t */\n\t@PropertyGetter(role = MODIFIER)\n\tSet<ModifierKind> getModifiers();\n\n\t/**\n\t * Tells if this element contains the given modifier.\n\t *\n\t * @param modifier\n\t * \t\tto search\n\t * @return {@code true} if this element contain the modifier\n\t */\n\tboolean hasModifier(ModifierKind modifier);\n\n\t/**\n\t * Sets the modifiers.\n\t */\n\t@PropertySetter(role = MODIFIER)\n\t<T extends CtModifiable> T setModifiers(Set<ModifierKind> modifiers);\n\n\t/**\n\t * add a modifier\n\t *\n\t * @param modifier\n\t */\n\t@PropertySetter(role = MODIFIER)\n\t<T extends CtModifiable> T addModifier(ModifierKind modifier);\n\n\t/**\n\t * remove a modifier\n\t *\n\t * @param modifier\n\t */\n\t@PropertySetter(role = MODIFIER)\n\t<T extends CtModifiable> T removeModifier(ModifierKind modifier);\n\n\t/**\n\t * Sets the visibility of this modifiable element (replaces old visibility).\n\t */\n\t@PropertySetter(role = MODIFIER)\n\t<T extends CtModifiable> T setVisibility(ModifierKind visibility);\n\n\t/**\n\t * Gets the visibility of this modifiable element.\n\t */\n\t@DerivedProperty\n\tModifierKind getVisibility();\n\n\tSet<CtExtendedModifier> getExtendedModifiers();\n\t<T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers);\n\n\t/**\n\t * Returns true if it contains a public modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isPublic();\n\n\t/**\n\t * Returns true if it contains a final modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isFinal();\n\n\t/**\n\t * Returns true if it contains a static modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isStatic();\n\n\t/**\n\t * Returns true if it contains a protected modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isProtected();\n\n\t/**\n\t * Returns true if it contains a private modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isPrivate();\n\n\t/**\n\t * Returns true if it contains an abstract modifier (see {@link #hasModifier(ModifierKind)})\n\t */\n\t@DerivedProperty\n\tboolean isAbstract();\n}\n"
    }, {
      "name" : "reflect/declaration/CtAnonymousExecutable.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This element defines an anonymous executable block declaration in a class.\n *\n * @see spoon.reflect.declaration.CtClass\n */\npublic interface CtAnonymousExecutable extends CtExecutable<Void>, CtTypeMember {\n\t@Override\n\tCtAnonymousExecutable clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtNamedElement> C setSimpleName(String simpleName);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtExecutable<Void>> T setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtExecutable<Void>> T setParameters(List<CtParameter<?>> parameters);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtTypedElement> C setType(CtTypeReference<Void> type);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtExecutable<Void>> T addParameter(CtParameter<?> parameter);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtExecutable<Void>> T addThrownType(CtTypeReference<? extends Throwable> throwType);\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtAnnotatedElementType.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\n/**\n * This enum specifies the element type which is annotated by the annotation\n */\npublic enum CtAnnotatedElementType {\n\t/**\n\t * Class, interface (including annotation type), or enum declaration\n\t */\n\tTYPE,\n\n\t/**\n\t * Field declaration (includes enum constants)\n\t */\n\tFIELD,\n\n\t/**\n\t * Method declaration\n\t */\n\tMETHOD,\n\n\t/**\n\t * Parameter declaration\n\t */\n\tPARAMETER,\n\n\t/**\n\t * Constructor declaration\n\t */\n\tCONSTRUCTOR,\n\n\t/**\n\t * Local variable declaration\n\t */\n\tLOCAL_VARIABLE,\n\n\t/**\n\t * Annotation type declaration\n\t */\n\tANNOTATION_TYPE,\n\n\t/**\n\t * Package declaration\n\t */\n\tPACKAGE,\n\n\t/**\n\t * Type parameter declaration\n\t */\n\tTYPE_PARAMETER,\n\n\t/**\n\t * Use of a type\n\t */\n\tTYPE_USE\n}\n"
    }, {
      "name" : "reflect/declaration/CtPackageDeclaration.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtPackageReference;\n\n/**\n * This element represents an package declaration.\n *\n * Example:\n * <pre>\n *     package your.nice.package.name;\n * </pre>\n *\n */\npublic interface CtPackageDeclaration extends CtElement {\n\n\t/**\n\t * Returns the reference to the package.\n\t */\n\t@PropertyGetter(role = CtRole.PACKAGE_REF)\n\tCtPackageReference getReference();\n\n\t/**\n\t * Sets the reference to the package.\n\t */\n\t@PropertySetter(role = CtRole.PACKAGE_REF)\n\tCtPackageDeclaration setReference(CtPackageReference reference);\n\n\t@Override\n\tCtPackageDeclaration clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtImport.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtImportVisitor;\nimport spoon.support.DerivedProperty;\n\nimport static spoon.reflect.path.CtRole.IMPORT_REFERENCE;\n\n/**\n * This element represents an import declaration.\n * The given reference should be of type {@link spoon.reflect.reference.CtTypeReference},\n * {@link spoon.reflect.reference.CtPackageReference}, {@link spoon.reflect.reference.CtExecutableReference},\n * {@link spoon.reflect.reference.CtFieldReference} or {@link spoon.support.reflect.reference.CtTypeMemberWildcardImportReferenceImpl}\n *\n * <pre>\n *     import static import static org.junit.Assert.*;\n * </pre>\n *\n * It will be ignored in all other cases.\n *\n * Example:\n * <pre>\n *     import java.io.File;\n * </pre>\n */\npublic interface CtImport extends CtElement {\n\t/**\n\t * Returns the kind of import (see {@link CtImportKind})\n\t */\n\t@DerivedProperty\n\tCtImportKind getImportKind();\n\n\t/**\n\t * Returns the reference of the import.\n\t */\n\t@PropertyGetter(role = IMPORT_REFERENCE)\n\tCtReference getReference();\n\n\t/**\n\t * Sets the reference of the import.\n\t * The import kind will be computed based on this reference.\n\t */\n\t@PropertySetter(role = IMPORT_REFERENCE)\n\t<T extends CtImport> T setReference(CtReference reference);\n\n\t/**\n\t * Accepts a {@link CtImportVisitor}\n\t */\n\tvoid accept(CtImportVisitor visitor);\n\n\t@Override\n\tCtImport clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtClass.java",
      "weight" : 42.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.CONSTRUCTOR;\nimport static spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE;\n\n/**\n * This element represents a class declaration.\n *\n * <pre>\n *     // a class definition\n *     class Foo {\n *        int x;\n *     }\n * </pre>\n * @author Renaud Pawlak\n */\npublic interface CtClass<T> extends CtType<T>, CtStatement {\n\t/**\n\t * Returns the anonymous blocks of this class.\n\t * Derived from {@link #getTypeMembers()}\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = ANNONYMOUS_EXECUTABLE)\n\tList<CtAnonymousExecutable> getAnonymousExecutables();\n\n\t/**\n\t * Returns the constructor of the class that takes the given argument types.\n\t *\n\t * Derived from {@link #getTypeMembers()}\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = CONSTRUCTOR)\n\tCtConstructor<T> getConstructor(CtTypeReference<?>... parameterTypes);\n\n\t/**\n\t * Returns the constructors of this class. This includes the default\n\t * constructor if this class has no constructors explicitly declared.\n\t *\n\t * Derived from {@link #getTypeMembers()}\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = CONSTRUCTOR)\n\tSet<CtConstructor<T>> getConstructors();\n\n\t/**\n\t * Sets the anonymous blocks of this class.\n\t */\n\t@PropertySetter(role = ANNONYMOUS_EXECUTABLE)\n\t<C extends CtClass<T>> C setAnonymousExecutables(List<CtAnonymousExecutable> e);\n\n\t/**\n\t * Add an anonymous block to this class.\n\t *\n\t * @param e\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = ANNONYMOUS_EXECUTABLE)\n\t<C extends CtClass<T>> C addAnonymousExecutable(CtAnonymousExecutable e);\n\n\t/**\n\t * Remove an anonymous block to this class.\n\t *\n\t * @param e\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = ANNONYMOUS_EXECUTABLE)\n\tboolean removeAnonymousExecutable(CtAnonymousExecutable e);\n\n\t/**\n\t * Sets the constructors for this class.\n\t */\n\t@PropertySetter(role = CONSTRUCTOR)\n\t<C extends CtClass<T>> C setConstructors(Set<CtConstructor<T>> constructors);\n\n\t/**\n\t * Adds a constructor to this class.\n\t */\n\t@PropertySetter(role = CONSTRUCTOR)\n\t<C extends CtClass<T>> C addConstructor(CtConstructor<T> constructor);\n\n\t/**\n\t * Removes a constructor from this class.\n\t */\n\t@PropertySetter(role = CONSTRUCTOR)\n\tvoid removeConstructor(CtConstructor<T> constructor);\n\n\t/**\n\t * Return {@code true} if the referenced type is a anonymous type\n\t */\n\t@Override\n\tboolean isAnonymous();\n\n\t@Override\n\tCtClass<T> clone();\n\n\t/**\n\t * Creates an instance of this class.\n\t *\n\t * Requirements:\n\t * - the class must have a default constructor.\n\t * - All dependencies (superclass, super-interfaces, imports) must be in the classpath,\n\t * because the code is actually compiled (otherwise an exception is thrown)\n\t *\n\t * If the class has super-interfaces, the object can be cast to one of them.\n\t * Otherwise, if the class has no super-interfaces, the methods can only be called with reflection.\n\t *\n\t * This instance is meant to be used for quick-testing, it uses a throwable classloader that\n\t * will be garbage-collected with the instance.\n\t */\n\tT newInstance();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtStatement> C setLabel(String label);\n}\n"
    }, {
      "name" : "reflect/declaration/CtCompilationUnit.java",
      "weight" : 79.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.List;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.Experimental;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.util.ModelList;\n\n/**\n * Defines a compilation unit. In Java, a compilation unit can contain only one\n * public type declaration and other secondary types declarations (not public).\n */\n@Experimental\npublic interface CtCompilationUnit extends CtElement {\n\tenum UNIT_TYPE {\n\t\tTYPE_DECLARATION,\n\t\tPACKAGE_DECLARATION,\n\t\tMODULE_DECLARATION,\n\t\tUNKNOWN\n\t}\n\n\t/**\n\t * Returns the declaration type of the compilation unit.\n\t */\n\tUNIT_TYPE getUnitType();\n\t/**\n\t * Gets the file that corresponds to this compilation unit if any (contains\n\t * the source code).\n\t */\n\tFile getFile();\n\n\t/**\n\t * Sets the file that corresponds to this compilation unit.\n\t */\n\tCtCompilationUnit setFile(File file);\n\n\t/**\n\t * @return array of offsets in the origin source file, where occurs line separator\n\t */\n\tint[] getLineSeparatorPositions();\n\n\t/**\n\t * @param lineSeparatorPositions array of offsets in the origin source file, where occurs line separator\n\t */\n\tCtCompilationUnit setLineSeparatorPositions(int[] lineSeparatorPositions);\n\t/**\n\t * Gets all binary (.class) files that corresponds to this compilation unit\n\t * and have been created by calling\n\t * {@link spoon.SpoonModelBuilder#compile(spoon.SpoonModelBuilder.InputType...)}.\n\t */\n\tList<File> getBinaryFiles();\n\n\t/**\n\t * Gets all the types declared in this compilation unit.\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = CtRole.DECLARED_TYPE)\n\tList<CtType<?>> getDeclaredTypes();\n\n\t/**\n\t * Gets references to all the types declared in this compilation unit.\n\t */\n\t@PropertyGetter(role = CtRole.DECLARED_TYPE_REF)\n\tList<CtTypeReference<?>> getDeclaredTypeReferences();\n\n\t/**\n\t * Sets the references to types declared in this compilation unit.\n\t */\n\t@PropertySetter(role = CtRole.DECLARED_TYPE_REF)\n\tCtCompilationUnit setDeclaredTypeReferences(List<CtTypeReference<?>> types);\n\n\t/**\n\t * Sets the types declared in this compilation unit.\n\t * It is here for backward compatibility.\n\t * It calls internally {@link #setDeclaredTypeReferences(List)}\n\t * so the {@link CtCompilationUnit} contains type reference only.\n\t * It doesn't contain whole type, which belongs to it's CtPackage in primary `java concept` model.\n\t * Note that {@link CtCompilationUnit} represents a secondary model related to mapping of java modules, packages and types to file system.\n\t */\n\t@DerivedProperty\n\tCtCompilationUnit setDeclaredTypes(List<CtType<?>> types);\n\n\t/**\n\t * Add a type to the list of declared types.\n\t * It is here for backward compatibility.\n\t * It calls internally {@link #addDeclaredTypeReference(CtTypeReference)}\n\t * so the {@link CtCompilationUnit} contains type reference only.\n\t * It doesn't contain whole type, which belongs to it's CtPackage in primary `java concept` model.\n\t * Note that {@link CtCompilationUnit} represents a secondary model related to mapping of java modules, packages and types to file system.\n\t */\n\t@DerivedProperty\n\tCtCompilationUnit addDeclaredType(CtType<?> type);\n\n\t/**\n\t * Add a type reference to the list of declared types\n\t */\n\t@PropertySetter(role = CtRole.DECLARED_TYPE_REF)\n\tCtCompilationUnit addDeclaredTypeReference(CtTypeReference<?> type);\n\n\t/**\n\t * Gets the declared module if the compilationUnit is \"module-info.java\"\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = CtRole.DECLARED_MODULE)\n\tCtModule getDeclaredModule();\n\n\t/**\n\t * Gets the declared module reference if the compilationUnit is \"module-info.java\"\n\t */\n\t@PropertyGetter(role = CtRole.DECLARED_MODULE_REF)\n\tCtModuleReference getDeclaredModuleReference();\n\n\t/**\n\t * Sets the declared module if the compilationUnit is \"module-info.java\"\n\t * It is here for backward compatibility.\n\t * It internally calls {@link #setDeclaredModuleReference(CtModuleReference)}\n\t * It doesn't contain whole CtModule, which belongs to CtModel in primary `java concept` model.\n\t * Note that {@link CtCompilationUnit} represents a secondary model related to mapping of java modules, packages and types to file system.\n\t */\n\t@DerivedProperty\n\tCtCompilationUnit setDeclaredModule(CtModule module);\n\t/**\n\t * Sets the declared module reference if the compilationUnit is \"module-info.java\"\n\t */\n\t@PropertySetter(role = CtRole.DECLARED_MODULE_REF)\n\tCtCompilationUnit setDeclaredModuleReference(CtModuleReference module);\n\n\t/**\n\t * Gets the declared package\n\t */\n\t@DerivedProperty\n\tCtPackage getDeclaredPackage();\n\n\t/**\n\t * @return the package declaration\n\t */\n\t@PropertyGetter(role = CtRole.PACKAGE_DECLARATION)\n\tCtPackageDeclaration getPackageDeclaration();\n\n\t/**\n\t * Sets the package declaration using the instance of CtPackage.\n\t * It is here for backward compatibility.\n\t * It calls internally {@link #setPackageDeclaration(CtPackageDeclaration)}\n\t * It doesn't contain whole CtPackage, which belongs to it's parent package or to CtModule in primary `java concept` model.\n\t * Note that {@link CtCompilationUnit} represents a secondary model related to mapping of java modules, packages and types to file system.\n\t */\n\t@DerivedProperty\n\tCtCompilationUnit setDeclaredPackage(CtPackage ctPackage);\n\n\t/**\n\t * Sets the package declaration\n\t */\n\t@PropertySetter(role = CtRole.PACKAGE_DECLARATION)\n\tCtCompilationUnit setPackageDeclaration(CtPackageDeclaration packageDeclaration);\n\n\t/**\n\t * Searches and returns the main type (the type which has the same name as\n\t * the file).\n\t */\n\t@DerivedProperty\n\tCtType<?> getMainType();\n\n\t/**\n\t * Gets the original source code as a string.\n\t */\n\tString getOriginalSourceCode();\n\n\t/**\n\t * Get the imports computed for this CU.\n\t * WARNING: This method is tagged as experimental, as its signature and/or usage might change in future release.\n\t * @return All the imports from the original source code\n\t */\n\t@Experimental\n\t@PropertyGetter(role = CtRole.DECLARED_IMPORT)\n\tModelList<CtImport> getImports();\n\n\t@Override\n\tCtCompilationUnit clone();\n\n\t/**\n\t * Set the imports of this CU\n\t * WARNING: This method is tagged as experimental, as its signature and/or usage might change in future release.\n\t * @param imports All the imports of the original source code\n\t */\n\t@Experimental\n\t@PropertySetter(role = CtRole.DECLARED_IMPORT)\n\tCtCompilationUnit setImports(Collection<CtImport> imports);\n\n\t@Override\n\t@DerivedProperty\n\tCtElement getParent();\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setParent(E parent);\n\n\t@Override\n\t@UnsettableProperty\n\t<E extends CtElement> E setPosition(SourcePosition position);\n}\n"
    }, {
      "name" : "reflect/declaration/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * \t<p>This package contains the meta-model part that models the declarations (program's structures such as classes, fields, etc).\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.declaration;\n"
    }, {
      "name" : "reflect/declaration/CtModuleRequirement.java",
      "weight" : 21.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\n\nimport java.util.Set;\n\n/**\n * Represents a require module in a Java module definition\n *\n * The requires directive specifies the name of a module on which the current module has a dependence.\n * The requires keyword may be followed by the modifier transitive.\n * This causes any module which requires the current module to have an implicitly declared dependence\n * on the module specified by the requires transitive directive.\n * The requires keyword may be followed by the modifier static.\n * This specifies that the dependence, while mandatory at compile time, is optional at run time.\n *\n * Example:\n * <pre>\n *     requires transitive com.example.foo.network;\n * </pre>\n *\n */\npublic interface CtModuleRequirement extends CtModuleDirective {\n\n\tenum RequiresModifier {\n\t\tSTATIC, TRANSITIVE;\n\t}\n\n\t@PropertyGetter(role = CtRole.MODIFIER)\n\tSet<RequiresModifier> getRequiresModifiers();\n\n\t@PropertySetter(role = CtRole.MODIFIER)\n\t<T extends CtModuleRequirement> T setRequiresModifiers(Set<RequiresModifier> requiresModifiers);\n\n\t@PropertyGetter(role = CtRole.MODULE_REF)\n\tCtModuleReference getModuleReference();\n\n\t@PropertySetter(role = CtRole.MODULE_REF)\n\t<T extends CtModuleRequirement> T setModuleReference(CtModuleReference moduleReference);\n\n\t@Override\n\tCtModuleRequirement clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtShadowable.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.IS_SHADOW;\n\n/** A shadow element is an element that is in the Spoon model, but does not exist in the actual source code.\n * The goal of shadow elements is to simplify transformations.\n */\npublic interface CtShadowable {\n\t/**\n\t * When an element isn't present in the factory (created in another factory),\n\t * this element is considered as \"shadow\". e.g., a shadow element can be a\n\t * CtType of java.lang.Class built when we call {@link CtTypeReference#getTypeDeclaration()}\n\t * on a reference of java.lang.Class.\n\t *\n\t * @return true if the element is a shadow element, otherwise false.\n\t */\n\t@PropertyGetter(role = IS_SHADOW)\n\tboolean isShadow();\n\n\t/**\n\t * Marks an element as shadow. To know what is a shadow element, see the javadoc of\n\t * {@link #isShadow()}.\n\t */\n\t@PropertySetter(role = IS_SHADOW)\n\t<E extends CtShadowable> E setShadow(boolean isShadow);\n}\n"
    }, {
      "name" : "reflect/declaration/CtTypeMember.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.support.DerivedProperty;\n\n/**\n * This interface represents a member of a class (field, method,\n * nested class or static/instance initializer).\n */\npublic interface CtTypeMember extends CtModifiable, CtNamedElement {\n\n\t/**\n\t * Gets the type that declares this class member.\n\t *\n\t * @return declaring class\n\t */\n\t@DerivedProperty\n\tCtType<?> getDeclaringType();\n\n\t/**\n\t * Returns the top level type declaring this type if an inner type or type member.\n\t * If this is already a top-level type, then returns itself.\n\t */\n\t@DerivedProperty\n\t<T> CtType<T> getTopLevelType();\n}\n"
    }, {
      "name" : "reflect/declaration/CtConstructor.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.NAME;\n\n/**\n * This element defines a constructor declaration.\n */\npublic interface CtConstructor<T> extends CtExecutable<T>, CtTypeMember, CtFormalTypeDeclarer, CtShadowable {\n\n\t/**\n\t * Always returns \"&lt;init&gt;\".\n\t */\n\t@Override\n\t@PropertyGetter(role = NAME)\n\tString getSimpleName();\n\n\t@Override\n\tCtConstructor<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtTypedElement> C setType(CtTypeReference<T> type);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtNamedElement> C setSimpleName(String simpleName);\n}\n"
    }, {
      "name" : "reflect/declaration/CtVariable.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.DEFAULT_EXPRESSION;\n\n/**\n * This abstract element defines a variable declaration.\n */\npublic interface CtVariable<T> extends CtNamedElement, CtTypedElement<T>, CtModifiable {\n\t/**\n\t * Gets the initialization expression assigned to the variable (also known\n\t * as the initializer), when declared.\n\t */\n\t@PropertyGetter(role = DEFAULT_EXPRESSION)\n\tCtExpression<T> getDefaultExpression();\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtVariableReference<T> getReference();\n\n\t/**\n\t * Sets the initialization expression assigned to the variable, when\n\t * declared.\n\t */\n\t@PropertySetter(role = DEFAULT_EXPRESSION)\n\t<C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> assignedExpression);\n}\n"
    }, {
      "name" : "reflect/declaration/CtUsedService.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * Represents the declaration of a used service in a {@link CtModule}\n *\n * The uses directive specifies a service for which the current module may discover providers via java.util.ServiceLoader.\n * The service must be a class type, an interface type, or an annotation type. It is a compile-time error if a uses directive specifies an enum type as the service.\n * The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module, or a compile-time error occurs.\n * It is a compile-time error if more than one uses directive in a module declaration specifies the same service.\n *\n * Example:\n *\n * <pre>\n *     uses java.logging.Logger;\n * </pre>\n */\npublic interface CtUsedService extends CtModuleDirective {\n\t@PropertyGetter(role = CtRole.SERVICE_TYPE)\n\tCtTypeReference getServiceType();\n\n\t@PropertySetter(role = CtRole.SERVICE_TYPE)\n\t<T extends CtUsedService> T setServiceType(CtTypeReference providingType);\n\n\t@Override\n\tCtUsedService clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtType.java",
      "weight" : 100.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.METHOD;\nimport static spoon.reflect.path.CtRole.FIELD;\nimport static spoon.reflect.path.CtRole.INTERFACE;\nimport static spoon.reflect.path.CtRole.NAME;\nimport static spoon.reflect.path.CtRole.NESTED_TYPE;\nimport static spoon.reflect.path.CtRole.SUPER_TYPE;\nimport static spoon.reflect.path.CtRole.TYPE_MEMBER;\n\n/**\n * This abstract element defines a super-type for classes and interfaces, which\n * can declare methods.\n *\n * The type parameter T refers to the actual class that this type represents.\n */\npublic interface CtType<T> extends CtNamedElement, CtTypeInformation, CtTypeMember, CtFormalTypeDeclarer, CtShadowable {\n\t/**\n\t * The string separator in a Java innertype qualified name.\n\t */\n\tString INNERTTYPE_SEPARATOR = \"$\";\n\t/**\n\t * Used in no classpath when we don't have any information to build the name of the type.\n\t */\n\tString NAME_UNKNOWN = \"<unknown>\";\n\n\t/**\n\t * Returns the simple (unqualified) name of this element.\n\t * Following the compilation convention, if the type is a local type,\n\t * the name starts with a numeric prefix (e.g. local class Foo has simple name 1Foo).\n\t */\n\t@Override\n\t@PropertyGetter(role = NAME)\n\tString getSimpleName();\n\n\t/**\n\t * Returns the types used by this type.\n\t *\n\t * @param includeSamePackage\n\t * \t\tset to true if the method should return also the types located\n\t * \t\tin the same package as the current type\n\t */\n\tSet<CtTypeReference<?>> getUsedTypes(boolean includeSamePackage);\n\n\t/**\n\t *\n\t * NEVER USE THIS.\n\t *\n\t * See {@link CtTypeReference#getActualClass()}.\n\t *\n\t * @deprecated (since Spoon 7.0.0) this will be removed from the public API\n\t */\n\t@DerivedProperty\n\tClass<T> getActualClass();\n\n\t/**\n\t * Gets a field from its name.\n\t *\n\t * @return null if does not exit\n\t */\n\t@PropertyGetter(role = FIELD)\n\tCtField<?> getField(String name);\n\n\t/**\n\t * Returns the fields that are directly declared by this class or interface.\n\t * Includes enum constants.\n\t *\n\t * Derived from {@link #getTypeMembers()}\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = FIELD)\n\tList<CtField<?>> getFields();\n\n\t/**\n\t * Gets a nested type from its name.\n\t */\n\t@PropertyGetter(role = NESTED_TYPE)\n\t<N extends CtType<?>> N getNestedType(String name);\n\n\t/**\n\t * Returns the declarations of the nested classes and interfaces that are\n\t * directly declared by this class or interface.\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = NESTED_TYPE)\n\tSet<CtType<?>> getNestedTypes();\n\n\t/**\n\t * Gets the package where this type is declared.\n\t */\n\t@DerivedProperty\n\tCtPackage getPackage();\n\n\t/**\n\t * Gets the entire class code with package and imports.\n\t */\n\t@DerivedProperty\n\tString toStringWithImports();\n\n\t/**\n\t * Returns the corresponding type reference.\n\t *\n\t * Overrides the return type.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtTypeReference<T> getReference();\n\n\t/**\n\t * Returns true if this type is top-level (declared as the main type in a\n\t * file).\n\t */\n\tboolean isTopLevel();\n\n\t/**\n\t * Adds a field at the top of the type (before static block).\n\t * Note that the position of these field will be negative to be written at the top of the type.\n\t *\n\t * @param field\n\t * @return <tt>true</tt> if the field is added.\n\t */\n\t@PropertySetter(role = FIELD)\n\t<F, C extends CtType<T>> C addFieldAtTop(CtField<F> field);\n\n\t/**\n\t * add a field at the end of the field list.\n\t *\n\t * @param field\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = FIELD)\n\t<F, C extends CtType<T>> C addField(CtField<F> field);\n\n\t/**\n\t * add a field at a given position.\n\t *\n\t * @param field\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = FIELD)\n\t<F, C extends CtType<T>> C addField(int index, CtField<F> field);\n\n\t/**\n\t * Sets all fields in the type.\n\t */\n\t@PropertySetter(role = FIELD)\n\t<C extends CtType<T>> C setFields(List<CtField<?>> fields);\n\n\t/**\n\t * remove a Field\n\t *\n\t * @param field\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = FIELD)\n\t<F> boolean removeField(CtField<F> field);\n\n\t/**\n\t * Add a nested type.\n\t *\n\t * @param nestedType\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = NESTED_TYPE)\n\t<N, C extends CtType<T>> C addNestedType(CtType<N> nestedType);\n\n\t/**\n\t * Remove a nested type.\n\t *\n\t * @param nestedType\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = NESTED_TYPE)\n\t<N> boolean removeNestedType(CtType<N> nestedType);\n\n\t/**\n\t * Sets all nested types.\n\t */\n\t@PropertySetter(role = NESTED_TYPE)\n\t<C extends CtType<T>> C setNestedTypes(Set<CtType<?>> nestedTypes);\n\n\t/**\n\t * Replace all the code snippets that are found in this type by the corresponding Spoon AST.\n\t *\n\t * @see CtCodeSnippet\n\t * @see spoon.reflect.code.CtCodeSnippetExpression\n\t * @see spoon.reflect.code.CtCodeSnippetStatement\n\t */\n\tvoid compileAndReplaceSnippets();\n\n\t/**\n\t * Return all the methods that can be called on an instance of this type.\n\t * It recursively collects all methods (both concrete and abstract) from all super-classes and all super-interfaces.\n\t * It deduplicates methods with the same signature, which are defined several times somewhere in the type hierarchy.\n\t *\n\t * Warning: this method can be really slow due to signature deduplication.\n\t *\n\t * It includes all methods: the methods of types whose source code is in the Spoon model,\n\t * the methods of types from the JDK and from libraries present in the classpath,\n\t * the methods of java.lang.Object (for all CtClass objects).\n\t * However, in noclasspath mode, it does not include methods from unknown types.\n\t * If methods are overridden somewhere in the type hierarchy, it returns only top methods (ie method definitions).\n\t */\n\t@DerivedProperty\n\tSet<CtMethod<?>> getAllMethods();\n\n\t/**\n\t * Gets a method from its return type, name, and parameter types.\n\t *\n\t * @return null if does not exit\n\t */\n\t@PropertyGetter(role = METHOD)\n\t<R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>... parameterTypes);\n\n\t/**\n\t * Gets a method from its name and parameter types.\n\t *\n\t * @return null if does not exit\n\t */\n\t@PropertyGetter(role = METHOD)\n\t<R> CtMethod<R> getMethod(String name, CtTypeReference<?>... parameterTypes);\n\n\t/**\n\t * Returns the methods that are directly declared by this class or\n\t * interface.\n\t *\n\t * Derived from {@link #getTypeMembers()}\n\t *\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = METHOD)\n\tSet<CtMethod<?>> getMethods();\n\n\t/**\n\t * Returns the methods that are directly declared by this class or\n\t * interface and annotated with one of the given annotations.\n\t */\n\t@PropertyGetter(role = METHOD)\n\tSet<CtMethod<?>> getMethodsAnnotatedWith(CtTypeReference<?>... annotationTypes);\n\n\t/**\n\t * Returns the methods that are directly declared by this class or\n\t * interface and that have the given name.\n\t */\n\t@PropertyGetter(role = METHOD)\n\tList<CtMethod<?>> getMethodsByName(String name);\n\n\t/**\n\t * Searches in the type for the given method.\n\t * Super classes and implemented interfaces are considered.\n\t * The matching criterion is that the signatures are identical.\n\t * @param method The method to search for in the class.\n\t * @return True: the type has the given method. False otherwise.\n\t */\n\tboolean hasMethod(CtMethod<?> method);\n\n\t/**\n\t * Sets the methods of this type.\n\t */\n\t@PropertySetter(role = METHOD)\n\t<C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods);\n\n\t/**\n\t * Adds a method to this type.\n\t */\n\t@PropertySetter(role = METHOD)\n\t<M, C extends CtType<T>> C addMethod(CtMethod<M> method);\n\n\t/**\n\t * Removes a method from this type.\n\t */\n\t@PropertySetter(role = METHOD)\n\t<M> boolean removeMethod(CtMethod<M> method);\n\n\t/**\n\t * Sets the superclass type.\n\t */\n\t@PropertySetter(role = SUPER_TYPE)\n\t<C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass);\n\n\t/**\n\t * Sets the super interfaces of this type.\n\t */\n\t@PropertySetter(role = INTERFACE)\n\t<C extends CtType<T>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces);\n\n\t/**\n\t * @param interfac\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = INTERFACE)\n\t<S, C extends CtType<T>> C addSuperInterface(CtTypeReference<S> interfac);\n\n\t/**\n\t * @param interfac\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = INTERFACE)\n\t<S> boolean removeSuperInterface(CtTypeReference<S> interfac);\n\n\t/**\n\t * Gets all type members of the type like fields, methods, anonymous block, etc.\n\t */\n\t@PropertyGetter(role = TYPE_MEMBER)\n\tList<CtTypeMember> getTypeMembers();\n\n\t/**\n\t * Adds a type member at the end of all type member of the type.\n\t */\n\t@PropertySetter(role = TYPE_MEMBER)\n\t<C extends CtType<T>> C addTypeMember(CtTypeMember member);\n\n\t/**\n\t * Adds a type member at a given position. Think to use this method if the order is\n\t * important for you.\n\t */\n\t@PropertySetter(role = TYPE_MEMBER)\n\t<C extends CtType<T>> C addTypeMemberAt(int position, CtTypeMember member);\n\n\t/**\n\t * Removes the type member.\n\t */\n\t@PropertySetter(role = TYPE_MEMBER)\n\tboolean removeTypeMember(CtTypeMember member);\n\n\t/**\n\t * Removes all types members with these new members.\n\t */\n\t@PropertySetter(role = TYPE_MEMBER)\n\t<C extends CtType<T>> C setTypeMembers(List<CtTypeMember> members);\n\n\t@Override\n\tCtType<T> clone();\n\n\t/**\n\t * Copy the type, where copy means cloning + porting all the references in the clone from the old type to the new type.\n\t *\n\t * The copied type is added to the same package (and this to the factory as well).\n\t *\n\t * A new unique method name is given for each copy, and this method can be called several times.\n\t */\n\tCtType<?> copyType();\n}\n"
    }, {
      "name" : "reflect/declaration/CtAnnotationType.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This element defines an annotation type.\n */\npublic interface CtAnnotationType<T extends Annotation> extends CtType<T> {\n\n\t@DerivedProperty\n\tSet<CtAnnotationMethod<?>> getAnnotationMethods();\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\t<M, C extends CtType<T>> C addMethod(CtMethod<M> method);\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\t<C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods);\n\n\t@Override\n\tCtAnnotationType<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtFormalTypeDeclarer> T setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<T>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass);\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtImportKind.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\npublic enum CtImportKind {\n\tTYPE, // import my.package.Type;\n\tALL_TYPES, // import my.package.*;\n\tALL_STATIC_MEMBERS, // import static my.package.Type.*;\n\tFIELD, // import static my.package.Type.f;\n\tMETHOD, // import static my.package.Type.m;\n\tUNRESOLVED // Any of the above when in mode no classpath and the reference cannot be resolved.\n\t// It is then stored as a pure String that will be printed as is when pretty printed.\n}\n"
    }, {
      "name" : "reflect/declaration/CtMethod.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.refactoring.Refactoring;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.Collection;\n\nimport static spoon.reflect.path.CtRole.IS_DEFAULT;\n\n\n/**\n * This element defines a method declaration.\n */\npublic interface CtMethod<T> extends CtExecutable<T>, CtTypeMember, CtFormalTypeDeclarer, CtShadowable {\n\t/**\n\t * @param superMethod to be checked method\n\t * @return true if this method overrides `superMethod`.<br>\n\t * Returns true for itself too.\n\t * <pre>\n\t * assertTrue(this.isOverriding(this))\n\t * </pre>\n\t */\n\tboolean isOverriding(CtMethod<?> superMethod);\n\t/**\n\t * Checks if the method is a default method. Default method can be in interfaces from\n\t * Java 8: http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html.\n\t */\n\t@PropertyGetter(role = IS_DEFAULT)\n\tboolean isDefaultMethod();\n\n\t/**\n\t * Sets the default value state of a method.\n\t */\n\t@PropertySetter(role = IS_DEFAULT)\n\t<C extends CtMethod<T>> C setDefaultMethod(boolean defaultMethod);\n\n\t@Override\n\tCtMethod<T> clone();\n\n\t/**\n\t * Returns the top-most methods in the hierarchy defining this method\n\t * (in super class and super interfaces).\n\t * Returns the empty collection if defined here for the first time.\n\t */\n\tCollection<CtMethod<?>> getTopDefinitions();\n\n\t/**\n\t * Copy the method, where copy means cloning + porting all the references of the old method to the new method (important for recursive methods).\n\t * The copied method is added to the type, with a suffix \"Copy\".\n\t *\n\t * A new unique method name is given for each copy, and this method can be called several times.\n\t *\n\t * If you want to rename the new method, use {@link Refactoring#changeMethodName(CtMethod, String)} (and not {@link #setSimpleName(String)}, which does not update the references)\n\t */\n\tCtMethod<?> copyMethod();\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtTypeParameter.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This element defines a declaration of a type parameter (aka generics).\n * For example, in class A&lt;E&gt; { ... }, the \"E\" is modeled as an instance of CtTypeParameter.\n */\npublic interface CtTypeParameter extends CtType<Object> {\n\t/** override the return type */\n\t@Override\n\t@DerivedProperty\n\tCtTypeParameterReference getReference();\n\n\t/**\n\t * @return the {@link CtFormalTypeDeclarer}, which declares this {@link CtTypeParameter}\n\t */\n\t@DerivedProperty\n\tCtFormalTypeDeclarer getTypeParameterDeclarer();\n\n\t// override the return type\n\t@Override\n\tCtTypeParameter clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtFormalTypeDeclarer> T setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<Object>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces);\n\n\t@Override\n\t@UnsettableProperty\n\t<S, C extends CtType<Object>> C addSuperInterface(CtTypeReference<S> interfac);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<Object>> C setTypeMembers(List<CtTypeMember> members);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<Object>> C setFields(List<CtField<?>> fields);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<Object>> C setMethods(Set<CtMethod<?>> methods);\n\n\t@Override\n\t@UnsettableProperty\n\t<M, C extends CtType<Object>> C addMethod(CtMethod<M> method);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<Object>> C setNestedTypes(Set<CtType<?>> nestedTypes);\n\n\t@Override\n\t@UnsettableProperty\n\t<N, C extends CtType<Object>> C addNestedType(CtType<N> nestedType);\n\n\t@Override\n\t@UnsettableProperty\n\t<F, C extends CtType<Object>> C addFieldAtTop(CtField<F> field);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtModifiable> T setModifiers(Set<ModifierKind> modifiers);\n}\n"
    }, {
      "name" : "reflect/declaration/CtTypeInformation.java",
      "weight" : 44.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\n\nimport java.util.Collection;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.INTERFACE;\nimport static spoon.reflect.path.CtRole.MODIFIER;\nimport static spoon.reflect.path.CtRole.SUPER_TYPE;\n\n/**\n * Returns information that can be obtained both at compile-time and run-time\n *\n * For CtElement, the compile-time information is given\n *\n * For CtTypeReference, the runtime information is given (using the Reflection API)\n *\n */\npublic interface CtTypeInformation {\n\t/**\n\t * Returns the interface types directly implemented by this class or\n\t * extended by this interface.\n\t */\n\t@PropertyGetter(role = INTERFACE)\n\tSet<CtTypeReference<?>> getSuperInterfaces();\n\n\t/**\n\t * Returns the fully qualified name of this type declaration.\n\t */\n\t@DerivedProperty\n\tString getQualifiedName();\n\n\t/**\n\t * Gets modifiers of this type.\n\t */\n\t@PropertyGetter(role = MODIFIER)\n\tSet<ModifierKind> getModifiers();\n\n\t/**\n\t * Return {@code true} if the referenced type is a primitive type (int,\n\t * double, boolean...).\n\t */\n\tboolean isPrimitive();\n\n\t/**\n\t * Return {@code true} if the referenced type is a anonymous type\n\t */\n\tboolean isAnonymous();\n\n\t/**\n\t * Return {@code true} if the referenced type is declared in an executable.\n\t * e.g. a type declared in a method or a lambda.\n\t *\n\t * This corresponds to <code>isLocalClass</code> of <code>java.lang.Class</code>.\n\t *\n\t * <pre>\n\t *     // Type declared in a method.\n\t *     public void make() {\n\t *         class Cook {\n\t *         }\n\t *     }\n\t *     // Type declared in a lambda.\n\t *     s -&gt; {\n\t *         class Cook {\n\t *         }\n\t *     }\n\t * </pre>\n\t */\n\tboolean isLocalType();\n\n\t/**\n\t * Returns true if this type is a class. Returns false for others (enum, interface, generics, annotation).\n\t */\n\tboolean isClass();\n\n\t/**\n\t * Returns true if this type is an interface.\n\t */\n\tboolean isInterface();\n\n\t/**\n\t * Returns true if this type is an enum.\n\t */\n\tboolean isEnum();\n\n\t/**\n\t * Returns true if this type is an annotation type.\n\t */\n\tboolean isAnnotationType();\n\n\t/**\n\t * Returns true if it refers to a type parameter (ie not a concrete class, eg \"T foo\"). It can refer to it directly (eg T), or indirectly (eg List&lt;T&gt;, or Set&lt;List&lt;T&gt;&gt;).\n\t */\n\t@DerivedProperty\n\tboolean isGenerics();\n\n\t/**\n\t * Returns true if the referenced type is a sub-type of the given type.\n\t * Returns true is type is self, it means: typeX.isSubtypeOf(typeX) is true too\n\t */\n\tboolean isSubtypeOf(CtTypeReference<?> type);\n\n\t/**\n\t * Returns the class type directly extended by this class.\n\t *\n\t * getSuperClass().getDeclaration()/getTypeDeclaration() returns the corresponding CtType (if in the source folder of Spoon).\n\t *\n\t * @return the class type directly extended by this class, or null if there\n\t *         is none or if the super class is not in the classpath (in noclasspath mode)\n\t */\n\t@PropertyGetter(role = SUPER_TYPE)\n\tCtTypeReference<?> getSuperclass();\n\n\t/**\n\t * Gets the fields declared by this type.\n\t */\n\t@DerivedProperty\n\tCollection<CtFieldReference<?>> getDeclaredFields();\n\n\t/**\n\t * Gets the fields declared by this type and by all its supertypes if\n\t * applicable.\n\t */\n\t@DerivedProperty\n\tCollection<CtFieldReference<?>> getAllFields();\n\n\t/**\n\t * Gets a field from its name.\n\t *\n\t * @return null if does not exit\n\t */\n\tCtFieldReference<?> getDeclaredField(String name);\n\n\t/**\n\t * Gets a field from this type or any super type or any implemented interface by field name.\n\t *\n\t * @return null if does not exit\n\t */\n\tCtFieldReference<?> getDeclaredOrInheritedField(String fieldName);\n\n\t/**\n\t * Gets the executables declared by this type if applicable.\n\t */\n\t@DerivedProperty\n\tCollection<CtExecutableReference<?>> getDeclaredExecutables();\n\n\t/**\n\t * Gets the executables declared by this type and by all its supertypes (static/instance methods, constructors, anonymous static blocks) if\n\t * applicable. This method returns:\n\t *\n\t * <ul>\n\t *     <li>static, instance and default methods</li>\n\t *     <li>constructors</li>\n\t * </ul>\n\t *\n\t * If a method is overridden twice in the hierarchy, it counts for two different elements.\n\t * The method can be abstract.\n\t */\n\t@DerivedProperty\n\tCollection<CtExecutableReference<?>> getAllExecutables();\n\n\t/**\n\t * @return the type erasure, which is computed by the java compiler to ensure that no new classes are created for parametrized types so that generics incur no runtime overhead.\n\t * See https://docs.oracle.com/javase/tutorial/java/generics/erasure.html\n\t */\n\t@DerivedProperty\n\tCtTypeReference<?> getTypeErasure();\n\n\n\t/**\n\t * @return true if this represents an array e.g. Object[] or int[]\n\t */\n\tboolean isArray();\n}\n"
    }, {
      "name" : "reflect/declaration/CtField.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\n/**\n * This element defines a field declaration.\n */\npublic interface CtField<T> extends CtVariable<T>, CtTypeMember, CtRHSReceiver<T>, CtShadowable {\n\n\t/**\n\t * The separator for a string representation of a field.\n\t */\n\tString FIELD_SEPARATOR = \"#\";\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtFieldReference<T> getReference();\n\n\t/**\n\t * Useful proxy to {@link #getDefaultExpression()}.\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtExpression<T> getAssignment();\n\n\t@Override\n\t@UnsettableProperty\n\t<U extends CtRHSReceiver<T>> U setAssignment(CtExpression<T> assignment);\n\n\t@Override\n\tCtField<T> clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtEnum.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.VALUE;\n\n/**\n * This element represents an enumeration declaration.\n *\n * Example:\n * <pre>\n *    enum Boolean { TRUE, FALSE }\n * </pre>\n\n */\npublic interface CtEnum<T extends Enum<?>> extends CtClass<T> {\n\t/**\n\t * Adds an enum value.\n\t *\n\t * @param enumValue\n\t * \t\tAn enum value.\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = VALUE)\n\t<C extends CtEnum<T>> C addEnumValue(CtEnumValue<?> enumValue);\n\n\t/**\n\t * Removes en enum value.\n\t *\n\t * @param enumValue\n\t * \t\tAn enum value.\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = VALUE)\n\tboolean removeEnumValue(CtEnumValue<?> enumValue);\n\n\t/**\n\t * Gets an enum value by its name.\n\t *\n\t * @param name\n\t * \t\tName of the enum value.\n\t * @return An enum value.\n\t */\n\t@PropertyGetter(role = VALUE)\n\tCtEnumValue<?> getEnumValue(String name);\n\n\t/**\n\t * Gets all enum values of the enumeration.\n\t *\n\t * @return All enum values.\n\t */\n\t@PropertyGetter(role = VALUE)\n\tList<CtEnumValue<?>> getEnumValues();\n\n\t/**\n\t *Sets all enum values of the enum.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<C extends CtEnum<T>> C setEnumValues(List<CtEnumValue<?>> enumValues);\n\n\t@Override\n\tCtEnum<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtFormalTypeDeclarer> T setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters);\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass);\n}\n"
    }, {
      "name" : "reflect/declaration/CtParameter.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.IS_VARARGS;\n\n/**\n * This element defines an executable parameter declaration.\n *\n * @see CtExecutable\n */\npublic interface CtParameter<T> extends CtVariable<T>, CtShadowable {\n\n\t/**\n\t * Gets the executable that is the parent declaration of this parameter\n\t * declaration.\n\t *\n\t * (Overriding the return type)\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtExecutable<?> getParent();\n\n\t/**\n\t * Returns <tt>true</tt> if this parameter accepts a variable number of\n\t * arguments (must be the last parameter of\n\t * {@link CtExecutable#getParameters()}).\n\t */\n\t@PropertyGetter(role = IS_VARARGS)\n\tboolean isVarArgs();\n\n\t/**\n\t * Sets this parameter to have varargs.\n\t */\n\t@PropertySetter(role = IS_VARARGS)\n\t<C extends CtParameter<T>> C setVarArgs(boolean varArgs);\n\n\t/** overriding the return type */\n\t@Override\n\t@DerivedProperty\n\tCtParameterReference<T> getReference();\n\n\t@Override\n\tCtParameter<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> assignedExpression);\n}\n"
    }, {
      "name" : "reflect/declaration/CtModule.java",
      "weight" : 102.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.support.DerivedProperty;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.EXPORTED_PACKAGE;\nimport static spoon.reflect.path.CtRole.MODIFIER;\nimport static spoon.reflect.path.CtRole.MODULE_DIRECTIVE;\nimport static spoon.reflect.path.CtRole.OPENED_PACKAGE;\nimport static spoon.reflect.path.CtRole.PROVIDED_SERVICE;\nimport static spoon.reflect.path.CtRole.REQUIRED_MODULE;\nimport static spoon.reflect.path.CtRole.SERVICE_TYPE;\nimport static spoon.reflect.path.CtRole.SUB_PACKAGE;\n\n/**\n * Represents a Java module as defined in Java 9.\n *\n * Modules are defined in `module-info.java` as follows:\n * <pre>\n *     module com.example.foo {\n *\n *     }\n * </pre>\n *\n * Modules define required modules, and exported packages for client code.\n *\n * A module can export a service, defined as a type.\n * Provided services are implementations of given service.\n * Modules can require services (\"uses\" in Java 9)\n *\n * An open module, with the open modifier,\n * grants access at compile time to types in only those packages which are explicitly exported,\n * but grants access at run time to types in all its packages, as if all packages had been exported.\n */\npublic interface CtModule extends CtNamedElement {\n\n\t/**\n\t * The name for the top level module.\n\t */\n\tString TOP_LEVEL_MODULE_NAME = \"unnamed module\";\n\n\t/**\n\t * Returns true if the module is the unnamed module\n\t */\n\t@DerivedProperty\n\tboolean isUnnamedModule();\n\n\t@PropertyGetter(role = MODIFIER)\n\tboolean isOpenModule();\n\n\t@PropertySetter(role = MODIFIER)\n\t<T extends CtModule> T setIsOpenModule(boolean openModule);\n\n\t@PropertySetter(role = MODULE_DIRECTIVE)\n\t<T extends CtModule> T setModuleDirectives(List<CtModuleDirective> moduleDirectives);\n\n\t@PropertySetter(role = MODULE_DIRECTIVE)\n\t<T extends CtModule> T addModuleDirective(CtModuleDirective moduleDirective);\n\n\t@PropertySetter(role = MODULE_DIRECTIVE)\n\t<T extends CtModule> T addModuleDirectiveAt(int position, CtModuleDirective moduleDirective);\n\n\t@PropertyGetter(role = MODULE_DIRECTIVE)\n\tList<CtModuleDirective> getModuleDirectives();\n\n\t@PropertySetter(role = MODULE_DIRECTIVE)\n\t<T extends CtModule> T removeModuleDirective(CtModuleDirective moduleDirective);\n\n\t@PropertyGetter(role = SERVICE_TYPE)\n\t@DerivedProperty\n\tList<CtUsedService> getUsedServices();\n\n\t@PropertySetter(role = SERVICE_TYPE)\n\t@DerivedProperty\n\t<T extends CtModule> T setUsedServices(List<CtUsedService> usedServices);\n\n\t@PropertySetter(role = SERVICE_TYPE)\n\t@DerivedProperty\n\t<T extends CtModule> T addUsedService(CtUsedService usedService);\n\n\t@PropertySetter(role = SERVICE_TYPE)\n\t@DerivedProperty\n\t<T extends CtModule> T removeUsedService(CtUsedService usedService);\n\n\t@PropertyGetter(role = EXPORTED_PACKAGE)\n\t@DerivedProperty\n\tList<CtPackageExport> getExportedPackages();\n\n\t@PropertySetter(role = EXPORTED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T setExportedPackages(List<CtPackageExport> exportedPackages);\n\n\t@PropertySetter(role = EXPORTED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T addExportedPackage(CtPackageExport exportedPackage);\n\n\t@PropertySetter(role = EXPORTED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T removeExportedPackage(CtPackageExport exportedPackage);\n\n\t@PropertyGetter(role = OPENED_PACKAGE)\n\t@DerivedProperty\n\tList<CtPackageExport> getOpenedPackages();\n\n\t@PropertySetter(role = OPENED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T setOpenedPackages(List<CtPackageExport> openedPackages);\n\n\t@PropertySetter(role = OPENED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T addOpenedPackage(CtPackageExport openedPackage);\n\n\t@PropertySetter(role = OPENED_PACKAGE)\n\t@DerivedProperty\n\t<T extends CtModule> T removeOpenedPackage(CtPackageExport openedPackage);\n\n\t@PropertyGetter(role = REQUIRED_MODULE)\n\t@DerivedProperty\n\tList<CtModuleRequirement> getRequiredModules();\n\n\t@PropertySetter(role = REQUIRED_MODULE)\n\t@DerivedProperty\n\t<T extends CtModule> T setRequiredModules(List<CtModuleRequirement> requiredModules);\n\n\t@PropertySetter(role = REQUIRED_MODULE)\n\t@DerivedProperty\n\t<T extends CtModule> T addRequiredModule(CtModuleRequirement requiredModule);\n\n\t@PropertySetter(role = REQUIRED_MODULE)\n\t@DerivedProperty\n\t<T extends CtModule> T removeRequiredModule(CtModuleRequirement requiredModule);\n\n\t@PropertyGetter(role = PROVIDED_SERVICE)\n\t@DerivedProperty\n\tList<CtProvidedService> getProvidedServices();\n\n\t@PropertySetter(role = PROVIDED_SERVICE)\n\t@DerivedProperty\n\t<T extends CtModule> T setProvidedServices(List<CtProvidedService> providedServices);\n\n\t@PropertySetter(role = PROVIDED_SERVICE)\n\t@DerivedProperty\n\t<T extends CtModule> T addProvidedService(CtProvidedService providedService);\n\n\t@PropertySetter(role = PROVIDED_SERVICE)\n\t@DerivedProperty\n\t<T extends CtModule> T removeProvidedService(CtProvidedService providedService);\n\n\t/**\n\t * returns the root package of the unnamed module\n\t * If there are several modules, it throws an exception\n\t */\n\t@PropertyGetter(role = SUB_PACKAGE)\n\tCtPackage getRootPackage();\n\n\t@PropertySetter(role = SUB_PACKAGE)\n\t<T extends CtModule> T setRootPackage(CtPackage rootPackage);\n\n\t@DerivedProperty\n\t@Override\n\tCtModuleReference getReference();\n\n\t@Override\n\tCtModule clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtFormalTypeDeclarer.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TYPE_PARAMETER;\n\n/**\n * This abstract element defines a declaration that accepts formal type\n * parameters (aka generics), such as a CtType (<code>class A&lt;E&gt;</code>), CtMethod or CtConstructor.\n */\npublic interface CtFormalTypeDeclarer extends CtTypeMember {\n\n\t/**\n\t * Returns the formal type parameters of this generic element.\n\t */\n\t@PropertyGetter(role = TYPE_PARAMETER)\n\tList<CtTypeParameter> getFormalCtTypeParameters();\n\n\t/**\n\t * Sets the type parameters of this generic element.\n\t */\n\t@PropertySetter(role = TYPE_PARAMETER)\n\t<T extends CtFormalTypeDeclarer> T setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters);\n\n\t/**\n\t * Add a type parameter to this generic element.\n\t */\n\t@PropertySetter(role = TYPE_PARAMETER)\n\t<T extends CtFormalTypeDeclarer> T addFormalCtTypeParameter(CtTypeParameter formalTypeParameter);\n\n\t/**\n\t * Removes a type parameters from this generic element.\n\t */\n\t@PropertySetter(role = TYPE_PARAMETER)\n\tboolean removeFormalCtTypeParameter(CtTypeParameter formalTypeParameter);\n}\n"
    }, {
      "name" : "reflect/declaration/CtProvidedService.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.util.List;\n\n/**\n * Represents a provided service in a {@link CtModule}.\n * The provides directive specifies a service for which the with clause specifies one or more service providers to java.util.ServiceLoader.\n * The service must be a class type, an interface type, or an annotation type. It is a compile-time error if a provides directive specifies an enum type as the service.\n *\n * The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module, or a compile-time error occurs.\n * Every service provider must be a class type or an interface type, that is public, and that is top level or nested static, or a compile-time error occurs.\n * Every service provider must be declared in the current module, or a compile-time error occurs.\n *\n * It is a compile-time error if more than one provides directive in a module declaration specifies the same service.\n * It is a compile-time error if the with clause of a given provides directive specifies the same service provider more than once.\n *\n * Example:\n * <pre>\n *     provides com.example.foo.spi.Itf with com.example.foo.Impl;\n * </pre>\n */\npublic interface CtProvidedService extends CtModuleDirective {\n\n\t@PropertyGetter(role = CtRole.SERVICE_TYPE)\n\tCtTypeReference getServiceType();\n\n\t@PropertySetter(role = CtRole.SERVICE_TYPE)\n\t<T extends CtProvidedService> T setServiceType(CtTypeReference providingType);\n\n\t@PropertyGetter(role = CtRole.IMPLEMENTATION_TYPE)\n\tList<CtTypeReference> getImplementationTypes();\n\n\t@PropertySetter(role = CtRole.IMPLEMENTATION_TYPE)\n\t<T extends CtProvidedService> T setImplementationTypes(List<CtTypeReference> usedTypes);\n\n\t@PropertySetter(role = CtRole.IMPLEMENTATION_TYPE)\n\t<T extends CtProvidedService> T addImplementationType(CtTypeReference usedType);\n\n\t@Override\n\tCtProvidedService clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtPackage.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.SUB_PACKAGE;\nimport static spoon.reflect.path.CtRole.CONTAINED_TYPE;\n\n/**\n * This element defines a package declaration. The packages are represented by a\n * tree.\n */\npublic interface CtPackage extends CtNamedElement, CtShadowable {\n\n\t/**\n\t * The separator for a string representation of a package.\n\t */\n\tString PACKAGE_SEPARATOR = \".\";\n\n\tchar PACKAGE_SEPARATOR_CHAR = '.';\n\n\t/**\n\t * The name for the top level package.\n\t */\n\tString TOP_LEVEL_PACKAGE_NAME = \"unnamed package\";\n\n\t/**\n\t * Gets the declaring module.\n\t */\n\t@DerivedProperty\n\tCtModule getDeclaringModule();\n\n\t/**\n\t * Gets the declaring package of the current one. Returns null if the package is not yet in another one.\n\t */\n\t@DerivedProperty\n\tCtPackage getDeclaringPackage();\n\n\t/**\n\t * Searches a child package by name.\n\t *\n\t * @param name\n\t * \t\tthe simple name of searched package\n\t * @return the found package or null\n\t */\n\t@PropertyGetter(role = SUB_PACKAGE)\n\tCtPackage getPackage(String name);\n\n\t/**\n\t * Gets the set of included child packages.\n\t */\n\t@PropertyGetter(role = SUB_PACKAGE)\n\tSet<CtPackage> getPackages();\n\n\t/**\n\t * Returns the fully qualified name of this package. This is also known as\n\t * the package's <i>canonical</i> name.\n\t *\n\t * @return the fully qualified name of this package, or the empty string if\n\t * this is the unnamed package\n\t */\n\tString getQualifiedName();\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtPackageReference getReference();\n\n\t/**\n\t * Finds a top-level type by name.\n\t *\n\t * @return the found type or null\n\t */\n\t@PropertyGetter(role = CONTAINED_TYPE)\n\t<T extends CtType<?>> T getType(String simpleName);\n\n\t/**\n\t * Returns the set of the top-level types in this package.\n\t */\n\t@PropertyGetter(role = CONTAINED_TYPE)\n\tSet<CtType<?>> getTypes();\n\n\t/**\n\t * Adds a type to this package.\n\t */\n\t@PropertySetter(role = CONTAINED_TYPE)\n\t<T extends CtPackage> T addType(CtType<?> type);\n\n\t/**\n\t * Removes a type from this package.\n\t */\n\t@PropertySetter(role = CONTAINED_TYPE)\n\tvoid removeType(CtType<?> type);\n\n\t/**\n\t * Sets the children defined in this package\n\t *\n\t * @param pack\n\t * \t\tnew set of child packages\n\t */\n\t@PropertySetter(role = SUB_PACKAGE)\n\t<T extends CtPackage> T setPackages(Set<CtPackage> pack);\n\n\t/**\n\t * add a subpackage\n\t *\n\t * @param pack\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = SUB_PACKAGE)\n\t<T extends CtPackage> T addPackage(CtPackage pack);\n\n\t/**\n\t * remove a subpackage\n\t *\n\t * @param pack\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = SUB_PACKAGE)\n\tboolean removePackage(CtPackage pack);\n\n\t/**\n\t * Sets the types defined in the package.\n\t *\n\t * @param types\n\t * \t\tnew Set of types\n\t */\n\t@PropertySetter(role = CONTAINED_TYPE)\n\t<T extends CtPackage> T setTypes(Set<CtType<?>> types);\n\n\t@Override\n\tCtPackage clone();\n\n\t/**\n\t * Returns {@code true} if this is an <i>unnamed</i> Java package.\n\t * See JLS §7.4.2. Unnamed Packages.\n\t */\n\tboolean isUnnamedPackage();\n\n\t/**\n\t* @return true if the package contains a package-info.java file\n\t*/\n\tboolean hasPackageInfo();\n\n\t/**\n\t * @return true if the package contains no types nor any other packages\n\t */\n\tboolean isEmpty();\n}\n"
    }, {
      "name" : "reflect/declaration/CtExecutable.java",
      "weight" : 38.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.PARAMETER;\nimport static spoon.reflect.path.CtRole.THROWN;\n\n/**\n * This element represents an executable element such as a method, a\n * constructor, or an anonymous block.\n */\npublic interface CtExecutable<R> extends CtNamedElement, CtTypedElement<R>, CtBodyHolder {\n\n\t/**\n\t * The separator for a string representation of an executable.\n\t */\n\tString EXECUTABLE_SEPARATOR = \"#\";\n\n\t/*\n\t * (non-Javadoc)\n\t *\n\t * @see spoon.reflect.declaration.CtNamedElement#getReference()\n\t */\n\t@Override\n\t@DerivedProperty\n\tCtExecutableReference<R> getReference();\n\n\t/**\n\t * Gets the body expression.\n\t */\n\t@Override\n\tCtBlock<R> getBody();\n\n\t/**\n\t * Gets the parameters list.\n\t */\n\t@PropertyGetter(role = PARAMETER)\n\tList<CtParameter<?>> getParameters();\n\n\t/**\n\t * Sets the parameters.\n\t */\n\t@PropertySetter(role = PARAMETER)\n\t<T extends CtExecutable<R>> T setParameters(List<CtParameter<?>> parameters);\n\n\t/**\n\t * Add a parameter for this executable\n\t *\n\t * @param parameter\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = PARAMETER)\n\t<T extends CtExecutable<R>> T addParameter(CtParameter<?> parameter);\n\n\t/**\n\t * Remove a parameter for this executable\n\t *\n\t * @param parameter\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\tboolean removeParameter(CtParameter<?> parameter);\n\n\t/**\n\t * Returns the exceptions and other throwables listed in this method or\n\t * constructor's <tt>throws</tt> clause.\n\t */\n\t@PropertyGetter(role = THROWN)\n\tSet<CtTypeReference<? extends Throwable>> getThrownTypes();\n\n\t/**\n\t * Sets the thrown types.\n\t */\n\t@PropertySetter(role = THROWN)\n\t<T extends CtExecutable<R>> T setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes);\n\n\t/**\n\t * add a thrown type.\n\t *\n\t * @param throwType\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = THROWN)\n\t<T extends CtExecutable<R>> T addThrownType(CtTypeReference<? extends Throwable> throwType);\n\n\t/**\n\t * remove a thrown type.\n\t *\n\t * @param throwType\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = THROWN)\n\tboolean removeThrownType(CtTypeReference<? extends Throwable> throwType);\n\n\t/**\n\t * Gets the signature of this method or constructor.\n\t * The signature is composed of the method name and the parameter types, all fully-qualified, eg \"int foo(java.lang.String)\".\n\t * The core contract is that in a type, there cannot be two methods with the same signature.\n\t *\n\t * Note that the concept of method signature in Java is not well defined (see chapter \"8.4.2 Method Signature\" of the Java specification, which defines what relations between signatures but not what a signature is exactly).\n\t *\n\t * Note also that the signature of a method reference is the same as the signature of the corresponding method if and only if the method parameters does not involve generics in their types. Otherwise, one has eg m(String) (reference) and m(T) (declaration)\n\t *\n\t * Reference: \"In the Java programming language, a method signature is the method name and the number and type of its parameters. Return types and thrown exceptions are not considered to be a part of the method signature.\"\n\t * see https://stackoverflow.com/questions/16149285/does-a-methods-signature-in-java-include-its-return-type\n\t * see https://en.wikipedia.org/wiki/Type_signature\n\t */\n\tString getSignature();\n\n\t@Override\n\tCtExecutable<R> clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtPackageExport.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\n\nimport java.util.List;\n\n/**\n * Represents an exported or opened package in a Java module\n *\n * The exports directive specifies the name of a package to be exported by the current module.\n * For code in other modules, this grants access at compile time and run time to the public and protected types in the package,\n * and the public and protected members of those types. It also grants reflective access to those types and members for code in other modules.\n *\n * The opens directive specifies the name of a package to be opened by the current module.\n * For code in other modules, this grants access at run time, but not compile time, to the public and protected types in the package,\n * and the public and protected members of those types. It also grants reflective access to all types in the package, and all their members, for code in other modules.\n *\n * It is permitted for opens to specify a package which is not declared by a compilation unit associated with the current module.\n * (If the package should happen to be declared by an observable compilation unit associated with another module, the opens directive has no effect on that other module.)\n *\n * If an exports or opens directive has a to clause, then the directive is qualified; otherwise, it is unqualified.\n * For a qualified directive, the public and protected types in the package, and their public and protected members, are accessible solely to code in the modules specified in the to clause.\n * The modules specified in the to clause are referred to as friends of the current module. For an unqualified directive, these types and their members are accessible to code in any module.\n * It is permitted for the to clause of an exports or opens directive to specify a module which is not observable (§7.7.6).\n *\n * Examples:\n * <pre>\n *     exports com.example.foo.internal to com.example.foo.probe;\n *     opens com.example.foo.quux;\n * </pre>\n */\npublic interface CtPackageExport extends CtModuleDirective {\n\n\t@PropertySetter(role = CtRole.OPENED_PACKAGE)\n\t<T extends CtPackageExport> T setOpenedPackage(boolean openedPackage);\n\n\t@PropertyGetter(role = CtRole.OPENED_PACKAGE)\n\tboolean isOpenedPackage();\n\n\t@PropertyGetter(role = CtRole.PACKAGE_REF)\n\tCtPackageReference getPackageReference();\n\n\t@PropertySetter(role = CtRole.PACKAGE_REF)\n\t<T extends CtPackageExport> T setPackageReference(CtPackageReference packageReference);\n\n\t@PropertyGetter(role = CtRole.MODULE_REF)\n\tList<CtModuleReference> getTargetExport();\n\n\t@PropertySetter(role = CtRole.MODULE_REF)\n\t<T extends CtPackageExport> T setTargetExport(List<CtModuleReference> targetExport);\n\n\t@PropertySetter(role = CtRole.MODULE_REF)\n\t<T extends CtPackageExport> T addTargetExport(CtModuleReference targetExport);\n\n\t@Override\n\tCtPackageExport clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtElement.java",
      "weight" : 96.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.processing.FactoryAccessor;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.path.CtPath;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitable;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.Root;\nimport spoon.reflect.visitor.chain.CtQueryable;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.ANNOTATION;\nimport static spoon.reflect.path.CtRole.COMMENT;\nimport static spoon.reflect.path.CtRole.IS_IMPLICIT;\nimport static spoon.reflect.path.CtRole.POSITION;\n\n/**\n * This interface is the root interface for the metamodel elements (any program\n * element).\n */\n@Root\npublic interface CtElement extends FactoryAccessor, CtVisitable, Cloneable, CtQueryable, Serializable, SourcePositionHolder {\n\n\t/**\n\t * Searches for an annotation of the given class that annotates the\n\t * current element.\n\t *\n\t * When used with a shadow element, this method might return an empty list even on an annotated element\n\t * because annotations without a RUNTIME retention policy are lost after compilation.\n\t *\n\t * WARNING: this method uses a class loader proxy, which is costly.\n\t * Use {@link #getAnnotation(CtTypeReference)} preferably.\n\t *\n\t * <p>\n\t * NOTE: before using an annotation proxy, you have to make sure that all\n\t * the types referenced by the annotation have been compiled and are in the\n\t * classpath so that accessed values can be converted into the actual types.\n\t *\n\t * @param <A>\n\t * \t\tthe annotation's type\n\t * @param annotationType\n\t * \t\tthe annotation's class\n\t * @return if found, returns a proxy for this annotation\n\t */\n\t@PropertyGetter(role = ANNOTATION)\n\t<A extends Annotation> A getAnnotation(Class<A> annotationType);\n\n\t/**\n\t * Gets the annotation element for a given annotation type.\n\t *\n\t * When used with a shadow element, this method might return an empty list even on an annotated element\n\t * because annotations without a RUNTIME retention policy are lost after compilation.\n\t *\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @return the annotation if this element is annotated by one annotation of\n\t * the given type\n\t */\n\t@PropertyGetter(role = ANNOTATION)\n\t<A extends Annotation> CtAnnotation<A> getAnnotation(\n\t\t\tCtTypeReference<A> annotationType);\n\n\t/**\n\t * @return  true if the element is annotated by the given annotation type.\n\t *\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t */\n\t@DerivedProperty\n\t<A extends Annotation> boolean hasAnnotation(Class<A> annotationType);\n\n\n\t/**\n\t * Returns the annotations that are present on this element.\n\t *\n\t * For sake of encapsulation, the returned list is unmodifiable.\n\t */\n\t@PropertyGetter(role = ANNOTATION)\n\tList<CtAnnotation<? extends Annotation>> getAnnotations();\n\n\t/**\n\t * Returns the text of the documentation (\"javadoc\") comment of this\n\t * element. It contains the text of Javadoc together with the tags.\n\t *\n\t * If one only wants only the text without the tag, one can call `getComments().get(0).getContent()`\n\t *\n\t * If one wants to analyze the tags, one can call `getComments().get(0).asJavaDoc().getTags()`\n\t *\n\t * See also {@link #getComments()}.and {@link spoon.reflect.code.CtJavaDoc}\n\t */\n\t@DerivedProperty\n\tString getDocComment();\n\n\t/**\n\t * Build a short representation of any element.\n\t */\n\t@DerivedProperty\n\tString getShortRepresentation();\n\n\t/**\n\t * Gets the position of this element in input source files\n\t *\n\t * @return Source file and line number of this element.\n\t * It never returns null. Use {@link SourcePosition#isValidPosition()}\n\t * to detect whether return instance contains start/end indexes.\n\t */\n\t@PropertyGetter(role = POSITION)\n\t@Override\n\tSourcePosition getPosition();\n\n\t/**\n\t * Replaces this element by another one.\n\t */\n\tvoid replace(CtElement element);\n\n\t/**\n\t * Replaces this element by several elements.\n\t * If `elements` contains one single element, it is equivalent to {@link #replace(CtElement)}.\n\t * If `elements` is empty, it is equivalent to {@link #delete()}.\n\t */\n\t<E extends CtElement> void replace(Collection<E> elements);\n\n\t/**\n\t * Add an annotation for this element\n\t *\n\t * @param annotation\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = ANNOTATION)\n\t<E extends CtElement> E addAnnotation(CtAnnotation<? extends Annotation> annotation);\n\n\t/**\n\t * Remove an annotation for this element\n\t *\n\t * @param annotation\n\t * @return <tt>true</tt> if this element changed as a result of the call\n\t */\n\t@PropertySetter(role = ANNOTATION)\n\tboolean removeAnnotation(CtAnnotation<? extends Annotation> annotation);\n\n\t/**\n\t * Sets the text of the documentation (\"javadoc\") comment of this\n\t * declaration. This API will set the content of the first javadoc\n\t * {@link CtComment} or create a new  javadoc {@link CtComment} if\n\t * no javadoc {@link CtComment} is available on this object.\n\t */\n\t<E extends CtElement> E setDocComment(String docComment);\n\n\t/**\n\t * Sets the position in the Java source file. Note that this information is\n\t * used to feed the line numbers in the generated bytecode if any (which is\n\t * useful for debugging).\n\t *\n\t * @param position\n\t * \t\tof this element in the input source files\n\t */\n\t@PropertySetter(role = POSITION)\n\t<E extends CtElement> E setPosition(SourcePosition position);\n\n\t/**\n\t * Gets the child elements annotated with the given annotation type's\n\t * instances.\n\t *\n\t * @param <E>\n\t * \t\tthe element's type\n\t * @param annotationType\n\t * \t\tthe annotation type\n\t * @return all the child elements annotated with an instance of the given\n\t * annotation type\n\t */\n\t<E extends CtElement> List<E> getAnnotatedChildren(\n\t\t\tClass<? extends Annotation> annotationType);\n\n\t/**\n\t * Returns true if this element is not present in the code (automatically added by the\n\t * Java compiler or inferred when the model is built).\n\t * Consequently, implicit elements are not pretty-printed and have no position.\n\t */\n\t@PropertyGetter(role = IS_IMPLICIT)\n\tboolean isImplicit();\n\n\t/**\n\t * Sets this element to be implicit.\n\t */\n\t@PropertySetter(role = IS_IMPLICIT)\n\t<E extends CtElement> E setImplicit(boolean b);\n\n\t/**\n\t * Calculates and returns the set of all the types referenced by this\n\t * element (and sub-elements in the AST).\n\t */\n\t@DerivedProperty\n\tSet<CtTypeReference<?>> getReferencedTypes();\n\n\t/**\n\t * Returns all the children elements recursively matching the filter.\n\t * If the receiver (this) matches the filter, it is also returned\n\t */\n\t<E extends CtElement> List<E> getElements(Filter<E> filter);\n\n\t/**\n\t * Sets the position of this element and all its children element. Note that\n\t * this information is used to feed the line numbers in the generated\n\t * bytecode if any (which is useful for debugging).\n\t *\n\t * @param position\n\t * \t\tof this element and all children in the input source file\n\t */\n\t<E extends CtElement> E setPositions(SourcePosition position);\n\n\t/**\n\t * Sets the annotations for this element.\n\t */\n\t@PropertySetter(role = ANNOTATION)\n\t<E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotation);\n\n\t/**\n\t * Gets the parent of current reference.\n\t *\n\t * @throws ParentNotInitializedException\n\t * \t\twhen the parent of this element is not initialized\n\t */\n\t@DerivedProperty\n\tCtElement getParent() throws ParentNotInitializedException;\n\n\t/**\n\t * Gets the first parent that matches the given type.\n\t */\n\t<P extends CtElement> P getParent(Class<P> parentType) throws ParentNotInitializedException;\n\n\t/**\n\t * Gets the first parent that matches the filter.\n\t * If the receiver (this) matches the filter, it is also returned\n\t */\n\t<E extends CtElement> E getParent(Filter<E> filter) throws ParentNotInitializedException;\n\n\t/**\n\t * Manually sets the parent element of the current element.\n\t *\n\t * @param parent\n\t * \t\tparent reference.\n\t */\n\t<E extends CtElement> E setParent(E parent);\n\n\t/**\n\t * Tells if this parent has been initialized.\n\t */\n\tboolean isParentInitialized();\n\n\t/**\n\t * Tells if the given element is a direct or indirect parent.\n\t */\n\tboolean hasParent(CtElement candidate);\n\n\t/**\n\t * Calculates and sets all the parents below this element. This function can\n\t * be called to check and fix parents after manipulating the model.\n\t */\n\tvoid updateAllParentsBelow();\n\n\t/**\n\t * @return the {@link CtRole} of the parent's attribute where this element is used.\n\t * It returns the primary role. For example ((CtMethod) method).getRoleInParent() returns {@link CtRole#TYPE_MEMBER}.\n\t * <br>\n\t * Returns null if parent doesn't contain this element as direct children or if this element has no parent.\n\t */\n\tCtRole getRoleInParent();\n\n\t/**\n\t * Deletes the element. For instance, delete a statement from its containing block. Warning: it may result in an incorrect AST, use at your own risk.\n\t */\n\tvoid delete();\n\n\t/**\n\t * Saves a bunch of metadata inside an Element\n\t */\n\t<E extends CtElement> E setAllMetadata(Map<String, Object> metadata);\n\n\t/**\n\t * Saves metadata inside an Element.\n\t */\n\t<E extends CtElement> E putMetadata(String key, Object val);\n\n\t/**\n\t * Retrieves metadata stored in an element. Returns null if it does not exist.\n\t */\n\tObject getMetadata(String key);\n\n\t/**\n\t * Retrieves all metadata stored in an element.\n\t */\n\tMap<String, Object> getAllMetadata();\n\n\t/**\n\t * Returns the metadata keys stored in an element.\n\t */\n\tSet<String> getMetadataKeys();\n\n\t/**\n\t * Set the comment list\n\t */\n\t@PropertySetter(role = COMMENT)\n\t<E extends CtElement> E setComments(List<CtComment> comments);\n\n\t/**\n\t * The list of comments\n\t * @return the list of comment\n\t */\n\t@PropertyGetter(role = COMMENT)\n\tList<CtComment> getComments();\n\n\t/**\n\t * Add a comment to the current element\n\t * <code>element.addComment(element.getFactory().Code().createComment(\"comment\", CtComment.CommentType.INLINE)</code>\n\t * @param comment the comment\n\t */\n\t@PropertySetter(role = COMMENT)\n\t<E extends CtElement> E addComment(CtComment comment);\n\n\t/**\n\t * Remove a comment\n\t * @param comment the comment to remove\n\t */\n\t@PropertySetter(role = COMMENT)\n\t<E extends CtElement> E removeComment(CtComment comment);\n\n\t/**\n\t * Clone the element which calls this method in a new object.\n\t *\n\t * Note that that references are kept as is, and thus, so if you clone whole classes\n\t * or methods, some parts of the cloned element (eg executable references) may still point to the initial element.\n\t * In this case, consider using methods {@link spoon.refactoring.Refactoring#copyType(CtType)} and {@link spoon.refactoring.Refactoring#copyMethod(CtMethod)} instead which does additional work beyond cloning.\n\t */\n\tCtElement clone();\n\n\t/**\n\t * @return a a single value (eg a CtElement), List, Set or Map depending on this `element` and `role`. Returned collections are read-only.\n\t * @param role the role of the returned attribute with respect to this element.\n\t *\n\t * For instance, \"klass.getValueByRole(CtRole.METHOD)\" returns a list of methods.\n\t *\n\t * See {@link spoon.reflect.meta.impl.RoleHandlerHelper} for more advanced methods.\n\t */\n\t<T> T getValueByRole(CtRole role);\n\n\t/**\n\t * Sets a field according to a role.\n\t * @param role the role of the field to be set\n\t * @param value to be assigned to this field.\n\t */\n\t<E extends CtElement, T> E  setValueByRole(CtRole role, T value);\n\n\t/**\n\t * Return the path from the model root to this CtElement, eg `.spoon.test.path.Foo.foo#body#statement[index=0]`\n\t */\n\tCtPath getPath();\n\n\t/**\n\t * Returns an iterator over this CtElement's descendants.\n\t * @return An iterator over this CtElement's descendants.\n\t */\n\tIterator<CtElement> descendantIterator();\n\n\t/**\n\t * Returns an Iterable instance of this CtElement, allowing for dfs traversal of its descendants.\n\t * @return an Iterable object that allows iterating through this CtElement's descendants.\n\t */\n\tIterable<CtElement> asIterable();\n\n\t/**\n\t * @return a list of CtElement containing the element's direct children.\n\t */\n\tList<CtElement> getDirectChildren();\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtEnumValue.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.support.UnsettableProperty;\n\n/**\n * Corresponds to one enum value specified in an enumeration.\n * If the enum value implicitly calls a constructor (see example below),\n * it is stored in the default expression of the field as CtConstructorCall,\n *\n * <pre>\n *     class enum {\n *         ENUM_VALUE(\"default expression.\");\n *     }\n * </pre>\n *\n * @param <T>\n * \t\tthe type of the enum, hence equal to the type of getParent().\n */\npublic interface CtEnumValue<T> extends CtField<T> {\n\t@Override\n\tCtEnumValue clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<U extends CtRHSReceiver<T>> U setAssignment(CtExpression<T> assignment);\n}\n"
    }, {
      "name" : "reflect/declaration/CtNamedElement.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.NAME;\n\n/**\n * Declares an element that has a name (a class, a method, a variable, etc).\n * Hence, all subclasses of CtNamedElement are in package \"declaration\".\n * Note that references don't define elements, hence are not under CtNamedElement\n * even if they also have methods set/getSimpleName.\n */\npublic interface CtNamedElement extends CtElement {\n\t/**\n\t * Returns the simple (unqualified) name of this element.\n\t */\n\t@PropertyGetter(role = NAME)\n\tString getSimpleName();\n\n\t/**\n\t * Sets the simple (unqualified) name of this element.\n\t */\n\t@PropertySetter(role = NAME)\n\t<T extends CtNamedElement> T setSimpleName(String simpleName);\n\n\t/**\n\t * Returns the corresponding reference.\n\t */\n\t@DerivedProperty\n\tCtReference getReference();\n\n\t@Override\n\tCtNamedElement clone();\n}\n"
    }, {
      "name" : "reflect/declaration/CtTypedElement.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.TYPE;\n\n/**\n * This abstract element defines a typed element.\n */\npublic interface CtTypedElement<T> extends CtElement {\n\t/**\n\t * Gets this element's type.\n\t */\n\t@PropertyGetter(role = TYPE)\n\tCtTypeReference<T> getType();\n\n\t/**\n\t * Sets this element's type.\n\t */\n\t@PropertySetter(role = TYPE)\n\t<C extends CtTypedElement> C setType(CtTypeReference<T> type);\n}\n"
    }, {
      "name" : "reflect/declaration/CtMultiTypedElement.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.MULTI_TYPE;\n\n/**\n * Defined an element with several types.\n */\npublic interface CtMultiTypedElement extends CtElement {\n\t/**\n\t * Adds a type for the element.\n\t */\n\t@PropertySetter(role = MULTI_TYPE)\n\t<T extends CtMultiTypedElement> T addMultiType(CtTypeReference<?> ref);\n\n\t/**\n\t * Removes a type for the element.\n\t */\n\t@PropertySetter(role = MULTI_TYPE)\n\tboolean removeMultiType(CtTypeReference<?> ref);\n\n\t/**\n\t * Gets all types of the element.\n\t */\n\t@PropertyGetter(role = MULTI_TYPE)\n\tList<CtTypeReference<?>> getMultiTypes();\n\n\t/**\n\t * Adds a type for the element.\n\t */\n\t@PropertySetter(role = MULTI_TYPE)\n\t<T extends CtMultiTypedElement> T setMultiTypes(List<CtTypeReference<?>> types);\n}\n"
    }, {
      "name" : "reflect/declaration/CtAnnotation.java",
      "weight" : 99.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.DerivedProperty;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.UnsettableProperty;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\nimport java.util.Map;\n\nimport static spoon.reflect.path.CtRole.ANNOTATION_TYPE;\nimport static spoon.reflect.path.CtRole.VALUE;\n\n/**\n * This element represents an annotation on an element.\n *\n * <pre>\n *     // statement annotated by annotation @SuppressWarnings\n *     &#64;SuppressWarnings(\"unchecked\")\n *     java.util.List&lt;?&gt; x = new java.util.ArrayList&lt;&gt;()\n * </pre>\n * @param <A>\n * \t\ttype of represented annotation\n */\npublic interface CtAnnotation<A extends Annotation> extends CtExpression<A>, CtShadowable {\n\n\t/**\n\t * Returns the actual annotation (a dynamic proxy for this element).\n\t *\n\t * <p>\n\t * NOTE: before using an annotation proxy, you have to make sure that all\n\t * the types referenced by the annotation have been compiled and are in the\n\t * classpath so that accessed values can be converted into the actual types.\n\t */\n\t@DerivedProperty\n\tA getActualAnnotation();\n\n\t/**\n\t * Returns the annotation type of this annotation.\n\t *\n\t * @return a reference to the type of this annotation\n\t */\n\t@PropertyGetter(role = ANNOTATION_TYPE)\n\tCtTypeReference<A> getAnnotationType();\n\n\t/**\n\t * Gets a value, as a CtExpression, for a given key without any conversion.\n\t *\n\t * If you need the actual value (eg an integer and not a literal, see {@link #getValueAsObject(String)} and similar methods.\n\t *\n\t * Note that this value type does not necessarily corresponds to the annotation\n\t * type member. For example, in case the annotation type expect an array of Object,\n\t * and a single value is given, Spoon will return only the object without the CtNewArray.\n\t * If you want to get a type closer to the annotation type one, see {@link #getWrappedValue(String)}.\n\t *\n\t * @param key\n\t * \t\tName of searched value.\n\t * @return the value expression or null if not found.\n\t */\n\t@PropertyGetter(role = VALUE)\n\t<T extends CtExpression> T getValue(String key);\n\n\t/** Returns the actual value of an annotation property */\n\t@DerivedProperty\n\tObject getValueAsObject(String key);\n\n\t/** Returns the actual value of an annotation property, as an integer (utility method) */\n\t@DerivedProperty\n\tint getValueAsInt(String key);\n\n\t/** Returns the actual value of an annotation property, as a String (utility method) */\n\t@DerivedProperty\n\tString getValueAsString(String key);\n\n\t/**\n\t * Gets a value for a given key and try to fix its type based on the\n\t * annotation type. For example, if the annotation type member expects an array of String,\n\t * and it can be resolved, this method will return a CtNewArray instead of a CtLiteral.\n\t *\n\t * Warning: the returned element might be detached from the model\n\t *\n\t * @param key\n\t * \t\tName of searched value.\n\t * @return the value expression or null if not found.\n\t */\n\t@DerivedProperty\n\t@PropertyGetter(role = VALUE)\n\t<T extends CtExpression> T getWrappedValue(String key);\n\n\t/**\n\t * Returns this annotation's elements and their values. This is returned in\n\t * the form of a map that associates element names with their corresponding\n\t * values. If you iterate over the map with entrySet(), the iteration order\n\t * complies with the order of annotation values in the source code.\n\t *\n\t * @return this annotation's element names and their values, or an empty map\n\t * if there are none\n\t */\n\t@PropertyGetter(role = VALUE)\n\tMap<String, CtExpression> getValues();\n\n\t/** Get all values of {@link #getValues()}, plus the default ones defined in the annotation type. */\n\t@DerivedProperty\n\tMap<String, CtExpression> getAllValues();\n\n\t/**\n\t * Sets the annotation's type.\n\t *\n\t * @param type\n\t * \t\treference to the type of this annotation\n\t */\n\t@PropertySetter(role = ANNOTATION_TYPE)\n\t<T extends CtAnnotation<A>> T setAnnotationType(CtTypeReference<? extends Annotation> type);\n\n\t/**\n\t * Set's this annotation's element names and their values. This is in the\n\t * form of a map that associates element names with their corresponding\n\t * values. Note that type values are stored as\n\t * {@link spoon.reflect.reference.CtTypeReference}.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T setElementValues(Map<String, Object> values);\n\n\t/**\n\t * Set's this annotation's element names and their values. This is in the\n\t * form of a map that associates element names with their corresponding\n\t * values.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T setValues(Map<String, CtExpression> values);\n\n\t/**\n\t * Returns the element which is annotated by this annotation.\n\t *\n\t * @return annotated {@link spoon.reflect.declaration.CtElement}\n\t */\n\t@DerivedProperty // the annotation is contained by the element not the other way around\n\tCtElement getAnnotatedElement();\n\n\t/**\n\t * Returns the type of the element which is annotated by this annotation.\n\t *\n\t * @return {@link spoon.reflect.declaration.CtAnnotatedElementType}\n\t */\n\t@DerivedProperty\n\tCtAnnotatedElementType getAnnotatedElementType();\n\n\t/**\n\t * Adds a new key-value pair for this annotation\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T addValue(String elementName, Object value);\n\n\t/**\n\t * Adds a new key-literal pair for this annotation.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T addValue(String elementName, CtLiteral<?> value);\n\n\t/**\n\t * Adds a new key-array pair for this annotation.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T addValue(String elementName, CtNewArray<? extends CtExpression> value);\n\n\t/**\n\t * Adds a new key-field access pair for this annotation.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T addValue(String elementName, CtFieldAccess<?> value);\n\n\t/**\n\t * Adds a new key-annotation pair for this annotation.\n\t */\n\t@PropertySetter(role = VALUE)\n\t<T extends CtAnnotation<A>> T addValue(String elementName, CtAnnotation<?> value);\n\n\t@Override\n\tCtAnnotation<A> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtExpression<A>> C setTypeCasts(List<CtTypeReference<?>> types);\n\n\tstatic CtAnnotatedElementType getAnnotatedElementTypeForCtElement(CtElement element) {\n\t\tif (element == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (element instanceof CtMethod) {\n\t\t\treturn CtAnnotatedElementType.METHOD;\n\t\t}\n\t\tif (element instanceof CtAnnotation || element instanceof CtAnnotationType) {\n\t\t\treturn CtAnnotatedElementType.ANNOTATION_TYPE;\n\t\t}\n\t\tif (element instanceof CtType) {\n\t\t\treturn CtAnnotatedElementType.TYPE;\n\t\t}\n\t\tif (element instanceof CtField) {\n\t\t\treturn CtAnnotatedElementType.FIELD;\n\t\t}\n\t\tif (element instanceof CtConstructor) {\n\t\t\treturn CtAnnotatedElementType.CONSTRUCTOR;\n\t\t}\n\t\tif (element instanceof CtParameter) {\n\t\t\treturn CtAnnotatedElementType.PARAMETER;\n\t\t}\n\t\tif (element instanceof CtLocalVariable) {\n\t\t\treturn CtAnnotatedElementType.LOCAL_VARIABLE;\n\t\t}\n\t\tif (element instanceof CtPackage) {\n\t\t\treturn CtAnnotatedElementType.PACKAGE;\n\t\t}\n\t\tif (element instanceof CtTypeParameterReference) {\n\t\t\treturn CtAnnotatedElementType.TYPE_PARAMETER;\n\t\t}\n\t\tif (element instanceof CtTypeReference) {\n\t\t\treturn CtAnnotatedElementType.TYPE_USE;\n\t\t}\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "reflect/declaration/ParentNotInitializedException.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.SpoonException;\n\n/**\n * This exception is thrown when the parent of an element has not been correctly\n * initialized.\n *\n * @author Renaud Pawlak\n * @see CtElement#setParent(CtElement)\n * @see CtElement#getParent()\n * @see CtElement#updateAllParentsBelow()\n */\npublic class ParentNotInitializedException extends SpoonException {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic ParentNotInitializedException(String message) {\n\t\tsuper(message);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtModuleDirective.java",
      "weight" : 3.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\n/**\n * Represents a directive of a {@link CtModule}\n *\n * The directives of a module declaration specify the module's dependences on other modules {@link CtModuleRequirement},\n * the packages it makes available to other modules {@link CtPackageExport},\n * the services it consumes {@link CtUsedService},\n * and the services it provides {@link CtProvidedService}.\n */\npublic interface CtModuleDirective extends CtElement {\n\n\n}\n"
    }, {
      "name" : "reflect/declaration/CtAnnotationMethod.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.DEFAULT_EXPRESSION;\n\n/**\n * This element defines an annotation method declared in an annotation type.\n */\npublic interface CtAnnotationMethod<T> extends CtMethod<T> {\n\t/**\n\t * Gets the default expression assigned to the annotation method.\n\t */\n\t@PropertyGetter(role = DEFAULT_EXPRESSION)\n\tCtExpression<T> getDefaultExpression();\n\n\t/**\n\t * Sets the default expression assigned to the annotation method.\n\t */\n\t@PropertySetter(role = DEFAULT_EXPRESSION)\n\t<C extends CtAnnotationMethod<T>> C setDefaultExpression(CtExpression<T> assignedExpression);\n\n\t@Override\n\tCtAnnotationMethod<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<T1 extends CtBodyHolder> T1 setBody(CtStatement body);\n\n\t@Override\n\t@UnsettableProperty\n\t<T1 extends CtExecutable<T>> T1 setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes);\n\n\t@Override\n\t@UnsettableProperty\n\t<T extends CtFormalTypeDeclarer> T setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters);\n\n\t@Override\n\t@UnsettableProperty\n\t<T1 extends CtExecutable<T>> T1 setParameters(List<CtParameter<?>> parameters);\n}\n"
    }, {
      "name" : "reflect/declaration/CtInterface.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.UnsettableProperty;\n\n/**\n * This element defines an interface declaration.\n */\npublic interface CtInterface<T> extends CtType<T> {\n\t@Override\n\tCtInterface<T> clone();\n\n\t@Override\n\t@UnsettableProperty\n\t<C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass);\n}\n"
    }, {
      "name" : "reflect/declaration/CtCodeSnippet.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\nimport spoon.reflect.annotations.PropertyGetter;\nimport spoon.reflect.annotations.PropertySetter;\n\nimport static spoon.reflect.path.CtRole.SNIPPET;\n\n/**\n * This interface represents snippets of source code that can be used in the AST\n * to represent complex code without having to build the corresponding program\n * model structure. It is mainly provided on simplification purpose in order to\n * avoid having to build the program's model. Code snippets should be compiled\n * to validate their contents and the result of the compilation should be used\n * to replace the code snippet in the final AST.\n *\n * @see CtType#compileAndReplaceSnippets()\n */\npublic interface CtCodeSnippet {\n\n\t/**\n\t * Sets the textual value of the code.\n\t */\n\t@PropertySetter(role = SNIPPET)\n\t<C extends CtCodeSnippet> C setValue(String value);\n\n\t/**\n\t * Gets the textual value of the code.\n\t */\n\t@PropertyGetter(role = SNIPPET)\n\tString getValue();\n\n}\n"
    }, {
      "name" : "reflect/declaration/ModifierKind.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.declaration;\n\n/**\n * Represents a modifier on the declaration of a program element such as a\n * class, method, or field.\n *\n * The order is important, because it is always pretty--printed is this order, enabling to have a JLS-compliant,\n * checkstyle compliant generated code (thanks to EnumSet used for modifiers).\n */\n\npublic enum ModifierKind {\n\n\t/**\n\t * The modifier <tt>public</tt>\n\t */\n\tPUBLIC,\n\t/**\n\t * The modifier <tt>protected</tt>\n\t */\n\tPROTECTED,\n\t/**\n\t * The modifier <tt>private</tt>\n\t */\n\tPRIVATE,\n\t/**\n\t * The modifier <tt>abstract</tt>\n\t */\n\tABSTRACT,\n\t/**\n\t * The modifier <tt>static</tt>\n\t */\n\tSTATIC,\n\t/**\n\t * The modifier <tt>final</tt>\n\t */\n\tFINAL,\n\t/**\n\t * The modifier <tt>transient</tt>\n\t */\n\tTRANSIENT,\n\t/**\n\t * The modifier <tt>volatile</tt>\n\t */\n\tVOLATILE,\n\t/**\n\t * The modifier <tt>synchronized</tt>\n\t */\n\tSYNCHRONIZED,\n\t/**\n\t * The modifier <tt>native</tt>\n\t */\n\tNATIVE,\n\t/**\n\t * The modifier <tt>strictfp</tt>\n\t */\n\tSTRICTFP;\n\n\tprivate String lowercase = null; // modifier name in lowercase\n\n\t/**\n\t * Returns this modifier's name in lowercase.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tif (lowercase == null) {\n\t\t\tlowercase = name().toLowerCase(java.util.Locale.US);\n\t\t}\n\t\treturn lowercase;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/CtImportVisitor.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\n/**\n * This interface defines the visitor for the different types of CtImport\n */\npublic interface CtImportVisitor {\n\t/**\n\t * Called for import like:\n\t * <code>import apackage.Type;</code>\n\t */\n\t<T> void visitTypeImport(CtTypeReference<T> typeReference);\n\t/**\n\t * Called for import like:\n\t * <code>import apackage.Type.staticMethod;</code>\n\t */\n\t<T> void visitMethodImport(CtExecutableReference<T> executableReference);\n\t/**\n\t * Called for import like:\n\t * <code>import apackage.Type.staticField;</code>\n\t */\n\t<T> void visitFieldImport(CtFieldReference<T> fieldReference);\n\t/**\n\t * Called for import like:\n\t * <code>import apackage.*;</code>\n\t */\n\tvoid visitAllTypesImport(CtPackageReference packageReference);\n\t/**\n\t * Called for import like:\n\t * <code>import apackage.Type.*;</code>\n\t */\n\t<T> void visitAllStaticMembersImport(CtTypeMemberWildcardImportReference typeReference);\n}\n"
    }, {
      "name" : "reflect/visitor/NameScopeImpl.java",
      "weight" : 63.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtParameter;\n\n/**\n * Maps names to CtElements, which are visible at current scanning place\n */\nclass NameScopeImpl implements LexicalScope {\n\n\tprivate final LexicalScope parent;\n\tprivate final CtElement scopeElement;\n\n\tpublic Map<String, CtNamedElement> getElementsByName() {\n\t\treturn elementsByName;\n\t}\n\n\tprivate final Map<String, CtNamedElement> elementsByName = new HashMap<>();\n\n\tNameScopeImpl(LexicalScope parent, CtElement scopeElement, List<CtParameter<?>> parameters) {\n\t\tthis(parent, scopeElement);\n\t\tfor (CtParameter<?> parameter : parameters) {\n\t\t\taddNamedElement(parameter);\n\t\t}\n\t}\n\n\tprotected NameScopeImpl(LexicalScope parent, CtElement scopeElement) {\n\t\tthis.parent = parent;\n\t\tthis.scopeElement = scopeElement;\n\t}\n\n\t@Override\n\tpublic NameScopeImpl addNamedElement(CtNamedElement element) {\n\t\telementsByName.put(element.getSimpleName(), element);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return the {@link CtElement} which represents the current scope\n\t */\n\t@Override\n\tpublic final CtElement getScopeElement() {\n\t\treturn scopeElement;\n\t}\n\n\tpublic final Optional<LexicalScope> getParent() {\n\t\treturn Optional.ofNullable(parent);\n\t}\n\n\t/**\n\t * @param name to be searched simple name\n\t * @param consumer is called for each named element with same name which are accessible from this {@link NameScopeImpl}\n\t * \tas long as there are some elements and consumer returns null. If `consumer` return not null value then it is returned\n\t * @return the value returned by `consumer` or null\n\t */\n\t@Override\n\tpublic <T> T forEachElementByName(String name, Function<? super CtNamedElement, T> consumer) {\n\t\tT r = forEachByName(elementsByName, name, consumer);\n\t\tif (scopeElement instanceof CtNamedElement) {\n\t\t\tCtNamedElement named = (CtNamedElement) scopeElement;\n\t\t\tif (name.equals(named.getSimpleName())) {\n\t\t\t\tr = consumer.apply(named);\n\t\t\t\tif (r != null) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (parent != null) {\n\t\t\treturn parent.forEachElementByName(name, consumer);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected static <T> T forEachByName(Map<String, CtNamedElement> map, String name, Function<? super CtNamedElement, T> consumer) {\n\t\tCtNamedElement named = map.get(name);\n\t\tif (named != null) {\n\t\t\treturn consumer.apply(named);\n\t\t}\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/LexicalScopeScanner.java",
      "weight" : 87.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * A {@link CtScanner} which provides current lexical scope\n * of currently scanned AST node.\n */\npublic class LexicalScopeScanner extends EarlyTerminatingScanner<Object> {\n\tprivate final Deque<LexicalScope> scopes = new ArrayDeque<>();\n\tprotected void enter(spoon.reflect.declaration.CtElement e) {\n\t\tLexicalScope newFinder = onElement(scopes.peek(), e);\n\t\tif (newFinder != null) {\n\t\t\tscopes.push(newFinder);\n\t\t}\n\t}\n\tprotected void exit(spoon.reflect.declaration.CtElement e) {\n\t\tLexicalScope topFinder = scopes.peek();\n\t\tif (topFinder != null && topFinder.getScopeElement() == e) {\n\t\t\t//we are living scope of this ConflictFinder. Pop it\n\t\t\tscopes.pop();\n\t\t}\n\t}\n\tprivate static NameScopeImpl EMPTY = new NameScopeImpl(null, null);\n\t/**\n\t * @return {@link LexicalScope} of actually scanned element. The {@link LexicalScope#forEachElementByName(String, java.util.function.Function)} can be used\n\t * to get all {@link CtElement}s which are mapped to that simple name\n\t */\n\tpublic LexicalScope getCurrentLexicalScope() {\n\t\tLexicalScope ns = scopes.peek();\n\t\treturn ns == null ? EMPTY : ns;\n\t}\n\n\t/**\n\t * Call it for each visited CtElement\n\t * @param parent the parent ConflictFinder\n\t * @param target an element\n\t * @return new {@link NameScopeImpl} if `target` element declares new naming scope or null if there is no new scope\n\t */\n\tprivate NameScopeImpl onElement(LexicalScope parent, CtElement target) {\n\t\tclass Visitor extends CtAbstractVisitor {\n\t\t\tNameScopeImpl finder = null;\n\t\t\t@Override\n\t\t\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\t\t\t\t//compilation unit items are added in TypeNameScope, because they depend on the inhertance hierarchy of the type itself\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\t\t\tfinder = new TypeNameScope(parent, ctClass);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\t\t\t\tfinder = new TypeNameScope(parent, intrface);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum) {\n\t\t\t\tfinder = new TypeNameScope(parent, ctEnum);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <A extends Annotation> void visitCtAnnotationType(CtAnnotationType<A> annotationType) {\n\t\t\t\tfinder = new TypeNameScope(parent, annotationType);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtMethod(CtMethod<T> m) {\n\t\t\t\tfinder = new NameScopeImpl(parent, m, m.getParameters());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtConstructor(CtConstructor<T> c) {\n\t\t\t\tfinder = new NameScopeImpl(parent, c, c.getParameters());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtLambda(CtLambda<T> lambda) {\n\t\t\t\tfinder = new NameScopeImpl(parent, lambda, lambda.getParameters());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void visitCtCatch(CtCatch catchBlock) {\n\t\t\t\tfinder = new NameScopeImpl(parent, catchBlock).addNamedElement(catchBlock.getParameter());\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <R> void visitCtBlock(CtBlock<R> block) {\n\t\t\t\tfinder = new NameScopeImpl(parent, block);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\t\t\t\tparent.addNamedElement(localVariable);\n\t\t\t}\n\t\t};\n\t\tVisitor scanner = new Visitor();\n\t\ttarget.accept(scanner);\n\t\treturn scanner.finder;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines visitor, scanner, and scanner-based query API for Java programs reified in the meta-model.</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.visitor;\n"
    }, {
      "name" : "reflect/visitor/CtDequeScanner.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * This class defines a scanner that maintains a scanning stack for contextual\n * awareness.\n */\npublic class CtDequeScanner extends CtScanner {\n\t/**\n\t * Default constructor.\n\t */\n\tpublic CtDequeScanner() {\n\t}\n\n\t/**\n\t * The stack of elements.\n\t */\n\tprotected Deque<CtElement> elementsDeque = new ArrayDeque<>();\n\n\t/**\n\t * Pops the element.\n\t */\n\t@Override\n\tprotected void exit(CtElement e) {\n\t\tCtElement ret = elementsDeque.pop();\n\t\tif (ret != e) {\n\t\t\tthrow new RuntimeException(\"Inconsistent Stack\");\n\t\t}\n\t\tsuper.exit(e);\n\t}\n\n\t/**\n\t * Pushes the element.\n\t */\n\t@Override\n\tprotected void enter(CtElement e) {\n\t\telementsDeque.push(e);\n\t\tsuper.enter(e);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtInheritanceScanner.java",
      "weight" : 787.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtAbstractInvocation;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCFlowBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLabelledFlowBreak;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtLoop;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleDirective;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtMultiTypedElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\n\n/**\n * This class provides an abstract implementation of the visitor that allows its\n * subclasses to scans the metamodel elements by recursively using their\n * (abstract) supertype scanning methods. It declares a scan method for each\n * abstract element of the AST and a visit method for each element of the AST.\n */\npublic abstract class CtInheritanceScanner implements CtVisitor {\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic CtInheritanceScanner() {\n\t}\n\n\tpublic <T> void visitCtCodeSnippetExpression(\n\t\t\tCtCodeSnippetExpression<T> e) {\n\t\tscanCtCodeSnippet(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtCodeSnippetStatement(CtCodeSnippetStatement e) {\n\t\tscanCtCodeSnippet(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\t/**\n\t * Generically scans a collection of meta-model elements.\n\t */\n\tpublic void scan(Collection<? extends CtElement> elements) {\n\t\tif (elements != null) {\n\t\t\tfor (CtElement e : elements) {\n\t\t\t\tscan(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generically scans a meta-model element.\n\t */\n\tpublic void scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\telement.accept(this);\n\t\t}\n\t}\n\n\t/**\n\t * Scans an abstract invocation.\n\t */\n\tpublic <T> void scanCtAbstractInvocation(CtAbstractInvocation<T> a) {\n\t}\n\n\t/**\n\t * Scans an abstract control flow break.\n\t */\n\tpublic void scanCtCFlowBreak(CtCFlowBreak flowBreak) {\n\t}\n\n\t/**\n\t * Scans a labelled control flow break.\n\t */\n\tpublic void scanCtLabelledFlowBreak(CtLabelledFlowBreak labelledFlowBreak) {\n\t}\n\n\t/**\n\t * Scans an abstract code element.\n\t */\n\tpublic void scanCtCodeElement(CtCodeElement e) {\n\n\t}\n\n\tpublic void scanCtTypeMember(CtTypeMember e) {\n\t}\n\n\tpublic void scanCtModuleDirective(CtModuleDirective e) {\n\n\t}\n\n\t/**\n\t * Scans an abstract element.\n\t */\n\tpublic void scanCtElement(CtElement e) {\n\t}\n\n\t/**\n\t * Scans an abstract executable.\n\t */\n\tpublic <R> void scanCtExecutable(CtExecutable<R> e) {\n\t}\n\n\t/**\n\t * Scans an abstract expression.\n\t */\n\tpublic <T> void scanCtExpression(CtExpression<T> expression) {\n\t}\n\n\t/**\n\t * Scans a formal type declarer.\n\t */\n\tpublic void scanCtFormalTypeDeclarer(CtFormalTypeDeclarer e) {\n\n\t}\n\n\tpublic void scanCtVisitable(CtVisitable e) {\n\n\t}\n\n\t/**\n\t * Scans an actual type container..\n\t */\n\tpublic void scanCtActualTypeContainer(CtActualTypeContainer reference) {\n\t}\n\n\t/**\n\t * Scans an abstract loop.\n\t */\n\tpublic void scanCtLoop(CtLoop loop) {\n\n\t}\n\n\t/**\n\t * Scans an abstract modifiable element.\n\t */\n\tpublic void scanCtModifiable(CtModifiable m) {\n\n\t}\n\n\t/**\n\t * Scans an abstract named element.\n\t */\n\tpublic void scanCtNamedElement(CtNamedElement e) {\n\t}\n\n\t/**\n\t * Scans an abstract reference.\n\t */\n\tpublic void scanCtReference(CtReference reference) {\n\n\t}\n\n\t/**\n\t * Scans an abstract statement.\n\t */\n\tpublic void scanCtStatement(CtStatement s) {\n\t}\n\n\t/**\n\t * Scans an abstract targeted expression.\n\t */\n\tpublic <T, E extends CtExpression<?>> void scanCtTargetedExpression(\n\t\t\tCtTargetedExpression<T, E> targetedExpression) {\n\t}\n\n\t/**\n\t * Scans an abstract type.\n\t */\n\tpublic <T> void scanCtType(CtType<T> type) {\n\t}\n\n\t/**\n\t * Scans an abstract typed element.\n\t */\n\tpublic <T> void scanCtTypedElement(CtTypedElement<T> e) {\n\t}\n\n\t/**\n\t * Scans an abstract variable declaration.\n\t */\n\tpublic <T> void scanCtVariable(CtVariable<T> v) {\n\t}\n\n\n\t/**\n\t * Scans an array access (read and write).\n\t */\n\tpublic <T, E extends CtExpression<?>> void scanCtArrayAccess(CtArrayAccess<T, E> arrayAccess) {\n\t}\n\n\t/**\n\t * Scans a field access (read and write).\n\t */\n\tpublic <T> void scanCtFieldAccess(CtFieldAccess<T> fieldAccess) {\n\t}\n\n\t/**\n\t * Scans a variable access (read and write).\n\t */\n\tpublic <T> void scanCtVariableAccess(CtVariableAccess<T> variableAccess) {\n\t}\n\n\t/**\n\t * Scans the right-hand side of an assignment\n\t */\n\tpublic <T> void scanCtRHSReceiver(CtRHSReceiver<T> ctRHSReceiver) {\n\t}\n\n\t/**\n\t * Scans a shadowable element\n\t */\n\tpublic void scanCtShadowable(CtShadowable ctShadowable) {\n\t}\n\n\t/**\n\t * Scans a body holder\n\t */\n\tpublic void scanCtBodyHolder(CtBodyHolder ctBodyHolder) {\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\tvisitCtVariableRead(fieldRead);\n\t\tscanCtFieldAccess(fieldRead);\n\t\tscanCtTargetedExpression(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {\n\t\tvisitCtVariableWrite(fieldWrite);\n\t\tscanCtFieldAccess(fieldWrite);\n\t\tscanCtTargetedExpression(fieldWrite);\n\t}\n\n\tpublic <T> void visitCtSuperAccess(CtSuperAccess<T> f) {\n\t\tvisitCtVariableRead(f);\n\t\tscanCtTargetedExpression(f);\n\t}\n\n\tpublic void scanCtMultiTypedElement(CtMultiTypedElement f) {\n\t}\n\n\tpublic <T, A extends T> void visitCtOperatorAssignment(\n\t\t\tCtOperatorAssignment<T, A> e) {\n\t\tvisitCtAssignment(e);\n\t}\n\n\t/**\n\t * Scans an abstract variable reference.\n\t */\n\tpublic <T> void scanCtVariableReference(CtVariableReference<T> reference) {\n\t}\n\n\t/**\n\t * Scans an abstract variable reference.\n\t */\n\tpublic <T> void scanCtTypeInformation(CtTypeInformation typeInfo) {\n\t}\n\n\tpublic <A extends Annotation> void visitCtAnnotation(\n\t\t\tCtAnnotation<A> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\tpublic <A extends Annotation> void visitCtAnnotationType(CtAnnotationType<A> e) {\n\t\tscanCtType(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypeInformation(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtFormalTypeDeclarer(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\tpublic void visitCtAnonymousExecutable(CtAnonymousExecutable e) {\n\t\tscanCtExecutable(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayRead(CtArrayRead<T> arrayRead) {\n\t\tscanCtArrayAccess(arrayRead);\n\t\tscanCtTargetedExpression(arrayRead);\n\t\tscanCtExpression(arrayRead);\n\t\tscanCtCodeElement(arrayRead);\n\t\tscanCtTypedElement(arrayRead);\n\t\tscanCtElement(arrayRead);\n\t\tscanCtVisitable(arrayRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayWrite(CtArrayWrite<T> arrayWrite) {\n\t\tscanCtArrayAccess(arrayWrite);\n\t\tscanCtTargetedExpression(arrayWrite);\n\t\tscanCtExpression(arrayWrite);\n\t\tscanCtCodeElement(arrayWrite);\n\t\tscanCtTypedElement(arrayWrite);\n\t\tscanCtElement(arrayWrite);\n\t\tscanCtVisitable(arrayWrite);\n\t}\n\n\tpublic <T> void visitCtArrayTypeReference(CtArrayTypeReference<T> e) {\n\t\tvisitCtTypeReference(e);\n\t}\n\n\tpublic <T> void visitCtAssert(CtAssert<T> e) {\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T, A extends T> void visitCtAssignment(\n\t\t\tCtAssignment<T, A> e) {\n\t\tscanCtStatement(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtRHSReceiver(e);\n\t}\n\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <R> void visitCtBlock(CtBlock<R> e) {\n\t\tscanCtStatement(e);\n\t\tvisitCtStatementList(e);\n\t}\n\n\tpublic void visitCtBreak(CtBreak e) {\n\t\tscanCtLabelledFlowBreak(e);\n\t\tscanCtCFlowBreak(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <E> void visitCtCase(CtCase<E> e) {\n\t\tscanCtStatement(e);\n\t\tvisitCtStatementList(e);\n\t}\n\n\tpublic void visitCtCatch(CtCatch e) {\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic <T> void visitCtClass(CtClass<T> e) {\n\t\tscanCtType(e);\n\t\tscanCtStatement(e);\n\t\tscanCtTypeInformation(e);\n\t\tscanCtFormalTypeDeclarer(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtElement(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameter(CtTypeParameter typeParameter) {\n\t\tscanCtType(typeParameter);\n\t\tscanCtTypeInformation(typeParameter);\n\t\tscanCtFormalTypeDeclarer(typeParameter);\n\t\tscanCtNamedElement(typeParameter);\n\t\tscanCtTypeMember(typeParameter);\n\t\tscanCtElement(typeParameter);\n\t\tscanCtModifiable(typeParameter);\n\t\tscanCtVisitable(typeParameter);\n\t\tscanCtShadowable(typeParameter);\n\t}\n\n\tpublic <T> void visitCtConditional(CtConditional<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtConstructor(CtConstructor<T> e) {\n\t\tscanCtExecutable(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtFormalTypeDeclarer(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic void visitCtContinue(CtContinue e) {\n\t\tscanCtLabelledFlowBreak(e);\n\t\tscanCtCFlowBreak(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtDo(CtDo e) {\n\t\tscanCtLoop(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> e) {\n\t\tvisitCtClass(e);\n\t}\n\n\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> e) {\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtActualTypeContainer(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtField(CtField<T> e) {\n\t\tscanCtNamedElement(e);\n\t\tscanCtVariable(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtRHSReceiver(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtEnumValue(CtEnumValue<T> enumValue) {\n\t\tvisitCtField(enumValue);\n\t}\n\n\tpublic <T> void visitCtThisAccess(CtThisAccess<T> e) {\n\t\tscanCtTargetedExpression(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtFieldReference(CtFieldReference<T> e) {\n\t\tscanCtVariableReference(e);\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtFor(CtFor e) {\n\t\tscanCtLoop(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic void visitCtForEach(CtForEach e) {\n\t\tscanCtLoop(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic void visitCtIf(CtIf e) {\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtInterface(CtInterface<T> e) {\n\t\tscanCtType(e);\n\t\tscanCtTypeInformation(e);\n\t\tscanCtFormalTypeDeclarer(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtElement(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\tpublic <T> void visitCtInvocation(CtInvocation<T> e) {\n\t\tscanCtAbstractInvocation(e);\n\t\tscanCtStatement(e);\n\t\tscanCtActualTypeContainer(e);\n\t\tscanCtTargetedExpression(e);\n\t\tscanCtElement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtExpression(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtTypedElement(e);\n\t}\n\n\tpublic <T> void visitCtLiteral(CtLiteral<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> e) {\n\t\tscanCtStatement(e);\n\t\tscanCtVariable(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtRHSReceiver(e);\n\t}\n\n\tpublic <T> void visitCtLocalVariableReference(\n\t\t\tCtLocalVariableReference<T> e) {\n\t\tscanCtVariableReference(e);\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> e) {\n\t\tscanCtVariable(e);\n\t\tscanCtMultiTypedElement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtCatchVariableReference(CtCatchVariableReference<T> e) {\n\t\tscanCtVariableReference(e);\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtMethod(CtMethod<T> e) {\n\t\tscanCtExecutable(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtFormalTypeDeclarer(e);\n\t\tscanCtTypeMember(e);\n\t\tscanCtElement(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\t\tvisitCtMethod(annotationMethod);\n\t}\n\n\tpublic <T> void visitCtNewArray(CtNewArray<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructorCall(CtConstructorCall<T> e) {\n\t\tscanCtTargetedExpression(e);\n\t\tscanCtAbstractInvocation(e);\n\t\tscanCtStatement(e);\n\t\tscanCtActualTypeContainer(e);\n\t\tscanCtExpression(e);\n\t\tscanCtElement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtNewClass(CtNewClass<T> e) {\n\t\tvisitCtConstructorCall(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLambda(CtLambda<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtExecutable(e);\n\t\tscanCtNamedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(\n\t\t\tCtExecutableReferenceExpression<T, E> e) {\n\t\tscanCtTargetedExpression(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T, A extends T> void visitCtOperatorAssignement(\n\t\t\tCtOperatorAssignment<T, A> assignment) {\n\t}\n\n\tpublic void visitCtPackage(CtPackage e) {\n\t\tscanCtNamedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\tpublic void visitCtPackageReference(CtPackageReference e) {\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtParameter(CtParameter<T> e) {\n\t\tscanCtNamedElement(e);\n\t\tscanCtVariable(e);\n\t\tscanCtModifiable(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\tpublic <T> void visitCtParameterReference(CtParameterReference<T> e) {\n\t\tscanCtVariableReference(e);\n\t\tscanCtReference(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <R> void visitCtReturn(CtReturn<R> e) {\n\t\tscanCtCFlowBreak(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <R> void visitCtStatementList(CtStatementList e) {\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <E> void visitCtSwitch(CtSwitch<E> e) {\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtSynchronized(CtSynchronized e) {\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtThrow(CtThrow e) {\n\t\tscanCtCFlowBreak(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic void visitCtTry(CtTry e) {\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\t@Override\n\tpublic void visitCtTryWithResource(CtTryWithResource e) {\n\t\tvisitCtTry(e);\n\t}\n\n\tpublic void visitCtTypeParameterReference(CtTypeParameterReference e) {\n\t\tvisitCtTypeReference(e);\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference wildcardReference) {\n\t\tvisitCtTypeParameterReference(wildcardReference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> e) {\n\t\tvisitCtTypeReference(e);\n\t}\n\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> e) {\n\t\tscanCtReference(e);\n\t\tscanCtTypeInformation(e);\n\t\tscanCtActualTypeContainer(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtShadowable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeAccess(CtTypeAccess<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> e) {\n\t\tscanCtExpression(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableRead(CtVariableRead<T> e) {\n\t\tscanCtVariableAccess(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableWrite(CtVariableWrite<T> e) {\n\t\tscanCtVariableAccess(e);\n\t\tscanCtExpression(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtTypedElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\t@Override\n\tpublic void visitCtComment(CtComment e) {\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDoc(CtJavaDoc e) {\n\t\tvisitCtComment(e);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDocTag(CtJavaDocTag e) {\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t}\n\n\tpublic <T> void visitCtAnnotationFieldAccess(\n\t\t\tCtAnnotationFieldAccess<T> e) {\n\t\tvisitCtVariableRead(e);\n\t\tscanCtTargetedExpression(e);\n\t}\n\n\tpublic void visitCtWhile(CtWhile e) {\n\t\tscanCtLoop(e);\n\t\tscanCtStatement(e);\n\t\tscanCtCodeElement(e);\n\t\tscanCtElement(e);\n\t\tscanCtVisitable(e);\n\t\tscanCtBodyHolder(e);\n\t}\n\n\tpublic <T> void visitCtUnboundVariableReference(CtUnboundVariableReference<T> reference) {\n\t\tscanCtVariableReference(reference);\n\t\tscanCtReference(reference);\n\t\tscanCtElement(reference);\n\t\tscanCtVisitable(reference);\n\t}\n\n\tpublic void scanCtCodeSnippet(CtCodeSnippet snippet) {\n\t}\n\n\t@Override\n\tpublic void visitCtImport(CtImport ctImport) {\n\t\tscanCtElement(ctImport);\n\t\tscanCtVisitable(ctImport);\n\t}\n\n\t@Override\n\tpublic void visitCtModule(CtModule module) {\n\t\tscanCtNamedElement(module);\n\t\tscanCtVisitable(module);\n\t\tscanCtElement(module);\n\t}\n\n\t@Override\n\tpublic void visitCtModuleReference(CtModuleReference moduleReference) {\n\t\tscanCtReference(moduleReference);\n\t\tscanCtElement(moduleReference);\n\t\tscanCtVisitable(moduleReference);\n\t}\n\n\t@Override\n\tpublic void visitCtPackageExport(CtPackageExport moduleExport) {\n\t\tscanCtElement(moduleExport);\n\t\tscanCtVisitable(moduleExport);\n\t\tscanCtModuleDirective(moduleExport);\n\t}\n\n\t@Override\n\tpublic void visitCtModuleRequirement(CtModuleRequirement moduleRequirement) {\n\t\tscanCtElement(moduleRequirement);\n\t\tscanCtVisitable(moduleRequirement);\n\t\tscanCtModuleDirective(moduleRequirement);\n\t}\n\n\t@Override\n\tpublic void visitCtProvidedService(CtProvidedService moduleProvidedService) {\n\t\tscanCtElement(moduleProvidedService);\n\t\tscanCtVisitable(moduleProvidedService);\n\t\tscanCtModuleDirective(moduleProvidedService);\n\t}\n\n\t@Override\n\tpublic void visitCtUsedService(CtUsedService usedService) {\n\t\tscanCtElement(usedService);\n\t\tscanCtVisitable(usedService);\n\t\tscanCtModuleDirective(usedService);\n\t}\n\n\t@Override\n\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\t\tscanCtElement(compilationUnit);\n\t\tscanCtVisitable(compilationUnit);\n\t}\n\n\t@Override\n\tpublic void visitCtPackageDeclaration(CtPackageDeclaration packageDeclaration) {\n\t\tscanCtElement(packageDeclaration);\n\t\tscanCtVisitable(packageDeclaration);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeMemberWildcardImportReference(CtTypeMemberWildcardImportReference wildcardReference) {\n\t\tscanCtReference(wildcardReference);\n\t\tscanCtElement(wildcardReference);\n\t\tscanCtVisitable(wildcardReference);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtAbstractBiScanner.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\n/**\n * Defines the core bi-scan responsibility.\n */\npublic abstract class CtAbstractBiScanner extends CtAbstractVisitor {\n\n\t/** This method is called to compare `element` and `other` when traversing two trees in parallel.*/\n\tpublic abstract void biScan(CtElement element, CtElement other);\n\n\t/** This method is called to compare `element` and `other` according to the role when traversing two trees in parallel. */\n\tpublic abstract void biScan(CtRole role, CtElement element, CtElement other);\n\n}\n"
    }, {
      "name" : "reflect/visitor/TokenWriter.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\n\n/**\n * Responsible for writing a token while pretty-printing.\n * Default is {@link DefaultTokenWriter}, can be provided by client too.\n */\npublic interface TokenWriter {\n\t/**\n\t * Writes one separator. It is -&gt; or :: or one of these characters: (){}[];,.:@=&lt;&gt;?&amp;|\n\t */\n\tTokenWriter writeSeparator(String token);\n\n\t/**\n\t * Writes one operator.\n\t *\t\t=\n\t *\t\t&gt;\n\t *\t\t&lt;\n\t *\t\t!\n\t *\t\t~\n\t *\t\t?\n\t *\t\t:\n\t *\t\t==\n\t *\t\t&lt;=\n\t *\t\t&gt;=\n\t *\t\t!=\n\t *\t\t&amp;&amp;\n\t *\t\t||\n\t *\t\t++\n\t *\t\t--\n\t *\t\t+\n\t *\t\t-\n\t *\t\t*\n\t *\t\t/\n\t *\t\t&amp;\n\t *\t\t|\n\t *\t\t^\n\t *\t\t%\n\t *\t\t&lt;&lt;\n\t *\t\t&gt;&gt;\n\t *\t\t&gt;&gt;&gt;\n\t *\t\t+=\n\t *\t\t-=\n\t *\t\t*=\n\t *\t\t/=\n\t *\t\t&amp;=\n\t *\t\t|=\n\t *\t\t^=\n\t *\t\t%=\n\t *\t\t&lt;&lt;=\n\t *\t\t&gt;&gt;=\n\t *\t\t&gt;&gt;&gt;=\n\t *\t\tinstanceof\n\t */\n\tTokenWriter writeOperator(String token);\n\n\t/**\n\t * writes literal. It can be a String, Character or an number\n\t */\n\tTokenWriter writeLiteral(String token);\n\n\t/**\n\t * writes a keyword\n\t *\t\tabstract continue for new switch\n\t *\t\tassert default goto package synchronized\n\t *\t\tboolean do if private this\n\t *\t\tbreak double implements protected throw\n\t *\t\tbyte else import public throws\n\t *\t\tcase enum instanceof return transient\n\t *\t\tcatch extends int short try\n\t *\t\tchar final interface static void\n\t *\t\tclass finally long strictfp volatile\n\t *\t\tconst float native super while\n\t */\n\tTokenWriter writeKeyword(String token);\n\n\t/**\n\t * writes a java identifier.\n\t */\n\tTokenWriter writeIdentifier(String token);\n\n\t/**\n\t * writes a code snippet - represents arbitrary code of {@link CtCodeSnippetExpression} or {@link CtCodeSnippetStatement}\n\t */\n\tTokenWriter writeCodeSnippet(String token);\n\n\t/**\n\t * writes a comment\n\t */\n\tTokenWriter writeComment(CtComment comment);\n\n\t/**\n\t * writes new line (EOL)\n\t */\n\tTokenWriter writeln();\n\t/**\n\t * increments indentation\n\t */\n\tTokenWriter incTab();\n\t/**\n\t * decrements indentation\n\t */\n\tTokenWriter decTab();\n\n\t/**\n\t * @return {@link PrinterHelper} used by this TokenWriter.\n\t *\n\t * Note that in the future, will return an interface eg IPrinterHelper instead.\n\t */\n\tPrinterHelper getPrinterHelper();\n\n\t/**\n\t * resets to the initial state\n\t */\n\tvoid reset();\n\n\t/**\n\t * Writes a single space.\n\t */\n\tTokenWriter writeSpace();\n}\n"
    }, {
      "name" : "reflect/visitor/CtAbstractImportVisitor.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\n/**\n * Provides an empty implementation of {@link CtImportVisitor}.\n */\npublic class CtAbstractImportVisitor implements CtImportVisitor {\n\n\t@Override\n\tpublic <T> void visitTypeImport(CtTypeReference<T> typeReference) {\n\t}\n\n\t@Override\n\tpublic <T> void visitMethodImport(CtExecutableReference<T> executableReference) {\n\t}\n\n\t@Override\n\tpublic <T> void visitFieldImport(CtFieldReference<T> fieldReference) {\n\t}\n\n\t@Override\n\tpublic void visitAllTypesImport(CtPackageReference packageReference) {\n\t}\n\n\t@Override\n\tpublic <T> void visitAllStaticMembersImport(CtTypeMemberWildcardImportReference typeReference) {\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtVisitor.java",
      "weight" : 173.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * This interface defines the visitor for the Spoon metamodel, as defined in\n * {@link spoon.reflect.declaration}, {@link spoon.reflect.code}, and\n * {@link spoon.reflect.reference}. It declares a visit method for each\n * element of the AST.\n */\npublic interface CtVisitor {\n\t/**\n\t * Visits an annotation.\n\t */\n\t<A extends Annotation> void visitCtAnnotation(CtAnnotation<A> annotation);\n\n\t/**\n\t * Visits a code snippet expression.\n\t */\n\t<T> void visitCtCodeSnippetExpression(CtCodeSnippetExpression<T> expression);\n\n\t/**\n\t * Visits a code snippet statement.\n\t */\n\tvoid visitCtCodeSnippetStatement(CtCodeSnippetStatement statement);\n\n\t/**\n\t * Visits an annotation type declaration.\n\t */\n\t<A extends Annotation> void visitCtAnnotationType(CtAnnotationType<A> annotationType);\n\n\t/**\n\t * Visits an anonymous executable.\n\t */\n\tvoid visitCtAnonymousExecutable(CtAnonymousExecutable anonymousExec);\n\n\t/**\n\t * Visits an array read access.\n\t */\n\t<T> void visitCtArrayRead(CtArrayRead<T> arrayRead);\n\n\t/**\n\t * Visits an array write access.\n\t */\n\t<T> void visitCtArrayWrite(CtArrayWrite<T> arrayWrite);\n\n\t/**\n\t * Visits a reference to an array type.\n\t */\n\t<T> void visitCtArrayTypeReference(CtArrayTypeReference<T> reference);\n\n\t/**\n\t * Visits an assert.\n\t */\n\t<T> void visitCtAssert(CtAssert<T> asserted);\n\n\t/**\n\t * Visits an assignment.\n\t */\n\t<T, A extends T> void visitCtAssignment(CtAssignment<T, A> assignement);\n\n\t/**\n\t * Visits a binary operator.\n\t */\n\t<T> void visitCtBinaryOperator(CtBinaryOperator<T> operator);\n\n\t/**\n\t * Visits a block of code.\n\t */\n\t<R> void visitCtBlock(CtBlock<R> block);\n\n\t/**\n\t * Visits a <code>break</code> statement.\n\t */\n\tvoid visitCtBreak(CtBreak breakStatement);\n\n\t/**\n\t * Visits a <code>case</code> clause.\n\t */\n\t<S> void visitCtCase(CtCase<S> caseStatement);\n\n\t/**\n\t * Visits a <code>catch</code> clause.\n\t */\n\tvoid visitCtCatch(CtCatch catchBlock);\n\n\t/**\n\t * Visits a class declaration.\n\t */\n\t<T> void visitCtClass(CtClass<T> ctClass);\n\n\t/**\n\t * Visits a type parameter declaration.\n\t */\n\tvoid visitCtTypeParameter(CtTypeParameter typeParameter);\n\n\t/**\n\t * Visits a conditional expression\n\t */\n\t<T> void visitCtConditional(CtConditional<T> conditional);\n\n\t/**\n\t * Visits a constructor declaration.\n\t */\n\t<T> void visitCtConstructor(CtConstructor<T> c);\n\n\t/**\n\t * Visits a <code>continue</code> statement.\n\t */\n\tvoid visitCtContinue(CtContinue continueStatement);\n\n\t/**\n\t * Visits a <code>do</code> loop.\n\t */\n\tvoid visitCtDo(CtDo doLoop);\n\n\t/**\n\t * Visits an enumeration declaration.\n\t */\n\t<T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum);\n\n\t/**\n\t * Visits a reference to an executable.\n\t */\n\t<T> void visitCtExecutableReference(CtExecutableReference<T> reference);\n\n\t/**\n\t * Visits a field declaration.\n\t */\n\t<T> void visitCtField(CtField<T> f);\n\n\t/**\n\t * Visits an enum value declaration.\n\t */\n\t<T> void visitCtEnumValue(CtEnumValue<T> enumValue);\n\n\t/**\n\t * Visits a this access.\n\t */\n\t<T> void visitCtThisAccess(CtThisAccess<T> thisAccess);\n\n\t/**\n\t * Visits a reference to a field.\n\t */\n\t<T> void visitCtFieldReference(CtFieldReference<T> reference);\n\n\t/**\n\t * Visits a reference to an unbound field\n\t */\n\t<T> void visitCtUnboundVariableReference(CtUnboundVariableReference<T> reference);\n\n\t/**\n\t * Visits a <code>for</code> loop.\n\t */\n\tvoid visitCtFor(CtFor forLoop);\n\n\t/**\n\t * Visits an enhanced <code>for</code> loop.\n\t */\n\tvoid visitCtForEach(CtForEach foreach);\n\n\t/**\n\t * Visits an <code>if</code> statement.\n\t */\n\tvoid visitCtIf(CtIf ifElement);\n\n\t/**\n\t * Visits an interface declaration.\n\t */\n\t<T> void visitCtInterface(CtInterface<T> intrface);\n\n\t/**\n\t * Visits an executable invocation.\n\t */\n\t<T> void visitCtInvocation(CtInvocation<T> invocation);\n\n\t/**\n\t * Visits a literal expression.\n\t */\n\t<T> void visitCtLiteral(CtLiteral<T> literal);\n\n\t/**\n\t * Visits a local variable declaration.\n\t */\n\t<T> void visitCtLocalVariable(CtLocalVariable<T> localVariable);\n\n\t/**\n\t * Visits a reference to a local variable.\n\t */\n\t<T> void visitCtLocalVariableReference(CtLocalVariableReference<T> reference);\n\n\t/**\n\t * Visits a catch variable declaration.\n\t */\n\t<T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable);\n\n\t/**\n\t * Visits a reference to a catch variable.\n\t */\n\t<T> void visitCtCatchVariableReference(CtCatchVariableReference<T> reference);\n\n\t/**\n\t * Visits a method declaration.\n\t */\n\t<T> void visitCtMethod(CtMethod<T> m);\n\n\t/**\n\t * Visits an annotation method declaration.\n\t */\n\t<T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod);\n\n\t/**\n\t * Visits an array construction.\n\t */\n\t<T> void visitCtNewArray(CtNewArray<T> newArray);\n\n\t/**\n\t * Visits a call to a constructor.\n\t */\n\t<T> void visitCtConstructorCall(CtConstructorCall<T> ctConstructorCall);\n\n\t/**\n\t * Visits an anonymous class construction.\n\t */\n\t<T> void visitCtNewClass(CtNewClass<T> newClass);\n\n\t/**\n\t * Visits an anonymous method construction.\n\t */\n\t<T> void visitCtLambda(CtLambda<T> lambda);\n\n\t/**\n\t * Visits a reference to an executable.\n\t */\n\t<T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(\n\t\t\tCtExecutableReferenceExpression<T, E> expression);\n\n\t/**\n\t * Visits an operator assignment.\n\t */\n\t<T, A extends T> void visitCtOperatorAssignment(\n\t\t\tCtOperatorAssignment<T, A> assignment);\n\n\t/**\n\t * Visits a package declaration.\n\t */\n\tvoid visitCtPackage(CtPackage ctPackage);\n\n\t/**\n\t * Visits a reference to a package.\n\t */\n\tvoid visitCtPackageReference(CtPackageReference reference);\n\n\t/**\n\t * Visits a parameter declaration.\n\t */\n\t<T> void visitCtParameter(CtParameter<T> parameter);\n\n\t/**\n\t * Visits a reference to a parameter.\n\t */\n\t<T> void visitCtParameterReference(CtParameterReference<T> reference);\n\n\t/**\n\t * Visits a <code>return</code> statement.\n\t */\n\t<R> void visitCtReturn(CtReturn<R> returnStatement);\n\n\t/**\n\t * Visits a statement list.\n\t */\n\t<R> void visitCtStatementList(CtStatementList statements);\n\n\t/**\n\t * Visits a <code>switch</code> statement.\n\t */\n\t<S> void visitCtSwitch(CtSwitch<S> switchStatement);\n\n\t/**\n\t * Visits a <code>synchronized</code> modifier.\n\t */\n\tvoid visitCtSynchronized(CtSynchronized synchro);\n\n\t/**\n\t * Visits a <code>throw</code> statement.\n\t */\n\tvoid visitCtThrow(CtThrow throwStatement);\n\n\t/**\n\t * Visits a <code>try</code> statement.\n\t */\n\tvoid visitCtTry(CtTry tryBlock);\n\n\t/**\n\t * Visits a <code>try</code> with resource statement.\n\t */\n\tvoid visitCtTryWithResource(CtTryWithResource tryWithResource);\n\n\t/**\n\t * Visits a reference to a type parameter.\n\t */\n\tvoid visitCtTypeParameterReference(CtTypeParameterReference ref);\n\n\t/**\n\t * Visits a reference to a wildcard.\n\t */\n\tvoid visitCtWildcardReference(CtWildcardReference wildcardReference);\n\n\t/**\n\t * Visits an intersection type.\n\t */\n\t<T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference);\n\n\t/**\n\t * Visits a reference to a type.\n\t */\n\t<T> void visitCtTypeReference(CtTypeReference<T> reference);\n\n\t/**\n\t * Visits a type access.\n\t */\n\t<T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess);\n\n\t/**\n\t * Visits a unary operator.\n\t */\n\t<T> void visitCtUnaryOperator(CtUnaryOperator<T> operator);\n\n\t/**\n\t * Visits a variable read access.\n\t */\n\t<T> void visitCtVariableRead(CtVariableRead<T> variableRead);\n\n\t/**\n\t * Visits a variable write access.\n\t */\n\t<T> void visitCtVariableWrite(CtVariableWrite<T> variableWrite);\n\n\t/**\n\t * Visits a <code>while</code> loop.\n\t */\n\tvoid visitCtWhile(CtWhile whileLoop);\n\n\t/**\n\t * Visits a field of an annotation.\n\t */\n\t<T> void visitCtAnnotationFieldAccess(CtAnnotationFieldAccess<T> annotationFieldAccess);\n\n\t/**\n\t * Visits a field read access.\n\t */\n\t<T> void visitCtFieldRead(CtFieldRead<T> fieldRead);\n\n\t/**\n\t * Visits a field write access.\n\t */\n\t<T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite);\n\n\t/**\n\t * Visits an access to a super invocation.\n\t */\n\t<T> void visitCtSuperAccess(CtSuperAccess<T> f);\n\n\t/**\n\t * Visits a comment\n\t */\n\tvoid visitCtComment(CtComment comment);\n\n\t/**\n\t * Visits a javadoc comment\n\t */\n\tvoid visitCtJavaDoc(CtJavaDoc comment);\n\n\t/**\n\t * Visits a javadoc tag\n\t */\n\tvoid visitCtJavaDocTag(CtJavaDocTag docTag);\n\n\t/**\n\t * Visits an import declaration\n\t */\n\tvoid visitCtImport(CtImport ctImport);\n\n\t/**\n\t * Visits a module declaration\n\t */\n\tvoid visitCtModule(CtModule module);\n\n\t/**\n\t * Visits a module reference\n\t */\n\tvoid visitCtModuleReference(CtModuleReference moduleReference);\n\n\t/**\n\t * Visits a package export in a module declaration.\n\t */\n\tvoid visitCtPackageExport(CtPackageExport moduleExport);\n\n\t/**\n\t * Visits a \"require\" directive in a module declaration.\n\t */\n\tvoid visitCtModuleRequirement(CtModuleRequirement moduleRequirement);\n\n\t/**\n\t * Visits a \"provides\" directive in a module declaration.\n\t */\n\tvoid visitCtProvidedService(CtProvidedService moduleProvidedService);\n\n\t/**\n\t * Visits a \"uses\" directive in a module declaration.\n\t */\n\tvoid visitCtUsedService(CtUsedService usedService);\n\n\t/**\n\t * Visits a compilation unit\n\t */\n\tvoid visitCtCompilationUnit(CtCompilationUnit compilationUnit);\n\n\t/**\n\t * Visits a package declaration\n\t */\n\tvoid visitCtPackageDeclaration(CtPackageDeclaration packageDeclaration);\n\n\t/**\n\t * Visits an import wildcard static type member reference\n\t */\n\tvoid visitCtTypeMemberWildcardImportReference(CtTypeMemberWildcardImportReference wildcardReference);\n}\n"
    }, {
      "name" : "reflect/visitor/ListPrinter.java",
      "weight" : 52.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.io.Closeable;\n\n/**\n * Helper which assures consistent printing of lists\n * prefixed with `start`, separated by `separator` and suffixed by `end`.<br>\n * If there is no item in the list then it prints `start` and then `end`<br>\n * If there is one item in the list then it prints `start`, item and then `end`<br>\n * If there is more then one items in the list then it prints `start`, items separated by `separator` and then `end`\n */\npublic class ListPrinter implements Closeable {\n\n\tprivate final TokenWriter printerTokenWriter;\n\tprivate final boolean nextPrefixSpace;\n\tprivate final String separator;\n\tprivate final boolean nextSuffixSpace;\n\tprivate final boolean endPrefixSpace;\n\tprivate final String end;\n\tprivate boolean isFirst = true;\n\n\tpublic ListPrinter(TokenWriter printerHelper, boolean startPrefixSpace, String start, boolean startSuffixSpace, boolean nextPrefixSpace, String next, boolean nextSuffixSpace, boolean endPrefixSpace, String end) {\n\t\tthis.printerTokenWriter = printerHelper;\n\t\tthis.nextPrefixSpace = nextPrefixSpace;\n\t\tthis.separator = next;\n\t\tthis.nextSuffixSpace = nextSuffixSpace;\n\t\tthis.endPrefixSpace = endPrefixSpace;\n\t\tthis.end = end;\n\n\t\tif (startPrefixSpace) {\n\t\t\tprinterHelper.writeSpace();\n\t\t}\n\t\tif (start != null && !start.isEmpty()) {\n\t\t\tprinterTokenWriter.writeSeparator(start);\n\t\t}\n\t\tif (startSuffixSpace) {\n\t\t\tprinterHelper.writeSpace();\n\t\t}\n\t}\n\n\t/**\n\t * Call that before printing of list item starts\n\t */\n\tpublic void printSeparatorIfAppropriate() {\n\t\tif (isFirst) {\n\t\t\t/*\n\t\t\t * we are starting first item. Do not print `separator` separator yet\n\t\t\t */\n\t\t\tisFirst = false;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we are starting separator item. Print `separator` separator now\n\t\t\t */\n\t\t\tif (nextPrefixSpace) {\n\t\t\t\tprinterTokenWriter.writeSpace();\n\t\t\t}\n\t\t\tif (separator != null && !separator.isEmpty()) {\n\t\t\t\tprinterTokenWriter.writeSeparator(separator);\n\t\t\t}\n\t\t\tif (nextSuffixSpace) {\n\t\t\t\tprinterTokenWriter.writeSpace();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void close() {\n\t\tif (endPrefixSpace) {\n\t\t\tprinterTokenWriter.writeSpace();\n\t\t}\n\t\tif (end != null && !end.isEmpty()) {\n\t\t\tprinterTokenWriter.writeSeparator(end);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtVisitable.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\n/**\n * Define a visitable element in spoon. You can read the page Wikipedia http://en.wikipedia.org/wiki/Visitor_pattern.\n */\npublic interface CtVisitable {\n\t/**\n\t * Accepts a visitor\n\t */\n\tvoid accept(CtVisitor visitor);\n}\n"
    }, {
      "name" : "reflect/visitor/AstParentConsistencyChecker.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\n\npublic class AstParentConsistencyChecker extends CtScanner {\n\n\tprivate CtElement parent;\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\tif (element == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (parent != null\n\t\t\t\t&& element.isParentInitialized() // this is the fix of #1747\n\t\t\t\t&& element.getParent() != parent) {\n\t\t\tthrow new IllegalStateException(toDebugString(element) // better debug\n\t\t\t\t\t+ \" is set as child of\\n\" + toDebugString(element.getParent())\n\t\t\t\t\t+ \"however it is visited as a child of\\n\" + toDebugString(parent));\n\t\t}\n\t\tCtElement parent = this.parent;\n\t\tthis.parent = element;\n\t\tsuper.scan(element);\n\t\tthis.parent = parent;\n\t}\n\n\tprivate static String toDebugString(CtElement e) {\n\t\treturn \"Element: \" + e + \"\\nSignature: \" + e.getShortRepresentation() + \"\\nClass: \" + e.getClass() + \"\\nposition: \" + e.getPosition() + \"\\n\";\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/ModelConsistencyChecker.java",
      "weight" : 45.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport org.apache.log4j.Level;\nimport spoon.compiler.Environment;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * This scanner checks that a program model is consistent with regards to the\n * parent elements (children must have the right parent). This class can be used\n * to validate that a program transformation does not harm the model integrity,\n * and also to automatically fix it when possible.\n */\npublic class ModelConsistencyChecker extends CtScanner {\n\n\tboolean fixInconsistencies;\n\tboolean fixNullParents;\n\n\tEnvironment environment;\n\n\tDeque<CtElement> stack = new ArrayDeque<>();\n\n\t/**\n\t * Creates a new model consistency checker.\n\t *\n\t * @param environment\n\t * \t\tthe environment where to report errors\n\t * @param fixInconsistencies\n\t * \t\tautomatically fix the inconsistencies rather than reporting\n\t * \t\twarnings (to report warnings, set this to false)\n\t * @param fixNullParents\n\t * \t\tautomatically fix the null parents rather than reporting\n\t * \t\twarnings (to report warnings, set this to false)\n\t */\n\tpublic ModelConsistencyChecker(Environment environment, boolean fixInconsistencies, boolean fixNullParents) {\n\t\tthis.environment = environment;\n\t\tthis.fixInconsistencies = fixInconsistencies;\n\t\tthis.fixNullParents = fixNullParents;\n\t}\n\n\t/**\n\t * Enters an element.\n\t */\n\t@Override\n\tpublic void enter(CtElement element) {\n\t\tif (!stack.isEmpty()) {\n\t\t\tif (!element.isParentInitialized() || element.getParent() != stack.peek()) {\n\t\t\t\tif ((!element.isParentInitialized() && fixNullParents) || (element.getParent() != stack.peek() && fixInconsistencies)) {\n\t\t\t\t\telement.setParent(stack.peek());\n\t\t\t\t} else {\n\t\t\t\t\tfinal String name = element instanceof CtNamedElement ? \" - \" + ((CtNamedElement) element).getSimpleName() : \"\";\n\t\t\t\t\tenvironment.report(null, Level.WARN,\n\t\t\t\t\t\t\t(element.isParentInitialized() ? \"inconsistent\" : \"null\") + \" parent for \" + element.getClass() + name + \" - \" + element.getPosition() + \" - \" + stack.peek()\n\t\t\t\t\t\t\t\t\t.getPosition());\n\t\t\t\t\tdumpStack();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack.push(element);\n\t}\n\n\t/**\n\t * Exits an element.\n\t */\n\t@Override\n\tprotected void exit(CtElement e) {\n\t\tstack.pop();\n\t}\n\n\tprivate void dumpStack() {\n\t\tenvironment.debugMessage(\"model consistency checker stack:\");\n\t\tfor (CtElement e : stack) {\n\t\t\tenvironment.debugMessage(\"    \" + e.getClass().getSimpleName() + \" \" + (e.getPosition().isValidPosition() ? String.valueOf(e.getPosition()) : \"(?)\"));\n\t\t}\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/Parent.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation defines a method that returns the parent of an element of the\n * meta model. It is used for the automatic generation of visitors of spoon\n * metamodel elements.\n */\n@Target({ ElementType.METHOD })\npublic @interface Parent {\n}\n"
    }, {
      "name" : "reflect/visitor/ImportScannerImpl.java",
      "weight" : 734.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.experimental.CtUnresolvedImport;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.SpoonClassNotFoundException;\nimport spoon.support.reflect.reference.CtTypeMemberWildcardImportReferenceImpl;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A scanner that calculates the imports for a given model.\n */\npublic class ImportScannerImpl extends CtScanner implements ImportScanner {\n\n\tprivate static final Collection<String> namesPresentInJavaLang8 =\n\t\t\tCollections.singletonList(\"FunctionalInterface\");\n\tprivate static final Collection<String> namesPresentInJavaLang9 = Arrays.asList(\n\t\t\t\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n\tprotected Map<String, CtTypeReference<?>> classImports = new TreeMap<>();\n\tprotected Map<String, CtFieldReference<?>> fieldImports = new TreeMap<>();\n\tprotected Map<String, CtExecutableReference<?>> methodImports = new TreeMap<>();\n\t//top declaring type of that import\n\tprotected CtTypeReference<?> targetType;\n\tprivate Map<String, Boolean> namesPresentInJavaLang = new HashMap<>();\n\tprivate Set<String> fieldAndMethodsNames = new HashSet<>();\n\tprivate Set<CtTypeReference> exploredReferences = new HashSet<>(); // list of explored references\n\tprivate Map<CtImport, Boolean> usedImport = new HashMap<>(); // defined if imports had been used or not\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\tenter(fieldRead);\n\t\tscan(fieldRead.getAnnotations());\n\t\tscan(fieldRead.getTypeCasts());\n\t\tscan(fieldRead.getVariable());\n\t\tscan(fieldRead.getTarget());\n\t\texit(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(reference.getDeclaringType());\n\t\tif (reference.isStatic()) {\n\t\t\taddFieldImport(reference);\n\t\t} else {\n\t\t\tscan(reference.getDeclaringType());\n\t\t}\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\tenter(reference);\n\t\tif (reference.isStatic()) {\n\t\t\taddMethodImport(reference);\n\t\t} else if (reference.isConstructor()) {\n\t\t\tscan(reference.getDeclaringType());\n\t\t}\n\t\tscan(reference.getActualTypeArguments());\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\t\tif (!(reference instanceof CtArrayTypeReference)) {\n\t\t\tCtTypeReference typeReference;\n\t\t\tif (reference.getDeclaringType() == null) {\n\t\t\t\ttypeReference = reference;\n\t\t\t} else {\n\t\t\t\ttypeReference = reference.getAccessType();\n\t\t\t}\n\n\t\t\tif (!typeReference.equals(reference)) {\n\t\t\t\tif (this.isAlreadyInUsedImport(reference)) {\n\t\t\t\t\tsuper.visitCtTypeReference(reference);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!this.isTypeInCollision(typeReference, false)) {\n\t\t\t\tthis.addClassImport(typeReference);\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtTypeReference(reference);\n\n\t}\n\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\telement.accept(this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDoc(CtJavaDoc ctJavaDoc) {\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\tstringBuilder.append(ctJavaDoc.getContent());\n\n\t\tfor (CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n\t\t\tstringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n\t\t}\n\n\t\tString javadoc = stringBuilder.toString();\n\t\tfor (CtImport ctImport : this.usedImport.keySet()) {\n\t\t\tswitch (ctImport.getImportKind()) {\n\t\t\t\tcase TYPE:\n\t\t\t\t\tif (javadoc.contains(ctImport.getReference().getSimpleName()) && ctImport.getReference() instanceof CtTypeReference) {\n\t\t\t\t\t\t//assure that it is not just any occurrence of same substring, but it is real javadoc link to the same type\n\t\t\t\t\t\tif (matchesTypeName(javadoc, (CtTypeReference<?>) ctImport.getReference())) {\n\t\t\t\t\t\t\tthis.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Set<String> mainTags = new HashSet<>(Arrays.asList(\"see\", \"throws\", \"exception\"));\n\tprivate static Set<String> inlineTags = new HashSet<>(Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\tprivate static Pattern tagRE = Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n\tprivate boolean matchesTypeName(String javadoc, CtTypeReference<?> typeRef) {\n\t\tMatcher m = tagRE.matcher(javadoc);\n\t\twhile (m.find()) {\n\t\t\tString bracket = m.group(1);\n\t\t\tString tag = m.group(2);\n\t\t\tif (\"{\".equals(bracket)) {\n\t\t\t\tif (inlineTags.contains(tag) == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (mainTags.contains(tag) == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString type = m.group(3);\n\t\t\tString params = m.group(5);\n\n\t\t\tif (isTypeMatching(type, typeRef)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (params != null) {\n\t\t\t\tString[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n\t\t\t\tfor (String paramType : paramTypes) {\n\t\t\t\t\tif (isTypeMatching(paramType, typeRef)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isTypeMatching(String typeName, CtTypeReference<?> typeRef) {\n\t\tif (typeName != null) {\n\t\t\tif (typeName.equals(typeRef.getQualifiedName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (typeName.equals(typeRef.getSimpleName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotationType(\n\t\t\tCtAnnotationType<A> annotationType) {\n\t\taddClassImport(annotationType.getReference());\n\t\tsuper.visitCtAnnotationType(annotationType);\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum) {\n\t\taddClassImport(ctEnum.getReference());\n\t\tsuper.visitCtEnum(ctEnum);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\t\taddClassImport(intrface.getReference());\n\t\tfor (CtTypeMember t : intrface.getTypeMembers()) {\n\t\t\tif (!(t instanceof CtType)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddClassImport(((CtType) t).getReference());\n\t\t}\n\t\tsuper.visitCtInterface(intrface);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\taddClassImport(ctClass.getReference());\n\t\tfor (CtTypeMember t : ctClass.getTypeMembers()) {\n\t\t\tif (!(t instanceof CtType)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taddClassImport(((CtType) t).getReference());\n\t\t}\n\t\tsuper.visitCtClass(ctClass);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\tfor (CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n\t\t\taddClassImport(type);\n\t\t}\n\t\tsuper.visitCtCatchVariable(catchVariable);\n\t}\n\n\t@Override\n\tpublic void visitCtInvocation(CtInvocation invocation) {\n\t\tthis.scan(invocation.getTypeCasts());\n\t\tthis.scan(invocation.getExecutable());\n\t\tif (!this.isImportedInMethodImports(invocation.getExecutable())) {\n\t\t\tthis.scan(invocation.getTarget());\n\t\t}\n\n\t\tthis.scan(invocation.getArguments());\n\t}\n\n\t@Override\n\tpublic Set<CtImport> getAllImports() {\n\t\tSet<CtImport> listallImports = new HashSet<>();\n\n\t\tfor (Map.Entry<CtImport, Boolean> entry : this.usedImport.entrySet()) {\n\t\t\tif (entry.getValue()) {\n\t\t\t\tlistallImports.add(entry.getKey());\n\t\t\t}\n\t\t}\n\n\t\tfor (CtReference reference : this.classImports.values()) {\n\t\t\tlistallImports.add(reference.getFactory().Type().createImport(reference));\n\t\t}\n\n\t\tfor (CtReference reference : this.fieldImports.values()) {\n\t\t\tlistallImports.add(reference.getFactory().Type().createImport(reference));\n\t\t}\n\n\t\tfor (CtReference reference : this.methodImports.values()) {\n\t\t\tlistallImports.add(reference.getFactory().Type().createImport(reference));\n\t\t}\n\t\treturn listallImports;\n\t}\n\n\t@Override\n\tpublic void computeImports(CtElement element) {\n\t\t//look for top declaring type of that simpleType\n\t\tif (element instanceof CtType) {\n\t\t\tCtType simpleType = (CtType) element;\n\t\t\ttargetType = simpleType.getReference().getTopLevelType();\n\t\t\taddClassImport(simpleType.getReference());\n\t\t\tscan(simpleType);\n\t\t} else {\n\t\t\tCtType<?> type = element.getParent(CtType.class);\n\t\t\ttargetType = type == null ? null : type.getReference().getTopLevelType();\n\t\t\tscan(element);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isImported(CtReference ref) {\n\t\tif (ref instanceof CtFieldReference) {\n\t\t\treturn isImportedInFieldImports((CtFieldReference) ref);\n\t\t} else if (ref instanceof CtExecutableReference) {\n\t\t\treturn isImportedInMethodImports((CtExecutableReference) ref);\n\t\t} else if (ref instanceof CtTypeReference) {\n\t\t\treturn isImportedInClassImports((CtTypeReference) ref);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void initWithImports(Iterable<CtImport> importCollection) {\n\t\tfor (CtImport ctImport : importCollection) {\n\t\t\tthis.usedImport.put(ctImport, (ctImport instanceof CtUnresolvedImport) ? Boolean.TRUE : Boolean.FALSE);\n\t\t}\n\t}\n\n\tprivate boolean isThereAnotherClassWithSameNameInAnotherPackage(CtTypeReference<?> ref) {\n\t\tfor (CtTypeReference typeref : this.exploredReferences) {\n\t\t\tif (typeref.getSimpleName().equals(ref.getSimpleName()) && !typeref.getQualifiedName().equals(ref.getQualifiedName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Adds a type to the classImports.\n\t */\n\tprotected boolean addClassImport(CtTypeReference<?> ref) {\n\t\tthis.exploredReferences.add(ref);\n\t\tif (ref == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (targetType != null && targetType.getSimpleName().equals(ref.getSimpleName()) && !targetType.equals(ref)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (classImports.containsKey(ref.getSimpleName())) {\n\t\t\treturn isImportedInClassImports(ref);\n\t\t}\n\t\t// don't import unnamed package elements\n\t\tif (ref.getPackage() == null || ref.getPackage().isUnnamedPackage()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (targetType != null && targetType.canAccess(ref) == false) {\n\t\t\t//ref type is not visible in targetType we must not add import for it, java compiler would fail on that.\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// we want to be sure that we are not importing a class because a static field or method we already imported\n\t\t// moreover we make exception for same package classes to avoid problems in FQN mode\n\n\t\tif (targetType != null) {\n\t\t\ttry {\n\t\t\t\tCtElement parent = ref.getParent();\n\t\t\t\tif (parent != null) {\n\t\t\t\t\tparent = parent.getParent();\n\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\tif ((parent instanceof CtFieldAccess) || (parent instanceof CtExecutable) || (parent instanceof CtInvocation)) {\n\n\t\t\t\t\t\t\tCtTypeReference declaringType;\n\t\t\t\t\t\t\tCtReference reference;\n\t\t\t\t\t\t\tCtPackageReference pack = targetType.getPackage();\n\t\t\t\t\t\t\tif (parent instanceof CtFieldAccess) {\n\t\t\t\t\t\t\t\tCtFieldAccess field = (CtFieldAccess) parent;\n\t\t\t\t\t\t\t\tCtFieldReference localReference = field.getVariable();\n\t\t\t\t\t\t\t\tdeclaringType = localReference.getDeclaringType();\n\t\t\t\t\t\t\t\treference = localReference;\n\t\t\t\t\t\t\t} else if (parent instanceof CtExecutable) {\n\t\t\t\t\t\t\t\tCtExecutable exec = (CtExecutable) parent;\n\t\t\t\t\t\t\t\tCtExecutableReference localReference = exec.getReference();\n\t\t\t\t\t\t\t\tdeclaringType = localReference.getDeclaringType();\n\t\t\t\t\t\t\t\treference = localReference;\n\t\t\t\t\t\t\t} else if (parent instanceof CtInvocation) {\n\t\t\t\t\t\t\t\tCtInvocation invo = (CtInvocation) parent;\n\t\t\t\t\t\t\t\tCtExecutableReference localReference = invo.getExecutable();\n\t\t\t\t\t\t\t\tdeclaringType = localReference.getDeclaringType();\n\t\t\t\t\t\t\t\treference = localReference;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdeclaringType = null;\n\t\t\t\t\t\t\t\treference = null;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (reference != null && isImported(reference)) {\n\t\t\t\t\t\t\t\t// if we are in the **same** package we do the import for test with method isImported\n\t\t\t\t\t\t\t\tif (declaringType != null) {\n\t\t\t\t\t\t\t\t\tif (declaringType.getPackage() != null && !declaringType.getPackage().isUnnamedPackage()) {\n\t\t\t\t\t\t\t\t\t\t// ignore java.lang package\n\t\t\t\t\t\t\t\t\t\tif (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n\t\t\t\t\t\t\t\t\t\t\t// ignore type in same package\n\t\t\t\t\t\t\t\t\t\t\tif (declaringType.getPackage().getSimpleName()\n\t\t\t\t\t\t\t\t\t\t\t\t\t.equals(pack.getSimpleName())) {\n\t\t\t\t\t\t\t\t\t\t\t\tclassImports.put(ref.getSimpleName(), ref);\n\t\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (ParentNotInitializedException e) {\n\t\t\t}\n\t\t\tCtPackageReference pack = targetType.getPackage();\n\t\t\tif (pack != null && ref.getPackage() != null && !ref.getPackage().isUnnamedPackage()) {\n\t\t\t\t// ignore java.lang package\n\t\t\t\tif (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\t// ignore type in same package\n\t\t\t\t\tif (ref.getPackage().getSimpleName()\n\t\t\t\t\t\t\t.equals(pack.getSimpleName())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!isAlreadyInUsedImport(ref)) {\n\t\t\tclassImports.put(ref.getSimpleName(), ref);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean setImportUsed(CtImport ctImport) {\n\t\tthis.usedImport.put(ctImport, true);\n\t\treturn true;\n\t}\n\n\tprivate boolean isAlreadyInUsedImport(CtReference ref) {\n\t\tString refQualifiedName = \"\";\n\t\tCtTypeReference refDeclaringType = null;\n\n\t\tboolean isTypeRef = false;\n\t\tboolean isExecRef = false;\n\t\tboolean isFieldRef = false;\n\n\t\tif (ref instanceof CtTypeReference) {\n\t\t\trefQualifiedName = ((CtTypeReference) ref).getQualifiedName();\n\t\t\tisTypeRef = true;\n\t\t} else if (ref instanceof CtExecutableReference) {\n\t\t\trefDeclaringType = ((CtExecutableReference) ref).getDeclaringType();\n\t\t\tisExecRef = true;\n\t\t} else if (ref instanceof CtFieldReference) {\n\t\t\trefDeclaringType = ((CtFieldReference) ref).getDeclaringType();\n\t\t\trefQualifiedName = ((CtFieldReference) ref).getQualifiedName();\n\t\t\tisFieldRef = true;\n\t\t}\n\n\t\tfor (CtImport ctImport : this.usedImport.keySet()) {\n\t\t\tswitch (ctImport.getImportKind()) {\n\t\t\t\tcase METHOD:\n\t\t\t\t\tif (isExecRef) {\n\t\t\t\t\t\tCtExecutableReference execRef = (CtExecutableReference) ctImport.getReference();\n\t\t\t\t\t\tCtTypeReference declaringType = execRef.getDeclaringType();\n\n\t\t\t\t\t\tif (execRef.getSimpleName().equals(ref.getSimpleName()) && declaringType != null && declaringType.equals(refDeclaringType)) {\n\t\t\t\t\t\t\treturn this.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FIELD:\n\t\t\t\t\tif (isFieldRef) {\n\t\t\t\t\t\tCtFieldReference importFieldRef = (CtFieldReference) ctImport.getReference();\n\t\t\t\t\t\tif (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n\t\t\t\t\t\t\treturn this.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_STATIC_MEMBERS:\n\t\t\t\t\tif ((isExecRef || isFieldRef) && refDeclaringType != null) {\n\t\t\t\t\t\tString qualifiedName = refDeclaringType.getQualifiedName();\n\t\t\t\t\t\tCtTypeMemberWildcardImportReferenceImpl importRef = (CtTypeMemberWildcardImportReferenceImpl) ctImport.getReference();\n\t\t\t\t\t\tString importRefStr = importRef.getTypeReference().getQualifiedName();\n\t\t\t\t\t\tif (qualifiedName.equals(importRefStr)) {\n\t\t\t\t\t\t\treturn this.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TYPE:\n\t\t\t\t\tif (isTypeRef) {\n\t\t\t\t\t\tCtTypeReference typeReference = (CtTypeReference) ctImport.getReference();\n\n\t\t\t\t\t\tif (typeReference.getQualifiedName().equals(refQualifiedName)) {\n\t\t\t\t\t\t\treturn this.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_TYPES:\n\t\t\t\t\tif (isTypeRef) {\n\t\t\t\t\t\tString typeImportQualifiedName = ctImport.getReference().getSimpleName();\n\n\t\t\t\t\t\tif (refQualifiedName.equals(typeImportQualifiedName)) {\n\t\t\t\t\t\t\treturn this.setImportUsed(ctImport);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNRESOLVED:\n\t\t\t\t\tCtUnresolvedImport unresolvedImport = (CtUnresolvedImport) ctImport;\n\t\t\t\t\tString importRef = unresolvedImport.getUnresolvedReference();\n\t\t\t\t\tString importRefPrefix = null;\n\n\t\t\t\t\tif (importRef.contains(\"*\")) {\n\t\t\t\t\t\timportRefPrefix = importRef.substring(0, importRef.length() - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isTypeRef && !unresolvedImport.isStatic()) {\n\t\t\t\t\t\treturn importRef.equals(refQualifiedName)\n\t\t\t\t\t\t\t\t|| (importRefPrefix != null\n\t\t\t\t\t\t\t\t&& refQualifiedName.startsWith(importRefPrefix)\n\t\t\t\t\t\t\t\t&& !refQualifiedName.substring(importRefPrefix.length()).contains(\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((isExecRef || isFieldRef) && refDeclaringType != null && unresolvedImport.isStatic()) {\n\t\t\t\t\t\tif (isExecRef) {\n\t\t\t\t\t\t\trefQualifiedName = refDeclaringType + \".\" + ref.getSimpleName();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn importRef.equals(refQualifiedName)\n\t\t\t\t\t\t\t\t|| (importRefPrefix != null\n\t\t\t\t\t\t\t\t&& refQualifiedName.startsWith(importRefPrefix)\n\t\t\t\t\t\t\t\t&& !refQualifiedName.substring(importRefPrefix.length()).contains(\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected boolean isImportedInClassImports(CtTypeReference<?> ref) {\n\t\tif (this.isAlreadyInUsedImport(ref)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (targetType != null) {\n\t\t\tCtPackageReference pack = targetType.getPackage();\n\n\t\t\t// we consider that if a class belongs to java.lang or the same package than the actual class\n\t\t\t// then it is imported by default\n\t\t\tif (pack != null &&  ref.getPackage() != null && !ref.getPackage().isUnnamedPackage()) {\n\t\t\t\t// ignore java.lang package\n\t\t\t\tif (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n\t\t\t\t\t// ignore type in same package\n\t\t\t\t\tif (ref.getPackage().getSimpleName()\n\t\t\t\t\t\t\t.equals(pack.getSimpleName())) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ref.equals(targetType)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n\t\t\tCtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n\t\t\treturn exist.getQualifiedName().equals(ref.getQualifiedName());\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This method is used to check if the declaring type has been already imported, or if it is local\n\t * In both case we do not want to import it, even in FQN mode.\n\t * @param declaringType\n\t * @return true if it is local or imported\n\t */\n\tprivate boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType) {\n\t\tif (declaringType != null) {\n\n\t\t\tboolean isInCollision = isTypeInCollision(declaringType, false);\n\t\t\tif (!isInCollision) {\n\t\t\t\tboolean importSuccess = addClassImport(declaringType);\n\t\t\t\tif (importSuccess) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean importedInClassImports = isImportedInClassImports(declaringType);\n\t\t\tboolean inJavaLang = classNamePresentInJavaLang(declaringType);\n\n\t\t\tif (importedInClassImports || inJavaLang) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\twhile (declaringType != null) {\n\t\t\t\tif (declaringType.equals(targetType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdeclaringType = declaringType.getDeclaringType();\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Test if the given executable reference is targeted a method name which is in collision with a method name of the current class\n\t * @param ref\n\t * @return\n\t */\n\tprivate boolean isInCollisionWithLocalMethod(CtExecutableReference ref) {\n\t\tCtType<?> typeDecl = ref.getParent(CtType.class);\n\n\t\tif (typeDecl != null) {\n\t\t\tString methodName = ref.getSimpleName();\n\n\t\t\tfor (CtMethod<?> method : typeDecl.getAllMethods()) {\n\t\t\t\tif (method.getSimpleName().equals(methodName)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected boolean addMethodImport(CtExecutableReference ref) {\n\t\t// static import is not supported below java 1.5\n\t\tif (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.isImportedInMethodImports(ref)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// if the whole class is imported: no need to import the method.\n\t\tif (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isInCollisionWithLocalMethod(ref)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmethodImports.put(ref.getSimpleName(), ref);\n\n\t\t// if we are in the same package than target type, we also import class to avoid FQN in FQN mode.\n\t\tif (ref.getDeclaringType() != null) {\n\t\t\tif (ref.getDeclaringType().getPackage() != null) {\n\t\t\t\tif (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n\t\t\t\t\taddClassImport(ref.getDeclaringType());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected boolean isImportedInMethodImports(CtExecutableReference<?> ref) {\n\t\tif (this.isAlreadyInUsedImport(ref)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n\t\t\tCtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n\t\t\treturn getSignature(exist).equals(getSignature(ref));\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate String getSignature(CtExecutableReference<?> exist) {\n\t\treturn (exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\")\n\t\t\t\t+ \".\" + exist.getSignature();\n\t}\n\n\tprotected boolean addFieldImport(CtFieldReference ref) {\n\t\t// static import is not supported below java 1.5\n\t\tif (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.fieldImports.containsKey(ref.getSimpleName())) {\n\t\t\treturn isImportedInFieldImports(ref);\n\t\t}\n\n\t\tif (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfieldImports.put(ref.getSimpleName(), ref);\n\t\treturn true;\n\t}\n\n\tprotected boolean isImportedInFieldImports(CtFieldReference<?> ref) {\n\t\tif (this.isAlreadyInUsedImport(ref)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n\t\t\tCtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n\t\t\ttry {\n\t\t\t\tif (exist.getFieldDeclaration() != null && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t// in some rare cases we could not access to the field, then we do not import it.\n\t\t\t} catch (SpoonClassNotFoundException notfound) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprotected boolean classNamePresentInJavaLang(CtTypeReference<?> ref) {\n\t\tBoolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n\t\tif (presentInJavaLang == null) {\n\t\t\t// The following procedure of determining if the handle is present in Java Lang or\n\t\t\t// not produces \"false positives\" if the analyzed source complianceLevel is > 6.\n\t\t\t// For example, it reports that FunctionalInterface is present in java.lang even\n\t\t\t// for compliance levels 6, 7. But this is not considered a bad thing, in opposite,\n\t\t\t// it makes generated code a little more compatible with future versions of Java.\n\t\t\tif (namesPresentInJavaLang8.contains(ref.getSimpleName())\n\t\t\t\t\t|| namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n\t\t\t\tpresentInJavaLang = true;\n\t\t\t} else {\n\t\t\t\t// Assuming Spoon's own runtime environment is Java 7+\n\t\t\t\ttry {\n\t\t\t\t\tClass.forName(\"java.lang.\" + ref.getSimpleName());\n\t\t\t\t\tpresentInJavaLang = true;\n\t\t\t\t} catch (NoClassDefFoundError | ClassNotFoundException e) {\n\t\t\t\t\tpresentInJavaLang = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnamesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n\t\t}\n\t\treturn presentInJavaLang;\n\t}\n\n\tprotected Set<String> lookForLocalVariables(CtElement parent) {\n\t\tSet<String> result = new HashSet<>();\n\n\t\t// try to get the block container\n\t\t// if the first container is the class, then we are not in a block and we can quit now.\n\t\twhile (parent != null && !(parent instanceof CtBlock)) {\n\t\t\tif (parent instanceof CtClass) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tparent = parent.getParent();\n\t\t}\n\n\t\tif (parent != null) {\n\t\t\tCtBlock block = (CtBlock) parent;\n\t\t\tboolean innerClass = false;\n\n\t\t\t// now we have the first container block, we want to check if we're not in an inner class\n\t\t\twhile (parent != null && !(parent instanceof CtClass)) {\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\n\t\t\tif (parent != null) {\n\t\t\t\t// uhoh it's not a package as a parent, we must in an inner block:\n\t\t\t\t// let's find the last block BEFORE the class call: some collision could occur because of variables defined in that block\n\t\t\t\tif (!(parent.getParent() instanceof CtPackage)) {\n\t\t\t\t\twhile (parent != null && !(parent instanceof CtBlock)) {\n\t\t\t\t\t\tparent = parent.getParent();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\tblock = (CtBlock) parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tAccessibleVariablesFinder avf = new AccessibleVariablesFinder(block);\n\t\t\tList<CtVariable> variables = avf.find();\n\n\t\t\tfor (CtVariable variable : variables) {\n\t\t\t\tresult.add(variable.getSimpleName());\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Test if the reference can be imported, i.e. test if the importation could lead to a collision.\n\t * @param ref\n\t * @return true if the ref should be imported.\n\t */\n\tprotected boolean isTypeInCollision(CtReference ref, boolean fqnMode) {\n\t\tif (targetType != null && targetType.getSimpleName().equals(ref.getSimpleName()) && !targetType.equals(ref)) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\tCtElement parent;\n\t\t\tif (ref instanceof CtTypeReference) {\n\t\t\t\tparent = ref.getParent();\n\t\t\t} else {\n\t\t\t\tparent = ref;\n\t\t\t}\n\n\t\t\t// in that case we are trying to import a type because of a literal we are scanning\n\t\t\t// i.e. a string, an int, etc.\n\t\t\tif (parent instanceof CtLiteral) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tSet<String> localVariablesOfBlock = new HashSet<>();\n\n\t\t\tif (parent instanceof CtField) {\n\t\t\t\tthis.fieldAndMethodsNames.add(((CtField) parent).getSimpleName());\n\t\t\t} else if (parent instanceof CtMethod) {\n\t\t\t\tthis.fieldAndMethodsNames.add(((CtMethod) parent).getSimpleName());\n\t\t\t} else {\n\t\t\t\tlocalVariablesOfBlock = this.lookForLocalVariables(parent);\n\t\t\t}\n\n\t\t\twhile (!(parent instanceof CtPackage)) {\n\t\t\t\tif ((parent instanceof CtFieldReference) || (parent instanceof CtExecutableReference) || (parent instanceof CtInvocation)) {\n\t\t\t\t\tCtReference parentType;\n\t\t\t\t\tif (parent instanceof CtInvocation) {\n\t\t\t\t\t\tparentType = ((CtInvocation) parent).getExecutable();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentType = (CtReference) parent;\n\t\t\t\t\t}\n\t\t\t\t\tLinkedList<String> qualifiedNameTokens = new LinkedList<>();\n\n\t\t\t\t\t// we don't want to test the current ref name, as we risk to create field import and make autoreference\n\t\t\t\t\tif (parentType != parent) {\n\t\t\t\t\t\tqualifiedNameTokens.add(parentType.getSimpleName());\n\t\t\t\t\t}\n\n\t\t\t\t\tCtTypeReference typeReference;\n\t\t\t\t\tif (parent instanceof CtFieldReference) {\n\t\t\t\t\t\ttypeReference = ((CtFieldReference) parent).getDeclaringType();\n\t\t\t\t\t} else if (parent instanceof CtExecutableReference) {\n\t\t\t\t\t\ttypeReference = ((CtExecutableReference) parent).getDeclaringType();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttypeReference = ((CtInvocation) parent).getExecutable().getDeclaringType();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeReference != null) {\n\t\t\t\t\t\tqualifiedNameTokens.addFirst(typeReference.getSimpleName());\n\n\t\t\t\t\t\tif (typeReference.getPackage() != null) {\n\t\t\t\t\t\t\tStringTokenizer token = new StringTokenizer(typeReference.getPackage().getSimpleName(), CtPackage.PACKAGE_SEPARATOR);\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\twhile (token.hasMoreElements()) {\n\t\t\t\t\t\t\t\tqualifiedNameTokens.add(index, token.nextToken());\n\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!qualifiedNameTokens.isEmpty()) {\n\t\t\t\t\t\t// qualified name token are ordered in the reverse order\n\t\t\t\t\t\t// if the first package name is a variable name somewhere, it could lead to a collision\n\t\t\t\t\t\tif (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n\t\t\t\t\t\t\tqualifiedNameTokens.removeFirst();\n\n\t\t\t\t\t\t\tif (fqnMode) {\n\t\t\t\t\t\t\t\t// in case we are testing a type: we should not import it if its entire name is in collision\n\t\t\t\t\t\t\t\t// for example: spoon.Launcher if a field spoon and another one Launcher exists\n\t\t\t\t\t\t\t\tif (ref instanceof CtTypeReference) {\n\t\t\t\t\t\t\t\t\tif (qualifiedNameTokens.isEmpty()) {\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// but if the other package names are not a variable name, it's ok to import\n\t\t\t\t\t\t\t\t\tfor (String testedToken : qualifiedNameTokens) {\n\t\t\t\t\t\t\t\t\t\tif (!fieldAndMethodsNames.contains(testedToken) && !localVariablesOfBlock.contains(testedToken)) {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t\t\t// However if it is a static method/field, we always accept to import them in this case\n\t\t\t\t\t\t\t\t// It is the last possibility for managing import for us\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// but if the other package names are not a variable name, it's ok to import\n\t\t\t\t\t\t\t\tfor (String testedToken : qualifiedNameTokens) {\n\t\t\t\t\t\t\t\t\tif (!fieldAndMethodsNames.contains(testedToken) && !localVariablesOfBlock.contains(testedToken)) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/EarlyTerminatingScanner.java",
      "weight" : 129.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Extends {@link CtScanner}, to support early termination of scanning process and scan listeners.\n * It is useful when your algorithm is searching for a specific node only.\n * In this case, you can call {@link #terminate()}, which ensures that no more AST nodes are visited,\n *<br>\n * It is possible to register an implementation of {@link CtScannerListener},\n * whose {@link CtScannerListener#enter(CtElement)}/{@link CtScannerListener#exit(CtElement)}\n * methods are called before/after each AST node is visited.<br>\n *\n * @param <T> the type of the result produced by this scanner.\n */\npublic class EarlyTerminatingScanner<T> extends CtScanner {\n\n\tprivate boolean terminate = false;\n\tprivate T result;\n\tprivate CtScannerListener listener;\n\tprotected CtRole scannedRole;\n\tprivate boolean visitCompilationUnitContent = false;\n\n\tprotected void terminate() {\n\t\tterminate = true;\n\t}\n\n\tprotected boolean isTerminated() {\n\t\treturn terminate;\n\t}\n\n\tprotected void setResult(T result) {\n\t\tthis.result = result;\n\t}\n\n\t/**\n\t * @return the result of scanning - the value, which was stored by a previous call of {@link #setResult(Object)}\n\t */\n\tpublic T getResult() {\n\t\treturn result;\n\t}\n\n\t/**\n\t * @return null or the implementation of {@link CtScannerListener}, which is registered to listen for enter/exit of nodes during scanning of the AST\n\t */\n\tpublic CtScannerListener getListener() {\n\t\treturn listener;\n\t}\n\n\t/**\n\t * @param listener the implementation of {@link CtScannerListener}, which will be called back when entering/exiting\n\t * odes during scanning.\n\t * @return this to support fluent API\n\t */\n\tpublic EarlyTerminatingScanner<T> setListener(CtScannerListener listener) {\n\t\tthis.listener = listener;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, Collection<? extends CtElement> elements) {\n\t\tif (isTerminated() || elements == null) {\n\t\t\treturn;\n\t\t}\n\t\t// we use defensive copy so as to be able to change the class while scanning\n\t\t// otherwise one gets a ConcurrentModificationException\n\t\tfor (CtElement e : new ArrayList<>(elements)) {\n\t\t\tscan(role, e);\n\t\t\tif (isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, Map<String, ? extends CtElement> elements) {\n\t\tif (isTerminated() || elements == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (CtElement obj : elements.values()) {\n\t\t\tscan(role, obj);\n\t\t\tif (isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, CtElement element) {\n\t\tscannedRole = role;\n\t\tsuper.scan(role, element);\n\t}\n\n\t/*\n\t * we cannot override scan(CtRole role, CtElement element) directly\n\t * because some implementations needs scan(CtElement element), which must be called too\n\t */\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\tif (element == null || isTerminated()) {\n\t\t\treturn;\n\t\t}\n\t\tif (listener == null) {\n\t\t\t//the listener is not defined\n\t\t\t//visit this element and may be children\n\t\t\tdoScan(scannedRole, element, ScanningMode.NORMAL);\n\t\t} else {\n\t\t\t//the listener is defined, call it's enter method first\n\t\t\tScanningMode mode = listener.enter(scannedRole, element);\n\t\t\tif (mode != ScanningMode.SKIP_ALL) {\n\t\t\t\t//the listener decided to visit this element and may be children\n\t\t\t\tdoScan(scannedRole, element, mode);\n\t\t\t\t//then call exit, only if enter returned true\n\t\t\t\tlistener.exit(scannedRole, element);\n\t\t\t} //else the listener decided to skip this element and all children. Do not call exit.\n\t\t}\n\t}\n\n\t/**\n\t * This method is called ONLY when the listener decides that the current element and children should be visited.\n\t * Subclasses can override it to react accordingly.\n\t */\n\tprotected void doScan(CtRole role, CtElement element, ScanningMode mode) {\n\t\t//send input to output\n\t\tif (mode.visitElement) {\n\t\t\tonElement(role, element);\n\t\t}\n\t\tif (mode.visitChildren) {\n\t\t\t//do not call scan(CtElement) nor scan(CtRole, CtElement), because they would cause StackOverflowError\n\t\t\telement.accept(this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\t\tif (isVisitCompilationUnitContent()) {\n\t\t\tenter(compilationUnit);\n\t\t\tscan(CtRole.COMMENT, compilationUnit.getComments());\n\t\t\tscan(CtRole.ANNOTATION, compilationUnit.getAnnotations());\n\t\t\tscan(CtRole.PACKAGE_DECLARATION, compilationUnit.getPackageDeclaration());\n\t\t\tscan(CtRole.DECLARED_IMPORT, compilationUnit.getImports());\n\t\t\t//visit directly the module (instead of reference only)\n\t\t\tscan(CtRole.DECLARED_MODULE, compilationUnit.getDeclaredModule());\n\t\t\t//visit directly the types (instead of references only)\n\t\t\tscan(CtRole.DECLARED_TYPE, compilationUnit.getDeclaredTypes());\n\t\t\texit(compilationUnit);\n\t\t} else {\n\t\t\tsuper.visitCtCompilationUnit(compilationUnit);\n\t\t}\n\t}\n\n\t/**\n\t * Called for each scanned element. The call of this method is influenced by {@link ScanningMode} defined by {@link CtScannerListener}\n\t * @param role a role of `element` in parent\n\t * @param element a scanned element\n\t */\n\tprotected void onElement(CtRole role, CtElement element) {\n\t}\n\n\t@Override\n\tpublic void scan(CtRole role, Object o) {\n\t\tif (isTerminated() || o == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (o instanceof CtElement) {\n\t\t\tscan(role, (CtElement) o);\n\t\t} else if (o instanceof Collection<?>) {\n\t\t\tscan(role, (Collection<? extends CtElement>) o);\n\t\t} else if (o instanceof Map<?, ?>) {\n\t\t\tfor (Object obj : ((Map) o).values()) {\n\t\t\t\tscan(role, obj);\n\t\t\t\tif (isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @return true if types and modules are visited. false if only their references are visited. false is default\n\t */\n\tpublic boolean isVisitCompilationUnitContent() {\n\t\treturn visitCompilationUnitContent;\n\t}\n\n\t/**\n\t * @param visitCompilationUnitContent use true if types and modules have to be visited. false if only their references have to be visited.\n\t * false is default\n\t */\n\tpublic EarlyTerminatingScanner<T> setVisitCompilationUnitContent(boolean visitCompilationUnitContent) {\n\t\tthis.visitCompilationUnitContent = visitCompilationUnitContent;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/ElementPrinterHelper.java",
      "weight" : 426.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.compiler.Environment;\nimport spoon.experimental.CtUnresolvedImport;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.printer.CommentOffset;\nimport spoon.reflect.visitor.PrintingContext.Writable;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.function.Consumer;\n\npublic class ElementPrinterHelper {\n\tprivate final DefaultJavaPrettyPrinter prettyPrinter;\n\tprivate final Environment env;\n\tprivate TokenWriter printer;\n\n\tpublic ElementPrinterHelper(TokenWriter printerTokenWriter, DefaultJavaPrettyPrinter prettyPrinter, Environment env) {\n\t\tthis.printer = printerTokenWriter;\n\t\tthis.prettyPrinter = prettyPrinter;\n\t\tthis.env = env;\n\t}\n\n\t/**\n\t * Writes the annotations for the given element.\n\t */\n\tpublic void writeAnnotations(CtElement element) {\n\t\tfor (CtAnnotation<?> annotation : element.getAnnotations()) {\n\n\t\t\t// if element is a type reference and the parent is a typed element\n\t\t\t// which contains exactly the same annotation, then we are certainly in this case:\n\t\t\t// @myAnnotation String myField\n\t\t\t// in which case the annotation is attached to the type and the variable\n\t\t\t// in that case, we only print the annotation once.\n\t\t\tif (element.isParentInitialized() && element instanceof CtTypeReference && (element.getParent() instanceof CtTypedElement) && element.getParent().getAnnotations().contains(annotation)) {\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprettyPrinter.scan(annotation);\n\t\t\tprinter.writeln();\n\t\t}\n\t}\n\n\t/**  writes the modifiers of this modifiable in a specific order */\n\tpublic void writeModifiers(CtModifiable modifiable) {\n\t\t// write the modifiers according to the convention on order\n\t\tList<String> firstPosition = new ArrayList<>(); // visibility: public, private, protected\n\t\tList<String> secondPosition = new ArrayList<>(); // keywords: static, abstract\n\t\tList<String> thirdPosition = new ArrayList<>(); // all other things\n\n\t\tfor (CtExtendedModifier extendedModifier : modifiable.getExtendedModifiers()) {\n\t\t\tif (!extendedModifier.isImplicit()) {\n\t\t\t\tModifierKind modifierKind = extendedModifier.getKind();\n\t\t\t\tif (modifierKind == ModifierKind.PUBLIC || modifierKind == ModifierKind.PRIVATE || modifierKind == ModifierKind.PROTECTED) {\n\t\t\t\t\tfirstPosition.add(modifierKind.toString());\n\t\t\t\t} else if (modifierKind == ModifierKind.ABSTRACT || modifierKind == ModifierKind.STATIC) {\n\t\t\t\t\tsecondPosition.add(modifierKind.toString());\n\t\t\t\t} else {\n\t\t\t\t\tthirdPosition.add(modifierKind.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (String s : firstPosition) {\n\t\t\tprinter.writeKeyword(s).writeSpace();\n\t\t}\n\n\t\tfor (String s : secondPosition) {\n\t\t\tprinter.writeKeyword(s).writeSpace();\n\t\t}\n\n\t\tfor (String s : thirdPosition) {\n\t\t\tprinter.writeKeyword(s).writeSpace();\n\t\t}\n\n\t\tif (modifiable instanceof CtMethod) {\n\t\t\tCtMethod m = (CtMethod) modifiable;\n\t\t\tif (m.isDefaultMethod()) {\n\t\t\t\tprinter.writeKeyword(\"default\").writeSpace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void visitCtNamedElement(CtNamedElement namedElement, CtCompilationUnit sourceCompilationUnit) {\n\t\twriteAnnotations(namedElement);\n\t\tif (env.isPreserveLineNumbers()) {\n\t\t\tgetPrinterHelper().adjustStartPosition(namedElement);\n\t\t}\n\t}\n\n\tpublic void writeExtendsClause(CtType<?> type) {\n\t\tif (type.getSuperclass() != null) {\n\t\t\tprinter.writeSpace().writeKeyword(\"extends\").writeSpace();\n\t\t\tprettyPrinter.scan(type.getSuperclass());\n\t\t}\n\t}\n\n\t/** writes the implemented interfaces with a ListPrinter */\n\tpublic void writeImplementsClause(CtType<?> type) {\n\t\tif (!type.getSuperInterfaces().isEmpty()) {\n\t\t\tprintList(type.getSuperInterfaces(), \"implements\",\n\t\t\t\tfalse, null, false, true, \",\", true, false, null,\n\t\t\t\tref -> prettyPrinter.scan(ref));\n\t\t}\n\t}\n\n\tpublic void writeExecutableParameters(CtExecutable<?> executable) {\n\t\tprintList(executable.getParameters(), null,\n\t\t\tfalse, \"(\", false, false, \",\", true, false, \")\",\n\t\t\tp -> prettyPrinter.scan(p));\n\t}\n\n\t/** writes the thrown exception with a ListPrinter */\n\tpublic void writeThrowsClause(CtExecutable<?> executable) {\n\t\tif (!executable.getThrownTypes().isEmpty()) {\n\t\t\tprintList(executable.getThrownTypes(), \"throws\",\n\t\t\t\tfalse, null, false, false, \",\", true, false, null,\n\t\t\t\tref -> prettyPrinter.scan(ref));\n\t\t}\n\t}\n\n\t/**\n\t * Writes a statement.\n\t */\n\tpublic void writeStatement(CtStatement statement) {\n\t\ttry (Writable _context = prettyPrinter.getContext().modify().setStatement(statement)) {\n\t\t\tprettyPrinter.scan(statement);\n\t\t}\n\t}\n\n\tpublic void writeElementList(List<CtTypeMember> elements) {\n\t\tfor (CtTypeMember element : elements) {\n\t\t\tif (element instanceof CtConstructor && element.isImplicit()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprinter.writeln();\n\t\t\tprettyPrinter.scan(element);\n\t\t\tif (!env.isPreserveLineNumbers()) {\n\t\t\t\tprinter.writeln();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Writes an annotation element.\n\t */\n\tpublic void writeAnnotationElement(Factory factory, Object value) {\n\t\tif (value instanceof CtTypeAccess) {\n\t\t\tprettyPrinter.scan((CtTypeAccess) value);\n\t\t\tprinter.writeSeparator(\".\").writeKeyword(\"class\");\n\t\t} else if (value instanceof CtFieldReference) {\n\t\t\tprettyPrinter.scan(((CtFieldReference<?>) value).getDeclaringType());\n\t\t\tprinter.writeSeparator(\".\").writeIdentifier(((CtFieldReference<?>) value).getSimpleName());\n\t\t} else if (value instanceof CtElement) {\n\t\t\tprettyPrinter.scan((CtElement) value);\n\t\t} else if (value instanceof String) {\n\t\t\tprinter.writeLiteral(\"\\\"\" + LiteralHelper.getStringLiteral((String) value, true) + \"\\\"\");\n\t\t} else if (value instanceof Collection) {\n\t\t\tprintList((Collection<?>) value, null,\n\t\t\t\tfalse, \"{\", false, true, \",\", false, false, \"}\",\n\t\t\t\tobj -> writeAnnotationElement(factory, obj));\n\t\t} else if (value instanceof Object[]) {\n\t\t\tprintList(Arrays.asList((Object[]) value), null,\n\t\t\t\tfalse, \"{\", false, true, \",\", false, false, \"}\",\n\t\t\t\tobj -> writeAnnotationElement(factory, obj));\n\t\t} else if (value instanceof Enum) {\n\t\t\ttry (Writable c = prettyPrinter.getContext().modify().ignoreGenerics(true)) {\n\t\t\t\tprettyPrinter.scan(factory.Type().createReference(((Enum<?>) value).getDeclaringClass()));\n\t\t\t}\n\t\t\tprinter.writeSeparator(\".\");\n\t\t\tprinter.writeIdentifier(value.toString());\n\t\t} else {\n\t\t\t//it probably prints, boolean, number, ...\n\t\t\tprinter.writeLiteral(value.toString());\n\t\t}\n\t}\n\n\t/**\n\t * Writes formal type parameters given in parameter.\n\t *\n\t * @param ctFormalTypeDeclarer\n\t * \t\tReference with formal type arguments.\n\t */\n\tpublic void writeFormalTypeParameters(CtFormalTypeDeclarer ctFormalTypeDeclarer) {\n\t\tfinal Collection<CtTypeParameter> parameters = ctFormalTypeDeclarer.getFormalCtTypeParameters();\n\t\tif (parameters == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (!parameters.isEmpty()) {\n\t\t\tprintList(parameters,\n\t\t\t\tnull,\tfalse, \"<\", false, false, \",\", true, false, \">\",\n\t\t\t\tparameter -> prettyPrinter.scan(parameter));\n\t\t}\n\t}\n\n\t/**\n\t * Writes actual type arguments in a {@link CtActualTypeContainer} element.\n\t *\n\t * @param ctGenericElementReference\n\t * \t\tReference with actual type arguments.\n\t */\n\tpublic void writeActualTypeArguments(CtActualTypeContainer ctGenericElementReference) {\n\t\tfinal Collection<CtTypeReference<?>> arguments = ctGenericElementReference.getActualTypeArguments();\n\t\tif (arguments != null && !arguments.isEmpty()) {\n\t\t\tprintList(arguments.stream().filter(a -> !a.isImplicit())::iterator,\n\t\t\t\tnull, false, \"<\", false, false, \",\", true, false, \">\",\n\t\t\t\targument -> {\n\t\t\t\t\tif (prettyPrinter.getContext().forceWildcardGenerics()) {\n\t\t\t\t\t\tprinter.writeSeparator(\"?\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprettyPrinter.scan(argument);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n\n\tprivate boolean isJavaLangClasses(String importType) {\n\t\treturn importType.matches(\"^(java\\\\.lang\\\\.)[^.]*$\");\n\t}\n\n\t/** writes the imports in a specific order (eg all static imports together */\n\tpublic void writeImports(Collection<CtImport> imports) {\n\t\tSet<String> setImports = new HashSet<>();\n\t\tSet<String> setStaticImports = new HashSet<>();\n\t\tfor (CtImport ctImport : imports) {\n\t\t\tString importTypeStr;\n\t\t\tswitch (ctImport.getImportKind()) {\n\t\t\t\tcase TYPE:\n\t\t\t\t\tCtTypeReference typeRef = (CtTypeReference) ctImport.getReference();\n\t\t\t\t\timportTypeStr = typeRef.getQualifiedName();\n\t\t\t\t\tif (!isJavaLangClasses(importTypeStr)) {\n\t\t\t\t\t\tsetImports.add(this.removeInnerTypeSeparator(importTypeStr));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_TYPES:\n\t\t\t\t\tCtPackageReference packageRef = (CtPackageReference) ctImport.getReference();\n\t\t\t\t\timportTypeStr = packageRef.getQualifiedName() + \".*\";\n\t\t\t\t\tif (!isJavaLangClasses(importTypeStr)) {\n\t\t\t\t\t\tsetImports.add(this.removeInnerTypeSeparator(importTypeStr));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase METHOD:\n\t\t\t\t\tCtExecutableReference execRef = (CtExecutableReference) ctImport.getReference();\n\t\t\t\t\tif (execRef.getDeclaringType() != null) {\n\t\t\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(execRef.getDeclaringType().getQualifiedName()) + \".\" + execRef.getSimpleName());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FIELD:\n\t\t\t\t\tCtFieldReference fieldRef = (CtFieldReference) ctImport.getReference();\n\t\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(fieldRef.getDeclaringType().getQualifiedName()) + \".\" + fieldRef.getSimpleName());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_STATIC_MEMBERS:\n\t\t\t\t\tCtTypeMemberWildcardImportReference typeStarRef = (CtTypeMemberWildcardImportReference) ctImport.getReference();\n\t\t\t\t\timportTypeStr = typeStarRef.getTypeReference().getQualifiedName();\n\t\t\t\t\tif (!isJavaLangClasses(importTypeStr)) {\n\t\t\t\t\t\tsetStaticImports.add(this.removeInnerTypeSeparator(importTypeStr) + \".*\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UNRESOLVED:\n\t\t\t\t\tCtUnresolvedImport unresolvedImport = (CtUnresolvedImport) ctImport;\n\t\t\t\t\timportTypeStr = unresolvedImport.getUnresolvedReference();\n\t\t\t\t\tif (!isJavaLangClasses(importTypeStr)) {\n\t\t\t\t\t\tif (unresolvedImport.isStatic()) {\n\t\t\t\t\t\t\tsetStaticImports.add(importTypeStr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetImports.add(importTypeStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tList<String> sortedImports = new ArrayList<>(setImports);\n\t\tCollections.sort(sortedImports);\n\t\tboolean isFirst = true;\n\t\tfor (String importLine : sortedImports) {\n\t\t\tif (isFirst) {\n\t\t\t\tprinter.writeln();\n\t\t\t\tprinter.writeln();\n\t\t\t\tisFirst = false;\n\t\t\t}\n\t\t\tprinter.writeKeyword(\"import\").writeSpace();\n\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t}\n\t\tif (!setStaticImports.isEmpty()) {\n\t\t\tif (isFirst) {\n\t\t\t\tprinter.writeln();\n\t\t\t}\n\t\t\tprinter.writeln();\n\t\t\tList<String> sortedStaticImports = new ArrayList<>(setStaticImports);\n\t\t\tCollections.sort(sortedStaticImports);\n\t\t\tfor (String importLine : sortedStaticImports) {\n\t\t\t\tprinter.writeKeyword(\"import\").writeSpace().writeKeyword(\"static\").writeSpace();\n\t\t\t\twriteQualifiedName(importLine).writeSeparator(\";\").writeln();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Write the compilation unit header.\n\t */\n\tpublic void writeHeader(List<CtType<?>> types, Collection<CtImport> imports) {\n\t\tif (!types.isEmpty()) {\n\t\t\tfor (CtType<?> ctType : types) {\n\t\t\t\twriteComment(ctType, CommentOffset.TOP_FILE);\n\t\t\t}\n\t\t\t// writing the header package\n\t\t\tif (!types.get(0).getPackage().isUnnamedPackage()) {\n\t\t\t\twritePackageLine(types.get(0).getPackage().getQualifiedName());\n\t\t\t}\n\t\t\tthis.writeImports(imports);\n\t\t\tprinter.writeln();\n\t\t\tprinter.writeln();\n\t\t}\n\t}\n\n\t/**\n\t * Write the compilation unit footer.\n\t */\n\tpublic void writeFooter(List<CtType<?>> types) {\n\t\tif (!types.isEmpty()) {\n\t\t\tfor (CtType<?> ctType : types) {\n\t\t\t\twriteComment(ctType, CommentOffset.BOTTOM_FILE);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void writePackageLine(String packageQualifiedName) {\n\t\tprinter.writeKeyword(\"package\").writeSpace();\n\t\twriteQualifiedName(packageQualifiedName).writeSeparator(\";\").writeln();\n\t}\n\n\tprivate String removeInnerTypeSeparator(String fqn) {\n\t\treturn fqn.replace(CtType.INNERTTYPE_SEPARATOR, \".\");\n\t}\n\n\tpublic void writeComment(CtComment comment) {\n\t\tif (!env.isCommentsEnabled() || comment == null) {\n\t\t\treturn;\n\t\t}\n\t\tprettyPrinter.scan(comment);\n\t\tprinter.writeln();\n\t}\n\n\tprivate void writeComment(List<CtComment> comments) {\n\t\tif (!env.isCommentsEnabled() || comments == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (CtComment comment : comments) {\n\t\t\twriteComment(comment);\n\t\t}\n\t}\n\n\tpublic void writeComment(CtElement element) {\n\t\tif (element == null) {\n\t\t\treturn;\n\t\t}\n\t\twriteComment(element.getComments());\n\t}\n\n\tpublic void writeComment(CtElement element, CommentOffset offset) {\n\t\twriteComment(getComments(element, offset));\n\t}\n\n\tpublic List<CtComment> getComments(CtElement element, CommentOffset offset) {\n\t\tList<CtComment> commentsToPrint = new ArrayList<>();\n\t\tif (!env.isCommentsEnabled() || element == null) {\n\t\t\treturn commentsToPrint;\n\t\t}\n\t\tfor (CtComment comment : element.getComments()) {\n\t\t\tif (comment.getCommentType() == CtComment.CommentType.FILE && offset == CommentOffset.TOP_FILE && element.getPosition().getSourceEnd() > comment.getPosition().getSourceStart()) {\n\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (comment.getCommentType() == CtComment.CommentType.FILE && offset == CommentOffset.BOTTOM_FILE && element.getPosition().getSourceEnd() < comment.getPosition().getSourceStart()) {\n\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (comment.getCommentType() == CtComment.CommentType.FILE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (comment.getPosition().isValidPosition() == false || element.getPosition().isValidPosition() == false) {\n\t\t\t\tif (offset == CommentOffset.BEFORE) {\n\t\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal int line = element.getPosition().getLine();\n\t\t\tfinal int sourceEnd = element.getPosition().getSourceEnd();\n\t\t\tfinal int sourceStart = element.getPosition().getSourceStart();\n\t\t\tif (offset == CommentOffset.BEFORE && (comment.getPosition().getLine() < line || (sourceStart <= comment.getPosition().getSourceStart() && sourceEnd > comment.getPosition().getSourceEnd()))) {\n\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t} else if (offset == CommentOffset.AFTER && (comment.getPosition().getSourceStart() > sourceEnd || comment.getPosition().getSourceEnd() == sourceEnd)) {\n\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t} else {\n\t\t\t\tfinal int endLine = element.getPosition().getEndLine();\n\t\t\t\tif (offset == CommentOffset.INSIDE && comment.getPosition().getLine() >= line && comment.getPosition().getEndLine() <= endLine) {\n\t\t\t\t\tcommentsToPrint.add(comment);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn commentsToPrint;\n\t}\n\n\t/** write all non-implicit parts of a block, with special care for indentation */\n\tpublic void writeIfOrLoopBlock(CtStatement block) {\n\t\tif (block != null) {\n\t\t\tif (!block.isImplicit() && (block instanceof CtBlock || block instanceof CtIf)) {\n\t\t\t\tprinter.writeSpace();\n\t\t\t}\n\t\t\tif (!(block instanceof CtBlock) && !(block instanceof CtIf)) {\n\t\t\t\tprinter.incTab();\n\t\t\t\tprinter.writeln();\n\t\t\t}\n\t\t\twriteStatement(block);\n\t\t\tif (!(block instanceof CtBlock) && !(block instanceof CtIf)) {\n\t\t\t\tprinter.decTab().writeln();\n\t\t\t}\n\t\t\tif (!block.isImplicit()) {\n\t\t\t\tif (!block.isParentInitialized() || (!(block.getParent() instanceof CtFor) && !(block.getParent() instanceof CtForEach) && !(block.getParent() instanceof CtIf))) {\n\t\t\t\t\tprinter.writeSpace();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tprinter.writeSeparator(\";\");\n\t\t}\n\t}\n\t/**\n\t * Creates new handler which assures consistent printing of lists\n\t * prefixed with `start`, separated by `next` and suffixed by `end`\n\t * @param startPrefixSpace if true then `start` token is prefixed with space\n\t * @param start the string which has to be printed at the beginning of the list\n\t * @param startSufficSpace if true then `start` token is suffixed with space\n\t * @param nextPrefixSpace if true then `next` token is prefixed with space\n\t * @param next the string which has to be used as separator before each next item\n\t * @param nextSuffixSpace if true then `next` token is suffixed with space\n\t * @param endPrefixSpace if true then `end` token is prefixed with space\n\t * @param end the string which has to be printed after the list\n\t * @return the {@link ListPrinter} whose {@link ListPrinter#printSeparatorIfAppropriate()} has to be called\n\t * before printing of each item.\n\t */\n\tprivate ListPrinter createListPrinter(boolean startPrefixSpace, String start, boolean startSufficSpace, boolean nextPrefixSpace, String next, boolean nextSuffixSpace, boolean endPrefixSpace, String end) {\n\t\treturn new ListPrinter(printer, startPrefixSpace, start, startSufficSpace, nextPrefixSpace, next, nextSuffixSpace, endPrefixSpace, end);\n\t}\n\n\tprivate static final String QUALIFIED_NAME_SEPARATORS = \".$\";\n\n\t/**\n\t * splits qualified name to primitive tokens and sends them to TokenWriter individually\n\t * @param qualifiedName to be sent qualified name\n\t */\n\tpublic TokenWriter writeQualifiedName(String qualifiedName) {\n\t\tStringTokenizer st = new StringTokenizer(qualifiedName, QUALIFIED_NAME_SEPARATORS, true);\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tString token = st.nextToken();\n\t\t\tif (token.length() == 1 && QUALIFIED_NAME_SEPARATORS.indexOf(token.charAt(0)) >= 0) {\n\t\t\t\tprinter.writeSeparator(token);\n\t\t\t} else {\n\t\t\t\tprinter.writeIdentifier(token);\n\t\t\t}\n\t\t}\n\t\treturn printer;\n\t}\n\n\tprivate PrinterHelper getPrinterHelper() {\n\t\treturn printer.getPrinterHelper();\n\t}\n\n\t/**\n\t * Prints list of elements with defined delimiters using `printer`\n\t * @param iterable the iterable of to be printed elements\n\t * @param startKeyword the optional start keyword. It is always printed if the value is not null\n\t * @param startPrefixSpace if true then `start` token is prefixed with space\n\t * @param start the string which has to be printed at the beginning of the list\n\t * @param startSuffixSpace if true then `start` token is suffixed with space\n\t * @param nextPrefixSpace if true then `next` token is prefixed with space\n\t * @param next the string which has to be used as separator before each next item\n\t * @param nextSuffixSpace if true then `next` token is suffixed with space\n\t * @param endPrefixSpace if true then `end` token is prefixed with space\n\t * @param end the string which has to be printed after the list\n\t * @param elementPrinter the {@link Consumer}, which is called once for each printer element of the `iterable`\n\t */\n\tpublic <T> void printList(Iterable<T> iterable,\n\t\t\tString startKeyword,\n\t\t\tboolean startPrefixSpace, String start, boolean startSuffixSpace,\n\t\t\tboolean nextPrefixSpace, String next, boolean nextSuffixSpace,\n\t\t\tboolean endPrefixSpace, String end,\n\t\t\tConsumer<T> elementPrinter) {\n\n\t\tif (startKeyword != null) {\n\t\t\tprinter.writeSpace().writeKeyword(startKeyword).writeSpace();\n\t\t}\n\t\ttry (spoon.reflect.visitor.ListPrinter lp = createListPrinter(\n\t\t\t\tstartPrefixSpace, start, startSuffixSpace,\n\t\t\t\tnextPrefixSpace, next, nextSuffixSpace,\n\t\t\t\tendPrefixSpace, end\n\t\t\t)) {\n\t\t\tfor (T item : iterable) {\n\t\t\t\tlp.printSeparatorIfAppropriate();\n\t\t\t\telementPrinter.accept(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CommentHelper.java",
      "weight" : 97.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.support.Internal;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\n\n/**\n * Computes source code representation of the Comment literal\n */\n@Internal\npublic class CommentHelper {\n\n\t/**\n\t * RegExp which matches all possible line separators\n\t */\n\tprivate static final Pattern LINE_SEPARATORS_RE = Pattern.compile(\"\\\\n\\\\r|\\\\n|\\\\r\");\n\n\tprivate CommentHelper() {\n\t}\n\n\t/** returns a pretty-printed version of a comment, with prefix, suffix, and intermediate prefix for block and Javadoc */\n\tpublic static String printComment(CtComment comment) {\n\t\tPrinterHelper ph = new PrinterHelper(comment.getFactory().getEnvironment());\n\t\t// now we only use one single method to print all tags\n\t\tprintCommentContent(ph, comment, s -> { return  s; });\n\t\treturn ph.toString();\n\t}\n\n\n\tstatic void printComment(PrinterHelper printer, CtComment comment) {\n\t\tCtComment.CommentType commentType = comment.getCommentType();\n\t\tString content = comment.getContent();\n\t\t// prefix\n\t\tswitch (commentType) {\n\t\tcase FILE:\n\t\t\tprinter.write(DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n\t\t\tbreak;\n\t\tcase JAVADOC:\n\t\t\tprinter.write(DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n\t\t\tbreak;\n\t\tcase INLINE:\n\t\t\tprinter.write(DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n\t\t\tbreak;\n\t\tcase BLOCK:\n\t\t\tprinter.write(DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n\t\t\tbreak;\n\t\t}\n\t\t// content\n\t\tswitch (commentType) {\n\t\t\tcase INLINE:\n\t\t\t\tprinter.write(content);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// per line suffix\n\t\t\t\tprintCommentContent(printer, comment, s -> { return (\" * \" + s).replaceAll(\" *$\", \"\"); });\n\t\t}\n\t\t// suffix\n\t\tswitch (commentType) {\n\t\t\tcase BLOCK:\n\t\t\t\tprinter.write(DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n\t\t\t\tbreak;\n\t\t\tcase FILE:\n\t\t\t\tprinter.write(DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n\t\t\t\tbreak;\n\t\t\tcase JAVADOC:\n\t\t\t\tprinter.write(DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tstatic void printCommentContent(PrinterHelper printer, CtComment comment, Function<String, String> transfo) {\n\t\tCtComment.CommentType commentType = comment.getCommentType();\n\t\tString content = comment.getContent();\n\t\tString[] lines = LINE_SEPARATORS_RE.split(content);\n\t\tfor (String com : lines) {\n\t\t\tif (commentType == CtComment.CommentType.BLOCK) {\n\t\t\t\tprinter.write(com);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tprinter.write(CtComment.LINE_SEPARATOR);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprinter.write(transfo.apply(com)).writeln(); // removing spaces at the end of the space\n\t\t\t}\n\t\t}\n\t\tif (comment instanceof CtJavaDoc) {\n\t\t\tList<CtJavaDocTag> tags = null;\n\t\t\tCollection<CtJavaDocTag> javaDocTags = ((CtJavaDoc) comment).getTags();\n\t\t\tif (javaDocTags != null && javaDocTags.isEmpty() == false) {\n\t\t\t\tprinter.write(transfo.apply(\"\")).writeln();\n\t\t\t\tfor (CtJavaDocTag docTag : javaDocTags) {\n\t\t\t\t\tprintJavaDocTag(printer, docTag, transfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void printJavaDocTag(PrinterHelper printer, CtJavaDocTag docTag, Function<String, String> transfo) {\n\t\tprinter.write(transfo.apply(CtJavaDocTag.JAVADOC_TAG_PREFIX));\n\t\tprinter.write(docTag.getType().name().toLowerCase());\n\t\tprinter.write(\" \");\n\t\tif (docTag.getType().hasParam()) {\n\t\t\tprinter.write(docTag.getParam()).writeln();\n\t\t}\n\n\t\tString[] tagLines = LINE_SEPARATORS_RE.split(docTag.getContent());\n\t\tfor (int i = 0; i < tagLines.length; i++) {\n\t\t\tString com = tagLines[i];\n\t\t\tif (docTag.getType().hasParam()) {\n\t\t\t\tprinter.write(transfo.apply(\"\\t\\t\"));\n\t\t\t}\n\t\t\tprinter.write(com.trim()).writeln();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/printer/CommentOffset.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.printer;\n\npublic enum CommentOffset {\n\tBOTTOM_FILE,\n\tTOP_FILE,\n\tBEFORE,\n\tAFTER,\n\tINSIDE\n}\n"
    }, {
      "name" : "reflect/visitor/ImportScanner.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtReference;\nimport spoon.support.Experimental;\n\nimport java.util.Set;\n\n/**\n * Used to compute the imports required to write readable code with no fully qualified names.\n * The import scanner API might still change in future release, that's why it is marked as experimental.\n */\n@Experimental\npublic interface ImportScanner {\n\n\t/**\n\t * Computes import of a {@link spoon.reflect.declaration.CtElement}\n\t */\n\tvoid computeImports(CtElement element);\n\n\t/**\n\t * Use computeImports or computeAllImports before getting the different imports.\n\t *\n\t * @return the list of computed imports or an empty collection if not imports has been computed.\n\t */\n\tSet<CtImport> getAllImports();\n\n\t/**\n\t * Checks if the type is already imported.\n\t */\n\tboolean isImported(CtReference ref);\n\n\t/**\n\t * Specify the original imports to use before computing new imports.\n\t */\n\tvoid initWithImports(Iterable<CtImport> importCollection);\n}\n"
    }, {
      "name" : "reflect/visitor/LiteralHelper.java",
      "weight" : 95.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.cu.SourcePosition;\n\n/**\n * Computes source code representation of the literal\n */\nabstract class LiteralHelper {\n\n\tprivate LiteralHelper() {\n\t}\n\n\t/**\n\t * @param literal to be converted literal\n\t * @return source code representation of the literal\n\t */\n\tpublic static <T> String getLiteralToken(CtLiteral<T> literal) {\n\t\tif (literal.getValue() == null) {\n\t\t\treturn \"null\";\n\t\t} else if (literal.getValue() instanceof Long) {\n\t\t\treturn literal.getValue() + \"L\";\n\t\t} else if (literal.getValue() instanceof Float) {\n\t\t\treturn literal.getValue() + \"F\";\n\t\t} else if (literal.getValue() instanceof Character) {\n\n\t\t\tboolean mayContainsSpecialCharacter = true;\n\n\t\t\tSourcePosition position = literal.getPosition();\n\t\t\tif (position.isValidPosition()) {\n\t\t\t\t// the size of the string in the source code, the -1 is the size of the ' or \" in the source code\n\t\t\t\tint stringLength = position.getSourceEnd() - position.getSourceStart() - 1;\n\t\t\t\t// if the string in the source is not the same as the string in the literal, the string may contains special characters\n\t\t\t\tmayContainsSpecialCharacter = stringLength != 1;\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder(10);\n\t\t\tsb.append('\\'');\n\t\t\tappendCharLiteral(sb, (Character) literal.getValue(), mayContainsSpecialCharacter);\n\t\t\tsb.append('\\'');\n\t\t\treturn sb.toString();\n\t\t} else if (literal.getValue() instanceof String) {\n\t\t\tboolean mayContainsSpecialCharacters = true;\n\n\t\t\tSourcePosition position = literal.getPosition();\n\t\t\tif (position.isValidPosition()) {\n\t\t\t\t// the size of the string in the source code, the -1 is the size of the ' or \" in the source code\n\t\t\t\tint stringLength = position.getSourceEnd() - position.getSourceStart() - 1;\n\t\t\t\t// if the string in the source is not the same as the string in the literal, the string may contains special characters\n\t\t\t\tmayContainsSpecialCharacters = ((String) literal.getValue()).length() != stringLength;\n\t\t\t}\n\t\t\treturn \"\\\"\" + getStringLiteral((String) literal.getValue(), mayContainsSpecialCharacters) + \"\\\"\";\n\t\t} else if (literal.getValue() instanceof Class) {\n\t\t\treturn ((Class<?>) literal.getValue()).getName();\n\t\t} else {\n\t\t\treturn literal.getValue().toString();\n\t\t}\n\t}\n\n\tstatic void appendCharLiteral(StringBuilder sb, Character c, boolean mayContainsSpecialCharacter) {\n\t\tif (!mayContainsSpecialCharacter) {\n\t\t\tsb.append(c);\n\t\t} else if (Character.UnicodeBlock.of(c) != Character.UnicodeBlock.BASIC_LATIN) {\n\t\t\tif (c < 0x10) {\n\t\t\t\tsb.append(\"\\\\u000\" + Integer.toHexString(c));\n\t\t\t} else if (c < 0x100) {\n\t\t\t\tsb.append(\"\\\\u00\" + Integer.toHexString(c));\n\t\t\t} else if (c < 0x1000) {\n\t\t\t\tsb.append(\"\\\\u0\" + Integer.toHexString(c));\n\t\t\t} else {\n\t\t\t\tsb.append(\"\\\\u\" + Integer.toHexString(c));\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (c) {\n\t\t\t\tcase '\\b':\n\t\t\t\t\tsb.append(\"\\\\b\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\t':\n\t\t\t\t\tsb.append(\"\\\\t\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\t\tsb.append(\"\\\\n\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\f':\n\t\t\t\t\tsb.append(\"\\\\f\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\r':\n\t\t\t\t\tsb.append(\"\\\\r\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\"':\n\t\t\t\t\tsb.append(\"\\\\\\\"\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\'':\n\t\t\t\t\tsb.append(\"\\\\'\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\': // take care not to display the escape as a potential\n\t\t\t\t\t// real char\n\t\t\t\t\tsb.append(\"\\\\\\\\\"); //$NON-NLS-1$\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsb.append(Character.isISOControl(c) ? String.format(\"\\\\u%04x\", (int) c) : Character.toString(c));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic String getStringLiteral(String value, boolean mayContainsSpecialCharacter) {\n\t\tif (!mayContainsSpecialCharacter) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tStringBuilder sb = new StringBuilder(value.length() * 2);\n\t\t\tfor (int i = 0; i < value.length(); i++) {\n\t\t\t\tappendCharLiteral(sb, value.charAt(i), mayContainsSpecialCharacter);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CacheBasedConflictFinder.java",
      "weight" : 44.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\n\n/** Caches some field and nested type names */\npublic class CacheBasedConflictFinder {\n\tCtType<?> type;\n\tCtTypeReference<?> typeRef;\n\tSet<String> cachedFieldNames;\n\tSet<String> cachedNestedTypeNames;\n\n\tCacheBasedConflictFinder(CtType<?> p_type) {\n\t\ttype = p_type;\n\t\ttypeRef = type.getReference();\n\t}\n\n\t/** returns true if the given name is a field name */\n\tpublic boolean hasFieldConflict(String name) {\n\t\tif (cachedFieldNames == null) {\n\t\t\tCollection<CtFieldReference<?>> allFields = type.getAllFields();\n\t\t\tcachedFieldNames = new HashSet<>(allFields.size());\n\t\t\tfor (CtFieldReference<?> field : allFields) {\n\t\t\t\tcachedFieldNames.add(field.getSimpleName());\n\t\t\t}\n\t\t}\n\t\treturn cachedFieldNames.contains(name);\n\t}\n\n\t/** returns true if the given name is a nested type name */\n\tpublic boolean hasNestedTypeConflict(String name) {\n\t\tif (cachedNestedTypeNames == null) {\n\t\t\tCollection<CtType<?>> allTypes = type.getNestedTypes();\n\t\t\tcachedNestedTypeNames = new HashSet<>(allTypes.size());\n\t\t\tfor (CtType<?> t : allTypes) {\n\t\t\t\tcachedNestedTypeNames.add(t.getSimpleName());\n\t\t\t}\n\t\t}\n\t\treturn cachedNestedTypeNames.contains(name);\n\t}\n\n\tpublic String getSimpleName() {\n\t\treturn typeRef.getSimpleName();\n\t}\n\n\tpublic CtPackageReference getPackage() {\n\t\treturn typeRef.getPackage();\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/OperatorHelper.java",
      "weight" : 82.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.UnaryOperatorKind;\n\n/**\n * Computes source code representation of the operator\n */\nclass OperatorHelper {\n\n\tprivate OperatorHelper() {\n\t}\n\n\tpublic static boolean isPrefixOperator(UnaryOperatorKind o) {\n\t\treturn isSufixOperator(o) == false;\n\t}\n\tpublic static boolean isSufixOperator(UnaryOperatorKind o) {\n\t\treturn o.name().startsWith(\"POST\");\n\t}\n\n\t/**\n\t * @return java source code representation of a pre or post unary operator.\n\t */\n\tpublic static String getOperatorText(UnaryOperatorKind o) {\n\t\tswitch (o) {\n\t\t\tcase POS:\n\t\t\t\treturn \"+\";\n\t\t\tcase NEG:\n\t\t\t\treturn \"-\";\n\t\t\tcase NOT:\n\t\t\t\treturn \"!\";\n\t\t\tcase COMPL:\n\t\t\t\treturn \"~\";\n\t\t\tcase PREINC:\n\t\t\t\treturn \"++\";\n\t\t\tcase PREDEC:\n\t\t\t\treturn \"--\";\n\t\t\tcase POSTINC:\n\t\t\t\treturn \"++\";\n\t\t\tcase POSTDEC:\n\t\t\t\treturn \"--\";\n\t\t\tdefault:\n\t\t\t\tthrow new SpoonException(\"Unsupported operator \" + o.name());\n\t\t}\n\t}\n\n\t/**\n\t * @return java source code representation of a binary operator.\n\t */\n\tpublic static String getOperatorText(BinaryOperatorKind o) {\n\t\tswitch (o) {\n\t\t\tcase OR:\n\t\t\t\treturn \"||\";\n\t\t\tcase AND:\n\t\t\t\treturn \"&&\";\n\t\t\tcase BITOR:\n\t\t\t\treturn \"|\";\n\t\t\tcase BITXOR:\n\t\t\t\treturn \"^\";\n\t\t\tcase BITAND:\n\t\t\t\treturn \"&\";\n\t\t\tcase EQ:\n\t\t\t\treturn \"==\";\n\t\t\tcase NE:\n\t\t\t\treturn \"!=\";\n\t\t\tcase LT:\n\t\t\t\treturn \"<\";\n\t\t\tcase GT:\n\t\t\t\treturn \">\";\n\t\t\tcase LE:\n\t\t\t\treturn \"<=\";\n\t\t\tcase GE:\n\t\t\t\treturn \">=\";\n\t\t\tcase SL:\n\t\t\t\treturn \"<<\";\n\t\t\tcase SR:\n\t\t\t\treturn \">>\";\n\t\t\tcase USR:\n\t\t\t\treturn \">>>\";\n\t\t\tcase PLUS:\n\t\t\t\treturn \"+\";\n\t\t\tcase MINUS:\n\t\t\t\treturn \"-\";\n\t\t\tcase MUL:\n\t\t\t\treturn \"*\";\n\t\t\tcase DIV:\n\t\t\t\treturn \"/\";\n\t\t\tcase MOD:\n\t\t\t\treturn \"%\";\n\t\t\tcase INSTANCEOF:\n\t\t\t\treturn \"instanceof\";\n\t\t\tdefault:\n\t\t\t\tthrow new SpoonException(\"Unsupported operator \" + o.name());\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/Query.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.chain.CtFunction;\nimport spoon.reflect.visitor.filter.TypeFilter;\n\nimport java.util.List;\n\n/**\n * This class provides some useful methods to retrieve program elements and\n * reference through a {@link spoon.reflect.visitor.CtScanner}-based deep\n * search. It uses the {@link spoon.reflect.visitor.Filter} facility to select the right\n * elements or references.\n */\npublic abstract class Query {\n\n\tprivate Query() {\n\t}\n\n\t/**\n\t * Within a given factory, returns all the program elements that match the\n\t * filter.\n\t *\n\t * @param <E>\n\t * \t\tthe type of the sought program elements\n\t * @param factory\n\t * \t\tthe factory that contains the elements where to recursive\n\t * \t\tsearch on\n\t * @param filter\n\t * \t\tthe filter which defines the matching criteria\n\t */\n\tpublic static <E extends CtElement> List<E> getElements(Factory factory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFilter<E> filter) {\n\t\treturn getElements(factory.Package().getRootPackage(), filter);\n\t}\n\n\t/**\n\t * Returns all the program elements that match the filter starting from the given rootElement.\n\t * Use {@link spoon.reflect.visitor.chain.CtQueryable#map(CtFunction)} if you need more control on the scanning context of the Filter.\n\t *\n\t * @param <E>\n\t * \t\tthe type of the sought program elements\n\t * @param rootElement\n\t * \t\tthe element to start the recursive search on\n\t * @param filter\n\t * \t\tthe filter which defines the matching criteria\n\t */\n\tpublic static <E extends CtElement> List<E> getElements(\n\t\t\tCtElement rootElement, Filter<E> filter) {\n\t\treturn rootElement.filterChildren(filter).list();\n\t}\n\n\t/**\n\t * Returns all the program element references that match the filter.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the sought program element references\n\t * @param rootElement\n\t * \t\tthe element to start the recursive search on\n\t * @param filter\n\t * \t\tthe filter which defines the matching criteria\n\t *\n\t */\n\tpublic static <T extends CtReference> List<T> getReferences(\n\t\t\tCtElement rootElement, Filter<T> filter) {\n\t\t// note that the new TypeFilter<>(CtReference.class) should not be necessary\n\t\t// thanks to using <T extends CtReference>\n\t\t// however, playing safe to satisfy contract in case of type erasure\n\t\treturn rootElement.filterChildren(new TypeFilter<>(CtReference.class)).filterChildren(filter).list();\n\t}\n\n\t/**\n\t * Within a given factory, returns all the program element references that\n\t * match the filter.\n\t *\n\t * @param <R>\n\t * \t\tthe type of the sought program element references\n\t * @param factory\n\t * \t\tthe factory that contains the references where to recursive\n\t * \t\tsearch on\n\t * @param filter\n\t * \t\tthe filter which defines the matching criteria\n\t */\n\tpublic static <R extends CtReference> List<R> getReferences(\n\t\t\tFactory factory, Filter<R> filter) {\n\t\treturn getReferences(factory.Package().getRootPackage(), filter);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/PrintingContext.java",
      "weight" : 128.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class PrintingContext {\n\n\tprivate long NEXT_FOR_VARIABLE       = 1 << 0;\n\tprivate long IGNORE_GENERICS         = 1 << 1;\n\tprivate long SKIP_ARRAY              = 1 << 2;\n\tprivate long IGNORE_STATIC_ACCESS    = 1 << 3;\n\tprivate long IGNORE_ENCLOSING_CLASS  = 1 << 4;\n\tprivate long FORCE_WILDCARD_GENERICS = 1 << 5;\n\tprivate long FIRST_FOR_VARIABLE      = 1 << 6;\n\n\tprivate long state;\n\tprivate CtStatement statement;\n\n\t/**\n\t * @return true if we are printing first variable declaration of CtFor statement\n\t */\n\tpublic boolean isFirstForVariable() {\n\t\treturn (state & FIRST_FOR_VARIABLE) != 0L;\n\t}\n\n\t/**\n\t * @return true if we are printing second or next variable declaration of CtFor statement\n\t */\n\tpublic boolean isNextForVariable() {\n\t\treturn (state & NEXT_FOR_VARIABLE) != 0L;\n\t}\n\n\tpublic boolean ignoreGenerics() {\n\t\treturn (state & IGNORE_GENERICS) != 0L;\n\t}\n\n\tpublic boolean skipArray() {\n\t\treturn (state & SKIP_ARRAY) != 0L;\n\t}\n\n\tpublic boolean ignoreStaticAccess() {\n\t\treturn (state & IGNORE_STATIC_ACCESS) != 0L;\n\t}\n\n\tpublic boolean ignoreEnclosingClass() {\n\t\treturn (state & IGNORE_ENCLOSING_CLASS) != 0L;\n\t}\n\n\tpublic boolean forceWildcardGenerics() {\n\t\treturn (state & FORCE_WILDCARD_GENERICS) != 0L;\n\t}\n\n\t/**\n\t * @return true if `stmt` has to be handled as statement in current printing context\n\t */\n\tpublic boolean isStatement(CtStatement stmt) {\n\t\treturn this.statement == stmt;\n\t}\n\n\tpublic class Writable implements AutoCloseable {\n\t\tprivate long oldState;\n\t\tprivate CtStatement oldStatement;\n\n\t\tprotected Writable() {\n\t\t\toldState = state;\n\t\t\toldStatement = statement;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tstate = oldState;\n\t\t\tstatement = oldStatement;\n\t\t}\n\n\t\t/**\n\t\t * @param v use true if printing first variable declaration of CtFor statement\n\t\t */\n\t\tpublic <T extends Writable> T isFirstForVariable(boolean v) {\n\t\t\tsetState(FIRST_FOR_VARIABLE, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\t/**\n\t\t * @param v use true if printing second or next variable declaration of CtFor statement\n\t\t */\n\t\tpublic <T extends Writable> T isNextForVariable(boolean v) {\n\t\t\tsetState(NEXT_FOR_VARIABLE, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tpublic <T extends Writable> T ignoreGenerics(boolean v) {\n\t\t\tsetState(IGNORE_GENERICS, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tpublic <T extends Writable> T skipArray(boolean v) {\n\t\t\tsetState(SKIP_ARRAY, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tpublic <T extends Writable> T ignoreStaticAccess(boolean v) {\n\t\t\tsetState(IGNORE_STATIC_ACCESS, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tpublic <T extends Writable> T ignoreEnclosingClass(boolean v) {\n\t\t\tsetState(IGNORE_ENCLOSING_CLASS, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tpublic <T extends Writable> T forceWildcardGenerics(boolean v) {\n\t\t\tsetState(FORCE_WILDCARD_GENERICS, v);\n\t\t\treturn (T) this;\n\t\t}\n\n\t\t/**\n\t\t * There are statements (e.g. invocation), which may play role of expression too.\n\t\t * They have to be suffixed by semicolon depending on the printing context.\n\t\t * Call this method to inform printer that invocation is used as statement.\n\t\t *\n\t\t * @param stmt the instance of the actually printed statement.\n\t\t * Such statement will be finished by semicolon.\n\t\t */\n\t\tpublic <T extends Writable> T setStatement(CtStatement stmt) {\n\t\t\tstatement = stmt;\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tprivate void setState(long mask, boolean v) {\n\t\t\tstate = v ? state | mask : state & ~mask;\n\t\t}\n\t}\n\n\tpublic Writable modify() {\n\t\treturn new Writable();\n\t}\n\n\tDeque<CacheBasedConflictFinder> currentThis = new ArrayDeque<>();\n\n\t/**\n\t * @return top level type\n\t */\n\tpublic CtTypeReference<?> getCurrentTypeReference() {\n\t\tif (currentTopLevel != null) {\n\t\t\tCacheBasedConflictFinder tc = getCurrentTypeContext();\n\t\t\tif (tc != null) {\n\t\t\t\treturn tc.typeRef;\n\t\t\t}\n\t\t\treturn currentTopLevel.getReference();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate CacheBasedConflictFinder getCurrentTypeContext() {\n\t\tif (currentThis != null && !currentThis.isEmpty()) {\n\t\t\treturn currentThis.peek();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void pushCurrentThis(CtType<?> type) {\n\t\tcurrentThis.push(new CacheBasedConflictFinder(type));\n\t}\n\n\tpublic void popCurrentThis() {\n\t\tcurrentThis.pop();\n\t}\n\n\n\tDeque<CtElement> elementStack = new ArrayDeque<>();\n\n\tDeque<CtExpression<?>> parenthesedExpression = new ArrayDeque<>();\n\n\tCtType<?> currentTopLevel;\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"context.ignoreGenerics: \" + ignoreGenerics() + \"\\n\";\n\t}\n\n\t/**\n\t * @param typeRef\n\t * @return true if typeRef is equal to current (actually printed) Type (currentThis)\n\t */\n\tpublic boolean isInCurrentScope(CtTypeReference<?> typeRef) {\n\t\tCtTypeReference<?> currentTypeRef = getCurrentTypeReference();\n\t\treturn typeRef.equals(currentTypeRef);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/TypeNameScope.java",
      "weight" : 149.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtImportKind;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.filter.AllTypeMembersFunction;\n\n/**\n * Represents a lexical scope of a type, with all accessible fields, nested type names and method names\n */\nclass TypeNameScope extends NameScopeImpl {\n\tprivate Map<String, CtNamedElement> fieldsByName;\n\tprivate Map<String, CtNamedElement> typesByName;\n\tprivate Map<String, CtNamedElement> methodsByName;\n\n\tTypeNameScope(LexicalScope conflictFinder, CtType<?> p_type) {\n\t\tsuper(conflictFinder, p_type);\n\t}\n\n\t@Override\n\tpublic <T> T forEachElementByName(String name, Function<? super CtNamedElement, T> consumer) {\n\t\tsuper.forEachElementByName(name, consumer);\n\t\tassureCacheInitialized();\n\t\tT r = forEachByName(fieldsByName, name, consumer);\n\t\tif (r != null) {\n\t\t\treturn r;\n\t\t}\n\t\tr = forEachByName(typesByName, name, consumer);\n\t\tif (r != null) {\n\t\t\treturn r;\n\t\t}\n\t\tr = forEachByName(methodsByName, name, consumer);\n\t\tif (r != null) {\n\t\t\treturn r;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void putType(CtType<?> t) {\n\t\tputIfNotExists(typesByName, t);\n\t}\n\tprivate void assureCacheInitialized() {\n\t\tif (fieldsByName == null) {\n\t\t\t//collect names of type members which are visible in this type\n\t\t\tfieldsByName = new HashMap<>();\n\t\t\ttypesByName = new HashMap<>();\n\t\t\tmethodsByName = new HashMap<>();\n\t\t\tCtType<?> type = (CtType<?>) getScopeElement();\n\t\t\ttype.map(new AllTypeMembersFunction().setMode(AllTypeMembersFunction.Mode.SKIP_PRIVATE)).forEach((CtTypeMember typeMember) -> {\n\t\t\t\t//the local members are visited first. Then members of super types/interfaces\n\t\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\t\tputIfNotExists(fieldsByName, (CtField<?>) typeMember);\n\t\t\t\t} else if (typeMember instanceof CtType) {\n\t\t\t\t\tputType((CtType<?>) typeMember);\n\t\t\t\t} else if (typeMember instanceof CtMethod) {\n\t\t\t\t\tputIfNotExists(methodsByName, (CtMethod<?>) typeMember);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (type.isTopLevel()) {\n\t\t\t\tCtCompilationUnit cu = type.getPosition().getCompilationUnit();\n\t\t\t\tif (cu != null) {\n\t\t\t\t\t//add types and static fields and methods from compilation unit\n\t\t\t\t\taddCompilationUnitNames(cu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * sort wildcard imports as last. The wildcard import of type has lower priority then explicit import of type\n\t */\n\tprivate static final Comparator<CtImport> importComparator = new Comparator<CtImport>() {\n\t\t@Override\n\t\tpublic int compare(CtImport o1, CtImport o2) {\n\t\t\tCtImportKind k1 = o1.getImportKind();\n\t\t\tCtImportKind k2 = o2.getImportKind();\n\t\t\treturn getOrderOfImportKind(k1) - getOrderOfImportKind(k2);\n\t\t}\n\n\t\tprivate int getOrderOfImportKind(CtImportKind ik) {\n\t\t\tswitch (ik) {\n\t\t\tcase ALL_STATIC_MEMBERS:\n\t\t\t\treturn 2;\n\t\t\tcase ALL_TYPES:\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tprivate void addCompilationUnitNames(CtCompilationUnit compilationUnit) {\n\t\tCtType<?> type = (CtType<?>) getScopeElement();\n\t\tCtTypeReference<?> typeRef = type.getReference();\n\t\t//all imported types and static members are visible too\n\t\tcompilationUnit.getImports().stream().sorted(importComparator).forEach(aImport -> {\n\t\t\taImport.accept(new CtImportVisitor() {\n\t\t\t\t@Override\n\t\t\t\tpublic <T> void visitTypeImport(CtTypeReference<T> typeReference) {\n\t\t\t\t\tputType(typeReference.getTypeDeclaration());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic <T> void visitMethodImport(CtExecutableReference<T> executableReference) {\n\t\t\t\t\tputIfNotExists(methodsByName, executableReference.getExecutableDeclaration());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic <T> void visitFieldImport(CtFieldReference<T> fieldReference) {\n\t\t\t\t\tputIfNotExists(fieldsByName, fieldReference.getFieldDeclaration());\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void visitAllTypesImport(CtPackageReference packageReference) {\n\t\t\t\t\tCtPackage pack = packageReference.getDeclaration();\n\t\t\t\t\tif (pack != null) {\n\t\t\t\t\t\tfor (CtType<?> type : pack.getTypes()) {\n\t\t\t\t\t\t\t//add only types which are not yet imported. Explicit import wins over wildcard import\n\t\t\t\t\t\t\tputType(type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic <T> void visitAllStaticMembersImport(CtTypeMemberWildcardImportReference typeReference) {\n\t\t\t\t\tCtType<?> type = typeReference.getDeclaration();\n\t\t\t\t\ttype.map(new AllTypeMembersFunction().setMode(AllTypeMembersFunction.Mode.SKIP_PRIVATE)).forEach((CtTypeMember typeMember) -> {\n\t\t\t\t\t\tif (typeMember.isStatic() && typeRef.canAccess(typeMember)) {\n\t\t\t\t\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\t\t\t\t\tputIfNotExists(fieldsByName, typeMember);\n\t\t\t\t\t\t\t} else if (typeMember instanceof CtMethod) {\n\t\t\t\t\t\t\t\tputIfNotExists(methodsByName, typeMember);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t//names of all types of same package are visible too, but with lower priority then explicitly imported elements\n\t\tCtPackage pack = compilationUnit.getDeclaredPackage();\n\t\tif (pack != null) {\n\t\t\tfor (CtType<?> packageType : pack.getTypes()) {\n\t\t\t\tif (packageType != getScopeElement() && !typesByName.containsKey(packageType.getSimpleName())) {\n\t\t\t\t\ttypesByName.put(packageType.getSimpleName(), packageType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//assures that type members nearer to local type are used\n\tprivate <T extends CtNamedElement> void putIfNotExists(Map<String, T> map, T element) {\n\t\tif (element == null) {\n\t\t\t//noclasspath mode. Ignore that.\n\t\t\treturn;\n\t\t}\n\t\tString name = element.getSimpleName();\n\t\tif (!map.containsKey(name)) {\n\t\t\tmap.put(name, element);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/AccessibleVariablesFinder.java",
      "weight" : 118.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Find local variables catch, parameters, fields, super fields\n * @author tdurieux\n */\npublic class AccessibleVariablesFinder {\n\n\tprivate CtElement expression;\n\n\tpublic AccessibleVariablesFinder(CtElement expression) {\n\t\tthis.expression = expression;\n\t}\n\n\tpublic List<CtVariable> find() {\n\t\tif (expression.isParentInitialized()) {\n\t\t\treturn getVariable(expression.getParent());\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tprivate List<CtVariable> getVariable(final CtElement parent) {\n\t\tfinal List<CtVariable> variables = new ArrayList<>();\n\t\tif (parent == null) {\n\t\t\treturn variables;\n\t\t}\n\t\tclass VariableScanner extends CtInheritanceScanner {\n\t\t\t@Override\n\t\t\tpublic void visitCtStatementList(CtStatementList e) {\n\t\t\t\tfor (int i = 0; i < e.getStatements().size(); i++) {\n\t\t\t\t\tCtStatement ctStatement = e.getStatements().get(i);\n\n\t\t\t\t\tif (expression.getPosition().isValidPosition() && ctStatement.getPosition().isValidPosition()\n\t\t\t\t\t\t\t&& ctStatement.getPosition().getSourceStart() > expression.getPosition().getSourceEnd()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ctStatement instanceof CtVariable) {\n\t\t\t\t\t\tvariables.add((CtVariable) ctStatement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.visitCtStatementList(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void scanCtType(CtType<T> type) {\n\t\t\t\tList<CtField<?>> fields = type.getFields();\n\t\t\t\tfor (CtField<?> ctField : fields) {\n\t\t\t\t\tif (ctField.hasModifier(ModifierKind.PUBLIC) || ctField.hasModifier(ModifierKind.PROTECTED)) {\n\t\t\t\t\t\tvariables.add(ctField);\n\t\t\t\t\t} else if (ctField.hasModifier(ModifierKind.PRIVATE)) {\n\t\t\t\t\t\tif (expression.hasParent(type)) {\n\t\t\t\t\t\t\tvariables.add(ctField);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (expression.getParent(CtPackage.class).equals(type.getParent(CtPackage.class))) {\n\t\t\t\t\t\t// default visibility\n\t\t\t\t\t\tvariables.add(ctField);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCtTypeReference<?> superclass = type.getSuperclass();\n\t\t\t\tif (superclass != null) {\n\t\t\t\t\tvariables.addAll(getVariable(superclass.getTypeDeclaration()));\n\t\t\t\t}\n\t\t\t\tSet<CtTypeReference<?>> superInterfaces = type.getSuperInterfaces();\n\t\t\t\tfor (CtTypeReference<?> typeReference : superInterfaces) {\n\t\t\t\t\tvariables.addAll(getVariable(typeReference.getTypeDeclaration()));\n\t\t\t\t}\n\t\t\t\tsuper.scanCtType(type);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtTryWithResource(CtTryWithResource e) {\n\t\t\t\tvariables.addAll(e.getResources());\n\t\t\t\tsuper.visitCtTryWithResource(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void scanCtExecutable(CtExecutable e) {\n\t\t\t\tvariables.addAll(e.getParameters());\n\t\t\t\tsuper.scanCtExecutable(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtFor(CtFor e) {\n\t\t\t\tfor (CtStatement ctStatement : e.getForInit()) {\n\t\t\t\t\tthis.scan(ctStatement);\n\t\t\t\t}\n\t\t\t\tsuper.visitCtFor(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtForEach(CtForEach e) {\n\t\t\t\tvariables.add(e.getVariable());\n\t\t\t\tsuper.visitCtForEach(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtMethod(CtMethod e) {\n\t\t\t\tthis.scan(e.getBody());\n\t\t\t\tsuper.visitCtMethod(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtLocalVariable(CtLocalVariable e) {\n\t\t\t\tvariables.add(e);\n\t\t\t\tsuper.visitCtLocalVariable(e);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtCatch(CtCatch e) {\n\t\t\t\tvariables.add(e.getParameter());\n\n\t\t\t\tsuper.visitCtCatch(e);\n\t\t\t}\n\t\t}\n\n\t\tnew VariableScanner().scan(parent);\n\n\t\treturn variables;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtBFSIterator.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.ArrayDeque;\nimport java.util.Iterator;\n/**\n * A class to be able to iterate over the children elements in the tree of a given node, in breadth-first order.\n */\npublic class CtBFSIterator extends CtScanner implements Iterator<CtElement> {\n\n\n\t/**\n\t * A deque containing the elements the iterator has seen but not expanded\n\t */\n\tprivate ArrayDeque<CtElement> deque = new ArrayDeque<>();\n\n\t/**\n\t * CtIterator constructor, prepares the iterator from the @root node\n\t *\n\t * @param root the initial node to expand\n\t */\n\tpublic CtBFSIterator(CtElement root) {\n\t\tif (root != null) {\n\t\t\tdeque.add(root);\n\t\t}\n\t}\n\n\t/**\n\t * prevent scanner from going down the tree, instead save with other CtElement children of the current node\n\t *\n\t * @param element the next direct child of the current node being expanded\n\t */\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\tdeque.add(element);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn !deque.isEmpty();\n\t}\n\n\t/**\n\t * Dereference the \"iterator\"\n\t *\n\t * @return CtElement the next element in BFS order without going down the tree\n\t */\n\t@Override\n\tpublic CtElement next() {\n\t\tCtElement next = deque.poll(); // get the element to expand from the deque\n\t\tnext.accept(this); // call @scan for each direct child of the node\n\t\treturn next;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/Root.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation defines an element as Root of the meta model. It is used for\n * the automatic generation of visitors of spoon metamodel elements.\n */\n@Target({ ElementType.TYPE })\npublic @interface Root {\n}\n"
    }, {
      "name" : "reflect/visitor/DefaultJavaPrettyPrinter.java",
      "weight" : 1668.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtComment.CommentType;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.code.UnaryOperatorKind;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleDirective;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.experimental.CtUnresolvedImport;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.PrintingContext.Writable;\nimport spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction;\nimport spoon.reflect.visitor.printer.CommentOffset;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * A visitor for generating Java code from the program compile-time model.\n */\npublic class DefaultJavaPrettyPrinter implements CtVisitor, PrettyPrinter {\n\n\t/**\n\t * Java file extension (.java).\n\t */\n\tpublic static final String JAVA_FILE_EXTENSION = \".java\";\n\n\t/**\n\t * Package declaration file name.\n\t */\n\tpublic static final String JAVA_PACKAGE_DECLARATION = \"package-info\" + JAVA_FILE_EXTENSION;\n\n\t/**\n\t * Module declaration file name.\n\t */\n\tpublic static final String JAVA_MODULE_DECLARATION = \"module-info\" + JAVA_FILE_EXTENSION;\n\n\t/**\n\t * Line separator which is used by the system\n\t */\n\tpublic static final String LINE_SEPARATOR = System.getProperty(\"line.separator\");\n\n\t/**\n\t * The star at the beginning of a block/JavaDoc comment line\n\t */\n\tpublic static final String COMMENT_STAR = \" * \";\n\n\t/**\n\t * The end of a block/JavaDoc comment\n\t */\n\tpublic static final String BLOCK_COMMENT_END = \" */\";\n\n\t/**\n\t * The beginning of a JavaDoc comment\n\t */\n\tpublic static final String JAVADOC_START = \"/**\";\n\n\t/**\n\t * The beginning of an inline comment\n\t */\n\tpublic static final String INLINE_COMMENT_START = \"// \";\n\n\t/**\n\t * The beginning of a block comment\n\t */\n\tpublic static final String BLOCK_COMMENT_START = \"/* \";\n\n\t/**\n\t * The printing context.\n\t *\n\t * since Spoon 7.1.0, use {{@link #getContext()}}\n\t */\n\tprivate PrintingContext context = new PrintingContext();\n\n\t/** get the import scanner of this pretty printer */\n\tpublic ImportScanner getImportsContext() {\n\t\treturn importsContext;\n\t}\n\n\t/**\n\t * Handle imports of classes.\n\t */\n\tprivate ImportScanner importsContext;\n\n\t/**\n\t * Environment which Spoon is executed.\n\t */\n\tprotected Environment env;\n\n\t/**\n\t * Token detector, which delegates tokens to {@link TokenWriter}\n\t */\n\tprivate TokenWriter printer;\n\n\t/**\n\t * Element printer helper.\n\t */\n\tprivate ElementPrinterHelper elementPrinterHelper;\n\n\t/**\n\t * Compilation unit we are printing.\n\t */\n\tprotected CtCompilationUnit sourceCompilationUnit;\n\n\t/**\n\t * Imports computed\n\t */\n\tSet<CtImport> imports;\n\n\t/**\n\t * Creates a new code generator visitor.\n\t */\n\tpublic DefaultJavaPrettyPrinter(Environment env) {\n\t\tthis.env = env;\n\t\tthis.imports = new HashSet<>();\n\t\tsetPrinterTokenWriter(new DefaultTokenWriter(new PrinterHelper(env)));\n\t\tif (env.isAutoImports()) {\n\t\t\tthis.importsContext = new ImportScannerImpl();\n\t\t} else {\n\t\t\tthis.importsContext = new MinimalImportScanner();\n\t\t}\n\t}\n\n\t/**\n\t * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n\t * defined by System.getProperty(\"line.separator\")\n\t */\n\tpublic String getLineSeparator() {\n\t\treturn getPrinterHelper().getLineSeparator();\n\t}\n\n\t/**\n\t * @param lineSeparator characters which will be printed as End of line.\n\t * By default there is System.getProperty(\"line.separator\")\n\t */\n\tpublic DefaultJavaPrettyPrinter setLineSeparator(String lineSeparator) {\n\t\tgetPrinterHelper().setLineSeparator(lineSeparator);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enters an expression.\n\t */\n\tprotected void enterCtExpression(CtExpression<?> e) {\n\t\tif (!(e instanceof CtStatement)) {\n\t\t\telementPrinterHelper.writeComment(e, CommentOffset.BEFORE);\n\t\t}\n\t\tgetPrinterHelper().mapLine(e, sourceCompilationUnit);\n\t\tif (shouldSetBracket(e)) {\n\t\t\tcontext.parenthesedExpression.push(e);\n\t\t\tprinter.writeSeparator(\"(\");\n\t\t}\n\t\tif (!e.getTypeCasts().isEmpty()) {\n\t\t\tfor (CtTypeReference<?> r : e.getTypeCasts()) {\n\t\t\t\tprinter.writeSeparator(\"(\");\n\t\t\t\tscan(r);\n\t\t\t\tprinter.writeSeparator(\")\").writeSpace();\n\t\t\t\tprinter.writeSeparator(\"(\");\n\t\t\t\tcontext.parenthesedExpression.push(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Enters a statement.\n\t */\n\tprotected void enterCtStatement(CtStatement s) {\n\t\telementPrinterHelper.writeComment(s, CommentOffset.BEFORE);\n\t\tgetPrinterHelper().mapLine(s, sourceCompilationUnit);\n\t\tif (!context.isNextForVariable()) {\n\t\t\t//TODO AnnotationLoopTest#testAnnotationDeclaredInForInit expects that annotations of next for variables are not printed\n\t\t\t//but may be correct is that the next variables are not annotated, because they might have different annotation then first param!\n\t\t\telementPrinterHelper.writeAnnotations(s);\n\t\t}\n\t\tif (!context.isFirstForVariable() && !context.isNextForVariable()) {\n\t\t\tif (s.getLabel() != null) {\n\t\t\t\tprinter.writeIdentifier(s.getLabel()).writeSpace().writeSeparator(\":\").writeSpace();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Exits a statement.\n\t */\n\tprotected void exitCtStatement(CtStatement statement) {\n\t\tif (!(statement instanceof CtBlock || statement instanceof CtIf || statement instanceof CtFor || statement instanceof CtForEach || statement instanceof CtWhile || statement instanceof CtTry\n\t\t\t\t|| statement instanceof CtSwitch || statement instanceof CtSynchronized || statement instanceof CtClass || statement instanceof CtComment)) {\n\t\t\tif (context.isStatement(statement) && !context.isFirstForVariable() && !context.isNextForVariable()) {\n\t\t\t\tprinter.writeSeparator(\";\");\n\t\t\t}\n\t\t}\n\t\telementPrinterHelper.writeComment(statement, CommentOffset.AFTER);\n\t}\n\n\t/**\n\t * Exits an expression.\n\t */\n\tprotected void exitCtExpression(CtExpression<?> e) {\n\t\twhile ((!context.parenthesedExpression.isEmpty()) && e == context.parenthesedExpression.peek()) {\n\t\t\tcontext.parenthesedExpression.pop();\n\t\t\tprinter.writeSeparator(\")\");\n\t\t}\n\t\tif (!(e instanceof CtStatement)) {\n\t\t\telementPrinterHelper.writeComment(e, CommentOffset.AFTER);\n\t\t}\n\t}\n\n\t/**\n\t * Make the imports for a given type.\n     *\n\t */\n\tprivate Collection<CtImport> computeImports(CtType<?> type) {\n\t\tcontext.currentTopLevel = type;\n\t\timportsContext.computeImports(context.currentTopLevel);\n\t\treturn importsContext.getAllImports();\n\t}\n\n\t/**\n\t * This method is called by {@link #scan(CtElement)} when entering a scanned element.\n\t * To be overridden to implement specific behavior.\n\t *\n\t * Same KISS design as for {@link CtScanner}.\n\t */\n\tprotected void enter(CtElement e) {\n\t}\n\n\t/**\n\t * This method is called by {@link #scan(CtElement)} when entering a scanned element.\n\t * To be overridden to implement specific behavior.\n\t */\n\tprotected void exit(CtElement e) {\n\t}\n\n\t/**\n\t * The generic scan method for an element.\n\t */\n\tpublic DefaultJavaPrettyPrinter scan(CtElement e) {\n\t\tif (e != null) {\n\t\t\tenter(e);\n\t\t\tcontext.elementStack.push(e);\n\t\t\tif (env.isPreserveLineNumbers()) {\n\t\t\t\tif (!(e instanceof CtNamedElement)) {\n\t\t\t\t\tgetPrinterHelper().adjustStartPosition(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\te.accept(this);\n\t\t\t} catch (SpoonException ex) {\n\t\t\t\tthrow ex;\n\t\t\t} catch (Exception ex) {\n\t\t\t\tString elementInfo = e.getClass().getName();\n\t\t\t\telementInfo += \" on path \" + getPath(e) + \"\\n\";\n\t\t\t\tif (e.getPosition().isValidPosition()) {\n\t\t\t\t\telementInfo += \"at position \" + e.getPosition().toString() + \" \";\n\t\t\t\t}\n\t\t\t\tthrow new SpoonException(\"Printing of \" + elementInfo + \"failed\", ex);\n\t\t\t}\n\t\t\tcontext.elementStack.pop();\n\t\t\texit(e);\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate static String getPath(CtElement ele) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\taddParentPath(sb, ele);\n\t\tif (ele instanceof CtVariableAccess) {\n\t\t\tsb.append(':').append(((CtVariableAccess) ele).getVariable().getSimpleName());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate static void addParentPath(StringBuilder sb, CtElement ele) {\n\t\tif (ele == null || (ele instanceof CtPackage && ((CtPackage) ele).isUnnamedPackage())) {\n\t\t\treturn;\n\t\t}\n\t\tif (ele.isParentInitialized()) {\n\t\t\taddParentPath(sb, ele.getParent());\n\t\t}\n\t\tsb.append(\"\\n\\t\").append(ele.getClass().getSimpleName());\n\t\tif (ele instanceof CtNamedElement) {\n\t\t\tsb.append(\":\").append(((CtNamedElement) ele).getSimpleName());\n\t\t} else if (ele instanceof CtReference) {\n\t\t\tsb.append(\":\").append(((CtReference) ele).getSimpleName());\n\t\t}\n\t}\n\n\tprivate boolean shouldSetBracket(CtExpression<?> e) {\n\t\tif (!e.getTypeCasts().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tif ((e.getParent() instanceof CtBinaryOperator) || (e.getParent() instanceof CtUnaryOperator)) {\n\t\t\t\treturn (e instanceof CtTargetedExpression) || (e instanceof CtAssignment) || (e instanceof CtConditional) || (e instanceof CtUnaryOperator) || e instanceof CtBinaryOperator;\n\t\t\t}\n\t\t\tif (e.getParent() instanceof CtTargetedExpression) {\n\t\t\t\treturn (e instanceof CtBinaryOperator) || (e instanceof CtAssignment) || (e instanceof CtConditional) || (e instanceof CtUnaryOperator);\n\t\t\t}\n\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t// nothing we accept not to have a parent\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets the currently pretty-printed string.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn printer.getPrinterHelper().toString();\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotation(CtAnnotation<A> annotation) {\n\t\telementPrinterHelper.writeAnnotations(annotation);\n\t\tprinter.writeSeparator(\"@\");\n\t\tscan(annotation.getAnnotationType());\n\t\tif (!annotation.getValues().isEmpty()) {\n\t\t\telementPrinterHelper.printList(annotation.getValues().entrySet(),\n\t\t\t\tnull, false, \"(\", false, false, \",\", true, false, \")\",\n\t\t\t\te -> {\n\t\t\t\t\tif ((annotation.getValues().size() == 1 && \"value\".equals(e.getKey())) == false) {\n\t\t\t\t\t\t//it is not a default value attribute. We must print a attribute name too.\n\t\t\t\t\t\tprinter.writeIdentifier(e.getKey()).writeSpace().writeOperator(\"=\").writeSpace();\n\t\t\t\t\t}\n\t\t\t\t\telementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n\t\t\t\t});\n\t\t}\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotationType(CtAnnotationType<A> annotationType) {\n\t\tvisitCtType(annotationType);\n\t\tprinter.writeSeparator(\"@\").writeKeyword(\"interface\")\n\t\t\t.writeSpace().writeIdentifier(annotationType.getSimpleName())\n\t\t\t.writeSpace().writeSeparator(\"{\").incTab();\n\n\t\telementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n\t\tprinter.decTab().writeSeparator(\"}\");\n\t}\n\n\t@Override\n\tpublic void visitCtAnonymousExecutable(CtAnonymousExecutable impl) {\n\t\telementPrinterHelper.writeComment(impl);\n\t\telementPrinterHelper.writeAnnotations(impl);\n\t\telementPrinterHelper.writeModifiers(impl);\n\t\tscan(impl.getBody());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayRead(CtArrayRead<T> arrayRead) {\n\t\tprintCtArrayAccess(arrayRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayWrite(CtArrayWrite<T> arrayWrite) {\n\t\tprintCtArrayAccess(arrayWrite);\n\t}\n\n\tprivate <T, E extends CtExpression<?>> void printCtArrayAccess(CtArrayAccess<T, E> arrayAccess) {\n\t\tenterCtExpression(arrayAccess);\n\t\tscan(arrayAccess.getTarget());\n\t\tprinter.writeSeparator(\"[\");\n\t\tscan(arrayAccess.getIndexExpression());\n\t\tprinter.writeSeparator(\"]\");\n\t\texitCtExpression(arrayAccess);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayTypeReference(CtArrayTypeReference<T> reference) {\n\t\tif (reference.isImplicit()) {\n\t\t\treturn;\n\t\t}\n\t\tscan(reference.getComponentType());\n\t\tif (!context.skipArray()) {\n\t\t\tprinter.writeSeparator(\"[\").writeSeparator(\"]\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAssert(CtAssert<T> asserted) {\n\t\tenterCtStatement(asserted);\n\t\tprinter.writeKeyword(\"assert\").writeSpace();\n\t\tscan(asserted.getAssertExpression());\n\t\tif (asserted.getExpression() != null) {\n\t\t\tprinter.writeSpace().writeSeparator(\":\").writeSpace();\n\t\t\tscan(asserted.getExpression());\n\t\t}\n\t\texitCtStatement(asserted);\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtAssignment(CtAssignment<T, A> assignement) {\n\t\tenterCtStatement(assignement);\n\t\tenterCtExpression(assignement);\n\t\tscan(assignement.getAssigned());\n\t\tprinter.writeSpace().writeOperator(\"=\").writeSpace();\n\t\tscan(assignement.getAssignment());\n\t\texitCtExpression(assignement);\n\t\texitCtStatement(assignement);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> operator) {\n\t\tenterCtExpression(operator);\n\t\tscan(operator.getLeftHandOperand());\n\t\tprinter.writeSpace();\n\t\tprinter.writeOperator(OperatorHelper.getOperatorText(operator.getKind()));\n\t\tprinter.writeSpace();\n\t\ttry (Writable _context = context.modify()) {\n\t\t\tif (operator.getKind() == BinaryOperatorKind.INSTANCEOF) {\n\t\t\t\t_context.forceWildcardGenerics(true);\n\t\t\t}\n\t\t\tscan(operator.getRightHandOperand());\n\t\t}\n\t\texitCtExpression(operator);\n\t}\n\n\t@Override\n\tpublic <R> void visitCtBlock(CtBlock<R> block) {\n\t\tenterCtStatement(block);\n\t\tif (!block.isImplicit()) {\n\t\t\tprinter.writeSeparator(\"{\");\n\t\t}\n\t\tprinter.incTab();\n\t\tfor (CtStatement statement : block.getStatements()) {\n\t\t\tif (!statement.isImplicit()) {\n\t\t\t\tprinter.writeln();\n\t\t\t\telementPrinterHelper.writeStatement(statement);\n\t\t\t}\n\t\t}\n\t\tprinter.decTab();\n\t\tgetPrinterHelper().adjustEndPosition(block);\n\t\tif (env.isPreserveLineNumbers()) {\n\t\t\tif (!block.isImplicit()) {\n\t\t\t\tprinter.writeSeparator(\"}\");\n\t\t\t}\n\t\t} else {\n\t\t\tprinter.writeln();\n\t\t\tif (!block.isImplicit()) {\n\t\t\t\tprinter.writeSeparator(\"}\");\n\t\t\t}\n\t\t}\n\t\texitCtStatement(block);\n\t}\n\n\t@Override\n\tpublic void visitCtBreak(CtBreak breakStatement) {\n\t\tenterCtStatement(breakStatement);\n\t\tprinter.writeKeyword(\"break\");\n\t\tif (breakStatement.getTargetLabel() != null) {\n\t\t\tprinter.writeSpace().writeKeyword(breakStatement.getTargetLabel());\n\t\t}\n\t\texitCtStatement(breakStatement);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic <E> void visitCtCase(CtCase<E> caseStatement) {\n\t\tenterCtStatement(caseStatement);\n\t\tif (caseStatement.getCaseExpression() != null) {\n\t\t\tprinter.writeKeyword(\"case\").writeSpace();\n\t\t\t// writing enum case expression\n\t\t\tif (caseStatement.getCaseExpression() instanceof CtFieldAccess) {\n\t\t\t\tfinal CtFieldReference variable = ((CtFieldAccess) caseStatement.getCaseExpression()).getVariable();\n\t\t\t\t// In noclasspath mode, we don't have always the type of the declaring type.\n\t\t\t\tif (variable.getType() != null\n\t\t\t\t\t\t&& variable.getDeclaringType() != null\n\t\t\t\t\t\t&& variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n\t\t\t\t\tprinter.writeIdentifier(variable.getSimpleName());\n\t\t\t\t} else {\n\t\t\t\t\tscan(caseStatement.getCaseExpression());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscan(caseStatement.getCaseExpression());\n\t\t\t}\n\t\t} else {\n\t\t\tprinter.writeKeyword(\"default\");\n\t\t}\n\t\tprinter.writeSpace().writeSeparator(\":\").incTab();\n\n\t\tfor (CtStatement statement : caseStatement.getStatements()) {\n\t\t\tprinter.writeln();\n\t\t\telementPrinterHelper.writeStatement(statement);\n\t\t}\n\t\tprinter.decTab();\n\t\texitCtStatement(caseStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtCatch(CtCatch catchBlock) {\n\t\telementPrinterHelper.writeComment(catchBlock, CommentOffset.BEFORE);\n\t\tprinter.writeSpace().writeKeyword(\"catch\").writeSpace().writeSeparator(\"(\");\n\t\tCtCatchVariable<? extends Throwable> parameter = catchBlock.getParameter();\n\t\tif (parameter != null && parameter.getMultiTypes().size() > 1) {\n\t\t\telementPrinterHelper.printList(parameter.getMultiTypes(),\n\t\t\t\t\tnull, false, null, false, true, \"|\", true, false, null,\n\t\t\t\t\ttype -> scan(type));\n\t\t\tprinter.writeSpace().writeIdentifier(parameter.getSimpleName());\n\t\t} else {\n\t\t\tscan(parameter);\n\t\t}\n\t\tprinter.writeSeparator(\")\").writeSpace();\n\t\tscan(catchBlock.getBody());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\tcontext.pushCurrentThis(ctClass);\n\t\tif (ctClass.getSimpleName() != null && !CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()) && !ctClass.isAnonymous()) {\n\t\t\tvisitCtType(ctClass);\n\t\t\tif (ctClass.isLocalType()) {\n\t\t\t\tprinter.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n\t\t\t} else {\n\t\t\t\tprinter.writeKeyword(\"class\").writeSpace().writeIdentifier(ctClass.getSimpleName());\n\t\t\t}\n\n\t\t\telementPrinterHelper.writeFormalTypeParameters(ctClass);\n\t\t\telementPrinterHelper.writeExtendsClause(ctClass);\n\t\t\telementPrinterHelper.writeImplementsClause(ctClass);\n\t\t}\n\t\tprinter.writeSpace().writeSeparator(\"{\").incTab();\n\t\telementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n\t\tgetPrinterHelper().adjustEndPosition(ctClass);\n\t\tprinter.decTab().writeSeparator(\"}\");\n\t\tcontext.popCurrentThis();\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameter(CtTypeParameter typeParameter) {\n\t\telementPrinterHelper.writeAnnotations(typeParameter);\n\t\tprinter.writeIdentifier(typeParameter.getSimpleName());\n\t\tif (typeParameter.getSuperclass() != null && typeParameter.getSuperclass().isImplicit() == false) {\n\t\t\tprinter.writeSpace().writeKeyword(\"extends\").writeSpace();\n\t\t\tscan(typeParameter.getSuperclass());\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConditional(CtConditional<T> conditional) {\n\t\tenterCtExpression(conditional);\n\t\tCtExpression<Boolean> condition = conditional.getCondition();\n\t\tboolean parent;\n\t\ttry {\n\t\t\tparent = conditional.getParent() instanceof CtAssignment || conditional.getParent() instanceof CtVariable;\n\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t// nothing if we have no parent\n\t\t\tparent = false;\n\t\t}\n\t\tif (parent) {\n\t\t\tprinter.writeSeparator(\"(\");\n\t\t}\n\t\tscan(condition);\n\t\tif (parent) {\n\t\t\tprinter.writeSeparator(\")\");\n\t\t}\n\t\tprinter.writeSpace().writeOperator(\"?\").writeSpace();\n\t\tCtExpression<T> thenExpression = conditional.getThenExpression();\n\t\tscan(thenExpression);\n\t\tprinter.writeSpace().writeOperator(\":\").writeSpace();\n\n\t\tCtExpression<T> elseExpression = conditional.getElseExpression();\n\t\tboolean isAssign;\n\t\tif ((isAssign = elseExpression instanceof CtAssignment)) {\n\t\t\tprinter.writeSeparator(\"(\");\n\t\t}\n\t\tscan(elseExpression);\n\t\tif (isAssign) {\n\t\t\tprinter.writeSeparator(\")\");\n\t\t}\n\t\texitCtExpression(conditional);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructor(CtConstructor<T> constructor) {\n\t\telementPrinterHelper.writeComment(constructor);\n\t\telementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n\t\telementPrinterHelper.writeModifiers(constructor);\n\t\telementPrinterHelper.writeFormalTypeParameters(constructor);\n\t\tif (!constructor.getFormalCtTypeParameters().isEmpty()) {\n\t\t\tprinter.writeSpace();\n\t\t}\n\t\tif (constructor.getDeclaringType() != null) {\n\t\t\tif (constructor.getDeclaringType().isLocalType()) {\n\t\t\t\tprinter.writeIdentifier(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n\t\t\t} else {\n\t\t\t\tprinter.writeIdentifier(constructor.getDeclaringType().getSimpleName());\n\t\t\t}\n\t\t}\n\t\telementPrinterHelper.writeExecutableParameters(constructor);\n\t\telementPrinterHelper.writeThrowsClause(constructor);\n\t\tprinter.writeSpace();\n\t\tscan(constructor.getBody());\n\t}\n\n\t@Override\n\tpublic void visitCtContinue(CtContinue continueStatement) {\n\t\tenterCtStatement(continueStatement);\n\t\tprinter.writeKeyword(\"continue\");\n\t\tif (continueStatement.getTargetLabel() != null) {\n\t\t\tprinter.writeSpace().writeIdentifier(continueStatement.getTargetLabel());\n\t\t}\n\t\texitCtStatement(continueStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtDo(CtDo doLoop) {\n\t\tenterCtStatement(doLoop);\n\t\tprinter.writeKeyword(\"do\");\n\t\telementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n\t\tprinter.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n\t\tscan(doLoop.getLoopingExpression());\n\t\tprinter.writeSpace().writeSeparator(\")\");\n\t\texitCtStatement(doLoop);\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum) {\n\t\tvisitCtType(ctEnum);\n\t\tprinter.writeKeyword(\"enum\").writeSpace().writeIdentifier(ctEnum.getSimpleName());\n\t\telementPrinterHelper.writeImplementsClause(ctEnum);\n\t\tcontext.pushCurrentThis(ctEnum);\n\t\tprinter.writeSpace().writeSeparator(\"{\").incTab().writeln();\n\n\t\tif (ctEnum.getEnumValues().isEmpty()) {\n\t\t\tprinter.writeSeparator(\";\").writeln();\n\t\t} else {\n\t\t\telementPrinterHelper.printList(ctEnum.getEnumValues(),\n\t\t\t\t\tnull, false, null, false, false, \",\", false, false, \";\",\n\t\t\t\t\tenumValue -> {\n\t\t\t\t\t\tprinter.writeln();\n\t\t\t\t\t\tscan(enumValue);\n\t\t\t\t\t});\n\t\t}\n\n\t\telementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n\t\tprinter.decTab().writeSeparator(\"}\");\n\t\tcontext.popCurrentThis();\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\t//it is not called during printing of sources. Use shortcut and print directly to PrinterHelper\n\t\tprinter.getPrinterHelper().write(reference.getSignature());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtField(CtField<T> f) {\n\t\telementPrinterHelper.writeComment(f, CommentOffset.BEFORE);\n\t\telementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n\t\telementPrinterHelper.writeModifiers(f);\n\t\tscan(f.getType());\n\t\tprinter.writeSpace();\n\t\tprinter.writeIdentifier(f.getSimpleName());\n\n\t\tif (f.getDefaultExpression() != null) {\n\t\t\tprinter.writeSpace().writeOperator(\"=\").writeSpace();\n\t\t\tscan(f.getDefaultExpression());\n\t\t}\n\t\tprinter.writeSeparator(\";\");\n\t\telementPrinterHelper.writeComment(f, CommentOffset.AFTER);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtEnumValue(CtEnumValue<T> enumValue) {\n\t\telementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n\t\telementPrinterHelper.writeComment(enumValue, CommentOffset.BEFORE);\n\t\tprinter.writeIdentifier(enumValue.getSimpleName());\n\t\tif (enumValue.getDefaultExpression() != null) {\n\t\t\tCtConstructorCall<?> constructorCall = (CtConstructorCall<?>) enumValue.getDefaultExpression();\n\t\t\tif (!constructorCall.isImplicit()) {\n\t\t\t\telementPrinterHelper.printList(constructorCall.getArguments(), null, false, \"(\", false, false, \",\", true, false, \")\", expr -> scan(expr));\n\t\t\t}\n\t\t\tif (constructorCall instanceof CtNewClass) {\n\t\t\t\tscan(((CtNewClass<?>) constructorCall).getAnonymousClass());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\tprintCtFieldAccess(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {\n\t\tprintCtFieldAccess(fieldWrite);\n\t}\n\n\tprivate boolean isImported(CtFieldReference fieldReference) {\n\t\tCtImport fieldImport = fieldReference.getFactory().createImport(fieldReference);\n\n\t\tif (this.imports.contains(fieldImport)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (fieldReference.getDeclaringType() == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCtTypeMemberWildcardImportReference staticTypeMemberReference = fieldReference.getFactory().Type().createTypeMemberWildcardImportReference(fieldReference.getDeclaringType());\n\t\t\tCtImport staticClassImport = fieldReference.getFactory().createImport(staticTypeMemberReference);\n\t\t\treturn this.imports.contains(staticClassImport);\n\t\t}\n\t}\n\n\tprivate boolean isImported(CtExecutableReference executableReference) {\n\t\tCtImport executableImport = executableReference.getFactory().createImport(executableReference);\n\n\t\tif (this.imports.contains(executableImport)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif (executableReference.getDeclaringType() == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCtTypeMemberWildcardImportReference staticTypeMemberReference = executableReference.getFactory().Type().createTypeMemberWildcardImportReference(executableReference.getDeclaringType());\n\t\t\tCtImport staticClassImport = executableReference.getFactory().createImport(staticTypeMemberReference);\n\t\t\treturn this.imports.contains(staticClassImport);\n\t\t}\n\t}\n\n\tprivate <T> void printCtFieldAccess(CtFieldAccess<T> f) {\n\t\tenterCtExpression(f);\n\t\ttry (Writable _context = context.modify()) {\n\t\t\tif ((f.getVariable().isStatic() || \"class\".equals(f.getVariable().getSimpleName())) && f.getTarget() instanceof CtTypeAccess) {\n\t\t\t\t_context.ignoreGenerics(true);\n\t\t\t}\n\t\t\tCtExpression<?> target = f.getTarget();\n\t\t\tif (target != null) {\n\t\t\t\tboolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n\t\t\t\tboolean isStaticField = f.getVariable().isStatic();\n\t\t\t\tboolean isImportedField = this.isImported(f.getVariable());\n\n\t\t\t\tif (!isInitializeStaticFinalField && !(isStaticField && isImportedField)) {\n\t\t\t\t\tif (target.isImplicit() && !(f.getVariable().getFieldDeclaration() == null && this.env.getNoClasspath())) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * target is implicit, check whether there is no conflict with an local variable, catch variable or parameter\n\t\t\t\t\t\t * in case of conflict make it explicit, otherwise the field access is shadowed by that variable.\n\t\t\t\t\t\t * Search for potential variable declaration until we found a class which declares or inherits this field\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfinal CtField<?> field = f.getVariable().getFieldDeclaration();\n\t\t\t\t\t\tif (field != null) {\n\t\t\t\t\t\t\tfinal String fieldName = field.getSimpleName();\n\t\t\t\t\t\t\tCtVariable<?> var = f.getVariable().map(new PotentialVariableDeclarationFunction(fieldName)).first();\n\t\t\t\t\t\t\tif (var != field) {\n\t\t\t\t\t\t\t\t//another variable declaration was found which is hiding the field declaration for this field access. Make the field access explicit\n\t\t\t\t\t\t\t\ttarget.setImplicit(false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//There is a model inconsistency\n\t\t\t\t\t\t\tprinter.writeComment(f.getFactory().createComment(\"ERROR: Missing field \\\"\" + f.getVariable().getSimpleName() + \"\\\", please check your model. The code may not compile.\", CommentType.BLOCK)).writeSpace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// the implicit drives the separator\n\t\t\t\t\tif (!target.isImplicit()) {\n\t\t\t\t\t\tscan(target);\n\t\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_context.ignoreStaticAccess(true);\n\t\t\t}\n\t\t\tscan(f.getVariable());\n\t\t}\n\t\texitCtExpression(f);\n\t}\n\n\t/**\n\t * Check if the target expression is a static final field initialized in a static anonymous block.\n\t */\n\tprivate <T> boolean isInitializeStaticFinalField(CtExpression<T> targetExp) {\n\t\tfinal CtElement parent;\n\t\tfinal CtAnonymousExecutable anonymousParent;\n\t\ttry {\n\t\t\tparent = targetExp.getParent();\n\t\t\tanonymousParent = targetExp.getParent(CtAnonymousExecutable.class);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn parent instanceof CtFieldWrite\n\t\t\t\t&& targetExp.equals(((CtFieldWrite) parent).getTarget())\n\t\t\t\t&& anonymousParent != null\n\t\t\t\t&& ((CtFieldWrite) parent).getVariable() != null\n\t\t\t\t&& ((CtFieldWrite) parent).getVariable().getModifiers().contains(ModifierKind.STATIC)\n\t\t\t\t&& ((CtFieldWrite) parent).getVariable().getModifiers().contains(ModifierKind.FINAL);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtThisAccess(CtThisAccess<T> thisAccess) {\n\t\ttry {\n\t\t\tenterCtExpression(thisAccess);\n\n\t\t\t// we only write qualified this when this is required\n\t\t\t// this is good both in fully-qualified mode and in readable (with-imports) mode\n\t\t\t// the implicit information is used for analysis (e.g. is visibility caused by implicit bugs?) but\n\t\t\t// not for pretty-printing\n\t\t\tCtTypeAccess target = (CtTypeAccess) thisAccess.getTarget();\n\t\t\tCtTypeReference targetType = target.getAccessedType();\n\n\t\t\t// readable mode as close as possible to the original code\n\t\t\tif (thisAccess.isImplicit()) {\n\t\t\t\t// write nothing, \"this\" is implicit and we unfortunately cannot always know\n\t\t\t\t// what the good target is in JDTTreeBuilder\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// the simplest case: we always print \"this\" if we're in the top-level class,\n\t\t\t// this is shorter (no qualified this), explicit, and less fragile wrt transformation\n\t\t\tif (targetType == null || (thisAccess.getParent(CtType.class) != null && thisAccess.getParent(CtType.class).isTopLevel())) {\n\t\t\t\tprinter.writeKeyword(\"this\");\n\t\t\t\treturn; // still go through finally block below\n\t\t\t}\n\n\t\t\t// we cannot have fully-qualified this in anonymous classes\n\t\t\t// we simply print \"this\" and it always works\n\t\t\t// this has to come after the implicit test just before\n\t\t\tif (targetType.isAnonymous()) {\n\t\t\t\tprinter.writeKeyword(\"this\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// complex case of qualified this\n\t\t\tif (!context.currentThis.isEmpty()) {\n\n\t\t\t\tCtType lastType = context.currentThis.peekFirst().type;\n\t\t\t\tString lastTypeQualifiedName = lastType.getQualifiedName();\n\t\t\t\tString targetTypeQualifiedName = targetType.getQualifiedName();\n\n\t\t\t\tif (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n\t\t\t\t\tif (!targetType.isImplicit()) {\n\t\t\t\t\t\tvisitCtTypeReferenceWithoutGenerics(targetType);\n\t\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t\t}\n\t\t\t\t\tprinter.writeKeyword(\"this\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the default super simple case only comes at the end\n\t\t\tprinter.writeKeyword(\"this\");\n\t\t} finally {\n\t\t\texitCtExpression(thisAccess);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtSuperAccess(CtSuperAccess<T> f) {\n\t\tenterCtExpression(f);\n\t\tif (f.getTarget() != null) {\n\t\t\tscan(f.getTarget());\n\t\t\tprinter.writeSeparator(\".\");\n\t\t}\n\t\tprinter.writeKeyword(\"super\");\n\n\t\texitCtExpression(f);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDoc(CtJavaDoc comment) {\n\t\tvisitCtComment(comment);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDocTag(CtJavaDocTag docTag) {\n\t\t/*\n\t\t * is not called during normal printing of java sources.\n\t\t * It can be called only when CtJavaDocTag has to be printed directly.\n\t\t * E.g. from CtJavaDocTag#toString\n\t\t * Write directly to PrinterHelper, because java doc tag is not a java token. Normally it is part of COMMENT token.\n\t\t */\n\t\tCommentHelper.printJavaDocTag(printer.getPrinterHelper(), docTag, x -> { return x; });\n\t}\n\n\t@Override\n\tpublic void visitCtImport(CtImport ctImport) {\n\t\tif (ctImport.getImportKind() != null) {\n\t\t\tprinter.writeKeyword(\"import\");\n\t\t\tprinter.writeSpace();\n\n\t\t\tswitch (ctImport.getImportKind()) {\n\t\t\t\tcase TYPE:\n\t\t\t\t\tvisitCtTypeReference((CtTypeReference) ctImport.getReference());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase METHOD:\n\t\t\t\t\tprinter.writeKeyword(\"static\");\n\t\t\t\t\tprinter.writeSpace();\n\t\t\t\t\tvisitCtExecutableReference((CtExecutableReference) ctImport.getReference());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FIELD:\n\t\t\t\t\tprinter.writeKeyword(\"static\");\n\t\t\t\t\tprinter.writeSpace();\n\t\t\t\t\tvisitCtFieldReference((CtFieldReference) ctImport.getReference());\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_TYPES:\n\t\t\t\t\tvisitCtPackageReference((CtPackageReference) ctImport.getReference());\n\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t\tprinter.writeIdentifier(\"*\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ALL_STATIC_MEMBERS:\n\t\t\t\t\tprinter.writeKeyword(\"static\");\n\t\t\t\t\tprinter.writeSpace();\n\t\t\t\t\tvisitCtTypeReference(((CtTypeMemberWildcardImportReference) ctImport.getReference()).getTypeReference());\n\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t\tprinter.writeIdentifier(\"*\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNRESOLVED:\n\t\t\t\t\tCtUnresolvedImport ctUnresolvedImport = (CtUnresolvedImport) ctImport;\n\t\t\t\t\tif (ctUnresolvedImport.isStatic()) {\n\t\t\t\t\t\tprinter.writeKeyword(\"static\");\n\t\t\t\t\t\tprinter.writeSpace();\n\t\t\t\t\t}\n\t\t\t\t\tprinter.writeCodeSnippet(ctUnresolvedImport.getUnresolvedReference());\n\t\t\t}\n\t\t\tprinter.writeSeparator(\";\");\n\t\t\tprinter.writeln();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtModule(CtModule module) {\n\t\tenter(module);\n\t\tif (module.isOpenModule()) {\n\t\t\tprinter.writeKeyword(\"open\").writeSpace();\n\t\t}\n\t\tprinter.writeKeyword(\"module\").writeSpace().writeIdentifier(module.getSimpleName());\n\t\tprinter.writeSpace().writeSeparator(\"{\").incTab().writeln();\n\n\t\tfor (CtModuleDirective moduleDirective : module.getModuleDirectives()) {\n\t\t\tscan(moduleDirective);\n\t\t}\n\n\t\tprinter.decTab().writeSeparator(\"}\");\n\t\texit(module);\n\t}\n\n\t@Override\n\tpublic void visitCtModuleReference(CtModuleReference moduleReference) {\n\t\tprinter.writeIdentifier(moduleReference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic void visitCtPackageExport(CtPackageExport moduleExport) {\n\t\tif (moduleExport.isOpenedPackage()) {\n\t\t\tprinter.writeKeyword(\"opens\");\n\t\t} else {\n\t\t\tprinter.writeKeyword(\"exports\");\n\t\t}\n\t\tprinter.writeSpace();\n\n\t\tvisitCtPackageReference(moduleExport.getPackageReference());\n\t\tif (!moduleExport.getTargetExport().isEmpty()) {\n\t\t\tthis.elementPrinterHelper.printList(moduleExport.getTargetExport(),\n\t\t\t\tnull, false, \" to\", true, false, \",\", true, false, null,\n\t\t\t\tmoduleReference -> scan(moduleReference));\n\t\t}\n\t\tprinter.writeSeparator(\";\").writeln();\n\t}\n\n\t@Override\n\tpublic void visitCtModuleRequirement(CtModuleRequirement moduleRequirement) {\n\t\tprinter.writeKeyword(\"requires\").writeSpace();\n\n\t\tif (!moduleRequirement.getRequiresModifiers().isEmpty()) {\n\t\t\tthis.elementPrinterHelper.printList(moduleRequirement.getRequiresModifiers(),\n\t\t\t\tnull, false, null, false, false, \" \", false, false, \" \",\n\t\t\t\tmodifier -> printer.writeKeyword(modifier.name().toLowerCase()));\n\t\t}\n\n\t\tscan(moduleRequirement.getModuleReference());\n\t\tprinter.writeSeparator(\";\").writeln();\n\t}\n\n\t@Override\n\tpublic void visitCtProvidedService(CtProvidedService moduleProvidedService) {\n\t\tprinter.writeKeyword(\"provides\").writeSpace();\n\t\tscan(moduleProvidedService.getServiceType());\n\t\tthis.elementPrinterHelper.printList(moduleProvidedService.getImplementationTypes(),\n\t\t\tnull, false, \" with\", true, false, \",\", true, false, null,\n\t\t\timplementations -> scan(implementations));\n\t\tprinter.writeSeparator(\";\").writeln();\n\t}\n\n\t@Override\n\tpublic void visitCtUsedService(CtUsedService usedService) {\n\t\tprinter.writeKeyword(\"uses\").writeSpace();\n\t\tscan(usedService.getServiceType());\n\t\tprinter.writeSeparator(\";\").writeln();\n\t}\n\n\t@Override\n\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\t\tswitch (compilationUnit.getUnitType()) {\n\t\tcase MODULE_DECLARATION:\n\t\t\t//TODO print module declaration\n\t\t\tbreak;\n\t\tcase PACKAGE_DECLARATION:\n\t\t\t//TODO print package declaration\n\t\t\tbreak;\n\t\tcase TYPE_DECLARATION:\n\t\t\tcalculate(compilationUnit, compilationUnit.getDeclaredTypes());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new SpoonException(\"Cannot print compilation unit of type \" + compilationUnit.getUnitType());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtPackageDeclaration(CtPackageDeclaration packageDeclaration) {\n\t\telementPrinterHelper.writePackageLine(packageDeclaration.getReference().getQualifiedName());\n\t}\n\n\t@Override\n\tpublic void visitCtTypeMemberWildcardImportReference(CtTypeMemberWildcardImportReference wildcardReference) {\n\t\tscan(wildcardReference.getTypeReference());\n\t\tprinter.writeSeparator(\".\").writeSeparator(\"*\");\n\t}\n\n\t@Override\n\tpublic void visitCtComment(CtComment comment) {\n\t\tif (!env.isCommentsEnabled() && context.elementStack.size() > 1) {\n\t\t\treturn;\n\t\t}\n\t\tprinter.writeComment(comment);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationFieldAccess(CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\tenterCtExpression(annotationFieldAccess);\n\t\ttry (Writable _context = context.modify()) {\n\t\t\tif (annotationFieldAccess.getTarget() != null) {\n\t\t\t\tscan(annotationFieldAccess.getTarget());\n\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t_context.ignoreStaticAccess(true);\n\t\t\t}\n\t\t\t_context.ignoreGenerics(true);\n\t\t\tscan(annotationFieldAccess.getVariable());\n\t\t\tprinter.writeSeparator(\"(\").writeSeparator(\")\");\n\t\t}\n\t\texitCtExpression(annotationFieldAccess);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\t\tboolean isStatic = \"class\".equals(reference.getSimpleName()) || !\"super\".equals(reference.getSimpleName()) && reference.isStatic();\n\n\t\tboolean printType = true;\n\n\t\tif (reference.isFinal() && reference.isStatic()) {\n\t\t\tCtTypeReference<?> declTypeRef = reference.getDeclaringType();\n\t\t\tif (declTypeRef.isAnonymous()) {\n\t\t\t\t//never print anonymous class ref\n\t\t\t\tprintType = false;\n\t\t\t} else {\n\t\t\t\tif (context.isInCurrentScope(declTypeRef)) {\n\t\t\t\t\t//do not printType if we are in scope of that type\n\t\t\t\t\tprintType = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isStatic && printType && !context.ignoreStaticAccess()) {\n\t\t\ttry (Writable _context = context.modify().ignoreGenerics(true)) {\n\t\t\t\tscan(reference.getDeclaringType());\n\t\t\t}\n\t\t\tprinter.writeSeparator(\".\");\n\t\t}\n\t\tif (\"class\".equals(reference.getSimpleName())) {\n\t\t\tprinter.writeKeyword(\"class\");\n\t\t} else {\n\t\t\tprinter.writeIdentifier(reference.getSimpleName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtFor(CtFor forLoop) {\n\t\tenterCtStatement(forLoop);\n\t\tprinter.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n\t\tList<CtStatement> st = forLoop.getForInit();\n\t\tif (!st.isEmpty()) {\n\t\t\ttry (Writable _context = context.modify().isFirstForVariable(true)) {\n\t\t\t\tscan(st.get(0));\n\t\t\t}\n\t\t}\n\t\tif (st.size() > 1) {\n\t\t\ttry (Writable _context = context.modify().isNextForVariable(true)) {\n\t\t\t\tfor (int i = 1; i < st.size(); i++) {\n\t\t\t\t\tprinter.writeSeparator(\",\").writeSpace();\n\t\t\t\t\tscan(st.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprinter.writeSeparator(\";\").writeSpace();\n\t\tscan(forLoop.getExpression());\n\t\tprinter.writeSeparator(\";\");\n\t\tif (!forLoop.getForUpdate().isEmpty()) {\n\t\t\tprinter.writeSpace();\n\t\t}\n\t\telementPrinterHelper.printList(forLoop.getForUpdate(),\n\t\t\tnull, false, null, false, true, \",\", true, false, null,\n\t\t\ts -> scan(s));\n\t\tprinter.writeSeparator(\")\");\n\t\telementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n\t\texitCtStatement(forLoop);\n\t}\n\n\t@Override\n\tpublic void visitCtForEach(CtForEach foreach) {\n\t\tenterCtStatement(foreach);\n\t\tprinter.writeKeyword(\"for\").writeSpace().writeSeparator(\"(\");\n\t\tscan(foreach.getVariable());\n\t\tprinter.writeSpace().writeSeparator(\":\").writeSpace();\n\t\tscan(foreach.getExpression());\n\t\tprinter.writeSeparator(\")\");\n\t\telementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n\t\texitCtStatement(foreach);\n\t}\n\n\t@Override\n\tpublic void visitCtIf(CtIf ifElement) {\n\t\tenterCtStatement(ifElement);\n\t\tprinter.writeKeyword(\"if\").writeSpace().writeSeparator(\"(\");\n\t\tscan(ifElement.getCondition());\n\t\tprinter.writeSeparator(\")\");\n\t\tCtStatement thenStmt = ifElement.getThenStatement();\n\t\tCtStatement elseStmt = ifElement.getElseStatement();\n\t\telementPrinterHelper.writeIfOrLoopBlock(thenStmt);\n\t\tif (elseStmt != null) {\n\t\t\tList<CtComment> comments = elementPrinterHelper.getComments(ifElement, CommentOffset.INSIDE);\n\t\t\tif (thenStmt != null) {\n\t\t\t\tSourcePosition thenPosition = thenStmt.getPosition();\n\t\t\t\tif (!thenPosition.isValidPosition() && thenStmt instanceof CtBlock) {\n\t\t\t\t\tCtStatement thenExpression = ((CtBlock) thenStmt).getStatement(0);\n\t\t\t\t\tthenPosition = thenExpression.getPosition();\n\t\t\t\t}\n\t\t\t\tfor (CtComment comment : comments) {\n\t\t\t\t\tif (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n\t\t\t\t\t\telementPrinterHelper.writeComment(comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (thenStmt instanceof CtBlock && !thenStmt.isImplicit()) {\n\t\t\t\t//add space after non implicit block\n\t\t\t\tprinter.writeSpace();\n\t\t\t}\n\t\t\tprinter.writeKeyword(\"else\");\n\t\t\telementPrinterHelper.writeIfOrLoopBlock(elseStmt);\n\t\t}\n\t\texitCtStatement(ifElement);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\t\tvisitCtType(intrface);\n\t\tprinter.writeKeyword(\"interface\").writeSpace().writeIdentifier(intrface.getSimpleName());\n\t\tif (intrface.getFormalCtTypeParameters() != null) {\n\t\t\telementPrinterHelper.writeFormalTypeParameters(intrface);\n\t\t}\n\n\t\tif (!intrface.getSuperInterfaces().isEmpty()) {\n\t\t\telementPrinterHelper.printList(intrface.getSuperInterfaces(),\n\t\t\t\t\"extends\", false, null, false, true, \",\", true, false, null,\n\t\t\t\tref -> scan(ref));\n\t\t}\n\t\tcontext.pushCurrentThis(intrface);\n\t\tprinter.writeSpace().writeSeparator(\"{\").incTab();\n\t\t// Content\n\t\telementPrinterHelper.writeElementList(intrface.getTypeMembers());\n\t\tprinter.decTab().writeSeparator(\"}\");\n\t\tcontext.popCurrentThis();\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInvocation(CtInvocation<T> invocation) {\n\t\tenterCtStatement(invocation);\n\t\tenterCtExpression(invocation);\n\t\tif (invocation.getExecutable().isConstructor()) {\n\t\t\t// It's a constructor (super or this)\n\t\t\telementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n\t\t\tCtType<?> parentType;\n\t\t\ttry {\n\t\t\t\tparentType = invocation.getParent(CtType.class);\n\t\t\t} catch (ParentNotInitializedException e) {\n\t\t\t\tparentType = null;\n\t\t\t}\n\t\t\tif (parentType != null && parentType.getQualifiedName() != null && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n\t\t\t\tprinter.writeKeyword(\"this\");\n\t\t\t} else {\n\t\t\t\tif (invocation.getTarget() != null && !invocation.getTarget().isImplicit()) {\n\t\t\t\t\tscan(invocation.getTarget());\n\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t}\n\t\t\t\tprinter.writeKeyword(\"super\");\n\t\t\t}\n\t\t} else {\n\t\t\t// It's a method invocation\n\t\t\tboolean isImported = this.isImported(invocation.getExecutable());\n\t\t\tif (!isImported) {\n\t\t\t\ttry (Writable _context = context.modify()) {\n\t\t\t\t\tif (invocation.getTarget() instanceof CtTypeAccess) {\n\t\t\t\t\t\t_context.ignoreGenerics(true);\n\t\t\t\t\t}\n\t\t\t\t\tif (invocation.getTarget() != null && !invocation.getTarget().isImplicit()) {\n\t\t\t\t\t\tscan(invocation.getTarget());\n\t\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telementPrinterHelper.writeActualTypeArguments(invocation);\n\t\t\tif (env.isPreserveLineNumbers()) {\n\t\t\t\tgetPrinterHelper().adjustStartPosition(invocation);\n\t\t\t}\n\t\t\tprinter.writeIdentifier(invocation.getExecutable().getSimpleName());\n\t\t}\n\t\telementPrinterHelper.printList(invocation.getArguments(),\n\t\t\tnull, false, \"(\", false, false, \",\", true, false, \")\",\n\t\t\te -> scan(e));\n\t\texitCtExpression(invocation);\n\t\texitCtStatement(invocation);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLiteral(CtLiteral<T> literal) {\n\t\tenterCtExpression(literal);\n\t\tprinter.writeLiteral(LiteralHelper.getLiteralToken(literal));\n\t\texitCtExpression(literal);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\t\tenterCtStatement(localVariable);\n\t\tif (env.isPreserveLineNumbers()) {\n\t\t\tgetPrinterHelper().adjustStartPosition(localVariable);\n\t\t}\n\t\tif (!context.isNextForVariable()) {\n\t\t\telementPrinterHelper.writeModifiers(localVariable);\n\t\t\tif (localVariable.isInferred() && this.env.getComplianceLevel() >= 10) {\n\t\t\t\tgetPrinterTokenWriter().writeKeyword(\"var\");\n\t\t\t} else {\n\t\t\t\tscan(localVariable.getType());\n\t\t\t}\n\t\t\tprinter.writeSpace();\n\t\t}\n\t\tprinter.writeIdentifier(localVariable.getSimpleName());\n\t\tif (localVariable.getDefaultExpression() != null) {\n\t\t\tprinter.writeSpace().writeOperator(\"=\").writeSpace();\n\t\t\tscan(localVariable.getDefaultExpression());\n\t\t}\n\t\texitCtStatement(localVariable);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLocalVariableReference(CtLocalVariableReference<T> reference) {\n\t\tprinter.writeIdentifier(reference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\tif (env.isPreserveLineNumbers()) {\n\t\t\tgetPrinterHelper().adjustStartPosition(catchVariable);\n\t\t}\n\t\telementPrinterHelper.writeModifiers(catchVariable);\n\t\tscan(catchVariable.getType());\n\t\tprinter.writeSpace();\n\t\tprinter.writeIdentifier(catchVariable.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariableReference(CtCatchVariableReference<T> reference) {\n\t\tprinter.writeIdentifier(reference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtMethod(CtMethod<T> m) {\n\t\telementPrinterHelper.writeComment(m, CommentOffset.BEFORE);\n\t\telementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n\t\telementPrinterHelper.writeModifiers(m);\n\t\telementPrinterHelper.writeFormalTypeParameters(m);\n\t\tif (!m.getFormalCtTypeParameters().isEmpty()) {\n\t\t\tprinter.writeSpace();\n\t\t}\n\t\ttry (Writable _context = context.modify().ignoreGenerics(false)) {\n\t\t\tscan(m.getType());\n\t\t}\n\t\tprinter.writeSpace();\n\t\tprinter.writeIdentifier(m.getSimpleName());\n\t\telementPrinterHelper.writeExecutableParameters(m);\n\t\telementPrinterHelper.writeThrowsClause(m);\n\t\tif (m.getBody() != null) {\n\t\t\tprinter.writeSpace();\n\t\t\tscan(m.getBody());\n\t\t\tif (m.getBody().getPosition().isValidPosition()) {\n\t\t\t\tif (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n\t\t\t\t\tif (m.getBody().getStatements().isEmpty() || !(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof CtReturn)) {\n\t\t\t\t\t\tgetPrinterHelper().putLineNumberMapping(m.getBody().getPosition().getEndLine());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgetPrinterHelper().undefineLine();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgetPrinterHelper().undefineLine();\n\t\t\t}\n\t\t} else {\n\t\t\tprinter.writeSeparator(\";\");\n\t\t}\n\t\telementPrinterHelper.writeComment(m, CommentOffset.AFTER);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\t\telementPrinterHelper.writeComment(annotationMethod);\n\t\telementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n\t\telementPrinterHelper.writeModifiers(annotationMethod);\n\t\tscan(annotationMethod.getType());\n\t\tprinter.writeSpace();\n\t\tprinter.writeIdentifier(annotationMethod.getSimpleName());\n\n\t\tprinter.writeSeparator(\"(\").writeSeparator(\")\");\n\t\tif (annotationMethod.getDefaultExpression() != null) {\n\t\t\tprinter.writeSpace().writeKeyword(\"default\").writeSpace();\n\t\t\tscan(annotationMethod.getDefaultExpression());\n\t\t}\n\t\tprinter.writeSeparator(\";\");\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic <T> void visitCtNewArray(CtNewArray<T> newArray) {\n\t\tenterCtExpression(newArray);\n\t\tboolean isNotInAnnotation;\n\t\ttry {\n\t\t\tisNotInAnnotation = (newArray.getParent(CtAnnotationType.class) == null) && (newArray.getParent(CtAnnotation.class) == null);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\tisNotInAnnotation = true;\n\t\t}\n\n\t\tif (isNotInAnnotation) {\n\t\t\tCtTypeReference<?> ref = newArray.getType();\n\n\t\t\tif (ref != null) {\n\t\t\t\tprinter.writeKeyword(\"new\").writeSpace();\n\t\t\t}\n\n\t\t\ttry (Writable _context = context.modify().skipArray(true)) {\n\t\t\t\tscan(ref);\n\t\t\t}\n\t\t\tfor (int i = 0; ref instanceof CtArrayTypeReference; i++) {\n\t\t\t\tprinter.writeSeparator(\"[\");\n\t\t\t\tif (newArray.getDimensionExpressions().size() > i) {\n\t\t\t\t\tCtExpression<Integer> e = newArray.getDimensionExpressions().get(i);\n\t\t\t\t\tscan(e);\n\t\t\t\t}\n\t\t\t\tprinter.writeSeparator(\"]\");\n\t\t\t\tref = ((CtArrayTypeReference) ref).getComponentType();\n\t\t\t}\n\t\t}\n\t\tif (newArray.getDimensionExpressions().isEmpty()) {\n\t\t\telementPrinterHelper.printList(newArray.getElements(),\n\t\t\t\tnull, false, \"{\", true, false, \",\", true, true, \"}\",\n\t\t\t\te -> scan(e));\n\t\t\telementPrinterHelper.writeComment(newArray, CommentOffset.INSIDE);\n\t\t}\n\t\telementPrinterHelper.writeComment(newArray, CommentOffset.AFTER);\n\t\texitCtExpression(newArray);\n\t}\n\n\n\t@Override\n\tpublic <T> void visitCtConstructorCall(CtConstructorCall<T> ctConstructorCall) {\n\t\tenterCtStatement(ctConstructorCall);\n\t\tenterCtExpression(ctConstructorCall);\n\n\t\tprintConstructorCall(ctConstructorCall);\n\n\t\texitCtExpression(ctConstructorCall);\n\t\texitCtStatement(ctConstructorCall);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtNewClass(CtNewClass<T> newClass) {\n\t\tenterCtStatement(newClass);\n\t\tenterCtExpression(newClass);\n\n\t\tprintConstructorCall(newClass);\n\n\t\tscan(newClass.getAnonymousClass());\n\t\texitCtExpression(newClass);\n\t\texitCtStatement(newClass);\n\t}\n\n\tprivate <T> void printConstructorCall(CtConstructorCall<T> ctConstructorCall) {\n\t\ttry (Writable _context = context.modify()) {\n\t\t\tif (ctConstructorCall.getTarget() != null) {\n\t\t\t\tscan(ctConstructorCall.getTarget());\n\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t_context.ignoreEnclosingClass(true);\n\t\t\t}\n\n\t\t\tif (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n\t\t\t\t_context.ignoreEnclosingClass(true);\n\t\t\t}\n\n\t\t\tprinter.writeKeyword(\"new\").writeSpace();\n\n\t\t\tif (!ctConstructorCall.getActualTypeArguments().isEmpty()) {\n\t\t\t\telementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n\t\t\t}\n\n\t\t\tscan(ctConstructorCall.getType());\n\t\t}\n\n\t\telementPrinterHelper.printList(ctConstructorCall.getArguments(),\n\t\t\tnull, false, \"(\", false, false, \",\", true, false, \")\",\n\t\t\texp -> scan(exp));\n\t}\n\n\t/**\n\t * JDT doesn't support <code>new Foo<K>.Bar()</code>. To avoid reprinting this kind of type reference,\n\t * we check that the reference has a declaring type with generics.\n\t * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=474593\n\t *\n\t * @param reference Type reference concerned by the bug.\n\t * @return true if a declaring type has generic types.\n\t */\n\tprivate <T> boolean hasDeclaringTypeWithGenerics(CtTypeReference<T> reference) {\n\t\t// We don't have a declaring type, it can't have generics.\n\t\tif (reference == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// If the declaring type isn't a type, we don't need this hack.\n\t\tif (reference.getDeclaringType() == null) {\n\t\t\treturn false;\n\t\t}\n\t\t// If current reference is a class declared in a method, we don't need this hack.\n\t\tif (reference.isLocalType()) {\n\t\t\treturn false;\n\t\t}\n\t\t// If declaring type have generics, we return true.\n\t\tif (!reference.getDeclaringType().getActualTypeArguments().isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\t// Checks if the declaring type has generic types.\n\t\treturn hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLambda(CtLambda<T> lambda) {\n\t\tenterCtExpression(lambda);\n\n\t\telementPrinterHelper.printList(lambda.getParameters(),\n\t\t\tnull, false, \"(\", false, false, \",\", false, false, \")\",\n\t\t\tparameter -> scan(parameter));\n\t\tprinter.writeSpace();\n\t\tprinter.writeSeparator(\"->\");\n\t\tprinter.writeSpace();\n\n\t\tif (lambda.getBody() != null) {\n\t\t\tscan(lambda.getBody());\n\t\t} else {\n\t\t\tscan(lambda.getExpression());\n\t\t}\n\t\texitCtExpression(lambda);\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(CtExecutableReferenceExpression<T, E> expression) {\n\t\tenterCtExpression(expression);\n\t\ttry (Writable _context = context.modify()) {\n\t\t\tif (expression.getExecutable().isStatic()) {\n\t\t\t\t_context.ignoreGenerics(true);\n\t\t\t}\n\t\t\tscan(expression.getTarget());\n\t\t}\n\t\tprinter.writeSeparator(\"::\");\n\t\tif (expression.getExecutable().isConstructor()) {\n\t\t\tprinter.writeKeyword(\"new\");\n\t\t} else {\n\t\t\tprinter.writeIdentifier(expression.getExecutable().getSimpleName());\n\t\t}\n\t\texitCtExpression(expression);\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtOperatorAssignment(CtOperatorAssignment<T, A> assignment) {\n\t\tenterCtStatement(assignment);\n\t\tenterCtExpression(assignment);\n\t\tscan(assignment.getAssigned());\n\t\tprinter.writeSpace();\n\t\t// the operators like +=, *= are sent as one operator token\n\t\tprinter.writeOperator(OperatorHelper.getOperatorText(assignment.getKind()) + \"=\");\n\t\tprinter.writeSpace();\n\t\tscan(assignment.getAssignment());\n\t\texitCtExpression(assignment);\n\t\texitCtStatement(assignment);\n\t}\n\n\t@Override\n\tpublic void visitCtPackage(CtPackage ctPackage) {\n\t\tif (!ctPackage.isUnnamedPackage()) {\n\t\t\telementPrinterHelper.writePackageLine(ctPackage.getQualifiedName());\n\t\t} else {\n\t\t\tprinter.writeComment(\n\t\t\t\t\tctPackage.getFactory().createComment(\"default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\", CommentType.INLINE)\n\t\t\t\t).writeln();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtPackageReference(CtPackageReference reference) {\n\t\telementPrinterHelper.writeQualifiedName(reference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtParameter(CtParameter<T> parameter) {\n\t\telementPrinterHelper.writeComment(parameter);\n\t\telementPrinterHelper.writeAnnotations(parameter);\n\t\telementPrinterHelper.writeModifiers(parameter);\n\t\tif (parameter.isVarArgs()) {\n\t\t\tscan(((CtArrayTypeReference<T>) parameter.getType()).getComponentType());\n\t\t\tprinter.writeSeparator(\"...\");\n\t\t} else {\n\t\t\tscan(parameter.getType());\n\t\t}\n\t\tprinter.writeSpace();\n\t\tprinter.writeIdentifier(parameter.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtParameterReference(CtParameterReference<T> reference) {\n\t\tprinter.writeIdentifier(reference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic <R> void visitCtReturn(CtReturn<R> returnStatement) {\n\t\tenterCtStatement(returnStatement);\n\t\tprinter.writeKeyword(\"return\");\n\t\t// checkstyle wants \"return;\" and not \"return ;\"\n\t\tif (returnStatement.getReturnedExpression() != null) {\n\t\t\tprinter.writeSpace();\n\t\t}\n\t\tscan(returnStatement.getReturnedExpression());\n\t\texitCtStatement(returnStatement);\n\t}\n\n\tprivate <T> void visitCtType(CtType<T> type) {\n\t\telementPrinterHelper.writeComment(type, CommentOffset.BEFORE);\n\t\tgetPrinterHelper().mapLine(type, sourceCompilationUnit);\n\t\tif (type.isTopLevel()) {\n\t\t\tcontext.currentTopLevel = type;\n\t\t}\n\t\telementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n\t\telementPrinterHelper.writeModifiers(type);\n\t}\n\n\t@Override\n\tpublic void visitCtStatementList(CtStatementList statements) {\n\t\tfor (CtStatement s : statements.getStatements()) {\n\t\t\tscan(s);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <E> void visitCtSwitch(CtSwitch<E> switchStatement) {\n\t\tenterCtStatement(switchStatement);\n\t\tprinter.writeKeyword(\"switch\").writeSpace().writeSeparator(\"(\");\n\t\tscan(switchStatement.getSelector());\n\t\tprinter.writeSeparator(\")\").writeSpace().writeSeparator(\"{\").incTab();\n\t\tfor (CtCase<?> c : switchStatement.getCases()) {\n\t\t\tprinter.writeln();\n\t\t\tscan(c);\n\t\t}\n\t\tif (env.isPreserveLineNumbers()) {\n\t\t\tprinter.decTab().writeSeparator(\"}\");\n\t\t} else {\n\t\t\tprinter.decTab().writeln().writeSeparator(\"}\");\n\t\t}\n\t\texitCtStatement(switchStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtSynchronized(CtSynchronized synchro) {\n\t\tenterCtStatement(synchro);\n\t\tprinter.writeKeyword(\"synchronized\");\n\t\tif (synchro.getExpression() != null) {\n\t\t\tprinter.writeSeparator(\"(\");\n\t\t\tscan(synchro.getExpression());\n\t\t\tprinter.writeSeparator(\")\").writeSpace();\n\t\t}\n\t\tscan(synchro.getBlock());\n\t\texitCtStatement(synchro);\n\t}\n\n\t@Override\n\tpublic void visitCtThrow(CtThrow throwStatement) {\n\t\tenterCtStatement(throwStatement);\n\t\tprinter.writeKeyword(\"throw\").writeSpace();\n\t\tscan(throwStatement.getThrownExpression());\n\t\texitCtStatement(throwStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtTry(CtTry tryBlock) {\n\t\tenterCtStatement(tryBlock);\n\t\tprinter.writeKeyword(\"try\").writeSpace();\n\t\tscan(tryBlock.getBody());\n\t\tfor (CtCatch c : tryBlock.getCatchers()) {\n\t\t\tscan(c);\n\t\t}\n\n\t\tif (tryBlock.getFinalizer() != null) {\n\t\t\tprinter.writeSpace().writeKeyword(\"finally\").writeSpace();\n\t\t\tscan(tryBlock.getFinalizer());\n\t\t}\n\t\texitCtStatement(tryBlock);\n\t}\n\n\t@Override\n\tpublic void visitCtTryWithResource(CtTryWithResource tryWithResource) {\n\t\tenterCtStatement(tryWithResource);\n\t\tprinter.writeKeyword(\"try\").writeSpace();\n\t\tif (tryWithResource.getResources() != null && !tryWithResource.getResources().isEmpty()) {\n\t\t\telementPrinterHelper.printList(tryWithResource.getResources(),\n\t\t\t\tnull, false, \"(\", false, false, \";\", false, false, \")\",\n\t\t\t\tr -> scan(r));\n\t\t}\n\t\tprinter.writeSpace();\n\t\tscan(tryWithResource.getBody());\n\t\tfor (CtCatch c : tryWithResource.getCatchers()) {\n\t\t\tscan(c);\n\t\t}\n\n\t\tif (tryWithResource.getFinalizer() != null) {\n\t\t\tprinter.writeSpace().writeKeyword(\"finally\").writeSpace();\n\t\t\tscan(tryWithResource.getFinalizer());\n\t\t}\n\t\texitCtStatement(tryWithResource);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameterReference(CtTypeParameterReference ref) {\n\t\tif (ref.isImplicit()) {\n\t\t\treturn;\n\t\t}\n\t\telementPrinterHelper.writeAnnotations(ref);\n\t\tif (printQualified(ref)) {\n\t\t\telementPrinterHelper.writeQualifiedName(ref.getQualifiedName());\n\t\t} else {\n\t\t\tprinter.writeIdentifier(ref.getSimpleName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference wildcardReference) {\n\t\tif (wildcardReference.isImplicit()) {\n\t\t\treturn;\n\t\t}\n\t\telementPrinterHelper.writeAnnotations(wildcardReference);\n\t\tprinter.writeSeparator(\"?\");\n\t\t// we ignore printing \"extends Object\" except if it's explicit\n\t\tif (!wildcardReference.isDefaultBoundingType() || !wildcardReference.getBoundingType().isImplicit()) {\n\t\t\tif (wildcardReference.isUpper()) {\n\t\t\t\tprinter.writeSpace().writeKeyword(\"extends\").writeSpace();\n\t\t\t} else {\n\t\t\t\tprinter.writeSpace().writeKeyword(\"super\").writeSpace();\n\t\t\t}\n\t\t\tscan(wildcardReference.getBoundingType());\n\t\t}\n\t}\n\n\tprivate boolean printQualified(CtTypeReference<?> ref) {\n\t\tif (importsContext.isImported(ref)  // If my.pkg.Something is imported\n\t\t\t\t|| (this.env.isAutoImports() && ref.getPackage() != null && \"java.lang\".equals(ref.getPackage().getSimpleName())) // or that we are in java.lang\n\t\t\t\t) {\n\t\t\tfor (CacheBasedConflictFinder typeContext : context.currentThis) {\n\t\t\t\t//A) we are in the context of a class which is also called \"Something\",\n\t\t\t\tif (typeContext.getSimpleName().equals(ref.getSimpleName())\n\t\t\t\t\t\t&& !Objects.equals(typeContext.getPackage(), ref.getPackage())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t//B) we are in the context of a class which defines field which is also called \"Something\",\n\t\t\t\t//\twe should still use qualified version my.pkg.Something\n\t\t\t\tif (typeContext.hasFieldConflict(ref.getSimpleName())\n\t\t\t\t\t\t|| typeContext.hasNestedTypeConflict(ref.getSimpleName()) // fix of #2369\n\t\t\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {\n\t\telementPrinterHelper.printList(reference.getBounds(),\n\t\t\tnull, false, null, false, true, \"&\", true, false, null,\n\t\t\tbound -> scan(bound));\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> ref) {\n\t\tvisitCtTypeReference(ref, true);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {\n\t\tif (typeAccess.isImplicit()) {\n\t\t\treturn;\n\t\t}\n\t\tenterCtExpression(typeAccess);\n\t\tscan(typeAccess.getAccessedType());\n\t\texitCtExpression(typeAccess);\n\t}\n\n\tprivate void visitCtTypeReferenceWithoutGenerics(CtTypeReference<?> ref) {\n\t\tvisitCtTypeReference(ref, false);\n\t}\n\n\tprivate void visitCtTypeReference(CtTypeReference<?> ref, boolean withGenerics) {\n\t\tif (ref.isImplicit()) {\n\t\t\treturn;\n\t\t}\n\t\tif (ref.isPrimitive()) {\n\t\t\telementPrinterHelper.writeAnnotations(ref);\n\t\t\tprinter.writeKeyword(ref.getSimpleName());\n\t\t\treturn;\n\t\t}\n\t\tboolean isInner = ref.getDeclaringType() != null;\n\t\tif (isInner) {\n\t\t\tif (!context.ignoreEnclosingClass() && !ref.isLocalType()) {\n\t\t\t\t//compute visible type which can be used to print access path to ref\n\t\t\t\tCtTypeReference<?> accessType = ref.getAccessType();\n\t\t\t\tif (!accessType.isAnonymous()) {\n\t\t\t\t\ttry (Writable _context = context.modify()) {\n\t\t\t\t\t\tif (!withGenerics) {\n\t\t\t\t\t\t\t_context.ignoreGenerics(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscan(accessType);\n\t\t\t\t\t}\n\t\t\t\t\tprinter.writeSeparator(\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t//?? are these annotations on correct place ??\n\t\t\telementPrinterHelper.writeAnnotations(ref);\n\t\t\tif (ref.isLocalType()) {\n\t\t\t\tprinter.writeIdentifier(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n\t\t\t} else {\n\t\t\t\tprinter.writeIdentifier(ref.getSimpleName());\n\t\t\t}\n\t\t} else {\n\t\t\tif (ref.getPackage() != null && printQualified(ref)) {\n\t\t\t\tif (!ref.getPackage().isUnnamedPackage()) {\n\t\t\t\t\tscan(ref.getPackage());\n\t\t\t\t\tprinter.writeSeparator(CtPackage.PACKAGE_SEPARATOR);\n\t\t\t\t}\n\t\t\t}\n\t\t\telementPrinterHelper.writeAnnotations(ref);\n\t\t\tprinter.writeIdentifier(ref.getSimpleName());\n\t\t}\n\t\tif (withGenerics && !context.ignoreGenerics()) {\n\t\t\ttry (Writable _context = context.modify().ignoreEnclosingClass(false)) {\n\t\t\t\telementPrinterHelper.writeActualTypeArguments(ref);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {\n\t\tenterCtStatement(operator);\n\t\tenterCtExpression(operator);\n\t\tUnaryOperatorKind op = operator.getKind();\n\t\tif (OperatorHelper.isPrefixOperator(op)) {\n\t\t\tprinter.writeOperator(OperatorHelper.getOperatorText(op));\n\t\t}\n\t\tscan(operator.getOperand());\n\t\tif (OperatorHelper.isSufixOperator(op)) {\n\t\t\tprinter.writeOperator(OperatorHelper.getOperatorText(op));\n\t\t}\n\t\texitCtExpression(operator);\n\t\texitCtStatement(operator);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableRead(CtVariableRead<T> variableRead) {\n\t\tenterCtExpression(variableRead);\n\t\tprinter.writeIdentifier(variableRead.getVariable().getSimpleName());\n\t\texitCtExpression(variableRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableWrite(CtVariableWrite<T> variableWrite) {\n\t\tenterCtExpression(variableWrite);\n\t\tprinter.writeIdentifier(variableWrite.getVariable().getSimpleName());\n\t\texitCtExpression(variableWrite);\n\t}\n\n\t@Override\n\tpublic void visitCtWhile(CtWhile whileLoop) {\n\t\tenterCtStatement(whileLoop);\n\t\tprinter.writeKeyword(\"while\").writeSpace().writeSeparator(\"(\");\n\t\tscan(whileLoop.getLoopingExpression());\n\t\tprinter.writeSeparator(\")\");\n\n\t\telementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n\t\texitCtStatement(whileLoop);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCodeSnippetExpression(CtCodeSnippetExpression<T> expression) {\n\t\telementPrinterHelper.writeComment(expression);\n\t\tprinter.writeCodeSnippet(expression.getValue());\n\t}\n\n\t@Override\n\tpublic void visitCtCodeSnippetStatement(CtCodeSnippetStatement statement) {\n\t\tenterCtStatement(statement);\n\t\tprinter.writeCodeSnippet(statement.getValue());\n\t\texitCtStatement(statement);\n\t}\n\n\tpublic ElementPrinterHelper getElementPrinterHelper() {\n\t\treturn elementPrinterHelper;\n\t}\n\n\tpublic PrintingContext getContext() {\n\t\treturn context;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnboundVariableReference(CtUnboundVariableReference<T> reference) {\n\t\tprinter.writeIdentifier(reference.getSimpleName());\n\t}\n\n\t@Override\n\tpublic String printPackageInfo(CtPackage pack) {\n\t\treset();\n\t\telementPrinterHelper.writeComment(pack);\n\n\t\t// we need to compute imports only for annotations\n\t\t// we don't want to get all imports coming from content of package\n\t\tfor (CtAnnotation annotation : pack.getAnnotations()) {\n\t\t\tthis.importsContext.computeImports(annotation);\n\t\t}\n\t\telementPrinterHelper.writeAnnotations(pack);\n\n\t\tif (!pack.isUnnamedPackage()) {\n\t\t\telementPrinterHelper.writePackageLine(pack.getQualifiedName());\n\t\t}\n\t\telementPrinterHelper.writeImports(this.importsContext.getAllImports());\n\t\treturn printer.getPrinterHelper().toString();\n\t}\n\n\t@Override\n\tpublic String printModuleInfo(CtModule module) {\n\t\treset();\n\t\tscan(module);\n\t\treturn this.getResult();\n\t}\n\n\t@Override\n\tpublic String getResult() {\n\t\treturn printer.getPrinterHelper().toString();\n\t}\n\n\tprivate void reset() {\n\t\tprinter.reset();\n\t\tcontext = new PrintingContext();\n\t\tif (env.isAutoImports()) {\n\t\t\tthis.importsContext = new ImportScannerImpl();\n\t\t} else {\n\t\t\tthis.importsContext = new MinimalImportScanner();\n\t\t}\n\t}\n\n\n\t/**\n\t * Write the compilation unit header.\n\t */\n\tpublic DefaultJavaPrettyPrinter writeHeader(List<CtType<?>> types, Collection<CtImport> imports) {\n\t\telementPrinterHelper.writeHeader(types, imports);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Write the compilation unit footer.\n\t */\n\tpublic DefaultJavaPrettyPrinter writeFooter(List<CtType<?>> types) {\n\t\telementPrinterHelper.writeFooter(types);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void calculate(CtCompilationUnit sourceCompilationUnit, List<CtType<?>> types) {\n\t\t// reset the importsContext to avoid errors with multiple CU\n\t\treset();\n\n\t\tthis.sourceCompilationUnit = sourceCompilationUnit;\n\t\tthis.imports = new HashSet<>();\n\t\tif (sourceCompilationUnit != null) {\n\t\t\tthis.importsContext.initWithImports(sourceCompilationUnit.getImports());\n\t\t}\n\n\t\tfor (CtType<?> t : types) {\n\t\t\timports.addAll(computeImports(t));\n\t\t}\n\t\tthis.writeHeader(types, imports);\n\t\tprintTypes(types);\n\t}\n\n\tprotected void printTypes(List<CtType<?>> types) {\n\t\tfor (CtType<?> t : types) {\n\t\t\tscan(t);\n\t\t\tif (!env.isPreserveLineNumbers()) {\n\t\t\t\t// saving lines and chars\n\t\t\t\tprinter.writeln().writeln();\n\t\t\t} else {\n\t\t\t\tgetPrinterHelper().adjustEndPosition(t);\n\t\t\t}\n\t\t}\n\t\tthis.writeFooter(types);\n\t}\n\n\t@Override\n\tpublic Map<Integer, Integer> getLineNumberMapping() {\n\t\treturn getPrinterHelper().getLineNumberMapping();\n\t}\n\n\t/**\n\t * @return current {@link TokenWriter}, so the subclasses of {@link DefaultJavaPrettyPrinter} can print tokens too\n\t */\n\tprotected TokenWriter getPrinterTokenWriter() {\n\t\treturn printer;\n\t}\n\n\t/**\n\t * Set {@link TokenWriter}, which has to be used to print tokens\n\t */\n\tpublic DefaultJavaPrettyPrinter setPrinterTokenWriter(TokenWriter tokenWriter) {\n\t\telementPrinterHelper = new ElementPrinterHelper(tokenWriter, this, env);\n\t\tprinter = tokenWriter;\n\t\treturn this;\n\t}\n\n\tprivate PrinterHelper getPrinterHelper() {\n\t\treturn printer.getPrinterHelper();\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/PrinterHelper.java",
      "weight" : 181.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.reflect.cu.position.PartialSourcePositionImpl;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Supports configurable printing of text with indentations and line and column counting\n */\npublic class PrinterHelper {\n\t/**\n\t * Line separator which is used by the printer helper.\n\t * By default the system line separator is used\n\t */\n\tprivate String lineSeparator = System.getProperty(\"line.separator\");\n\n\t/**\n\t * Environment which Spoon is executed.\n\t */\n\tprivate Environment env;\n\n\t/**\n\t * The string buffer in which the code is generated.\n\t */\n\tprotected final StringBuffer sbf = new StringBuffer();\n\n\t/**\n\t * Number of tabs when we print the source code.\n\t */\n\tprivate int nbTabs = 0;\n\n\t/**\n\t * Current line number.\n\t */\n\tprivate int line = 1;\n\n\t/**\n\t * Current column number\n\t * Not used yet, but this shows the advantage of encapsulating all sbf.append in calls to {@link #write(char)} or {@link #write(String)}.\n\t * This will be used for sniper mode later\n\t */\n\tprivate int column = 1;\n\n\t/**\n\t * Mapping for line numbers.\n\t */\n\tprivate Map<Integer, Integer> lineNumberMapping = new HashMap<>();\n\n\t/*\n\t * each writeln() sets this to true.\n\t * if true then first call of write first writes tabs and then resets this to false\n\t */\n\tprotected boolean shouldWriteTabs = true;\n\t/*\n\t * true if last written character was \\r\n\t * It helps to detect windows EOL, which is \\r\\n\n\t */\n\tprivate boolean lastCharWasCR = false;\n\n\tpublic PrinterHelper(Environment env) {\n\t\tthis.env = env;\n\t}\n\n\t/**\n\t * resets to the initial state\n\t */\n\tpublic void reset() {\n\t\tsbf.setLength(0);\n\t\tnbTabs = 0;\n\t\tline = 1;\n\t\tcolumn = 1;\n\t\tshouldWriteTabs = true;\n\t\t//create new map, because clients keeps reference to it\n\t\tlineNumberMapping = new HashMap<>();\n\t}\n\n\t/**\n\t * Outputs a string.\n\t */\n\tpublic PrinterHelper write(String s) {\n\t\tif (s != null) {\n\t\t\tint len = s.length();\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\twrite(s.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Outputs a char.\n\t */\n\tpublic PrinterHelper write(char c) {\n\t\tif (c == '\\r') {\n\t\t\tsbf.append(c);\n\t\t\tline++;\n\t\t\t// reset the column index\n\t\t\tcolumn = 1;\n\t\t\tshouldWriteTabs = true;\n\t\t\tlastCharWasCR = true;\n\t\t\treturn this;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tsbf.append(c);\n\t\t\tif (lastCharWasCR) {\n\t\t\t\t//increment line only once in sequence of \\r\\n.\n\t\t\t\t//last was \\r, so nothing to do\n\t\t\t} else {\n\t\t\t\t//increment line only once in sequence of \\r\\n.\n\t\t\t\t//last was NOT \\r, so do it now\n\t\t\t\tline++;\n\t\t\t\t// reset the column index\n\t\t\t\tcolumn = 1;\n\t\t\t\tshouldWriteTabs = true;\n\t\t\t}\n\t\t\tlastCharWasCR = false;\n\t\t\treturn this;\n\t\t}\n\t\tautoWriteTabs();\n\t\tsbf.append(c);\n\t\tcolumn += 1;\n\t\tlastCharWasCR = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Generates a new line.\n\t */\n\tpublic PrinterHelper writeln() {\n\t\twrite(lineSeparator);\n\t\treturn this;\n\t}\n\n\tprivate void writeTabsInternal() {\n\t\tfor (int i = 0; i < nbTabs; i++) {\n\t\t\tif (env.isUsingTabulations()) {\n\t\t\t\tsbf.append('\\t');\n\t\t\t\tcolumn += 1;\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < env.getTabulationSize(); j++) {\n\t\t\t\t\tsbf.append(' ');\n\t\t\t\t\tcolumn += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void autoWriteTabs() {\n\t\tif (shouldWriteTabs) {\n\t\t\twriteTabsInternal();\n\t\t\tshouldWriteTabs = false;\n\t\t}\n\t}\n\n\t/**\n\t * Increments the current number of tabs.\n\t */\n\tpublic PrinterHelper incTab() {\n\t\tnbTabs++;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Decrements the current number of tabs.\n\t */\n\tpublic PrinterHelper decTab() {\n\t\tnbTabs--;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return the current number of tabs.\n\t */\n\tpublic int getTabCount() {\n\t\treturn nbTabs;\n\t}\n\n\t/**\n\t * Sets the current number of tabs.\n\t */\n\tpublic PrinterHelper setTabCount(int tabCount) {\n\t\tnbTabs = tabCount;\n\t\treturn this;\n\t}\n\n\tpublic boolean removeLine() {\n\t\tString ls = lineSeparator;\n\t\tint i = sbf.length() - ls.length();\n\t\tboolean hasWhite = false;\n\t\twhile (i > 0 && !ls.equals(sbf.substring(i, i + ls.length()))) {\n\t\t\tif (!isWhite(sbf.charAt(i))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thasWhite = true;\n\t\t\ti--;\n\t\t}\n\t\tif (i <= 0) {\n\t\t\treturn false;\n\t\t}\n\t\thasWhite = hasWhite || isWhite(sbf.charAt(i - 1));\n\t\tsbf.replace(i, i + ls.length(), hasWhite ? \"\" : \" \");\n\t\tline--;\n\t\treturn true;\n\t}\n\n\tprivate boolean isWhite(char c) {\n\t\treturn (c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r');\n\t}\n\n\t/** writes as many newlines as needed to align the line number again between the element position and the current line number */\n\tpublic PrinterHelper adjustStartPosition(CtElement e) {\n\t\tif (!e.isImplicit() && e.getPosition().isValidPosition()) {\n\t\t\t// we should add some lines\n\t\t\twhile (line < e.getPosition().getLine()) {\n\t\t\t\twriteln();\n\t\t\t}\n\t\t\t// trying to remove some lines\n\t\t\twhile (line > e.getPosition().getLine()) {\n\t\t\t\tif (!removeLine()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic PrinterHelper adjustEndPosition(CtElement e) {\n\t\tif (env.isPreserveLineNumbers() && e.getPosition().isValidPosition()) {\n\t\t\t// let's add lines if required\n\t\t\twhile (line < e.getPosition().getEndLine()) {\n\t\t\t\twriteln();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic void undefineLine() {\n\t\tif (lineNumberMapping.get(line) == null) {\n\t\t\tputLineNumberMapping(0);\n\t\t}\n\t}\n\n\tpublic void mapLine(CtElement e, CtCompilationUnit unitExpected) {\n\t\tSourcePosition sp = e.getPosition();\n\t\tif ((sp.isValidPosition())\n\t\t\t\t&& (sp.getCompilationUnit() == unitExpected)\n\t\t\t\t&& (sp instanceof PartialSourcePositionImpl) == false) {\n\t\t\t// only map elements coming from the source CU\n\t\t\tputLineNumberMapping(e.getPosition().getLine());\n\t\t} else {\n\t\t\tundefineLine();\n\t\t}\n\t}\n\n\tpublic void putLineNumberMapping(int valueLine) {\n\t\tlineNumberMapping.put(this.line, valueLine);\n\t}\n\n\tpublic Map<Integer, Integer> getLineNumberMapping() {\n\t\treturn Collections.unmodifiableMap(lineNumberMapping);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn sbf.toString();\n\t}\n\n\t/**\n\t * @return current line separator. By default there is CR LF, LF or CR depending on the Operation system\n\t * defined by System.getProperty(\"line.separator\")\n\t */\n\tpublic String getLineSeparator() {\n\t\treturn lineSeparator;\n\t}\n\n\t/**\n\t * @param lineSeparator characters which will be printed as End of line.\n\t * By default there is System.getProperty(\"line.separator\")\n\t */\n\tpublic void setLineSeparator(String lineSeparator) {\n\t\tthis.lineSeparator = lineSeparator;\n\t}\n\n\t/** writes a space ' ' */\n\tpublic void writeSpace() {\n\t\tthis.write(' ');\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtIterator.java",
      "weight" : 40.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n/**\n * A class to be able to iterate over the children elements in the tree of a given node, in depth-first order.\n */\npublic class CtIterator extends CtScanner implements Iterator<CtElement> {\n\t/**\n\t * A deque containing the elements the iterator has seen but not expanded\n\t */\n\tprivate ArrayDeque<CtElement> deque = new ArrayDeque<CtElement>() {\n\t\t/**\n\t\t * add a collection of elements with addFirst instead of default add() which defaults to addLast()\n\t\t * @param c Collection of CtElements\n\t\t * @return true if this deque has changed, in accordance with original method\n\t\t */\n\t\t@Override\n\t\tpublic boolean addAll(Collection c) {\n\t\t\tfor (Object aC : c) {\n\t\t\t\tthis.addFirst((CtElement) aC);\n\t\t\t}\n\t\t\treturn !c.isEmpty();\n\t\t}\n\t};\n\n\t/**\n\t * A deque to be used when scanning an element so that @deque preserves the elements in dfs without complete expansion\n\t */\n\tprivate ArrayDeque<CtElement> current_children = new ArrayDeque<>();\n\n\t/**\n\t * CtIterator constructor, prepares the iterator from the @root node\n\t *\n\t * @param root the initial node to expand\n\t */\n\tpublic CtIterator(CtElement root) {\n\t\tif (root != null) {\n\t\t\tdeque.add(root);\n\t\t}\n\t}\n\n\t/**\n\t * prevent scanner from going down the tree, instead save with other CtElement children of the current node\n\t *\n\t * @param element the next direct child of the current node being expanded\n\t */\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\tcurrent_children.addFirst(element);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn !deque.isEmpty();\n\t}\n\n\t/**\n\t * Dereference the \"iterator\"\n\t *\n\t * @return CtElement the next element in DFS order without going down the tree\n\t */\n\t@Override\n\tpublic CtElement next() {\n\t\tCtElement next = deque.pollFirst(); // get the element to expand from the deque\n\t\tcurrent_children.clear(); // clear for this scan\n\t\tnext.accept(this); // call @scan for each direct child of the node\n\t\tdeque.addAll(current_children); // overridden method to add all to first\n\t\treturn next;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/Filter.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface defines a filter for program elements.\n *\n * @param <T>\n * \t\tthe type of the filtered elements (an element belonging to the\n * \t\tfiltered element must be assignable from <code>T</code>).\n */\npublic interface Filter<T extends CtElement> {\n\t/**\n\t * Tells if the given element matches.\n\t * @param element - the element to be checked for a match. Parameter element is never null if {@link Query} is used.\n\t */\n\tboolean matches(T element);\n}\n"
    }, {
      "name" : "reflect/visitor/JavaIdentifiers.java",
      "weight" : 56.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.reference.CtExecutableReference;\n\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * This enum defines the Java keywords and some helper method to determine if\n * some strings are Java identifiers.\n */\npublic enum JavaIdentifiers {\n\n\tIMPORT, PACKAGE, INTERFACE, CLASS, ENUM, SUPER, THIS, ASSERT, EXTENDS, BREAK, CASE, CATCH, CONTINUE, DO, FOR, IF,\n\tNEW, RETURN, SWITCH, THROW, TRY, WHILE,\n\n\tPUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, TRANSIENT, VOLATILE, SYNCHRONIZED, NATIVE, STRICTFP;\n\n\t/**\n\t * Contains the Java keywords.\n\t */\n\tpublic static final Set<String> KEYWORDS;\n\n\tstatic {\n\t\tKEYWORDS = new HashSet<>();\n\t\tfor (JavaIdentifiers kw : JavaIdentifiers.values()) {\n\t\t\tKEYWORDS.add(kw.name().toLowerCase());\n\t\t}\n\t}\n\n\tstatic boolean isJavaIdentifier(String s) {\n\t\tif (s.isEmpty() || !Character.isJavaIdentifierStart(s.charAt(0))) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 1; i < s.length(); i++) {\n\t\t\tif (!Character.isJavaIdentifierPart(s.charAt(i))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if a string is a valid Java identifier and not a Java keyword.\n\t *\n\t * @param string\n\t * \t\tthe string to be tested\n\t */\n\tpublic static boolean isLegalJavaIdentifier(String string) {\n\t\tif (string == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !KEYWORDS.contains(string) && isJavaIdentifier(string);\n\t}\n\n\t/**\n\t * Checks if a string is a valid Java package identifier.\n\t *\n\t * @param string\n\t * \t\tthe string to be tested\n\t */\n\tpublic static boolean isLegalJavaPackageIdentifier(String string) {\n\t\tif (string == null) {\n\t\t\treturn false;\n\t\t}\n\t\tStringTokenizer st = new StringTokenizer(string, \".\");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tString s = st.nextToken();\n\t\t\tif (!isLegalJavaIdentifier(s)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if a string is a valid Java package identifier.\n\t *\n\t * @param string\n\t * \t\tthe string to be tested\n\t */\n\tpublic static boolean isLegalJavaExecutableIdentifier(String string) {\n\t\tif (string == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (string.equals(CtExecutableReference.CONSTRUCTOR_NAME)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn isLegalJavaIdentifier(string);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/Child.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation defines a method that contains children of an element of the\n * meta model. It is used for the automatic generation of visitors of spoon\n * metamodel elements.\n */\n@Target({ ElementType.METHOD })\npublic @interface Child {\n\t/**\n\t * The ordering of the child relatively to the other children of the parent\n\t * node. Children will be scanned in the declared order.\n\t */\n\tint order() default 0;\n}\n"
    }, {
      "name" : "reflect/visitor/CtBiScannerDefault.java",
      "weight" : 818.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\n\n/**\n * This visitor implements a deep-search scan on the model for 2 elements.\n *\n * Ensures that all children nodes are visited once, a visit means three method\n * calls, one call to \"enter\", one call to \"exit\" and one call to biScan.\n *\n * This class is generated automatically by the processor spoon.generating.CtBiScannerGenerator.\n *\n * Is used by EqualsVisitor.\n */\n// autogenerated by CtBiScannerGenerator\npublic class CtBiScannerDefault extends spoon.reflect.visitor.CtAbstractBiScanner {\n\tprotected java.util.Deque<spoon.reflect.declaration.CtElement> stack = new java.util.ArrayDeque<>();\n\n\tprotected void enter(spoon.reflect.declaration.CtElement e) {\n\t}\n\n\tprotected void exit(spoon.reflect.declaration.CtElement e) {\n\t}\n\n\tpublic void biScan(spoon.reflect.declaration.CtElement element, spoon.reflect.declaration.CtElement other) {\n\t\tif (other == null) {\n\t\t\treturn;\n\t\t}\n\t\tstack.push(other);\n\t\ttry {\n\t\t\telement.accept(this);\n\t\t} finally {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n\tpublic void biScan(spoon.reflect.path.CtRole role, spoon.reflect.declaration.CtElement element, spoon.reflect.declaration.CtElement other) {\n\t\tbiScan(element, other);\n\t}\n\n\tprotected void biScan(spoon.reflect.path.CtRole role, java.util.Collection<? extends spoon.reflect.declaration.CtElement> elements, java.util.Collection<? extends spoon.reflect.declaration.CtElement> others) {\n\t\tfor (java.util.Iterator<? extends spoon.reflect.declaration.CtElement> firstIt = elements.iterator(), secondIt = others.iterator(); (firstIt.hasNext()) && (secondIt.hasNext());) {\n\t\t\tbiScan(role, firstIt.next(), secondIt.next());\n\t\t}\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {\n\t\tspoon.reflect.declaration.CtAnnotation other = ((spoon.reflect.declaration.CtAnnotation) (this.stack.peek()));\n\t\tenter(annotation);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, annotation.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, annotation.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION_TYPE, annotation.getAnnotationType(), other.getAnnotationType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, annotation.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.VALUE, annotation.getValues().values(), other.getValues().values());\n\t\texit(annotation);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n\t\tspoon.reflect.declaration.CtAnnotationType other = ((spoon.reflect.declaration.CtAnnotationType) (this.stack.peek()));\n\t\tenter(annotationType);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, annotationType.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_MEMBER, annotationType.getTypeMembers(), other.getTypeMembers());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, annotationType.getComments(), other.getComments());\n\t\texit(annotationType);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtAnonymousExecutable(final spoon.reflect.declaration.CtAnonymousExecutable anonymousExec) {\n\t\tspoon.reflect.declaration.CtAnonymousExecutable other = ((spoon.reflect.declaration.CtAnonymousExecutable) (this.stack.peek()));\n\t\tenter(anonymousExec);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, anonymousExec.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, anonymousExec.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, anonymousExec.getComments(), other.getComments());\n\t\texit(anonymousExec);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayRead(final spoon.reflect.code.CtArrayRead<T> arrayRead) {\n\t\tspoon.reflect.code.CtArrayRead other = ((spoon.reflect.code.CtArrayRead) (this.stack.peek()));\n\t\tenter(arrayRead);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, arrayRead.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, arrayRead.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, arrayRead.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, arrayRead.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, arrayRead.getIndexExpression(), other.getIndexExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, arrayRead.getComments(), other.getComments());\n\t\texit(arrayRead);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayWrite(final spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n\t\tspoon.reflect.code.CtArrayWrite other = ((spoon.reflect.code.CtArrayWrite) (this.stack.peek()));\n\t\tenter(arrayWrite);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, arrayWrite.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, arrayWrite.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, arrayWrite.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, arrayWrite.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, arrayWrite.getIndexExpression(), other.getIndexExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, arrayWrite.getComments(), other.getComments());\n\t\texit(arrayWrite);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtArrayTypeReference(final spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtArrayTypeReference other = ((spoon.reflect.reference.CtArrayTypeReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, reference.getPackage(), other.getPackage());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, reference.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getComponentType(), other.getComponentType());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments(), other.getActualTypeArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtAssert(final spoon.reflect.code.CtAssert<T> asserted) {\n\t\tspoon.reflect.code.CtAssert other = ((spoon.reflect.code.CtAssert) (this.stack.peek()));\n\t\tenter(asserted);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, asserted.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CONDITION, asserted.getAssertExpression(), other.getAssertExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, asserted.getExpression(), other.getExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, asserted.getComments(), other.getComments());\n\t\texit(asserted);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T, A extends T> void visitCtAssignment(final spoon.reflect.code.CtAssignment<T, A> assignement) {\n\t\tspoon.reflect.code.CtAssignment other = ((spoon.reflect.code.CtAssignment) (this.stack.peek()));\n\t\tenter(assignement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, assignement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, assignement.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, assignement.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.ASSIGNED, assignement.getAssigned(), other.getAssigned());\n\t\tbiScan(spoon.reflect.path.CtRole.ASSIGNMENT, assignement.getAssignment(), other.getAssignment());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, assignement.getComments(), other.getComments());\n\t\texit(assignement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtBinaryOperator(final spoon.reflect.code.CtBinaryOperator<T> operator) {\n\t\tspoon.reflect.code.CtBinaryOperator other = ((spoon.reflect.code.CtBinaryOperator) (this.stack.peek()));\n\t\tenter(operator);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, operator.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, operator.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, operator.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.LEFT_OPERAND, operator.getLeftHandOperand(), other.getLeftHandOperand());\n\t\tbiScan(spoon.reflect.path.CtRole.RIGHT_OPERAND, operator.getRightHandOperand(), other.getRightHandOperand());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, operator.getComments(), other.getComments());\n\t\texit(operator);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <R> void visitCtBlock(final spoon.reflect.code.CtBlock<R> block) {\n\t\tspoon.reflect.code.CtBlock other = ((spoon.reflect.code.CtBlock) (this.stack.peek()));\n\t\tenter(block);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, block.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.STATEMENT, block.getStatements(), other.getStatements());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, block.getComments(), other.getComments());\n\t\texit(block);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtBreak(final spoon.reflect.code.CtBreak breakStatement) {\n\t\tspoon.reflect.code.CtBreak other = ((spoon.reflect.code.CtBreak) (this.stack.peek()));\n\t\tenter(breakStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, breakStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, breakStatement.getComments(), other.getComments());\n\t\texit(breakStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <S> void visitCtCase(final spoon.reflect.code.CtCase<S> caseStatement) {\n\t\tspoon.reflect.code.CtCase other = ((spoon.reflect.code.CtCase) (this.stack.peek()));\n\t\tenter(caseStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, caseStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, caseStatement.getCaseExpression(), other.getCaseExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.STATEMENT, caseStatement.getStatements(), other.getStatements());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, caseStatement.getComments(), other.getComments());\n\t\texit(caseStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtCatch(final spoon.reflect.code.CtCatch catchBlock) {\n\t\tspoon.reflect.code.CtCatch other = ((spoon.reflect.code.CtCatch) (this.stack.peek()));\n\t\tenter(catchBlock);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, catchBlock.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.PARAMETER, catchBlock.getParameter(), other.getParameter());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, catchBlock.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, catchBlock.getComments(), other.getComments());\n\t\texit(catchBlock);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtClass(final spoon.reflect.declaration.CtClass<T> ctClass) {\n\t\tspoon.reflect.declaration.CtClass other = ((spoon.reflect.declaration.CtClass) (this.stack.peek()));\n\t\tenter(ctClass);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ctClass.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.SUPER_TYPE, ctClass.getSuperclass(), other.getSuperclass());\n\t\tbiScan(spoon.reflect.path.CtRole.INTERFACE, ctClass.getSuperInterfaces(), other.getSuperInterfaces());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_PARAMETER, ctClass.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_MEMBER, ctClass.getTypeMembers(), other.getTypeMembers());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ctClass.getComments(), other.getComments());\n\t\texit(ctClass);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n\t\tspoon.reflect.declaration.CtTypeParameter other = ((spoon.reflect.declaration.CtTypeParameter) (this.stack.peek()));\n\t\tenter(typeParameter);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, typeParameter.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.SUPER_TYPE, typeParameter.getSuperclass(), other.getSuperclass());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, typeParameter.getComments(), other.getComments());\n\t\texit(typeParameter);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtConditional(final spoon.reflect.code.CtConditional<T> conditional) {\n\t\tspoon.reflect.code.CtConditional other = ((spoon.reflect.code.CtConditional) (this.stack.peek()));\n\t\tenter(conditional);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, conditional.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, conditional.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CONDITION, conditional.getCondition(), other.getCondition());\n\t\tbiScan(spoon.reflect.path.CtRole.THEN, conditional.getThenExpression(), other.getThenExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.ELSE, conditional.getElseExpression(), other.getElseExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, conditional.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, conditional.getTypeCasts(), other.getTypeCasts());\n\t\texit(conditional);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtConstructor(final spoon.reflect.declaration.CtConstructor<T> c) {\n\t\tspoon.reflect.declaration.CtConstructor other = ((spoon.reflect.declaration.CtConstructor) (this.stack.peek()));\n\t\tenter(c);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, c.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.PARAMETER, c.getParameters(), other.getParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.THROWN, c.getThrownTypes(), other.getThrownTypes());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_PARAMETER, c.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, c.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, c.getComments(), other.getComments());\n\t\texit(c);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtContinue(final spoon.reflect.code.CtContinue continueStatement) {\n\t\tspoon.reflect.code.CtContinue other = ((spoon.reflect.code.CtContinue) (this.stack.peek()));\n\t\tenter(continueStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, continueStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, continueStatement.getComments(), other.getComments());\n\t\texit(continueStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtDo(final spoon.reflect.code.CtDo doLoop) {\n\t\tspoon.reflect.code.CtDo other = ((spoon.reflect.code.CtDo) (this.stack.peek()));\n\t\tenter(doLoop);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, doLoop.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, doLoop.getLoopingExpression(), other.getLoopingExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, doLoop.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, doLoop.getComments(), other.getComments());\n\t\texit(doLoop);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T extends java.lang.Enum<?>> void visitCtEnum(final spoon.reflect.declaration.CtEnum<T> ctEnum) {\n\t\tspoon.reflect.declaration.CtEnum other = ((spoon.reflect.declaration.CtEnum) (this.stack.peek()));\n\t\tenter(ctEnum);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ctEnum.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.INTERFACE, ctEnum.getSuperInterfaces(), other.getSuperInterfaces());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_MEMBER, ctEnum.getTypeMembers(), other.getTypeMembers());\n\t\tbiScan(spoon.reflect.path.CtRole.VALUE, ctEnum.getEnumValues(), other.getEnumValues());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ctEnum.getComments(), other.getComments());\n\t\texit(ctEnum);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtExecutableReference(final spoon.reflect.reference.CtExecutableReference<T> reference) {\n\t\tspoon.reflect.reference.CtExecutableReference other = ((spoon.reflect.reference.CtExecutableReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, reference.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ARGUMENT_TYPE, reference.getParameters(), other.getParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments(), other.getActualTypeArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, reference.getComments(), other.getComments());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtField(final spoon.reflect.declaration.CtField<T> f) {\n\t\tspoon.reflect.declaration.CtField other = ((spoon.reflect.declaration.CtField) (this.stack.peek()));\n\t\tenter(f);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, f.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, f.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.DEFAULT_EXPRESSION, f.getDefaultExpression(), other.getDefaultExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, f.getComments(), other.getComments());\n\t\texit(f);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtEnumValue(final spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n\t\tspoon.reflect.declaration.CtEnumValue other = ((spoon.reflect.declaration.CtEnumValue) (this.stack.peek()));\n\t\tenter(enumValue);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, enumValue.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, enumValue.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.DEFAULT_EXPRESSION, enumValue.getDefaultExpression(), other.getDefaultExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, enumValue.getComments(), other.getComments());\n\t\texit(enumValue);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtThisAccess(final spoon.reflect.code.CtThisAccess<T> thisAccess) {\n\t\tspoon.reflect.code.CtThisAccess other = ((spoon.reflect.code.CtThisAccess) (this.stack.peek()));\n\t\tenter(thisAccess);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, thisAccess.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, thisAccess.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, thisAccess.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, thisAccess.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, thisAccess.getTarget(), other.getTarget());\n\t\texit(thisAccess);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtAnnotationFieldAccess(final spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\tspoon.reflect.code.CtAnnotationFieldAccess other = ((spoon.reflect.code.CtAnnotationFieldAccess) (this.stack.peek()));\n\t\tenter(annotationFieldAccess);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, annotationFieldAccess.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, annotationFieldAccess.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, annotationFieldAccess.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, annotationFieldAccess.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, annotationFieldAccess.getVariable(), other.getVariable());\n\t\texit(annotationFieldAccess);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtFieldReference(final spoon.reflect.reference.CtFieldReference<T> reference) {\n\t\tspoon.reflect.reference.CtFieldReference other = ((spoon.reflect.reference.CtFieldReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, reference.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtFor(final spoon.reflect.code.CtFor forLoop) {\n\t\tspoon.reflect.code.CtFor other = ((spoon.reflect.code.CtFor) (this.stack.peek()));\n\t\tenter(forLoop);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, forLoop.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.FOR_INIT, forLoop.getForInit(), other.getForInit());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, forLoop.getExpression(), other.getExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.FOR_UPDATE, forLoop.getForUpdate(), other.getForUpdate());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, forLoop.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, forLoop.getComments(), other.getComments());\n\t\texit(forLoop);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtForEach(final spoon.reflect.code.CtForEach foreach) {\n\t\tspoon.reflect.code.CtForEach other = ((spoon.reflect.code.CtForEach) (this.stack.peek()));\n\t\tenter(foreach);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, foreach.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.FOREACH_VARIABLE, foreach.getVariable(), other.getVariable());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, foreach.getExpression(), other.getExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, foreach.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, foreach.getComments(), other.getComments());\n\t\texit(foreach);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtIf(final spoon.reflect.code.CtIf ifElement) {\n\t\tspoon.reflect.code.CtIf other = ((spoon.reflect.code.CtIf) (this.stack.peek()));\n\t\tenter(ifElement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ifElement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CONDITION, ifElement.getCondition(), other.getCondition());\n\t\tbiScan(spoon.reflect.path.CtRole.THEN, ((spoon.reflect.code.CtStatement) (ifElement.getThenStatement())), other.getThenStatement());\n\t\tbiScan(spoon.reflect.path.CtRole.ELSE, ((spoon.reflect.code.CtStatement) (ifElement.getElseStatement())), other.getElseStatement());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ifElement.getComments(), other.getComments());\n\t\texit(ifElement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtInterface(final spoon.reflect.declaration.CtInterface<T> intrface) {\n\t\tspoon.reflect.declaration.CtInterface other = ((spoon.reflect.declaration.CtInterface) (this.stack.peek()));\n\t\tenter(intrface);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, intrface.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.INTERFACE, intrface.getSuperInterfaces(), other.getSuperInterfaces());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_PARAMETER, intrface.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_MEMBER, intrface.getTypeMembers(), other.getTypeMembers());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, intrface.getComments(), other.getComments());\n\t\texit(intrface);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtInvocation(final spoon.reflect.code.CtInvocation<T> invocation) {\n\t\tspoon.reflect.code.CtInvocation other = ((spoon.reflect.code.CtInvocation) (this.stack.peek()));\n\t\tenter(invocation);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, invocation.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, invocation.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, invocation.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.EXECUTABLE_REF, invocation.getExecutable(), other.getExecutable());\n\t\tbiScan(spoon.reflect.path.CtRole.ARGUMENT, invocation.getArguments(), other.getArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, invocation.getComments(), other.getComments());\n\t\texit(invocation);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtLiteral(final spoon.reflect.code.CtLiteral<T> literal) {\n\t\tspoon.reflect.code.CtLiteral other = ((spoon.reflect.code.CtLiteral) (this.stack.peek()));\n\t\tenter(literal);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, literal.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, literal.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, literal.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, literal.getComments(), other.getComments());\n\t\texit(literal);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtLocalVariable(final spoon.reflect.code.CtLocalVariable<T> localVariable) {\n\t\tspoon.reflect.code.CtLocalVariable other = ((spoon.reflect.code.CtLocalVariable) (this.stack.peek()));\n\t\tenter(localVariable);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, localVariable.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, localVariable.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.DEFAULT_EXPRESSION, localVariable.getDefaultExpression(), other.getDefaultExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, localVariable.getComments(), other.getComments());\n\t\texit(localVariable);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtLocalVariableReference(final spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtLocalVariableReference other = ((spoon.reflect.reference.CtLocalVariableReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtCatchVariable(final spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n\t\tspoon.reflect.code.CtCatchVariable other = ((spoon.reflect.code.CtCatchVariable) (this.stack.peek()));\n\t\tenter(catchVariable);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, catchVariable.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, catchVariable.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.MULTI_TYPE, catchVariable.getMultiTypes(), other.getMultiTypes());\n\t\texit(catchVariable);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtCatchVariableReference(final spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtCatchVariableReference other = ((spoon.reflect.reference.CtCatchVariableReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtMethod(final spoon.reflect.declaration.CtMethod<T> m) {\n\t\tspoon.reflect.declaration.CtMethod other = ((spoon.reflect.declaration.CtMethod) (this.stack.peek()));\n\t\tenter(m);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, m.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_PARAMETER, m.getFormalCtTypeParameters(), other.getFormalCtTypeParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, m.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.PARAMETER, m.getParameters(), other.getParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.THROWN, m.getThrownTypes(), other.getThrownTypes());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, m.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, m.getComments(), other.getComments());\n\t\texit(m);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n\t\tspoon.reflect.declaration.CtAnnotationMethod other = ((spoon.reflect.declaration.CtAnnotationMethod) (this.stack.peek()));\n\t\tenter(annotationMethod);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, annotationMethod.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, annotationMethod.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.DEFAULT_EXPRESSION, annotationMethod.getDefaultExpression(), other.getDefaultExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, annotationMethod.getComments(), other.getComments());\n\t\texit(annotationMethod);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {\n\t\tspoon.reflect.code.CtNewArray other = ((spoon.reflect.code.CtNewArray) (this.stack.peek()));\n\t\tenter(newArray);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, newArray.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, newArray.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, newArray.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, newArray.getElements(), other.getElements());\n\t\tbiScan(spoon.reflect.path.CtRole.DIMENSION, newArray.getDimensionExpressions(), other.getDimensionExpressions());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, newArray.getComments(), other.getComments());\n\t\texit(newArray);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConstructorCall(final spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n\t\tspoon.reflect.code.CtConstructorCall other = ((spoon.reflect.code.CtConstructorCall) (this.stack.peek()));\n\t\tenter(ctConstructorCall);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ctConstructorCall.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, ctConstructorCall.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.EXECUTABLE_REF, ctConstructorCall.getExecutable(), other.getExecutable());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, ctConstructorCall.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.ARGUMENT, ctConstructorCall.getArguments(), other.getArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ctConstructorCall.getComments(), other.getComments());\n\t\texit(ctConstructorCall);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtNewClass(final spoon.reflect.code.CtNewClass<T> newClass) {\n\t\tspoon.reflect.code.CtNewClass other = ((spoon.reflect.code.CtNewClass) (this.stack.peek()));\n\t\tenter(newClass);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, newClass.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, newClass.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.EXECUTABLE_REF, newClass.getExecutable(), other.getExecutable());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, newClass.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.ARGUMENT, newClass.getArguments(), other.getArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.NESTED_TYPE, newClass.getAnonymousClass(), other.getAnonymousClass());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, newClass.getComments(), other.getComments());\n\t\texit(newClass);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLambda(final spoon.reflect.code.CtLambda<T> lambda) {\n\t\tspoon.reflect.code.CtLambda other = ((spoon.reflect.code.CtLambda) (this.stack.peek()));\n\t\tenter(lambda);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, lambda.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, lambda.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, lambda.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.PARAMETER, lambda.getParameters(), other.getParameters());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, lambda.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, lambda.getExpression(), other.getExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, lambda.getComments(), other.getComments());\n\t\texit(lambda);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(final spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n\t\tspoon.reflect.code.CtExecutableReferenceExpression other = ((spoon.reflect.code.CtExecutableReferenceExpression) (this.stack.peek()));\n\t\tenter(expression);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, expression.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, expression.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, expression.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, expression.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.EXECUTABLE_REF, expression.getExecutable(), other.getExecutable());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, expression.getTarget(), other.getTarget());\n\t\texit(expression);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T, A extends T> void visitCtOperatorAssignment(final spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n\t\tspoon.reflect.code.CtOperatorAssignment other = ((spoon.reflect.code.CtOperatorAssignment) (this.stack.peek()));\n\t\tenter(assignment);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, assignment.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, assignment.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, assignment.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.ASSIGNED, assignment.getAssigned(), other.getAssigned());\n\t\tbiScan(spoon.reflect.path.CtRole.ASSIGNMENT, assignment.getAssignment(), other.getAssignment());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, assignment.getComments(), other.getComments());\n\t\texit(assignment);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtPackage(final spoon.reflect.declaration.CtPackage ctPackage) {\n\t\tspoon.reflect.declaration.CtPackage other = ((spoon.reflect.declaration.CtPackage) (this.stack.peek()));\n\t\tenter(ctPackage);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ctPackage.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.SUB_PACKAGE, ctPackage.getPackages(), other.getPackages());\n\t\tbiScan(spoon.reflect.path.CtRole.CONTAINED_TYPE, ctPackage.getTypes(), other.getTypes());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ctPackage.getComments(), other.getComments());\n\t\texit(ctPackage);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtPackageReference(final spoon.reflect.reference.CtPackageReference reference) {\n\t\tspoon.reflect.reference.CtPackageReference other = ((spoon.reflect.reference.CtPackageReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtParameter(final spoon.reflect.declaration.CtParameter<T> parameter) {\n\t\tspoon.reflect.declaration.CtParameter other = ((spoon.reflect.declaration.CtParameter) (this.stack.peek()));\n\t\tenter(parameter);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, parameter.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, parameter.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, parameter.getComments(), other.getComments());\n\t\texit(parameter);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtParameterReference(final spoon.reflect.reference.CtParameterReference<T> reference) {\n\t\tspoon.reflect.reference.CtParameterReference other = ((spoon.reflect.reference.CtParameterReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <R> void visitCtReturn(final spoon.reflect.code.CtReturn<R> returnStatement) {\n\t\tspoon.reflect.code.CtReturn other = ((spoon.reflect.code.CtReturn) (this.stack.peek()));\n\t\tenter(returnStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, returnStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, returnStatement.getReturnedExpression(), other.getReturnedExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, returnStatement.getComments(), other.getComments());\n\t\texit(returnStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <R> void visitCtStatementList(final spoon.reflect.code.CtStatementList statements) {\n\t\tspoon.reflect.code.CtStatementList other = ((spoon.reflect.code.CtStatementList) (this.stack.peek()));\n\t\tenter(statements);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, statements.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.STATEMENT, statements.getStatements(), other.getStatements());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, statements.getComments(), other.getComments());\n\t\texit(statements);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <S> void visitCtSwitch(final spoon.reflect.code.CtSwitch<S> switchStatement) {\n\t\tspoon.reflect.code.CtSwitch other = ((spoon.reflect.code.CtSwitch) (this.stack.peek()));\n\t\tenter(switchStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, switchStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, switchStatement.getSelector(), other.getSelector());\n\t\tbiScan(spoon.reflect.path.CtRole.CASE, switchStatement.getCases(), other.getCases());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, switchStatement.getComments(), other.getComments());\n\t\texit(switchStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtSynchronized(final spoon.reflect.code.CtSynchronized synchro) {\n\t\tspoon.reflect.code.CtSynchronized other = ((spoon.reflect.code.CtSynchronized) (this.stack.peek()));\n\t\tenter(synchro);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, synchro.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, synchro.getExpression(), other.getExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, synchro.getBlock(), other.getBlock());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, synchro.getComments(), other.getComments());\n\t\texit(synchro);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtThrow(final spoon.reflect.code.CtThrow throwStatement) {\n\t\tspoon.reflect.code.CtThrow other = ((spoon.reflect.code.CtThrow) (this.stack.peek()));\n\t\tenter(throwStatement);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, throwStatement.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, throwStatement.getThrownExpression(), other.getThrownExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, throwStatement.getComments(), other.getComments());\n\t\texit(throwStatement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtTry(final spoon.reflect.code.CtTry tryBlock) {\n\t\tspoon.reflect.code.CtTry other = ((spoon.reflect.code.CtTry) (this.stack.peek()));\n\t\tenter(tryBlock);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, tryBlock.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, tryBlock.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.CATCH, tryBlock.getCatchers(), other.getCatchers());\n\t\tbiScan(spoon.reflect.path.CtRole.FINALIZER, tryBlock.getFinalizer(), other.getFinalizer());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, tryBlock.getComments(), other.getComments());\n\t\texit(tryBlock);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtTryWithResource(final spoon.reflect.code.CtTryWithResource tryWithResource) {\n\t\tspoon.reflect.code.CtTryWithResource other = ((spoon.reflect.code.CtTryWithResource) (this.stack.peek()));\n\t\tenter(tryWithResource);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, tryWithResource.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TRY_RESOURCE, tryWithResource.getResources(), other.getResources());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, tryWithResource.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.CATCH, tryWithResource.getCatchers(), other.getCatchers());\n\t\tbiScan(spoon.reflect.path.CtRole.FINALIZER, tryWithResource.getFinalizer(), other.getFinalizer());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, tryWithResource.getComments(), other.getComments());\n\t\texit(tryWithResource);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtTypeParameterReference(final spoon.reflect.reference.CtTypeParameterReference ref) {\n\t\tspoon.reflect.reference.CtTypeParameterReference other = ((spoon.reflect.reference.CtTypeParameterReference) (this.stack.peek()));\n\t\tenter(ref);\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, ref.getPackage(), other.getPackage());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, ref.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ref.getAnnotations(), other.getAnnotations());\n\t\texit(ref);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n\t\tspoon.reflect.reference.CtWildcardReference other = ((spoon.reflect.reference.CtWildcardReference) (this.stack.peek()));\n\t\tenter(wildcardReference);\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, wildcardReference.getPackage(), other.getPackage());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, wildcardReference.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, wildcardReference.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.BOUNDING_TYPE, wildcardReference.getBoundingType(), other.getBoundingType());\n\t\texit(wildcardReference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtIntersectionTypeReference other = ((spoon.reflect.reference.CtIntersectionTypeReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, reference.getPackage(), other.getPackage());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, reference.getDeclaringType(), other.getDeclaringType());\n\t\t// TypeReferenceTest fails if actual type arguments are really not set-able on CtIntersectionTypeReference\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments(), other.getActualTypeArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.BOUND, reference.getBounds(), other.getBounds());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtTypeReference(final spoon.reflect.reference.CtTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtTypeReference other = ((spoon.reflect.reference.CtTypeReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, reference.getPackage(), other.getPackage());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARING_TYPE, reference.getDeclaringType(), other.getDeclaringType());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments(), other.getActualTypeArguments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, reference.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, reference.getComments(), other.getComments());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtTypeAccess(final spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n\t\tspoon.reflect.code.CtTypeAccess other = ((spoon.reflect.code.CtTypeAccess) (this.stack.peek()));\n\t\tenter(typeAccess);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, typeAccess.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, typeAccess.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.ACCESSED_TYPE, typeAccess.getAccessedType(), other.getAccessedType());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, typeAccess.getComments(), other.getComments());\n\t\texit(typeAccess);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtUnaryOperator(final spoon.reflect.code.CtUnaryOperator<T> operator) {\n\t\tspoon.reflect.code.CtUnaryOperator other = ((spoon.reflect.code.CtUnaryOperator) (this.stack.peek()));\n\t\tenter(operator);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, operator.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, operator.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, operator.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, operator.getOperand(), other.getOperand());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, operator.getComments(), other.getComments());\n\t\texit(operator);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableRead(final spoon.reflect.code.CtVariableRead<T> variableRead) {\n\t\tspoon.reflect.code.CtVariableRead other = ((spoon.reflect.code.CtVariableRead) (this.stack.peek()));\n\t\tenter(variableRead);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, variableRead.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, variableRead.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, variableRead.getVariable(), other.getVariable());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, variableRead.getComments(), other.getComments());\n\t\texit(variableRead);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableWrite(final spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n\t\tspoon.reflect.code.CtVariableWrite other = ((spoon.reflect.code.CtVariableWrite) (this.stack.peek()));\n\t\tenter(variableWrite);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, variableWrite.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, variableWrite.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, variableWrite.getVariable(), other.getVariable());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, variableWrite.getComments(), other.getComments());\n\t\texit(variableWrite);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtWhile(final spoon.reflect.code.CtWhile whileLoop) {\n\t\tspoon.reflect.code.CtWhile other = ((spoon.reflect.code.CtWhile) (this.stack.peek()));\n\t\tenter(whileLoop);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, whileLoop.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.EXPRESSION, whileLoop.getLoopingExpression(), other.getLoopingExpression());\n\t\tbiScan(spoon.reflect.path.CtRole.BODY, whileLoop.getBody(), other.getBody());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, whileLoop.getComments(), other.getComments());\n\t\texit(whileLoop);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtCodeSnippetExpression(final spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n\t\tspoon.reflect.code.CtCodeSnippetExpression other = ((spoon.reflect.code.CtCodeSnippetExpression) (this.stack.peek()));\n\t\tenter(expression);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, expression.getType(), other.getType());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, expression.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, expression.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, expression.getTypeCasts(), other.getTypeCasts());\n\t\texit(expression);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic void visitCtCodeSnippetStatement(final spoon.reflect.code.CtCodeSnippetStatement statement) {\n\t\tspoon.reflect.code.CtCodeSnippetStatement other = ((spoon.reflect.code.CtCodeSnippetStatement) (this.stack.peek()));\n\t\tenter(statement);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, statement.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, statement.getAnnotations(), other.getAnnotations());\n\t\texit(statement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\tpublic <T> void visitCtUnboundVariableReference(final spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtUnboundVariableReference other = ((spoon.reflect.reference.CtUnboundVariableReference) (this.stack.peek()));\n\t\tenter(reference);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE, reference.getType(), other.getType());\n\t\texit(reference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldRead(final spoon.reflect.code.CtFieldRead<T> fieldRead) {\n\t\tspoon.reflect.code.CtFieldRead other = ((spoon.reflect.code.CtFieldRead) (this.stack.peek()));\n\t\tenter(fieldRead);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, fieldRead.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, fieldRead.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, fieldRead.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, fieldRead.getVariable(), other.getVariable());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, fieldRead.getComments(), other.getComments());\n\t\texit(fieldRead);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldWrite(final spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n\t\tspoon.reflect.code.CtFieldWrite other = ((spoon.reflect.code.CtFieldWrite) (this.stack.peek()));\n\t\tenter(fieldWrite);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, fieldWrite.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, fieldWrite.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, fieldWrite.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, fieldWrite.getVariable(), other.getVariable());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, fieldWrite.getComments(), other.getComments());\n\t\texit(fieldWrite);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtSuperAccess(final spoon.reflect.code.CtSuperAccess<T> f) {\n\t\tspoon.reflect.code.CtSuperAccess other = ((spoon.reflect.code.CtSuperAccess) (this.stack.peek()));\n\t\tenter(f);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, f.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, f.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.CAST, f.getTypeCasts(), other.getTypeCasts());\n\t\tbiScan(spoon.reflect.path.CtRole.TARGET, f.getTarget(), other.getTarget());\n\t\tbiScan(spoon.reflect.path.CtRole.VARIABLE, f.getVariable(), other.getVariable());\n\t\texit(f);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtComment(final spoon.reflect.code.CtComment comment) {\n\t\tspoon.reflect.code.CtComment other = ((spoon.reflect.code.CtComment) (this.stack.peek()));\n\t\tenter(comment);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, comment.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, comment.getAnnotations(), other.getAnnotations());\n\t\texit(comment);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDoc(final spoon.reflect.code.CtJavaDoc javaDoc) {\n\t\tspoon.reflect.code.CtJavaDoc other = ((spoon.reflect.code.CtJavaDoc) (this.stack.peek()));\n\t\tenter(javaDoc);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, javaDoc.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, javaDoc.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT_TAG, javaDoc.getTags(), other.getTags());\n\t\texit(javaDoc);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDocTag(final spoon.reflect.code.CtJavaDocTag docTag) {\n\t\tspoon.reflect.code.CtJavaDocTag other = ((spoon.reflect.code.CtJavaDocTag) (this.stack.peek()));\n\t\tenter(docTag);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, docTag.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, docTag.getAnnotations(), other.getAnnotations());\n\t\texit(docTag);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtImport(final spoon.reflect.declaration.CtImport ctImport) {\n\t\tspoon.reflect.declaration.CtImport other = ((spoon.reflect.declaration.CtImport) (this.stack.peek()));\n\t\tenter(ctImport);\n\t\tbiScan(spoon.reflect.path.CtRole.IMPORT_REFERENCE, ctImport.getReference(), other.getReference());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, ctImport.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, ctImport.getComments(), other.getComments());\n\t\texit(ctImport);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtModule(spoon.reflect.declaration.CtModule module) {\n\t\tspoon.reflect.declaration.CtModule other = ((spoon.reflect.declaration.CtModule) (this.stack.peek()));\n\t\tenter(module);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, module.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, module.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.MODULE_DIRECTIVE, module.getModuleDirectives(), other.getModuleDirectives());\n\t\tbiScan(spoon.reflect.path.CtRole.SUB_PACKAGE, module.getRootPackage(), other.getRootPackage());\n\t\texit(module);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {\n\t\tspoon.reflect.reference.CtModuleReference other = ((spoon.reflect.reference.CtModuleReference) (this.stack.peek()));\n\t\tenter(moduleReference);\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, moduleReference.getAnnotations(), other.getAnnotations());\n\t\texit(moduleReference);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n\t\tspoon.reflect.declaration.CtPackageExport other = ((spoon.reflect.declaration.CtPackageExport) (this.stack.peek()));\n\t\tenter(moduleExport);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, moduleExport.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, moduleExport.getPackageReference(), other.getPackageReference());\n\t\tbiScan(spoon.reflect.path.CtRole.MODULE_REF, moduleExport.getTargetExport(), other.getTargetExport());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, moduleExport.getAnnotations(), other.getAnnotations());\n\t\texit(moduleExport);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n\t\tspoon.reflect.declaration.CtModuleRequirement other = ((spoon.reflect.declaration.CtModuleRequirement) (this.stack.peek()));\n\t\tenter(moduleRequirement);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, moduleRequirement.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.MODULE_REF, moduleRequirement.getModuleReference(), other.getModuleReference());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, moduleRequirement.getAnnotations(), other.getAnnotations());\n\t\texit(moduleRequirement);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {\n\t\tspoon.reflect.declaration.CtProvidedService other = ((spoon.reflect.declaration.CtProvidedService) (this.stack.peek()));\n\t\tenter(moduleProvidedService);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, moduleProvidedService.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.SERVICE_TYPE, moduleProvidedService.getServiceType(), other.getServiceType());\n\t\tbiScan(spoon.reflect.path.CtRole.IMPLEMENTATION_TYPE, moduleProvidedService.getImplementationTypes(), other.getImplementationTypes());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, moduleProvidedService.getAnnotations(), other.getAnnotations());\n\t\texit(moduleProvidedService);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {\n\t\tspoon.reflect.declaration.CtUsedService other = ((spoon.reflect.declaration.CtUsedService) (this.stack.peek()));\n\t\tenter(usedService);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, usedService.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.SERVICE_TYPE, usedService.getServiceType(), other.getServiceType());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, usedService.getAnnotations(), other.getAnnotations());\n\t\texit(usedService);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtCompilationUnit(spoon.reflect.declaration.CtCompilationUnit compilationUnit) {\n\t\tspoon.reflect.declaration.CtCompilationUnit other = ((spoon.reflect.declaration.CtCompilationUnit) (this.stack.peek()));\n\t\tenter(compilationUnit);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, compilationUnit.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, compilationUnit.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_DECLARATION, compilationUnit.getPackageDeclaration(), other.getPackageDeclaration());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARED_IMPORT, compilationUnit.getImports(), other.getImports());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARED_MODULE_REF, compilationUnit.getDeclaredModuleReference(), other.getDeclaredModuleReference());\n\t\tbiScan(spoon.reflect.path.CtRole.DECLARED_TYPE_REF, compilationUnit.getDeclaredTypeReferences(), other.getDeclaredTypeReferences());\n\t\texit(compilationUnit);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageDeclaration(spoon.reflect.declaration.CtPackageDeclaration packageDeclaration) {\n\t\tspoon.reflect.declaration.CtPackageDeclaration other = ((spoon.reflect.declaration.CtPackageDeclaration) (this.stack.peek()));\n\t\tenter(packageDeclaration);\n\t\tbiScan(spoon.reflect.path.CtRole.COMMENT, packageDeclaration.getComments(), other.getComments());\n\t\tbiScan(spoon.reflect.path.CtRole.ANNOTATION, packageDeclaration.getAnnotations(), other.getAnnotations());\n\t\tbiScan(spoon.reflect.path.CtRole.PACKAGE_REF, packageDeclaration.getReference(), other.getReference());\n\t\texit(packageDeclaration);\n\t}\n\n\t// autogenerated by CtBiScannerGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeMemberWildcardImportReference(spoon.reflect.reference.CtTypeMemberWildcardImportReference wildcardReference) {\n\t\tspoon.reflect.reference.CtTypeMemberWildcardImportReference other = ((spoon.reflect.reference.CtTypeMemberWildcardImportReference) (this.stack.peek()));\n\t\tenter(wildcardReference);\n\t\tbiScan(spoon.reflect.path.CtRole.TYPE_REF, wildcardReference.getTypeReference(), other.getTypeReference());\n\t\texit(wildcardReference);\n\t}\n}\n\n"
    }, {
      "name" : "reflect/visitor/filter/AllTypeMembersFunction.java",
      "weight" : 71.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\nimport spoon.reflect.visitor.chain.CtQueryable;\n\n/**\n * Expects {@link CtType} as input\n * and produces all {@link CtTypeMember}s declared in input class\n * or any super class or super interface.\n * It first returns own type members, then type members of superclass, etc.\n */\npublic class AllTypeMembersFunction implements CtConsumableFunction<CtTypeInformation>, CtQueryAware {\n\n\tpublic enum Mode {\n\t\t/**\n\t\t * Returns all type members - including private\n\t\t */\n\t\tALL,\n\t\t/**\n\t\t * Returns only type members, which are accessible from the input `type`.\n\t\t * It means that inherited private type members are skipped\n\t\t */\n\t\tSKIP_PRIVATE\n\t}\n\n\tprivate CtQuery query;\n\tprivate final Class<?> memberClass;\n\tprivate Set<String> distinctSet;\n\tprivate Mode mode = Mode.ALL;\n\n\t/**\n\t * returns all type members\n\t */\n\tpublic AllTypeMembersFunction() {\n\t\tthis.memberClass = null;\n\t}\n\n\t/**\n\t * returns all type members which are instance of `memberClass`.<br>\n\t * Example:<br>\n\t * <code>\n\t * CtField allFields = ctType.map(new AllTypeMembersFunction(CtField.class)).list();\n\t * </code>\n\t */\n\tpublic AllTypeMembersFunction(Class<?> memberClass) {\n\t\tthis.memberClass = memberClass;\n\t}\n\n\t/**\n\t * The types whose qualified name is in distinctSet are not visited.\n\t * The qualified name of each type visited by this mapping function is added to `distinctSet`\n\t * @param distinctSet - Set of qualified names of types, which has to be ignored, because they were already processed\n\t */\n\tpublic AllTypeMembersFunction distinctSet(Set<String> distinctSet) {\n\t\tthis.distinctSet = distinctSet;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(CtTypeInformation input, final CtConsumer<Object> outputConsumer) {\n\t\tString inputQName = input.getQualifiedName();\n\t\tfinal CtQuery q = ((CtQueryable) input).map(new SuperInheritanceHierarchyFunction(distinctSet == null ? new HashSet<>() : distinctSet).includingSelf(true));\n\t\tq.forEach(new CtConsumer<CtType<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtType<?> type) {\n\t\t\t\tboolean isInputType = inputQName.equals(type.getQualifiedName());\n\t\t\t\tloop: for (CtTypeMember typeMember : type.getTypeMembers()) {\n\t\t\t\t\tif (memberClass == null || memberClass.isInstance(typeMember)) {\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\tcase ALL:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SKIP_PRIVATE:\n\t\t\t\t\t\t\tif (typeMember.hasModifier(ModifierKind.PRIVATE) && !isInputType) {\n\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new SpoonException(\"Unexpected mode \" + mode);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toutputConsumer.accept(typeMember);\n\t\t\t\t\t}\n\t\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\t\tq.terminate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n\n\t/**\n\t * @param mode defines how whether type members with limited visibility are returned\n\t */\n\tpublic AllTypeMembersFunction setMode(Mode mode) {\n\t\tthis.mode = mode;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/CompositeFilter.java",
      "weight" : 56.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This class defines a composite filter, which can compose several filters\n * together by using {@link spoon.reflect.visitor.filter.FilteringOperator}.\n *\n * @author Renaud Pawlak\n */\npublic class CompositeFilter<T extends CtElement> implements Filter<T> {\n\n\t/**\n\t * Defines the matching using\n\t * {@link spoon.reflect.visitor.filter.FilteringOperator}.\n\t */\n\t@Override\n\tpublic boolean matches(T element) {\n\t\tswitch (operator) {\n\t\tcase INTERSECTION:\n\t\t\tfor (Filter<T> f : filters) {\n\t\t\t\tif (!hasMatch(f, element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\tcase UNION:\n\t\t\tfor (Filter<T> f : filters) {\n\t\t\t\tif (hasMatch(f, element)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\tcase SUBSTRACTION:\n\t\t\tif (filters.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!filters[0].matches(element)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 1; i < filters.length; i++) {\n\t\t\t\tif (filters[i].matches(element)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tFilter<T>[] filters;\n\n\tFilteringOperator operator;\n\n\t/**\n\t * Creates a new composite filter.\n\t *\n\t * @param operator\n\t * \t\tthe operator used to compose the filters together\n\t * @param filters\n\t * \t\tthe filters to be composed\n\t */\n\tpublic CompositeFilter(FilteringOperator operator, Filter<T>... filters) {\n\t\tthis.filters = filters;\n\t\tthis.operator = operator;\n\t}\n\n\tprivate boolean hasMatch(Filter<T> filter, T element) {\n\t\ttry {\n\t\t\treturn filter.matches(element);\n\t\t} catch (ClassCastException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getType() {\n\t\treturn (Class<T>) CtElement.class;\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/filter/LocalVariableReferenceFunction.java",
      "weight" : 134.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.CtAbstractVisitor;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\n\n/**\n * This mapping function expects a {@link CtLocalVariable} as input\n * and returns all {@link CtLocalVariableReference}s, which refers this input.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtLocalVariable var = ...;\n * var\n *   .map(new LocalVariableReferenceFunction())\n *   .forEach((CtLocalVariableReference ref)->...process references...);\n * }\n * </pre>\n */\npublic class LocalVariableReferenceFunction implements CtConsumableFunction<CtElement> {\n\tfinal CtVariable<?> targetVariable;\n\tfinal Class<?> variableClass;\n\tfinal Class<?> variableReferenceClass;\n\n\tpublic LocalVariableReferenceFunction() {\n\t\tthis(CtLocalVariable.class, CtLocalVariableReference.class);\n\t}\n\n\t/**\n\t * This constructor allows to define input local variable - the one for which this function will search for.\n\t * In such case the input of mapping function represents the scope\n\t * where this local variable is searched for.\n\t * @param localVariable - the local variable declaration which is searched in scope of input element of this mapping function.\n\t */\n\tpublic LocalVariableReferenceFunction(CtLocalVariable<?> localVariable) {\n\t\tthis(CtLocalVariable.class, CtLocalVariableReference.class, localVariable);\n\t}\n\n\tLocalVariableReferenceFunction(Class<?> variableClass, Class<?> variableReferenceClass) {\n\t\tthis.variableClass = variableClass;\n\t\tthis.variableReferenceClass = variableReferenceClass;\n\t\tthis.targetVariable = null;\n\t}\n\n\tLocalVariableReferenceFunction(Class<?> variableClass, Class<?> variableReferenceClass, CtVariable<?> variable) {\n\t\tthis.variableClass = variableClass;\n\t\tthis.variableReferenceClass = variableReferenceClass;\n\t\tthis.targetVariable = variable;\n\t}\n\n\t@Override\n\tpublic void apply(final CtElement scope, CtConsumer<Object> outputConsumer) {\n\t\tCtVariable<?> var = targetVariable;\n\t\tif (var == null) {\n\t\t\tif (variableClass.isInstance(scope)) {\n\t\t\t\tvar = (CtVariable<?>) scope;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"The input of \" + getClass().getSimpleName() + \" must be a \" + variableClass.getSimpleName() + \" but is \" + scope.getClass().getSimpleName());\n\t\t\t}\n\t\t}\n\t\tfinal CtVariable<?> variable = var;\n\t\tfinal String simpleName = variable.getSimpleName();\n\t\t//the context which knows whether we are scanning in scope of local type or not\n\t\tfinal Context context = new Context();\n\t\tCtQuery scopeQuery;\n\t\tif (scope == variable) {\n\t\t\t//we are starting search from local variable declaration\n\t\t\tscopeQuery = createScopeQuery(variable, scope, context);\n\t\t} else {\n\t\t\t//we are starting search later, somewhere deep in scope of variable declaration\n\t\t\tfinal CtElement variableParent = variable.getParent();\n\t\t\t/*\n\t\t\t * search in parents of searching scope for the variableParent\n\t\t\t * 1) to check that scope is a child of variableParent\n\t\t\t * 2) to detect if there is an local class between variable declaration and scope\n\t\t\t */\n\t\t\tif (scope.map(new ParentFunction()).select(new Filter<CtElement>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean matches(CtElement element) {\n\t\t\t\t\tif (element instanceof CtType) {\n\t\t\t\t\t\t//detected that the search scope is in local class declared in visibility scope of variable\n\t\t\t\t\t\tcontext.nrTypes++;\n\t\t\t\t\t}\n\t\t\t\t\treturn variableParent == element;\n\t\t\t\t}\n\t\t\t}).first() == null) {\n\t\t\t\t//the scope is not under children of localVariable\n\t\t\t\tthrow new SpoonException(\"Cannot search for references of variable in wrong scope.\");\n\t\t\t}\n\t\t\t//search in all children of the scope element\n\t\t\tscopeQuery = scope.map(new CtScannerFunction().setListener(context));\n\t\t}\n\t\tscopeQuery.select(new Filter<CtElement>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean matches(CtElement element) {\n\t\t\t\t\tif (variableReferenceClass.isInstance(element)) {\n\t\t\t\t\t\tCtVariableReference<?> varRef = (CtVariableReference<?>) element;\n\t\t\t\t\t\tif (simpleName.equals(varRef.getSimpleName())) {\n\t\t\t\t\t\t\t//we have found a variable reference of required type in visibility scope of targetVariable\n\t\t\t\t\t\t\tif (context.hasLocalType()) {\n\t\t\t\t\t\t\t\t//there exists a local type in visibility scope of this variable declaration\n\t\t\t\t\t\t\t\t//another variable declarations in scope of this local class may shadow input localVariable\n\t\t\t\t\t\t\t\t//so finally check that found variable reference is really a reference to target variable\n\t\t\t\t\t\t\t\treturn variable == varRef.getDeclaration();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//else we can be sure that found reference is reference to variable\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.forEach(outputConsumer);\n\t}\n\n\tprivate static class Context implements CtScannerListener {\n\t\tint nrTypes = 0;\n\n\t\t@Override\n\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\tif (element instanceof CtType) {\n\t\t\t\tnrTypes++;\n\t\t\t}\n\t\t\treturn ScanningMode.NORMAL;\n\t\t}\n\n\t\t@Override\n\t\tpublic void exit(CtElement element) {\n\t\t\tif (element instanceof CtType) {\n\t\t\t\tnrTypes--;\n\t\t\t}\n\t\t}\n\t\tboolean hasLocalType() {\n\t\t\treturn nrTypes > 0;\n\t\t}\n\t}\n\n\tprivate static final class QueryCreator extends CtAbstractVisitor {\n\t\tCtElement scope;\n\t\tCtScannerListener listener;\n\t\tCtQuery query;\n\n\t\tQueryCreator(CtElement scope, CtScannerListener listener) {\n\t\t\tthis.scope = scope;\n\t\t\tthis.listener = listener;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\t\t\tquery = scope.map(new LocalVariableScopeFunction(listener));\n\t\t}\n\t\t@Override\n\t\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\t\tquery = scope.map(new CatchVariableScopeFunction(listener));\n\t\t}\n\t\t@Override\n\t\tpublic <T> void visitCtParameter(CtParameter<T> parameter) {\n\t\t\tquery = scope.map(new ParameterScopeFunction(listener));\n\t\t}\n\t}\n\n\tprivate CtQuery createScopeQuery(CtVariable<?> variable, CtElement scope, Context context) {\n\t\tQueryCreator qc = new QueryCreator(scope, context);\n\t\tvariable.accept(qc);\n\t\tif (qc.query == null) {\n\t\t\tthrow new SpoonException(\"Unexpected type of variable: \" + variable.getClass().getName());\n\t\t}\n\t\treturn qc.query;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package contains a set of useful filters when querying the model.</p>\n */\npackage spoon.reflect.visitor.filter;\n"
    }, {
      "name" : "reflect/visitor/filter/ParameterScopeFunction.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtScannerListener;\n\n/**\n * This Query expects a {@link CtParameter} as input\n * and returns all CtElements,\n * which are in visibility scope of that parameter.\n * In other words, it returns all elements,\n * which might be reference to that parameter.\n * <br>\n * It can be used to search for variable declarations or\n * variable references which might be in name conflict with input parameter.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtParameter param = ...;\n * param.map(new ParameterScopeFunction()).forEach(...process result...);\n * }\n * </pre>\n */\npublic class ParameterScopeFunction implements CtConsumableFunction<CtParameter<?>> {\n\tprivate final CtScannerListener listener;\n\n\tpublic ParameterScopeFunction() {\n\t\tthis.listener = null;\n\t}\n\tpublic ParameterScopeFunction(CtScannerListener queryListener) {\n\t\tthis.listener = queryListener;\n\t}\n\n\t@Override\n\tpublic void apply(CtParameter<?> parameter, CtConsumer<Object> outputConsumer) {\n\t\tCtExecutable<?> exec = parameter.getParent(CtExecutable.class);\n\t\tif (exec == null) {\n\t\t\t//cannot search for parameter references of parameter which has no executable\n\t\t\treturn;\n\t\t}\n\t\texec\n\t\t\t.map(new CtScannerFunction().setListener(this.listener))\n\t\t\t.forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/FieldAccessFilter.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.reference.CtFieldReference;\n\n/**\n * This simple filter matches all the accesses to a given field.\n */\npublic class FieldAccessFilter extends VariableAccessFilter<CtFieldAccess<?>> {\n\n\t/**\n\t * Creates a new field access filter.\n\t *\n\t * @param field\n\t * \t\tthe accessed field\n\t */\n\tpublic FieldAccessFilter(CtFieldReference<?> field) {\n\t\tsuper(field);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/filter/InvocationFilter.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This simple filter matches all the accesses to a given executable or any\n * executable that overrides it.\n */\npublic class InvocationFilter implements Filter<CtInvocation<?>> {\n\n\tprivate CtExecutableReference<?> executable;\n\n\t/**\n\t * Creates a new invocation filter.\n\t *\n\t * @param executable\n\t * \t\tthe executable to be tested for being invoked\n\t */\n\tpublic InvocationFilter(CtExecutableReference<?> executable) {\n\t\tthis.executable = executable;\n\t}\n\n\t/**\n\t * Creates a new invocation filter.\n\t *\n\t * @param method\n\t * \t\tthe executable to be tested for being invoked.\n\t */\n\tpublic InvocationFilter(CtMethod<?> method) {\n\t\tthis(method.getReference());\n\t}\n\n\t@Override\n\tpublic boolean matches(CtInvocation<?> invocation) {\n\t\treturn invocation.getExecutable().isOverriding(executable);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/FieldScopeFunction.java",
      "weight" : 42.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * This Query expects a {@link CtField} as input\n * and returns all CtElements,\n * which are in visibility scope of that field.\n * In other words, it returns all elements,\n * which might be reference to that field.\n * <br>\n * It can be used to search for variable declarations or\n * variable references which might be in name conflict with input field.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtField param = ...;\n * param.map(new FieldScopeFunction()).forEach(...process result...);\n * }\n * </pre>\n */\npublic class FieldScopeFunction implements CtConsumableFunction<CtField<?>> {\n\n\tpublic FieldScopeFunction() {\n\t}\n\n\t@Override\n\tpublic void apply(CtField<?> field, CtConsumer<Object> outputConsumer) {\n\t\tif (field.hasModifier(ModifierKind.PRIVATE)) {\n\t\t\tsearchForPrivateField(field, outputConsumer);\n\t\t} else if (field.hasModifier(ModifierKind.PUBLIC)) {\n\t\t\tsearchForPublicField(field, outputConsumer);\n\t\t} else if (field.hasModifier(ModifierKind.PROTECTED)) {\n\t\t\tsearchForProtectedField(field, outputConsumer);\n\t\t} else {\n\t\t\tsearchForPackageProtectedField(field, outputConsumer);\n\t\t}\n\t}\n\tprotected void searchForPrivateField(CtField<?> field, CtConsumer<Object> outputConsumer) {\n\t\t//private field can be referred from the scope of current top level type only and children\n\t\tfield.getTopLevelType()\n\t\t\t.filterChildren(null)\n\t\t\t.forEach(outputConsumer);\n\t}\n\tprotected void searchForProtectedField(CtField<?> field, CtConsumer<Object> outputConsumer) {\n\t\t//protected field can be referred from the scope of current top level type only and children\n\t\tfield.getFactory().getModel()\n\t\t\t//search for all types which inherits from declaring type of this field\n\t\t\t.filterChildren(new SubtypeFilter(field.getDeclaringType().getReference()))\n\t\t\t//visit all elements in scope of these inherited types\n\t\t\t.filterChildren(null)\n\t\t\t.forEach(outputConsumer);\n\t}\n\tprotected void searchForPublicField(CtField<?> field, CtConsumer<Object> outputConsumer) {\n\t\t//public field is visible everywhere\n\t\tfield.getFactory().getModel()\n\t\t\t//visit all children of root package\n\t\t\t.filterChildren(null)\n\t\t\t.forEach(outputConsumer);\n\t}\n\tprotected void searchForPackageProtectedField(CtField<?> field, CtConsumer<Object> outputConsumer) {\n\t\t//package protected fields are visible in scope of the package of the top level type of the `field`\n\t\tfield.getTopLevelType().getPackage()\n\t\t\t//visit all children of package, where top level type of the field is declared\n\t\t\t.filterChildren(null)\n\t\t\t.forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/PotentialVariableDeclarationFunction.java",
      "weight" : 97.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\n\n/**\n * This mapping function searches for all {@link CtVariable} instances,\n * which might be a declaration of an input {@link CtElement}.\n * <br>\n * It can be used to search for variable declarations of\n * variable references and for detection of variable name conflicts\n * <br>\n * It returns {@link CtLocalVariable} instances,\n * or it returns {@link CtCatchVariable} instances of catch blocks,\n * or i returns {@link CtParameter} instances of methods, lambdas and catch blocks.\n * or it returns {@link CtField} instances from wrapping classes and their super classes too.\n * <br>\n * The elements are visited in the following order: first elements are thought in the nearest parent blocks,\n * then in the fields of wrapping classes, then in the fields of super classes, etc.\n * <br>\n * Example: Search for all potential {@link CtVariable} declarations<br>\n * <pre> {@code\n * CtVariableReference varRef = ...;\n * varRef.map(new PotentialVariableDeclarationFunction()).forEach(...process result...);\n * }\n * </pre>\n * Example: Search for {@link CtVariable} declaration of variable named `varName` in scope \"scope\"\n * <pre> {@code\n * CtElement scope = ...;\n * String varName = \"anVariableName\";\n * CtVariable varOrNull = scope.map(new PotentialVariableDeclarationFunction(varName)).first();\n * }\n * </pre>\n */\npublic class PotentialVariableDeclarationFunction implements CtConsumableFunction<CtElement>, CtQueryAware {\n\n\tprivate boolean isTypeOnTheWay;\n\tprivate final String variableName;\n\tprivate CtQuery query;\n\tprivate boolean isInStaticScope;\n\n\tpublic PotentialVariableDeclarationFunction() {\n\t\tthis.variableName = null;\n\t}\n\n\t/**\n\t * Searches for a variable with exact name.\n\t * @param variableName\n\t */\n\tpublic PotentialVariableDeclarationFunction(String variableName) {\n\t\tthis.variableName = variableName;\n\t}\n\n\t@Override\n\tpublic void apply(CtElement input, CtConsumer<Object> outputConsumer) {\n\t\tisTypeOnTheWay = false;\n\t\tisInStaticScope = false;\n\t\t//Search previous siblings for element which may represents the declaration of this local variable\n\t\tCtQuery siblingsQuery = input.getFactory().createQuery()\n\t\t\t\t.map(new SiblingsFunction().mode(SiblingsFunction.Mode.PREVIOUS))\n\t\t\t\t//select only CtVariable nodes\n\t\t\t\t.select(new TypeFilter<>(CtVariable.class));\n\t\tif (variableName != null) {\n\t\t\t//variable name is defined so we have to search only for variables with that name\n\t\t\tsiblingsQuery = siblingsQuery.select(new NamedElementFilter<>(CtNamedElement.class, variableName));\n\t\t}\n\n\t\tCtElement scopeElement = input;\n\t\t//Search input and then all parents until first CtPackage for element which may represents the declaration of this local variable\n\t\twhile (scopeElement != null && !(scopeElement instanceof CtPackage) && scopeElement.isParentInitialized()) {\n\t\t\tCtElement parent = scopeElement.getParent();\n\t\t\tif (parent instanceof CtType<?>) {\n\t\t\t\tisTypeOnTheWay = true;\n\t\t\t\t//visit each CtField of `parent` CtType\n\t\t\t\tCtQuery q = parent.map(new AllTypeMembersFunction(CtField.class));\n\t\t\t\tq.forEach((CtField<?> field) -> {\n\t\t\t\t\tif (isInStaticScope && field.hasModifier(ModifierKind.STATIC) == false) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * the variable reference is used in static scope,\n\t\t\t\t\t\t * but the field is not static - ignore it\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t//else send field as potential variable declaration\n\t\t\t\t\tif (sendToOutput(field, outputConsumer)) {\n\t\t\t\t\t\t//and terminate the internal query q if outer query is already terminated\n\t\t\t\t\t\tq.terminate();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (parent instanceof CtBodyHolder || parent instanceof CtStatementList) {\n\t\t\t\t//visit all previous CtVariable siblings of scopeElement element in parent BodyHolder or Statement list\n\t\t\t\tsiblingsQuery.setInput(scopeElement).forEach(outputConsumer);\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//visit parameters of CtCatch and CtExecutable (method, lambda)\n\t\t\t\tif (parent instanceof CtCatch) {\n\t\t\t\t\tCtCatch ctCatch = (CtCatch) parent;\n\t\t\t\t\tif (sendToOutput(ctCatch.getParameter(), outputConsumer)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (parent instanceof CtExecutable) {\n\t\t\t\t\tCtExecutable<?> exec = (CtExecutable<?>) parent;\n\t\t\t\t\tfor (CtParameter<?> param : exec.getParameters()) {\n\t\t\t\t\t\tif (sendToOutput(param, outputConsumer)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parent instanceof CtModifiable) {\n\t\t\t\tisInStaticScope = isInStaticScope || ((CtModifiable) parent).hasModifier(ModifierKind.STATIC);\n\t\t\t}\n\t\t\tscopeElement = parent;\n\t\t}\n\t}\n\n\t/**\n\t * @param var\n\t * @param output\n\t * @return true if query processing is terminated\n\t */\n\tprivate boolean sendToOutput(CtVariable<?> var, CtConsumer<Object> output) {\n\t\tif (variableName == null || variableName.equals(var.getSimpleName())) {\n\t\t\toutput.accept(var);\n\t\t}\n\t\treturn query.isTerminated();\n\t}\n\n\t/**\n\t * This method provides access to current state of this function.\n\t * It is intended to be called by other mapping functions at query processing time or after query is finished.\n\t *\n\t * @return true if there is an local class on the way from the input of this mapping function\n\t * to the actually found potential variable declaration\n\t */\n\tpublic boolean isTypeOnTheWay() {\n\t\treturn isTypeOnTheWay;\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/AllMethodsSameSignatureFunction.java",
      "weight" : 148.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\nimport spoon.support.visitor.ClassTypingContext;\nimport spoon.support.visitor.SubInheritanceHierarchyResolver;\n\n/**\n * Returns all methods/lambdas with same signature in related inheritance hierarchies.\n * It can be be used to found all other methods, which has to be changed if signature of method or lambda expression has to be changed.<br>\n *\n * Expects {@link CtExecutable} as input\n * and produces all {@link CtExecutable}s,\n * which have same signature and are declared in sub/super classes or sub/super interfaces of this or related inheritance hierarchy.<br>\n *\n * It makes sense to call this mapping functions for {@link CtMethod} and {@link CtLambda} instances\n * and then it returns {@link CtMethod} and {@link CtLambda} instance which overrides each other or have same signature.\n */\npublic class AllMethodsSameSignatureFunction implements CtConsumableFunction<CtExecutable<?>>, CtQueryAware {\n\n\tprivate boolean includingSelf = false;\n\tprivate boolean includingLambdas = true;\n\tprivate CtQuery query;\n\n\tpublic AllMethodsSameSignatureFunction() {\n\t}\n\n\t/**\n\t * @param includingSelf if true then input element is sent to output too. By default it is false.\n\t */\n\tpublic AllMethodsSameSignatureFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param includingLambdas if true then extra search for {@link CtLambda} executables,\n\t * with same signature will be processed too.\n\t * If false, then it returns only {@link CtMethod} instances.\n\t * By default it is true.\n\t */\n\tpublic AllMethodsSameSignatureFunction includingLambdas(boolean includingLambdas) {\n\t\tthis.includingLambdas = includingLambdas;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(final CtExecutable<?> targetExecutable, final CtConsumer<Object> outputConsumer) {\n\t\t//prepare filter for lambda expression. It will be configured by the algorithm below\n\t\tfinal LambdaFilter lambdaFilter = new LambdaFilter();\n\t\tfinal CtQuery lambdaQuery = targetExecutable.getFactory().getModel().filterChildren(lambdaFilter);\n\t\t//the to be searched method\n\t\tCtMethod<?> targetMethod;\n\t\tif (targetExecutable instanceof CtLambda) {\n\t\t\t//the input is lambda\n\t\t\tif (includingSelf && includingLambdas) {\n\t\t\t\toutputConsumer.accept(targetExecutable);\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//in case of lambda, the target method is the method implemented by lambda\n\t\t\ttargetMethod = ((CtLambda<?>) targetExecutable).getOverriddenMethod();\n\t\t\toutputConsumer.accept(targetMethod);\n\t\t\tif (query.isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//the input is the lambda expression, which was already returned or doesn't have to be returned at all because includingSelf == false\n\t\t\t//add extra filter into lambdaQuery which skips that input lambda expression\n\t\t\tlambdaQuery.select(new Filter<CtLambda<?>>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean matches(CtLambda<?> lambda) {\n\t\t\t\t\treturn targetExecutable != lambda;\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (targetExecutable instanceof CtMethod) {\n\t\t\tif (includingSelf) {\n\t\t\t\toutputConsumer.accept(targetExecutable);\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttargetMethod = (CtMethod<?>) targetExecutable;\n\t\t} else {\n\t\t\t//CtConstructor or CtAnonymousExecutable never overrides other executable. We are done\n\t\t\tif (includingSelf) {\n\t\t\t\toutputConsumer.accept(targetExecutable);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfinal List<CtMethod<?>> targetMethods = new ArrayList<>();\n\t\ttargetMethods.add(targetMethod);\n\t\tCtType<?> declaringType = targetMethod.getDeclaringType();\n\t\tlambdaFilter.addImplementingInterface(declaringType);\n\t\t//search for all declarations and implementations of this method in sub and super classes and interfaces of all related hierarchies.\n\t\tclass Context {\n\t\t\tboolean haveToSearchForSubtypes;\n\t\t}\n\t\tfinal Context context = new Context();\n\t\t//at the beginning we know that we have to always search for sub types too.\n\t\tcontext.haveToSearchForSubtypes = true;\n\t\t//Sub inheritance hierarchy function, which remembers visited sub types and does not returns/visits them again\n\t\tfinal SubInheritanceHierarchyResolver subHierarchyFnc = new SubInheritanceHierarchyResolver(declaringType.getFactory().getModel().getRootPackage());\n\t\t//add hierarchy of `targetMethod` as to be checked for sub types of declaring type\n\t\tsubHierarchyFnc.addSuperType(declaringType);\n\t\t//unique names of all types whose super inheritance hierarchy was searched for rootType\n\t\tSet<String> typesCheckedForRootType = new HashSet<>();\n\t\t//list of sub types whose inheritance hierarchy has to be checked\n\t\tfinal List<CtType<?>> toBeCheckedSubTypes = new ArrayList<>();\n\t\t//add hierarchy of `targetMethod` as to be checked for super types of declaring type\n\t\ttoBeCheckedSubTypes.add(declaringType);\n\t\twhile (!toBeCheckedSubTypes.isEmpty()) {\n\t\t\tfor (CtType<?> subType : toBeCheckedSubTypes) {\n\t\t\t\tClassTypingContext ctc = new ClassTypingContext(subType);\n\t\t\t\t//search for first target method from the same type inheritance hierarchy\n\t\t\t\ttargetMethod = getTargetMethodOfHierarchy(targetMethods, ctc);\n\t\t\t\t//search for all methods with same signature in inheritance hierarchy of `subType`\n\t\t\t\tforEachOverridenMethod(ctc, targetMethod, typesCheckedForRootType, new CtConsumer<CtMethod<?>>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(CtMethod<?> overriddenMethod) {\n\t\t\t\t\t\ttargetMethods.add(overriddenMethod);\n\t\t\t\t\t\toutputConsumer.accept(overriddenMethod);\n\t\t\t\t\t\tCtType<?> type = overriddenMethod.getDeclaringType();\n\t\t\t\t\t\tlambdaFilter.addImplementingInterface(type);\n\t\t\t\t\t\tsubHierarchyFnc.addSuperType(type);\n\t\t\t\t\t\t//mark that new super type was added, so we have to search for sub types again\n\t\t\t\t\t\tcontext.haveToSearchForSubtypes = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttoBeCheckedSubTypes.clear();\n\t\t\tif (context.haveToSearchForSubtypes) {\n\t\t\t\tcontext.haveToSearchForSubtypes = false;\n\t\t\t\t//there are some new super types, whose sub inheritance hierarchy has to be checked\n\t\t\t\t//search their inheritance hierarchy for sub types\n\t\t\t\tsubHierarchyFnc.forEachSubTypeInPackage(new CtConsumer<CtType<?>>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(CtType<?> type) {\n\t\t\t\t\t\ttoBeCheckedSubTypes.add(type);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (includingLambdas) {\n\t\t\t//search for all lambdas implementing any of the found interfaces\n\t\t\tlambdaQuery.forEach(outputConsumer);\n\t\t}\n\t}\n\n\t/**\n\t * calls outputConsumer for each method which is overridden by 'thisMethod' in scope of `ctc`.\n\t * There is assured that each method is returned only once.\n\t *\n\t * @param ctc - class typing context whose scope is searched for overridden methods\n\t * @param thisMethod - the\n\t * @param distintTypesSet set of qualified names of types which were already visited\n\t * @param outputConsumer result handling consumer\n\t */\n\tprivate void forEachOverridenMethod(final ClassTypingContext ctc, final CtMethod<?> thisMethod, Set<String> distintTypesSet, final CtConsumer<CtMethod<?>> outputConsumer) {\n\t\tfinal CtQuery q = ctc.getAdaptationScope()\n\t\t\t.map(new AllTypeMembersFunction(CtMethod.class).distinctSet(distintTypesSet));\n\t\tq.forEach(new CtConsumer<CtMethod<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtMethod<?> thatMethod) {\n\t\t\t\tif (thisMethod == thatMethod) {\n\t\t\t\t\t//do not return scope method\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//check whether method is overridden by searched method\n\t\t\t\t/*\n\t\t\t\t * note: we are in super inheritance hierarchy of type declaring input `method`, so we do not have to check isSubTypeOf.\n\t\t\t\t * Check for isSubSignature is enough\n\t\t\t\t */\n\t\t\t\tif (ctc.isSubSignature(thisMethod, thatMethod)) {\n\t\t\t\t\toutputConsumer.accept(thatMethod);\n\t\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\t\tq.terminate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate CtMethod<?> getTargetMethodOfHierarchy(List<CtMethod<?>> targetMethods, ClassTypingContext ctc) {\n\t\tfor (CtMethod<?> method : targetMethods) {\n\t\t\tCtType<?> declaringType = method.getDeclaringType();\n\t\t\tif (ctc.isSubtypeOf(declaringType.getReference())) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t\t//this should never happen\n\t\tthrow new SpoonException(\"No target executable was found in super type hiearchy of class typing context\");\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/DirectReferenceFilter.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.reference.CtReference;\n\n/**\n * This simple filter matches all the references to a given element by using\n * reference equality.\n */\npublic class DirectReferenceFilter<T extends CtReference> extends AbstractFilter<T> {\n\tCtReference reference;\n\n\t/**\n\t * Creates the filter.\n\t *\n\t * @param reference\n\t *            the matching reference\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic DirectReferenceFilter(CtReference reference) {\n\t\tsuper((Class<T>) reference.getClass());\n\t\tthis.reference = reference;\n\t}\n\n\t@Override\n\tpublic boolean matches(T reference) {\n\t\tif (super.matches(reference) == false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.reference.equals(reference);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/LambdaFilter.java",
      "weight" : 34.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This filter matches all the {@link CtLambda} elements, which implements defined interface(s)\n */\npublic class LambdaFilter implements Filter<CtLambda<?>> {\n\n\tprivate Set<String> qualifiedNamesOfInterfaces = new HashSet<>();\n\n\t/**\n\t * Use {@link #addImplementingInterface(CtTypeInformation)} to define set of interfaces whose lambdas it is search for\n\t */\n\tpublic LambdaFilter() {\n\t}\n\n\t/**\n\t * Matches all lambdas implementing `iface`\n\t * Use {@link #addImplementingInterface(CtTypeInformation)} to define set of interfaces whose lambdas it is search for\n\t */\n\tpublic LambdaFilter(CtInterface<?> iface) {\n\t\taddImplementingInterface(iface);\n\t}\n\n\t/**\n\t * Matches all lambdas implementing `iface`\n\t * Use {@link #addImplementingInterface(CtTypeInformation)} to define set of interfaces whose lambdas it is search for\n\t */\n\tpublic LambdaFilter(CtTypeReference<?> iface) {\n\t\taddImplementingInterface(iface);\n\t}\n\n\t/**\n\t * Allows to search for lambdas implemented by different interfaces.\n\t * @param typeInfo interface whose lambda implementations it is searching for\n\t */\n\tpublic LambdaFilter addImplementingInterface(CtTypeInformation typeInfo) {\n\t\tif (typeInfo instanceof CtType) {\n\t\t\tif (typeInfo instanceof CtInterface) {\n\t\t\t\tqualifiedNamesOfInterfaces.add(typeInfo.getQualifiedName());\n\t\t\t} //else ignore that request, because lambda can implement only interfaces\n\t\t} else {\n\t\t\t//do not check if it is interface or not. That check needs CtType in model and it might be not available in some modes\n\t\t\t//it is OK to search for non interface types. It simply founds no lambda implementing that\n\t\t\tqualifiedNamesOfInterfaces.add(typeInfo.getQualifiedName());\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtLambda<?> lambda) {\n\t\treturn qualifiedNamesOfInterfaces.contains(lambda.getType().getQualifiedName());\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/SubInheritanceHierarchyFunction.java",
      "weight" : 56.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\nimport spoon.support.visitor.SubInheritanceHierarchyResolver;\n\n/**\n * Expects a {@link CtTypeInformation} as input\n * and produces all sub classes and sub interfaces recursively.<br>\n * The output is produced in arbitrary order.\n */\npublic class SubInheritanceHierarchyFunction implements CtConsumableFunction<CtTypeInformation>, CtQueryAware {\n\n\tprivate boolean includingSelf = false;\n\tprivate boolean includingInterfaces = true;\n\tprivate CtQuery query;\n\tprivate boolean failOnClassNotFound = false;\n\n\t/**\n\t * The mapping function created using this constructor\n\t * will visit each sub class and sub interface\n\t * following sub hierarchy.\n\t */\n\tpublic SubInheritanceHierarchyFunction() {\n\t}\n\n\t/**\n\t * @param includingSelf if true then input element is sent to output too. By default it is false.\n\t */\n\tpublic SubInheritanceHierarchyFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param includingInterfaces if false then interfaces are not visited - only super classes. By default it is true.\n\t */\n\tpublic SubInheritanceHierarchyFunction includingInterfaces(boolean includingInterfaces) {\n\t\tthis.includingInterfaces = includingInterfaces;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param failOnClassNotFound sets whether processing should throw an exception if class is missing in noClassPath mode\n\t */\n\tpublic SubInheritanceHierarchyFunction failOnClassNotFound(boolean failOnClassNotFound) {\n\t\tthis.failOnClassNotFound = failOnClassNotFound;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(CtTypeInformation input, final CtConsumer<Object> outputConsumer) {\n\t\tfinal SubInheritanceHierarchyResolver fnc = new SubInheritanceHierarchyResolver(((CtElement) input).getFactory().getModel().getRootPackage())\n\t\t\t.failOnClassNotFound(failOnClassNotFound)\n\t\t\t.includingInterfaces(includingInterfaces);\n\t\tif (includingSelf) {\n\t\t\tif (input instanceof CtTypeReference) {\n\t\t\t\toutputConsumer.accept(((CtTypeReference<?>) input).getTypeDeclaration());\n\t\t\t} else {\n\t\t\t\toutputConsumer.accept(((CtType<?>) input));\n\t\t\t}\n\t\t}\n\t\tfnc.addSuperType(input);\n\t\tfnc.forEachSubTypeInPackage(new CtConsumer<CtType>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtType typeInfo) {\n\t\t\t\toutputConsumer.accept(typeInfo);\n\t\t\t\tif (query.isTerminated()) {\n\t\t\t\t\t//Cannot terminate, because its support was removed.\n\t\t\t\t\t//I think there are cases where it might be useful.\n//\t\t\t\t\tfnc.terminate();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/ReturnOrThrowFilter.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtCFlowBreak;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This simple filter matches all the occurrences of a return or a throw\n * statement (end of execution flow).\n */\npublic class ReturnOrThrowFilter implements Filter<CtCFlowBreak> {\n\n\t@Override\n\tpublic boolean matches(CtCFlowBreak cflowBreak) {\n\t\treturn (cflowBreak instanceof CtReturn)\n\t\t\t\t|| (cflowBreak instanceof CtThrow);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/AbstractFilter.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport java.lang.reflect.Method;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.Filter;\nimport spoon.support.util.RtHelper;\n\n/**\n * Defines an abstract filter based on matching on the element types.\n *\n * Not necessary in simple cases thanks to the use of runtime reflection.\n */\npublic abstract class AbstractFilter<T extends CtElement> implements Filter<T> {\n\n\tprivate Class<T> type;\n\n\t/**\n\t * Creates a filter with the type of the potentially matching elements.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AbstractFilter(Class<? super T> type) {\n\t\tthis.type = (Class<T>) type;\n\t}\n\n\t/**\n\t * Creates a filter with the type computed by reflection from the matches method parameter\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AbstractFilter() {\n\t\tMethod method = RtHelper.getMethod(getClass(), \"matches\", 1);\n\t\tif (method == null) {\n\t\t\tthrow new SpoonException(\"The method matches with one parameter was not found on the class \" + getClass().getName());\n\t\t}\n\t\tthis.type = (Class<T>) method.getParameterTypes()[0];\n\t}\n\n\tpublic Class<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic boolean matches(T element) {\n\t\treturn type.isAssignableFrom(element.getClass());\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/OverriddenMethodFilter.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.visitor.Filter;\nimport spoon.support.visitor.ClassTypingContext;\n\n/**\n * Gets all overridden method from the method given.\n */\npublic class OverriddenMethodFilter implements Filter<CtMethod<?>> {\n\tprivate final CtMethod<?> method;\n\tprivate final ClassTypingContext context;\n\tprivate boolean includingSelf = false;\n\n\t/**\n\t * Creates a new overridden method filter.\n\t *\n\t * @param method\n\t * \t\tthe executable to be tested for being invoked\n\t */\n\tpublic OverriddenMethodFilter(CtMethod<?> method) {\n\t\tthis.method = method;\n\t\tcontext = new ClassTypingContext(method.getDeclaringType());\n\t}\n\n\t/**\n\t * @param includingSelf if false then element which is equal to the #method is not matching.\n\t * false is default behavior\n\t */\n\tpublic OverriddenMethodFilter includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtMethod<?> element) {\n\t\tif (method == element) {\n\t\t\treturn this.includingSelf;\n\t\t}\n\t\treturn context.isOverriding(method, element);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/OverriddenMethodQuery.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * Gets all overridden method from the method given.\n */\npublic class OverriddenMethodQuery implements CtConsumableFunction<CtMethod<?>> {\n\t@Override\n\tpublic void apply(CtMethod<?> input, CtConsumer<Object> outputConsumer) {\n\t\tCtPackage searchScope = input.getFactory().Package().getRootPackage();\n\t\tsearchScope.filterChildren(new OverriddenMethodFilter(input)).forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/CatchVariableScopeFunction.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtScannerListener;\n\n/**\n * This Query expects a {@link CtCatchVariable} as input\n * and returns all CtElements,\n * which are in visibility scope of that catch variable.\n * In other words, it returns all elements,\n * which might be reference to that catch variable.\n * <br>\n * It can be used to search for variable declarations or\n * variable references which might be in name conflict with input catch variable.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtCatchVariable var = ...;\n * var.map(new CatchVariableScopeFunction()).forEach(...process result...);\n * }\n * </pre>\n */\npublic class CatchVariableScopeFunction implements CtConsumableFunction<CtCatchVariable<?>> {\n\tprivate final CtScannerListener listener;\n\n\tpublic CatchVariableScopeFunction() {\n\t\tthis.listener = null;\n\t}\n\tpublic CatchVariableScopeFunction(CtScannerListener queryListener) {\n\t\tthis.listener = queryListener;\n\t}\n\n\t@Override\n\tpublic void apply(CtCatchVariable<?> catchVariable, CtConsumer<Object> outputConsumer) {\n\t\tcatchVariable\n\t\t\t.getParent(CtCatch.class).getBody()\n\t\t\t.map(new CtScannerFunction().setListener(this.listener))\n\t\t\t.forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/CatchVariableReferenceFunction.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.reference.CtCatchVariableReference;\n\n/**\n * This Query expects a {@link CtCatchVariable} as input\n * and returns all {@link CtCatchVariableReference}s, which refers this input.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtCatchVariable var = ...;\n * var\n *   .map(new CatchVariableReferenceFunction())\n *   .forEach((CtCatchVariableReference ref)->...process references...);\n * }\n * </pre>\n */\npublic class CatchVariableReferenceFunction extends LocalVariableReferenceFunction {\n\n\tpublic CatchVariableReferenceFunction() {\n\t\tsuper(CtCatchVariable.class, CtCatchVariableReference.class);\n\t}\n\n\tpublic CatchVariableReferenceFunction(CtCatchVariable<?> catchVariable) {\n\t\tsuper(CtCatchVariable.class, CtCatchVariableReference.class, catchVariable);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/AnnotationFilter.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport java.lang.annotation.Annotation;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This filter matches all the elements annotated with a given annotation type.\n */\npublic class AnnotationFilter<E extends CtElement> extends TypeFilter<E> {\n\n\tprivate Class<? extends Annotation> annotationType;\n\n\t/**\n\t * Creates the filter.\n\t *\n\t * @param annotationType\n\t * \t\tthe annotation type which is searched\n\t */\n\tpublic AnnotationFilter(Class<? extends Annotation> annotationType) {\n\t\tsuper(CtElement.class);\n\t\tthis.annotationType = annotationType;\n\t}\n\n\t/**\n\t * Creates a new annotation filter.\n\t */\n\tpublic AnnotationFilter(Class<E> elementType,\n\t\t\t\t\t\t\tClass<? extends Annotation> annotationType) {\n\t\tsuper(elementType);\n\t\tthis.annotationType = annotationType;\n\t}\n\n\t@Override\n\tpublic boolean matches(E element) {\n\t\treturn super.matches(element) && element.getAnnotation(annotationType) != null;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/AbstractReferenceFilter.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This class defines an abstract reference filter that needs to be subclassed\n * in order to define the matching criteria.\n *\n * @param <T>\n * \t\tthe type of the reference to be matched\n */\npublic abstract class AbstractReferenceFilter<T extends CtReference> extends AbstractFilter<T> implements Filter<T> {\n\n\t/**\n\t * Creates a reference filter with the type of the potentially matching\n\t * references.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AbstractReferenceFilter(Class<? super T> type) {\n\t\tsuper(type);\n\t}\n\n\t/**\n\t * Creates a filter with the type computed by reflection from the matches method parameter\n\t */\n\tpublic AbstractReferenceFilter() {\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/ParameterReferenceFunction.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.reference.CtParameterReference;\n\n/**\n * This Query expects a {@link CtParameter} as input\n * and returns all {@link CtParameterReference}s, which refers this input.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtParameter param = ...;\n * param\n *   .map(new ParameterReferenceFunction())\n *   .forEach((CtParameterReference ref)->...process references...);\n * }\n * </pre>\n */\npublic class ParameterReferenceFunction extends LocalVariableReferenceFunction {\n\n\tpublic ParameterReferenceFunction() {\n\t\tsuper(CtParameter.class, CtParameterReference.class);\n\t}\n\n\t/**\n\t * This constructor allows to define target parameter - the one for which this function will search for.\n\t * In such case the input of mapping function represents the searching scope\n\t * @param parameter - the parameter declaration which is searched in scope of input element\n\t */\n\tpublic ParameterReferenceFunction(CtParameter<?> parameter) {\n\t\tsuper(CtParameter.class, CtParameterReference.class, parameter);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/LineFilter.java",
      "weight" : 44.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtLoop;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ParentNotInitializedException;\n\n/**\n * This filter matches all elements that can be considered as line of code (e.g. directly contained in a block, or a then statement). This discards CtStatement that are not used as statement (such as a method call used as RHS).\n * <pre>\n * // lines of a method\n * List&lt;CtStatement&gt; lines = method.getElements(new LineFilter());\n * // find the parent that is used as a statement (in a block or in a branch)\n * CtStatement parentStatement = element.getParent(new LineFilter());\n * </pre>\n */\npublic class LineFilter extends TypeFilter<CtStatement> {\n\n\t/**\n\t * Creates the filter.\n\t */\n\tpublic LineFilter() {\n\t\tsuper(CtStatement.class);\n\t}\n\n\t@Override\n\tpublic boolean matches(CtStatement element) {\n\t\tif (!super.matches(element)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (element instanceof CtBlock) {\n\t\t\treturn false;\n\t\t}\n\t\tCtElement parent;\n\t\ttry {\n\t\t\tparent = element.getParent();\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (parent instanceof CtStatementList) {\n\t\t\treturn true;\n\t\t}\n\t\tif (parent instanceof CtIf) {\n\t\t\tCtIf anIf = (CtIf) parent;\n\t\t\treturn element.equals(anIf.getThenStatement()) || element.equals(anIf.getElseStatement());\n\t\t}\n\t\tif (parent instanceof CtLoop) {\n\t\t\tCtLoop loop = (CtLoop) parent;\n\t\t\tCtStatement body = loop.getBody();\n\t\t\tif (body == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn body.equals(element);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/LocalVariableScopeFunction.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtScannerListener;\n\n/**\n * This Query expects a {@link CtLocalVariable} as input\n * and returns all CtElements,\n * which are in visibility scope of that local variable.\n * In other words, it returns all elements,\n * which might be reference to that local variable.\n * <br>\n * It can be used to search for variable declarations or\n * variable references which might be in name conflict with input local variable.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtLocalVariable var = ...;\n * var.map(new LocalVariableScopeFunction()).forEach(...process result...);\n * }\n * </pre>\n */\npublic class LocalVariableScopeFunction implements CtConsumableFunction<CtLocalVariable<?>> {\n\tprivate final CtScannerListener listener;\n\n\tpublic LocalVariableScopeFunction() {\n\t\tthis.listener = null;\n\t}\n\n\tpublic LocalVariableScopeFunction(CtScannerListener queryListener) {\n\t\tthis.listener = queryListener;\n\t}\n\n\t@Override\n\tpublic void apply(final CtLocalVariable<?> localVariable, CtConsumer<Object> outputConsumer) {\n\t\tlocalVariable\n\t\t\t.map(new SiblingsFunction().mode(SiblingsFunction.Mode.NEXT).includingSelf(true))\n\t\t\t.map(new CtScannerFunction().setListener(this.listener))\n\t\t\t.select(new Filter<CtElement>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean matches(CtElement element) {\n\t\t\t\t\t//ignore localVariable itself\n\t\t\t\t\treturn localVariable != element;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/SuperInheritanceHierarchyFunction.java",
      "weight" : 222.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\nimport spoon.support.SpoonClassNotFoundException;\n\nimport java.util.Set;\n\n/**\n * Expects a {@link CtTypeInformation} as input\n * and produces all super classes and super interfaces recursively.<br>\n * The output is produced in following order:\n * <ol>\n * <li>input type. if `includingSelf==true`\n * <li>all interfaces of type recursively\n * <li>parent class of type\n * <li>goto 1: using  parent class as input type\n * </ol>\n */\npublic class SuperInheritanceHierarchyFunction implements CtConsumableFunction<CtTypeInformation>, CtQueryAware {\n\tprivate boolean includingSelf = false;\n\tprivate boolean includingInterfaces = true;\n\tprivate CtQuery query;\n\tprivate boolean failOnClassNotFound = false;\n\tprivate CtScannerListener listener;\n\tprivate boolean returnTypeReferences = false;\n\tprivate boolean interfacesExtendObject = false;\n\n\t/**\n\t * Super inheritance hierarchy scanning listener.\n\t * Use it instead of {@link CtScannerListener}\n\t * if you need to know whether visited type reference is class or interface\n\t */\n\tprivate static class Listener implements CtScannerListener {\n\n\t\t/**\n\t\t * Called before the scanner enters an type\n\t\t *\n\t\t * @param typeRef the type reference to be scanned.\n\t\t * @param isClass true if type reference refers to class, false if it is an interface\n\t\t * @return a {@link ScanningMode} that drives how the scanner processes this element and its children.\n\t\t * For instance, returning {@link ScanningMode#SKIP_ALL} causes that element and all children to be skipped and {@link #exit(CtElement)} are be NOT called for that element.\n\t\t */\n\t\tpublic ScanningMode enter(CtTypeReference<?> typeRef, boolean isClass) {\n\t\t\treturn enter((CtElement) typeRef);\n\t\t}\n\n\t\t/**\n\t\t * This method is called after the element and all its children have been visited.\n\t\t * This method is NOT called if an exception is thrown in {@link #enter(CtElement)} or during the scanning of the element or any of its children element.\n\t\t * This method is NOT called for an element for which {@link #enter(CtElement)} returned {@link ScanningMode#SKIP_ALL}.\n\t\t *\n\t\t * @param typeRef the type reference that has just been scanned.\n\t\t * @param isClass true if type reference refers to class, false if it is an interface\n\t\t */\n\t\tpublic void exit(CtTypeReference<?> typeRef, boolean isClass) {\n\t\t\texit((CtElement) typeRef);\n\t\t}\n\n\t\t@Override\n\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\treturn ScanningMode.NORMAL;\n\t\t}\n\n\t\t@Override\n\t\tpublic void exit(CtElement element) {\n\t\t}\n\t}\n\n\t/**\n\t * The mapping function created using this constructor\n\t * will visit each super class and super interface\n\t * following super hierarchy. It can happen\n\t * that some interfaces will be visited more then once\n\t * if they are in super inheritance hierarchy more then once.<br>\n\t * Use second constructor if you want to visit each interface only once.\n\t */\n\tpublic SuperInheritanceHierarchyFunction() {\n\t}\n\n\t/**\n\t * The mapping function created using this constructor\n\t * will visit each super class and super interface\n\t * following super hierarchy. It is assured\n\t * that interfaces will be visited only once\n\t * even if they are in super inheritance hierarchy more then once.<br>\n\t *\n\t * @param visitedSet assures that each class/interface is visited only once\n\t * The types which are already contained in `visitedSet` are not visited\n\t * and not returned by this mapping function.\n\t */\n\tpublic SuperInheritanceHierarchyFunction(Set<String> visitedSet) {\n\t\tlistener = new DistinctTypeListener(visitedSet);\n\t}\n\n\t/**\n\t * Implementation of {@link CtScannerListener},\n\t * which is used to assure that each interface is visited only once.\n\t * It can be extended to implement more powerful listener\n\t */\n\tpublic static class DistinctTypeListener extends Listener {\n\t\tSet<String> visitedSet;\n\n\t\tpublic DistinctTypeListener(Set<String> visitedSet) {\n\t\t\tthis.visitedSet = visitedSet;\n\t\t}\n\n\t\t@Override\n\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\tif (visitedSet.add(((CtTypeInformation) element).getQualifiedName())) {\n\t\t\t\treturn ScanningMode.NORMAL;\n\t\t\t}\n\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t}\n\t\t@Override\n\t\tpublic void exit(CtElement element) {\n\t\t}\n\t}\n\n\t/**\n\t * @param includingSelf if true then input element is sent to output too. By default it is false.\n\t */\n\tpublic SuperInheritanceHierarchyFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param includingInterfaces if false then interfaces are not visited - only super classes. By default it is true.\n\t */\n\tpublic SuperInheritanceHierarchyFunction includingInterfaces(boolean includingInterfaces) {\n\t\tthis.includingInterfaces = includingInterfaces;\n\t\treturn this;\n\t}\n\n\t/**\n\t * configures whether {@link CtType} or {@link CtTypeReference} instances are returned by this mapping function\n\t * @param returnTypeReferences if true then {@link CtTypeReference} instances are returned by this mapping function\n\t * @return this to support fluent API\n\t */\n\tpublic SuperInheritanceHierarchyFunction returnTypeReferences(boolean returnTypeReferences) {\n\t\tthis.returnTypeReferences = returnTypeReferences;\n\t\treturn this;\n\t}\n\n\t/**\n\t * configures whether it should visit {@link Object} at the end of interface extends interface hierarchy.\n\t * Note: interface cannot extend Object (only other interfaces),\n\t * but note that interface inherits all public type members of {@link Object},\n\t * so there are use cases where client wants to visit Object as last member of interface inheritance hierarchy\n\t * @param interfacesExtendObject if true then {@link Object} is visited at the end too\n\t * @return this to support fluent API\n\t */\n\tpublic SuperInheritanceHierarchyFunction interfacesExtendObject(boolean interfacesExtendObject) {\n\t\tthis.interfacesExtendObject = interfacesExtendObject;\n\t\treturn this;\n\t}\n\t/**\n\t * The listener evens are called in this order:\n\t * <ol>\n\t * <li> enter(input element)\n\t * <li> return input element\n\t * <li> enter/exit for each super interface of input element recursively\n\t * <li> call 1-5) recursively where input element is super class of input element\n\t * <li> exit(input element)\n\t * </ol>\n\t * Note: this order is assured and some algorithms already depend on it!\n\t *\n\t * @param listener the implementation of {@link CtScannerListener}, which will listen for enter/exit of {@link CtTypeReference} during type hierarchy scanning\n\t * @return this to support fluent API\n\t */\n\tpublic SuperInheritanceHierarchyFunction setListener(CtScannerListener listener) {\n\t\tif (this.listener != null) {\n\t\t\tthrow new SpoonException(\"Cannot register listener on instance created with constructor which accepts the Set<String>. Use the no parameter constructor if listener has to be registered\");\n\t\t}\n\t\tthis.listener = listener;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param failOnClassNotFound sets whether processing should throw an exception if class is missing in noClassPath mode\n\t */\n\tpublic SuperInheritanceHierarchyFunction failOnClassNotFound(boolean failOnClassNotFound) {\n\t\tthis.failOnClassNotFound = failOnClassNotFound;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(CtTypeInformation input, CtConsumer<Object> outputConsumer) {\n\t\tCtTypeReference<?> typeRef;\n\t\tCtType<?> type;\n\t\t//detect whether input is a class or something else (e.g. interface)\n\t\tboolean isClass;\n\t\tif (input instanceof CtType) {\n\t\t\ttype = (CtType<?>) input;\n\t\t\ttypeRef = type.getReference();\n\t\t} else {\n\t\t\ttypeRef = (CtTypeReference<?>) input;\n\t\t\ttry {\n\t\t\t\ttype = typeRef.getTypeDeclaration();\n\t\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\t\tif (typeRef.getFactory().getEnvironment().getNoClasspath() == false) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\ttype = null;\n\t\t\t}\n\t\t}\n\t\t//if the type is unknown, than we expect it is interface, otherwise we would visit java.lang.Object too, even for interfaces\n\t\tisClass = type instanceof CtClass;\n\t\tif (isClass == false && includingInterfaces == false) {\n\t\t\t//the input is interface, but this scanner should visit only interfaces. Finish\n\t\t\treturn;\n\t\t}\n\t\tScanningMode mode = enter(typeRef, isClass);\n\t\tif (mode == ScanningMode.SKIP_ALL) {\n\t\t\t//listener decided to not visit that input. Finish\n\t\t\treturn;\n\t\t}\n\t\tif (includingSelf) {\n\t\t\tsendResult(typeRef, outputConsumer);\n\t\t\tif (query.isTerminated()) {\n\t\t\t\tmode = ScanningMode.SKIP_CHILDREN;\n\t\t\t}\n\t\t}\n\t\tif (mode == ScanningMode.NORMAL) {\n\t\t\tif (isClass == false) {\n\t\t\t\tvisitSuperInterfaces(typeRef, outputConsumer);\n\t\t\t\tif (interfacesExtendObject) {\n\t\t\t\t\t//last visit Object.class, because interface inherits all public type members of Object.class\n\t\t\t\t\tsendResultWithListener(typeRef.getFactory().Type().OBJECT, isClass, outputConsumer, (ref) -> { });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//call visitSuperClasses only for input of type class. The contract of visitSuperClasses requires that\n\t\t\t\tvisitSuperClasses(typeRef, outputConsumer, includingInterfaces);\n\t\t\t}\n\t\t}\n\t\texit(typeRef, isClass);\n\t}\n\n\t/**\n\t * calls `outputConsumer.accept(superClass)` for all super classes of superType.\n\t *\n\t * @param superTypeRef the reference to a class. This method is called only for classes. Never for interface\n\t * @param includingInterfaces if true then all superInterfaces of each type are sent to `outputConsumer` too.\n\t */\n\tprotected void visitSuperClasses(CtTypeReference<?> superTypeRef, CtConsumer<Object> outputConsumer, boolean includingInterfaces) {\n\t\tif (Object.class.getName().equals(superTypeRef.getQualifiedName())) {\n\t\t\t//java.lang.Object has no interface or super classes\n\t\t\treturn;\n\t\t}\n\t\tif (includingInterfaces) {\n\t\t\tvisitSuperInterfaces(superTypeRef, outputConsumer);\n\t\t\tif (query.isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tCtTypeReference<?> superClassRef = superTypeRef.getSuperclass();\n\t\tif (superClassRef == null) {\n\t\t\t//only CtClasses extend object,\n\t\t\t//this method is called only for classes (not for interfaces) so we know we can visit java.lang.Object now too\n\t\t\tsuperClassRef = superTypeRef.getFactory().Type().OBJECT;\n\t\t}\n\t\tsendResultWithListener(superClassRef, true,\n\t\t\t\toutputConsumer, (classRef) -> visitSuperClasses(classRef, outputConsumer, includingInterfaces));\n\t}\n\n\t/**\n\t * calls `outputConsumer.accept(interface)` for all superInterfaces of type recursively.\n\t */\n\tprotected void visitSuperInterfaces(CtTypeReference<?> type, CtConsumer<Object> outputConsumer) {\n\t\tSet<CtTypeReference<?>> superInterfaces;\n\t\ttry {\n\t\t\tsuperInterfaces = type.getSuperInterfaces();\n\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\tif (failOnClassNotFound) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tLauncher.LOGGER.warn(\"Cannot load class: \" + type.getQualifiedName() + \" with class loader \"\n\t\t\t\t\t+ Thread.currentThread().getContextClassLoader());\n\t\t\treturn;\n\t\t}\n\t\tfor (CtTypeReference<?> ifaceRef : superInterfaces) {\n\t\t\tsendResultWithListener(ifaceRef, false,\n\t\t\t\t\toutputConsumer, (ref) -> visitSuperInterfaces(ref, outputConsumer));\n\t\t\tif (query.isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void sendResultWithListener(CtTypeReference<?> classRef, boolean isClass, CtConsumer<Object> outputConsumer, CtConsumer<CtTypeReference<?>> runNext) {\n\t\tScanningMode mode = enter(classRef, isClass);\n\t\tif (mode == ScanningMode.SKIP_ALL) {\n\t\t\treturn;\n\t\t}\n\t\tsendResult(classRef, outputConsumer);\n\t\tif (mode == ScanningMode.NORMAL && query.isTerminated() == false) {\n\t\t\trunNext.accept(classRef);\n\t\t}\n\t\texit(classRef, isClass);\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n\n\tprivate ScanningMode enter(CtTypeReference<?> type, boolean isClass) {\n\t\tif (listener == null) {\n\t\t\treturn ScanningMode.NORMAL;\n\t\t}\n\t\tif (listener instanceof Listener) {\n\t\t\tListener typeListener = (Listener) listener;\n\t\t\treturn typeListener.enter(type, isClass);\n\t\t}\n\t\treturn listener.enter(type);\n\t}\n\n\tprivate void exit(CtTypeReference<?> type, boolean isClass) {\n\t\tif (listener != null) {\n\t\t\tif (listener instanceof Listener) {\n\t\t\t\t((Listener) listener).exit(type, isClass);\n\t\t\t} else {\n\t\t\t\tlistener.exit(type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void sendResult(CtTypeReference<?> typeRef, CtConsumer<Object> outputConsumer) {\n\t\tif (returnTypeReferences) {\n\t\t\toutputConsumer.accept(typeRef);\n\t\t} else {\n\t\t\tCtType<?> type;\n\t\t\ttry {\n\t\t\t\ttype = typeRef.getTypeDeclaration();\n\t\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\t\tif (failOnClassNotFound) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tLauncher.LOGGER.warn(\"Cannot load class: \" + typeRef.getQualifiedName() + \" with class loader \"\n\t\t\t\t\t\t+ Thread.currentThread().getContextClassLoader());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toutputConsumer.accept(type);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/SiblingsFunction.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * visits siblings of input element.\n * The sibling is the element whose sibling.getParent()==input.getParent()\n * <br>\n * The siblings are visited in order in which they would be visited by CtScanner.\n * The input element is by default not visited. But if {@link #includingSelf(boolean)} is called with value true,\n * then input element is visited too in the order in which CtScanner would visit it.\n *\n *  The visiting order is relevant, because this scanner is used for example resolve local variable declarations.\n */\npublic class SiblingsFunction implements CtConsumableFunction<CtElement> {\n\n\t/**\n\t * Defines visiting mode\n\t */\n\tpublic enum Mode {\n\t\tALL,\t//all siblings are visited\n\t\tPREVIOUS, //only previous siblings of input element\n\t\tNEXT\t//only next siblings of input element\n\t}\n\n\tprivate Mode mode = Mode.ALL;\n\tprivate boolean includingSelf = false;\n\n\tpublic SiblingsFunction() {\n\t}\n\n\t/**\n\t * @param includingSelf if false then input element is not visited\n\t */\n\tpublic SiblingsFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param mode defines which siblings will be visited. See {@link Mode} for possible values\n\t */\n\tpublic SiblingsFunction mode(Mode mode) {\n\t\tthis.mode = mode;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(final CtElement input, final CtConsumer<Object> outputConsumer) {\n\t\tfinal CtElement parent = input.getParent();\n\t\tparent.accept(new CtScanner() {\n\t\t\tboolean hasVisitedInput = false;\n\t\t\tboolean visitPrev = mode == Mode.ALL || mode == Mode.PREVIOUS;\n\t\t\tboolean visitNext = mode == Mode.ALL || mode == Mode.NEXT;\n\t\t\t@Override\n\t\t\tpublic void scan(CtElement element) {\n\t\t\t\tif (element != null && element.isParentInitialized() && element.getParent() == parent) {\n\t\t\t\t\t//visit only elements whose parent is same\n\t\t\t\t\tboolean canVisit = hasVisitedInput ? visitNext : visitPrev;\n\t\t\t\t\tif (input == element) {\n\t\t\t\t\t\thasVisitedInput = true;\n\t\t\t\t\t\tcanVisit = includingSelf;\n\t\t\t\t\t}\n\t\t\t\t\tif (canVisit) {\n\t\t\t\t\t\toutputConsumer.accept(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/FilteringOperator.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\n/**\n * This enumeration defines the possible composition operators for filters. It\n * is used in {@link spoon.reflect.visitor.filter.CompositeFilter}.\n *\n * @see spoon.reflect.visitor.Filter\n */\npublic enum FilteringOperator {\n\n\t/**\n\t * Defines the union of several filters: it matches if one of the filters\n\t * matches.\n\t */\n\tUNION,\n\t/**\n\t * Defines the intersection of several filters: it matches if all the\n\t * filters match.\n\t */\n\tINTERSECTION,\n\t/**\n\t * Defines the substraction of several filters to one filter: it matches if\n\t * the first filter matches and all the others do not match.\n\t */\n\tSUBSTRACTION\n\n}\n"
    }, {
      "name" : "reflect/visitor/filter/SubtypeFilter.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * Matches all CtType elements, which are sub type of {@link #superType}\n * Matches the input `superType` too.\n * Call {@link #includingSelf(boolean)} with value false, if instance of {@link #superType} should no match this {@link Filter}\n */\npublic class SubtypeFilter extends AbstractFilter<CtType<?>> {\n\n\tprivate CtTypeReference<?> superType;\n\tprivate String superTypeQualifiedName;\n\n\tpublic SubtypeFilter(CtTypeReference<?> superType) {\n\t\tthis.superType = superType;\n\t}\n\n\t/**\n\t * @param includingSelf if false then element which is equal to to #superType is not matching\n\t */\n\tpublic SubtypeFilter includingSelf(boolean includingSelf) {\n\t\tif (includingSelf) {\n\t\t\tsuperTypeQualifiedName = null;\n\t\t} else {\n\t\t\tsuperTypeQualifiedName = superType.getQualifiedName();\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtType<?> mayBeSubType) {\n\t\tif (superTypeQualifiedName != null && superTypeQualifiedName.equals(mayBeSubType.getQualifiedName())) {\n\t\t\t//we should not accept superType\n\t\t\treturn false;\n\t\t}\n\t\treturn mayBeSubType.isSubtypeOf(superType);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/VariableScopeFunction.java",
      "weight" : 45.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * The mapping function, accepting {@link CtVariable}\n * <ul>\n * <li>CtLocalVariable - local variable declared in body\n * <li>CtParameter - method parameter\n * <li>CtCatchVariable - try - catch variable\n * </ul>\n * and returning all the CtElements, which exists in visibility scope of this variable.\n */\npublic class VariableScopeFunction implements CtConsumableFunction<CtVariable<?>> {\n\n\tprotected final Visitor visitor = new Visitor();\n\tprotected CtConsumer<Object> outputConsumer;\n\n\t@Override\n\tpublic void apply(CtVariable<?> variable, CtConsumer<Object> outputConsumer) {\n\t\tthis.outputConsumer = outputConsumer;\n\t\tvariable.accept(visitor);\n\t}\n\n\tprivate static final LocalVariableScopeFunction localVariableScopeFunction = new LocalVariableScopeFunction();\n\tprivate static final ParameterScopeFunction parameterScopeFunction = new ParameterScopeFunction();\n\tprivate static final CatchVariableScopeFunction catchVariableScopeFunction = new CatchVariableScopeFunction();\n\n\tprotected class Visitor extends CtScanner {\n\t\t@Override\n\t\tprotected void enter(CtElement e) {\n\t\t\tthrow new SpoonException(\"Unsupported variable of type \" + e.getClass().getName());\n\t\t}\n\t\t/**\n\t\t * calls outputConsumer for each reference of the field\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtField(CtField<T> field) {\n\t\t\tthrow new SpoonException(\"Field scope function is not supported\");\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the local variable\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\t\t\tlocalVariableScopeFunction.apply(localVariable, outputConsumer);\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the parameter\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtParameter(CtParameter<T> parameter) {\n\t\t\tparameterScopeFunction.apply(parameter, outputConsumer);\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the catch variable\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\t\tcatchVariableScopeFunction.apply(catchVariable, outputConsumer);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/CtScannerFunction.java",
      "weight" : 51.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\n\n/**\n * Returns all children of an element.\n * More than this, it is a parameterizable class to be subclassed which provides all the power of {@link spoon.reflect.visitor.CtScanner} in the context of queries.\n * <br>\n * In particular, one can a register a {@link CtScannerListener}, it is called-back when entering/exiting each scanned AST node\n * and it drives the scanning process (see {@link ScanningMode}).\n */\npublic class CtScannerFunction implements CtConsumableFunction<CtElement>, CtQueryAware {\n\n\tprivate final Scanner scanner;\n\tprivate boolean includingSelf = true;\n\n\tpublic CtScannerFunction() {\n\t\tscanner = new Scanner();\n\t}\n\n\t/**\n\t * @param includingSelf if true then input element is sent to output too. By default it is false.\n\t */\n\tpublic CtScannerFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param listener the implementation of {@link CtScannerListener}, which will listen for enter/exit of nodes during scanning of AST\n\t * @return this to support fluent API\n\t */\n\tpublic CtScannerFunction setListener(CtScannerListener listener) {\n\t\tscanner.setListener(listener);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(CtElement input, CtConsumer<Object> outputConsumer) {\n\t\tscanner.next = outputConsumer;\n\t\tif (this.includingSelf) {\n\t\t\tscanner.scan(input);\n\t\t} else {\n\t\t\tinput.accept(scanner);\n\t\t}\n\t}\n\n\t/*\n\t * it is called automatically by CtQuery implementation,\n\t * when this mapping function is added.\n\t */\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tscanner.query = query;\n\t}\n\n\tprivate static class Scanner extends EarlyTerminatingScanner<Void> {\n\t\tprotected CtConsumer<Object> next;\n\t\tprivate CtQuery query;\n\n\t\t@Override\n\t\tprotected void onElement(CtRole role, CtElement element) {\n\t\t\tnext.accept(element);\n\t\t\tsuper.onElement(role, element);\n\t\t}\n\n\t\t/*\n\t\t * override {@link EarlyTerminatingScanner#isTerminated()} and let it stop when query is terminated\n\t\t */\n\t\t@Override\n\t\tprotected boolean isTerminated() {\n\t\t\treturn query.isTerminated();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/ParentFunction.java",
      "weight" : 36.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtQueryAware;\n\n/**\n * This Function expects a {@link CtElement} as input\n * and returns all parents of this element.\n *\n * By default input is not returned,\n * but this behavior can be changed by call of {@link #includingSelf(boolean)} with value true\n */\npublic class ParentFunction implements CtConsumableFunction<CtElement>, CtQueryAware {\n\n\tprivate boolean includingSelf = false;\n\tprivate CtQuery query;\n\n\tpublic ParentFunction() {\n\t}\n\n\t/**\n\t * @param includingSelf if true then input element is sent to output too. By default it is false.\n\t */\n\tpublic ParentFunction includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void apply(CtElement input, CtConsumer<Object> outputConsumer) {\n\t\tif (input == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (includingSelf) {\n\t\t\toutputConsumer.accept(input);\n\t\t}\n\t\tCtElement parent = input;\n\t\tCtModule topLevel = input.getFactory().getModel().getUnnamedModule();\n\t\twhile (parent != null && parent != topLevel && query.isTerminated() == false && parent.isParentInitialized()) {\n\t\t\tparent = parent.getParent();\n\t\t\toutputConsumer.accept(parent);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setQuery(CtQuery query) {\n\t\tthis.query = query;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/OverridingMethodFilter.java",
      "weight" : 21.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * Gets all overriding method from the method given.\n */\npublic class OverridingMethodFilter implements Filter<CtMethod<?>> {\n\tprivate final CtMethod<?> method;\n\tprivate boolean includingSelf = false;\n\n\t/**\n\t * Creates a new overriding method filter.\n\t *\n\t * @param method\n\t * \t\tthe executable to be tested for being invoked\n\t */\n\tpublic OverridingMethodFilter(CtMethod<?> method) {\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * @param includingSelf if false then element which is equal to the #method is not matching.\n\t * false is default behavior\n\t */\n\tpublic OverridingMethodFilter includingSelf(boolean includingSelf) {\n\t\tthis.includingSelf = includingSelf;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtMethod<?> element) {\n\t\tif (method == element) {\n\t\t\treturn this.includingSelf;\n\t\t}\n\t\treturn element.isOverriding(method);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/VariableReferenceFunction.java",
      "weight" : 60.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * The mapping function, accepting {@link CtVariable}\n * <ul>\n * <li>CtLocalVariable - local variable declared in body\n * <li>CtField - member field of an type\n * <li>CtParameter - method parameter\n * <li>CtCatchVariable - try - catch variable\n * </ul>\n * and returning all the {@link CtVariableReference}, which refers this variable\n */\npublic class VariableReferenceFunction implements CtConsumableFunction<CtElement> {\n\n\tprotected final Visitor visitor = new Visitor();\n\tprivate final CtVariable<?> variable;\n\tprotected CtConsumer<Object> outputConsumer;\n\tprotected CtElement scope;\n\n\tpublic VariableReferenceFunction() {\n\t\tthis.variable = null;\n\t}\n\n\tpublic VariableReferenceFunction(CtVariable<?> variable) {\n\t\tthis.variable = variable;\n\t}\n\n\t@Override\n\tpublic void apply(CtElement variableOrScope, CtConsumer<Object> outputConsumer) {\n\t\tscope = variableOrScope;\n\t\tCtVariable<?> var = this.variable;\n\t\tif (var == null) {\n\t\t\tif (variableOrScope instanceof CtVariable<?>) {\n\t\t\t\tvar = (CtVariable<?>) variableOrScope;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"The input of VariableReferenceFunction must be a CtVariable but is a \" + variableOrScope.getClass().getSimpleName());\n\t\t\t}\n\t\t}\n\t\tthis.outputConsumer = outputConsumer;\n\t\tvar.accept(visitor);\n\t}\n\n\tprotected class Visitor extends CtScanner {\n\t\t@Override\n\t\tprotected void enter(CtElement e) {\n\t\t\tthrow new SpoonException(\"Unsupported variable of type \" + e.getClass().getName());\n\t\t}\n\t\t/**\n\t\t * calls outputConsumer for each reference of the field\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtField(CtField<T> field) {\n\t\t\tnew FieldReferenceFunction((CtField<?>) variable).apply(scope, outputConsumer);\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the local variable\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\t\t\tnew LocalVariableReferenceFunction((CtLocalVariable<?>) variable).apply(scope, outputConsumer);\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the parameter\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtParameter(CtParameter<T> parameter) {\n\t\t\tnew ParameterReferenceFunction((CtParameter<?>) variable).apply(scope, outputConsumer);\n\t\t}\n\n\t\t/**\n\t\t * calls outputConsumer for each reference of the catch variable\n\t\t */\n\t\t@Override\n\t\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\t\tnew CatchVariableReferenceFunction((CtCatchVariable<?>) variable).apply(scope, outputConsumer);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/RegexFilter.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * Filters elements with a regular expression on the element's code. Example:\n *\n * <pre>\n * CtFieldAccess thisAccess = type.getElements(new ExpressionFilter(&quot;this&quot;))\n * \t\t.get(0);\n * </pre>\n */\npublic class RegexFilter<E extends CtElement> implements Filter<E> {\n\tprivate final Pattern regex;\n\n\tpublic RegexFilter(String regex) {\n\t\tif (regex == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tthis.regex = Pattern.compile(regex);\n\t}\n\n\t@Override\n\tpublic boolean matches(E element) {\n\t\tMatcher m = regex.matcher(element.toString());\n\t\treturn m.matches();\n\t}\n\n\tpublic Class<CtElement> getType() {\n\t\treturn CtElement.class;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/FieldReferenceFunction.java",
      "weight" : 34.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtConsumer;\n\n/**\n * This Query expects a {@link CtField} as input\n * and returns all {@link CtFieldReference}s, which refers this input.\n * <br>\n * Usage:<br>\n * <pre> {@code\n * CtField param = ...;\n * param\n *   .map(new FieldReferenceFunction())\n *   .forEach((CtFieldReference ref)->...process references...);\n * }\n * </pre>\n */\npublic class FieldReferenceFunction implements CtConsumableFunction<CtElement> {\n\tprivate final CtField<?> field;\n\n\tpublic FieldReferenceFunction() {\n\t\tthis.field = null;\n\t}\n\n\tpublic FieldReferenceFunction(CtField<?> field) {\n\t\tthis.field = field;\n\t}\n\n\t@Override\n\tpublic void apply(CtElement fieldOrScope, CtConsumer<Object> outputConsumer) {\n\t\tCtElement scope;\n\t\tCtField<?> field = this.field;\n\t\tif (field == null) {\n\t\t\tif (fieldOrScope instanceof CtField) {\n\t\t\t\tfield = (CtField<?>) fieldOrScope;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"The input of FieldReferenceFunction must be a CtField but is \" + fieldOrScope.getClass().getSimpleName());\n\t\t\t}\n\t\t\tscope = field.getFactory().getModel().getUnnamedModule();\n\t\t} else {\n\t\t\tscope = fieldOrScope;\n\t\t}\n\t\tscope\n\t\t\t.filterChildren(new DirectReferenceFilter<CtFieldReference<?>>(field.getReference()))\n\t\t\t.forEach(outputConsumer);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/TypeFilter.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This simple filter matches all the elements of a given type.\n */\npublic class TypeFilter<T extends CtElement> extends AbstractFilter<T> {\n\n\t/**\n\t * Creates the filter.\n\t *\n\t * @param type\n\t * \t\tthe type that matches\n\t */\n\tpublic TypeFilter(Class<? super T> type) {\n\t\tsuper(type);\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/filter/VariableAccessFilter.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This simple filter matches all the accesses to a given field.\n */\npublic class VariableAccessFilter<T extends CtVariableAccess<?>> implements Filter<T> {\n\tCtVariableReference<?> variable;\n\n\t/**\n\t * Creates a new field access filter.\n\t *\n\t * @param variable\n\t * \t\tthe accessed variable\n\t */\n\tpublic VariableAccessFilter(CtVariableReference<?> variable) {\n\t\tif (variable == null) {\n\t\t\tthrow new IllegalArgumentException(\"The parameter variable cannot be null.\");\n\t\t}\n\t\tthis.variable = variable;\n\t}\n\n\t@Override\n\tpublic boolean matches(T variableAccess) {\n\t\treturn variable.equals(variableAccess.getVariable());\n\t}\n\n}\n"
    }, {
      "name" : "reflect/visitor/filter/ReferenceTypeFilter.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.reference.CtReference;\n\n/**\n * This simple filter matches all the references of a given type.\n *\n * @param <T>\n * \t\tthe type of the reference to be matched\n *\n */\npublic class ReferenceTypeFilter<T extends CtReference> extends TypeFilter<T> {\n\n\t/**\n\t * Creates the filter.\n\t *\n\t * @param type\n\t * \t\tthe type that matches\n\t */\n\tpublic ReferenceTypeFilter(Class<? super T> type) {\n\t\tsuper(type);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/NamedElementFilter.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * Filters elements by name and by type (for instance to find a method). Example:\n *\n * <pre>\n * CtMethod&lt;?&gt; normalFor = type.getElements(\n * \t\tnew NamedElementFilter&lt;CtMethod&lt;?&gt;&gt;(CtMethod.class, &quot;normalFor&quot;)).get(0);\n * </pre>\n */\npublic class NamedElementFilter<T extends CtNamedElement> implements Filter<T> {\n\tprivate final String name;\n\tprivate Class<T> acceptedClass;\n\n\t/**\n\t *\n\t * @param name Name of the expected element\n\t * @param acceptedClass Expected class of the results\n\t */\n\tpublic NamedElementFilter(Class<T> acceptedClass, String name) {\n\t\tif (name == null || acceptedClass == null) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tthis.name = name;\n\t\tthis.acceptedClass = acceptedClass;\n\t}\n\n\t@Override\n\tpublic boolean matches(T element) {\n\t\ttry {\n\t\t\treturn acceptedClass.isAssignableFrom(element.getClass()) && name.equals(element.getSimpleName());\n\t\t} catch (UnsupportedOperationException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getType() {\n\t\treturn acceptedClass;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/filter/ExecutableReferenceFilter.java",
      "weight" : 51.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.filter;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.Filter;\n\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This filter matches all the {@link CtExecutableReference} referencing defined one or more {@link CtExecutable}s.\n */\npublic class ExecutableReferenceFilter implements Filter<CtExecutableReference<?>> {\n\n\tprivate Map<CtExecutable<?>, CtExecutable<?>> executables = new IdentityHashMap<>();\n\tprivate Set<String> typeQualifiedNames = new HashSet<>();\n\tprivate Set<String> methodNames = new HashSet<>();\n\n\t/**\n\t * Creates a new executable reference filter.\n\t *\n\t * Call {@link #addExecutable(CtExecutable)} to define executables\n\t * whose references it matches.\n\t */\n\tpublic ExecutableReferenceFilter() {\n\t}\n\n\t/**\n\t * Creates a new executable reference filter.\n\t *\n\t * @param executable\n\t * \t\tthe executable whose references it matches\n\t */\n\tpublic ExecutableReferenceFilter(CtExecutable<?> executable) {\n\t\taddExecutable(executable);\n\t}\n\n\t/**\n\t * Add next {@link CtExecutable} whose {@link CtExecutableReference}s has to be matched\n\t *\n\t * @param executable searched {@link CtExecutable} instance\n\t * @return this to support fluent API\n\t */\n\tpublic ExecutableReferenceFilter addExecutable(CtExecutable<?> executable) {\n\t\texecutables.put(executable, executable);\n\t\tif (executable instanceof CtTypeMember) {\n\t\t\tCtType<?> declType = ((CtTypeMember) executable).getDeclaringType();\n\t\t\tif (declType == null) {\n\t\t\t\tthrow new SpoonException(\"Cannot search for executable reference, which has no declaring type\");\n\t\t\t}\n\t\t\ttypeQualifiedNames.add(declType.getQualifiedName());\n\t\t\tif (executable instanceof CtMethod<?>) {\n\t\t\t\tmethodNames.add(((CtMethod<?>) executable).getSimpleName());\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtExecutableReference<?> execRef) {\n\t\tif (execRef.getSimpleName().startsWith(CtExecutableReference.LAMBDA_NAME_PREFIX)) {\n\t\t\t//reference to lambda\n\t\t\treturn executables.containsKey(execRef.getDeclaration());\n\t\t} else {\n\t\t\t//reference to constructor or method\n\t\t\tCtTypeReference<?> declaringType = execRef.getDeclaringType();\n\t\t\tif (declaringType != null && typeQualifiedNames.contains(declaringType.getQualifiedName())) {\n\t\t\t\tif (CtExecutableReference.CONSTRUCTOR_NAME.equals(execRef.getSimpleName()) || methodNames.contains(execRef.getSimpleName())) {\n\t\t\t\t\treturn executables.containsKey(execRef.getDeclaration());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/CtScanner.java",
      "weight" : 847.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\n\n/**\n * This visitor implements a deep-search scan on the model.\n *\n * Ensures that all children nodes are visited once, a visit means three method\n * calls, one call to \"enter\", one call to \"exit\" and one call to scan.\n *\n * Is used by the processing and filtering engine.\n */\npublic abstract class CtScanner implements CtVisitor {\n\t/**\n\t * Default constructor.\n\t */\n\tpublic CtScanner() {\n\t}\n\n\t/**\n\t * This method is upcalled by the scanner when entering a scanned element.\n\t * To be overridden to implement specific scanners.\n\t */\n\tprotected void enter(CtElement e) {\n\t}\n\n\t/**\n\t * This method is upcalled by the scanner when exiting a scanned element. To\n\t * be overridden to implement specific scanners.\n\t */\n\tprotected void exit(CtElement e) {\n\t}\n\n\t/**\n\t * Generically scans a collection of meta-model elements.\n\t */\n\tpublic void scan(CtRole role, Collection<? extends CtElement> elements) {\n\t\tif (elements != null) {\n\t\t\t// we use defensive copy so as to be able to change the class while scanning\n\t\t\t// otherwise one gets a ConcurrentModificationException\n\t\t\tfor (CtElement e : new ArrayList<>(elements)) {\n\t\t\t\tscan(role, e);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Generically scans a Map of meta-model elements.\n\t */\n\tpublic void scan(CtRole role, Map<String, ? extends CtElement> elements) {\n\t\tif (elements != null) {\n\t\t\tfor (CtElement obj : elements.values()) {\n\t\t\t\tscan(role, obj);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generically scans a collection of meta-model elements.\n\t */\n\tpublic void scan(Collection<? extends CtElement> elements) {\n\t\tscan(null, elements);\n\t}\n\n\t/**\n\t * Generically scans a meta-model element.\n\t */\n\tpublic void scan(CtRole role, CtElement element) {\n\t\tscan(element);\n\t}\n\n\t/**\n\t * Generically scans a meta-model element.\n\t */\n\tpublic void scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\telement.accept(this);\n\t\t}\n\t}\n\n\tpublic <A extends Annotation> void visitCtAnnotation(final CtAnnotation<A> annotation) {\n\t\tenter(annotation);\n\t\tscan(CtRole.TYPE, annotation.getType());\n\t\tscan(CtRole.COMMENT, annotation.getComments());\n\t\tscan(CtRole.ANNOTATION_TYPE, annotation.getAnnotationType());\n\t\tscan(CtRole.ANNOTATION, annotation.getAnnotations());\n\t\tscan(CtRole.VALUE, annotation.getValues());\n\t\texit(annotation);\n\t}\n\n\t/**\n\t * Generically scans an object that can be an element, a reference, or a\n\t * collection of those.\n\t */\n\tpublic void scan(Object o) {\n\t\tscan(null, o);\n\t}\n\t/**\n\t * Generically scans an object that can be an element, a reference, or a\n\t * collection of those.\n\t */\n\tpublic void scan(CtRole role, Object o) {\n\t\tif (o instanceof CtElement) {\n\t\t\tscan(role, ((CtElement) (o)));\n\t\t}\n\t\tif (o instanceof Collection<?>) {\n\t\t\tscan(role, (Collection<? extends CtElement>) o);\n\t\t}\n\t\tif (o instanceof Map<?, ?>) {\n\t\t\tscan(role, (Map<String, ? extends CtElement>) o);\n\t\t}\n\t}\n\n\tpublic <A extends Annotation> void visitCtAnnotationType(final CtAnnotationType<A> annotationType) {\n\t\tenter(annotationType);\n\t\tscan(CtRole.ANNOTATION, annotationType.getAnnotations());\n\t\tscan(CtRole.TYPE_MEMBER, annotationType.getTypeMembers());\n\t\tscan(CtRole.COMMENT, annotationType.getComments());\n\t\texit(annotationType);\n\t}\n\n\tpublic void visitCtAnonymousExecutable(final CtAnonymousExecutable anonymousExec) {\n\t\tenter(anonymousExec);\n\t\tscan(CtRole.ANNOTATION, anonymousExec.getAnnotations());\n\t\tscan(CtRole.BODY, anonymousExec.getBody());\n\t\tscan(CtRole.COMMENT, anonymousExec.getComments());\n\t\texit(anonymousExec);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayRead(final CtArrayRead<T> arrayRead) {\n\t\tenter(arrayRead);\n\t\tscan(CtRole.ANNOTATION, arrayRead.getAnnotations());\n\t\tscan(CtRole.TYPE, arrayRead.getType());\n\t\tscan(CtRole.CAST, arrayRead.getTypeCasts());\n\t\tscan(CtRole.TARGET, arrayRead.getTarget());\n\t\tscan(CtRole.EXPRESSION, arrayRead.getIndexExpression());\n\t\tscan(CtRole.COMMENT, arrayRead.getComments());\n\t\texit(arrayRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayWrite(final CtArrayWrite<T> arrayWrite) {\n\t\tenter(arrayWrite);\n\t\tscan(CtRole.ANNOTATION, arrayWrite.getAnnotations());\n\t\tscan(CtRole.TYPE, arrayWrite.getType());\n\t\tscan(CtRole.CAST, arrayWrite.getTypeCasts());\n\t\tscan(CtRole.TARGET, arrayWrite.getTarget());\n\t\tscan(CtRole.EXPRESSION, arrayWrite.getIndexExpression());\n\t\tscan(CtRole.COMMENT, arrayWrite.getComments());\n\t\texit(arrayWrite);\n\t}\n\n\tpublic <T> void visitCtArrayTypeReference(final CtArrayTypeReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.PACKAGE_REF, reference.getPackage());\n\t\tscan(CtRole.DECLARING_TYPE, reference.getDeclaringType());\n\t\tscan(CtRole.TYPE, reference.getComponentType());\n\t\tscan(CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtAssert(final CtAssert<T> asserted) {\n\t\tenter(asserted);\n\t\tscan(CtRole.ANNOTATION, asserted.getAnnotations());\n\t\tscan(CtRole.CONDITION, asserted.getAssertExpression());\n\t\tscan(CtRole.EXPRESSION, asserted.getExpression());\n\t\tscan(CtRole.COMMENT, asserted.getComments());\n\t\texit(asserted);\n\t}\n\n\tpublic <T, A extends T> void visitCtAssignment(final CtAssignment<T, A> assignement) {\n\t\tenter(assignement);\n\t\tscan(CtRole.ANNOTATION, assignement.getAnnotations());\n\t\tscan(CtRole.TYPE, assignement.getType());\n\t\tscan(CtRole.CAST, assignement.getTypeCasts());\n\t\tscan(CtRole.ASSIGNED, assignement.getAssigned());\n\t\tscan(CtRole.ASSIGNMENT, assignement.getAssignment());\n\t\tscan(CtRole.COMMENT, assignement.getComments());\n\t\texit(assignement);\n\t}\n\n\tpublic <T> void visitCtBinaryOperator(final CtBinaryOperator<T> operator) {\n\t\tenter(operator);\n\t\tscan(CtRole.ANNOTATION, operator.getAnnotations());\n\t\tscan(CtRole.TYPE, operator.getType());\n\t\tscan(CtRole.CAST, operator.getTypeCasts());\n\t\tscan(CtRole.LEFT_OPERAND, operator.getLeftHandOperand());\n\t\tscan(CtRole.RIGHT_OPERAND, operator.getRightHandOperand());\n\t\tscan(CtRole.COMMENT, operator.getComments());\n\t\texit(operator);\n\t}\n\n\tpublic <R> void visitCtBlock(final CtBlock<R> block) {\n\t\tenter(block);\n\t\tscan(CtRole.ANNOTATION, block.getAnnotations());\n\t\tscan(CtRole.STATEMENT, block.getStatements());\n\t\tscan(CtRole.COMMENT, block.getComments());\n\t\texit(block);\n\t}\n\n\tpublic void visitCtBreak(final CtBreak breakStatement) {\n\t\tenter(breakStatement);\n\t\tscan(CtRole.ANNOTATION, breakStatement.getAnnotations());\n\t\tscan(CtRole.COMMENT, breakStatement.getComments());\n\t\texit(breakStatement);\n\t}\n\n\tpublic <S> void visitCtCase(final CtCase<S> caseStatement) {\n\t\tenter(caseStatement);\n\t\tscan(CtRole.ANNOTATION, caseStatement.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, caseStatement.getCaseExpression());\n\t\tscan(CtRole.STATEMENT, caseStatement.getStatements());\n\t\tscan(CtRole.COMMENT, caseStatement.getComments());\n\t\texit(caseStatement);\n\t}\n\n\tpublic void visitCtCatch(final CtCatch catchBlock) {\n\t\tenter(catchBlock);\n\t\tscan(CtRole.ANNOTATION, catchBlock.getAnnotations());\n\t\tscan(CtRole.PARAMETER, catchBlock.getParameter());\n\t\tscan(CtRole.BODY, catchBlock.getBody());\n\t\tscan(CtRole.COMMENT, catchBlock.getComments());\n\t\texit(catchBlock);\n\t}\n\n\tpublic <T> void visitCtClass(final CtClass<T> ctClass) {\n\t\tenter(ctClass);\n\t\tscan(CtRole.ANNOTATION, ctClass.getAnnotations());\n\t\tscan(CtRole.SUPER_TYPE, ctClass.getSuperclass());\n\t\tscan(CtRole.INTERFACE, ctClass.getSuperInterfaces());\n\t\tscan(CtRole.TYPE_PARAMETER, ctClass.getFormalCtTypeParameters());\n\t\tscan(CtRole.TYPE_MEMBER, ctClass.getTypeMembers());\n\t\tscan(CtRole.COMMENT, ctClass.getComments());\n\t\texit(ctClass);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameter(CtTypeParameter typeParameter) {\n\t\tenter(typeParameter);\n\t\tscan(CtRole.ANNOTATION, typeParameter.getAnnotations());\n\t\tscan(CtRole.SUPER_TYPE, typeParameter.getSuperclass());\n\t\tscan(CtRole.COMMENT, typeParameter.getComments());\n\t\texit(typeParameter);\n\t}\n\n\tpublic <T> void visitCtConditional(final CtConditional<T> conditional) {\n\t\tenter(conditional);\n\t\tscan(CtRole.TYPE, conditional.getType());\n\t\tscan(CtRole.ANNOTATION, conditional.getAnnotations());\n\t\tscan(CtRole.CONDITION, conditional.getCondition());\n\t\tscan(CtRole.THEN, conditional.getThenExpression());\n\t\tscan(CtRole.ELSE, conditional.getElseExpression());\n\t\tscan(CtRole.COMMENT, conditional.getComments());\n\t\tscan(CtRole.CAST, conditional.getTypeCasts());\n\t\texit(conditional);\n\t}\n\n\tpublic <T> void visitCtConstructor(final CtConstructor<T> c) {\n\t\tenter(c);\n\t\tscan(CtRole.ANNOTATION, c.getAnnotations());\n\t\tscan(CtRole.PARAMETER, c.getParameters());\n\t\tscan(CtRole.THROWN, c.getThrownTypes());\n\t\tscan(CtRole.TYPE_PARAMETER, c.getFormalCtTypeParameters());\n\t\tscan(CtRole.BODY, c.getBody());\n\t\tscan(CtRole.COMMENT, c.getComments());\n\t\texit(c);\n\t}\n\n\tpublic void visitCtContinue(final CtContinue continueStatement) {\n\t\tenter(continueStatement);\n\t\tscan(CtRole.ANNOTATION, continueStatement.getAnnotations());\n\t\tscan(CtRole.COMMENT, continueStatement.getComments());\n\t\texit(continueStatement);\n\t}\n\n\tpublic void visitCtDo(final CtDo doLoop) {\n\t\tenter(doLoop);\n\t\tscan(CtRole.ANNOTATION, doLoop.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, doLoop.getLoopingExpression());\n\t\tscan(CtRole.BODY, doLoop.getBody());\n\t\tscan(CtRole.COMMENT, doLoop.getComments());\n\t\texit(doLoop);\n\t}\n\n\tpublic <T extends Enum<?>> void visitCtEnum(final CtEnum<T> ctEnum) {\n\t\tenter(ctEnum);\n\t\tscan(CtRole.ANNOTATION, ctEnum.getAnnotations());\n\t\tscan(CtRole.INTERFACE, ctEnum.getSuperInterfaces());\n\t\tscan(CtRole.TYPE_MEMBER, ctEnum.getTypeMembers());\n\t\tscan(CtRole.VALUE, ctEnum.getEnumValues());\n\t\tscan(CtRole.COMMENT, ctEnum.getComments());\n\t\texit(ctEnum);\n\t}\n\n\tpublic <T> void visitCtExecutableReference(final CtExecutableReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.DECLARING_TYPE, reference.getDeclaringType());\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\tscan(CtRole.ARGUMENT_TYPE, reference.getParameters());\n\t\tscan(CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\tscan(CtRole.COMMENT, reference.getComments());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtField(final CtField<T> f) {\n\t\tenter(f);\n\t\tscan(CtRole.ANNOTATION, f.getAnnotations());\n\t\tscan(CtRole.TYPE, f.getType());\n\t\tscan(CtRole.DEFAULT_EXPRESSION, f.getDefaultExpression());\n\t\tscan(CtRole.COMMENT, f.getComments());\n\t\texit(f);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtEnumValue(final CtEnumValue<T> enumValue) {\n\t\tenter(enumValue);\n\t\tscan(CtRole.ANNOTATION, enumValue.getAnnotations());\n\t\tscan(CtRole.TYPE, enumValue.getType());\n\t\tscan(CtRole.DEFAULT_EXPRESSION, enumValue.getDefaultExpression());\n\t\tscan(CtRole.COMMENT, enumValue.getComments());\n\t\texit(enumValue);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtThisAccess(final CtThisAccess<T> thisAccess) {\n\t\tenter(thisAccess);\n\t\tscan(CtRole.COMMENT, thisAccess.getComments());\n\t\tscan(CtRole.ANNOTATION, thisAccess.getAnnotations());\n\t\tscan(CtRole.TYPE, thisAccess.getType());\n\t\tscan(CtRole.CAST, thisAccess.getTypeCasts());\n\t\tscan(CtRole.TARGET, thisAccess.getTarget());\n\t\texit(thisAccess);\n\t}\n\n\tpublic <T> void visitCtAnnotationFieldAccess(final CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\tenter(annotationFieldAccess);\n\t\tscan(CtRole.COMMENT, annotationFieldAccess.getComments());\n\t\tscan(CtRole.ANNOTATION, annotationFieldAccess.getAnnotations());\n\t\tscan(CtRole.CAST, annotationFieldAccess.getTypeCasts());\n\t\tscan(CtRole.TARGET, annotationFieldAccess.getTarget());\n\t\tscan(CtRole.VARIABLE, annotationFieldAccess.getVariable());\n\t\texit(annotationFieldAccess);\n\t}\n\n\tpublic <T> void visitCtFieldReference(final CtFieldReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.DECLARING_TYPE, reference.getDeclaringType());\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic void visitCtFor(final CtFor forLoop) {\n\t\tenter(forLoop);\n\t\tscan(CtRole.ANNOTATION, forLoop.getAnnotations());\n\t\tscan(CtRole.FOR_INIT, forLoop.getForInit());\n\t\tscan(CtRole.EXPRESSION, forLoop.getExpression());\n\t\tscan(CtRole.FOR_UPDATE, forLoop.getForUpdate());\n\t\tscan(CtRole.BODY, forLoop.getBody());\n\t\tscan(CtRole.COMMENT, forLoop.getComments());\n\t\texit(forLoop);\n\t}\n\n\tpublic void visitCtForEach(final CtForEach foreach) {\n\t\tenter(foreach);\n\t\tscan(CtRole.ANNOTATION, foreach.getAnnotations());\n\t\tscan(CtRole.FOREACH_VARIABLE, foreach.getVariable());\n\t\tscan(CtRole.EXPRESSION, foreach.getExpression());\n\t\tscan(CtRole.BODY, foreach.getBody());\n\t\tscan(CtRole.COMMENT, foreach.getComments());\n\t\texit(foreach);\n\t}\n\n\tpublic void visitCtIf(final CtIf ifElement) {\n\t\tenter(ifElement);\n\t\tscan(CtRole.ANNOTATION, ifElement.getAnnotations());\n\t\tscan(CtRole.CONDITION, ifElement.getCondition());\n\t\tscan(CtRole.THEN, ((CtStatement) (ifElement.getThenStatement())));\n\t\tscan(CtRole.ELSE, ((CtStatement) (ifElement.getElseStatement())));\n\t\tscan(CtRole.COMMENT, ifElement.getComments());\n\t\texit(ifElement);\n\t}\n\n\tpublic <T> void visitCtInterface(final CtInterface<T> intrface) {\n\t\tenter(intrface);\n\t\tscan(CtRole.ANNOTATION, intrface.getAnnotations());\n\t\tscan(CtRole.INTERFACE, intrface.getSuperInterfaces());\n\t\tscan(CtRole.TYPE_PARAMETER, intrface.getFormalCtTypeParameters());\n\t\tscan(CtRole.TYPE_MEMBER, intrface.getTypeMembers());\n\t\tscan(CtRole.COMMENT, intrface.getComments());\n\t\texit(intrface);\n\t}\n\n\tpublic <T> void visitCtInvocation(final CtInvocation<T> invocation) {\n\t\tenter(invocation);\n\t\tscan(CtRole.ANNOTATION, invocation.getAnnotations());\n\t\tscan(CtRole.CAST, invocation.getTypeCasts());\n\t\tscan(CtRole.TARGET, invocation.getTarget());\n\t\tscan(CtRole.EXECUTABLE_REF, invocation.getExecutable());\n\t\tscan(CtRole.ARGUMENT, invocation.getArguments());\n\t\tscan(CtRole.COMMENT, invocation.getComments());\n\t\texit(invocation);\n\t}\n\n\tpublic <T> void visitCtLiteral(final CtLiteral<T> literal) {\n\t\tenter(literal);\n\t\tscan(CtRole.ANNOTATION, literal.getAnnotations());\n\t\tscan(CtRole.TYPE, literal.getType());\n\t\tscan(CtRole.CAST, literal.getTypeCasts());\n\t\tscan(CtRole.COMMENT, literal.getComments());\n\t\texit(literal);\n\t}\n\n\tpublic <T> void visitCtLocalVariable(final CtLocalVariable<T> localVariable) {\n\t\tenter(localVariable);\n\t\tscan(CtRole.ANNOTATION, localVariable.getAnnotations());\n\t\tscan(CtRole.TYPE, localVariable.getType());\n\t\tscan(CtRole.DEFAULT_EXPRESSION, localVariable.getDefaultExpression());\n\t\tscan(CtRole.COMMENT, localVariable.getComments());\n\t\texit(localVariable);\n\t}\n\n\tpublic <T> void visitCtLocalVariableReference(final CtLocalVariableReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtCatchVariable(final CtCatchVariable<T> catchVariable) {\n\t\tenter(catchVariable);\n\t\tscan(CtRole.COMMENT, catchVariable.getComments());\n\t\tscan(CtRole.ANNOTATION, catchVariable.getAnnotations());\n\t\tscan(CtRole.MULTI_TYPE, catchVariable.getMultiTypes());\n\t\texit(catchVariable);\n\t}\n\n\tpublic <T> void visitCtCatchVariableReference(final CtCatchVariableReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtMethod(final CtMethod<T> m) {\n\t\tenter(m);\n\t\tscan(CtRole.ANNOTATION, m.getAnnotations());\n\t\tscan(CtRole.TYPE_PARAMETER, m.getFormalCtTypeParameters());\n\t\tscan(CtRole.TYPE, m.getType());\n\t\tscan(CtRole.PARAMETER, m.getParameters());\n\t\tscan(CtRole.THROWN, m.getThrownTypes());\n\t\tscan(CtRole.BODY, m.getBody());\n\t\tscan(CtRole.COMMENT, m.getComments());\n\t\texit(m);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\t\tenter(annotationMethod);\n\t\tscan(CtRole.ANNOTATION, annotationMethod.getAnnotations());\n\t\tscan(CtRole.TYPE, annotationMethod.getType());\n\t\tscan(CtRole.DEFAULT_EXPRESSION, annotationMethod.getDefaultExpression());\n\t\tscan(CtRole.COMMENT, annotationMethod.getComments());\n\t\texit(annotationMethod);\n\t}\n\n\tpublic <T> void visitCtNewArray(final CtNewArray<T> newArray) {\n\t\tenter(newArray);\n\t\tscan(CtRole.ANNOTATION, newArray.getAnnotations());\n\t\tscan(CtRole.TYPE, newArray.getType());\n\t\tscan(CtRole.CAST, newArray.getTypeCasts());\n\t\tscan(CtRole.EXPRESSION, newArray.getElements());\n\t\tscan(CtRole.DIMENSION, newArray.getDimensionExpressions());\n\t\tscan(CtRole.COMMENT, newArray.getComments());\n\t\texit(newArray);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructorCall(final CtConstructorCall<T> ctConstructorCall) {\n\t\tenter(ctConstructorCall);\n\t\tscan(CtRole.ANNOTATION, ctConstructorCall.getAnnotations());\n\t\tscan(CtRole.CAST, ctConstructorCall.getTypeCasts());\n\t\tscan(CtRole.EXECUTABLE_REF, ctConstructorCall.getExecutable());\n\t\tscan(CtRole.TARGET, ctConstructorCall.getTarget());\n\t\tscan(CtRole.ARGUMENT, ctConstructorCall.getArguments());\n\t\tscan(CtRole.COMMENT, ctConstructorCall.getComments());\n\t\texit(ctConstructorCall);\n\t}\n\n\tpublic <T> void visitCtNewClass(final CtNewClass<T> newClass) {\n\t\tenter(newClass);\n\t\tscan(CtRole.ANNOTATION, newClass.getAnnotations());\n\t\tscan(CtRole.CAST, newClass.getTypeCasts());\n\t\tscan(CtRole.EXECUTABLE_REF, newClass.getExecutable());\n\t\tscan(CtRole.TARGET, newClass.getTarget());\n\t\tscan(CtRole.ARGUMENT, newClass.getArguments());\n\t\tscan(CtRole.NESTED_TYPE, newClass.getAnonymousClass());\n\t\tscan(CtRole.COMMENT, newClass.getComments());\n\t\texit(newClass);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLambda(final CtLambda<T> lambda) {\n\t\tenter(lambda);\n\t\tscan(CtRole.ANNOTATION, lambda.getAnnotations());\n\t\tscan(CtRole.TYPE, lambda.getType());\n\t\tscan(CtRole.CAST, lambda.getTypeCasts());\n\t\tscan(CtRole.PARAMETER, lambda.getParameters());\n\t\tscan(CtRole.BODY, lambda.getBody());\n\t\tscan(CtRole.EXPRESSION, lambda.getExpression());\n\t\tscan(CtRole.COMMENT, lambda.getComments());\n\t\texit(lambda);\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(final CtExecutableReferenceExpression<T, E> expression) {\n\t\tenter(expression);\n\t\tscan(CtRole.COMMENT, expression.getComments());\n\t\tscan(CtRole.ANNOTATION, expression.getAnnotations());\n\t\tscan(CtRole.TYPE, expression.getType());\n\t\tscan(CtRole.CAST, expression.getTypeCasts());\n\t\tscan(CtRole.EXECUTABLE_REF, expression.getExecutable());\n\t\tscan(CtRole.TARGET, expression.getTarget());\n\t\texit(expression);\n\t}\n\n\tpublic <T, A extends T> void visitCtOperatorAssignment(final CtOperatorAssignment<T, A> assignment) {\n\t\tenter(assignment);\n\t\tscan(CtRole.ANNOTATION, assignment.getAnnotations());\n\t\tscan(CtRole.TYPE, assignment.getType());\n\t\tscan(CtRole.CAST, assignment.getTypeCasts());\n\t\tscan(CtRole.ASSIGNED, assignment.getAssigned());\n\t\tscan(CtRole.ASSIGNMENT, assignment.getAssignment());\n\t\tscan(CtRole.COMMENT, assignment.getComments());\n\t\texit(assignment);\n\t}\n\n\tpublic void visitCtPackage(final CtPackage ctPackage) {\n\t\tenter(ctPackage);\n\t\tscan(CtRole.ANNOTATION, ctPackage.getAnnotations());\n\t\tscan(CtRole.SUB_PACKAGE, ctPackage.getPackages());\n\t\tscan(CtRole.CONTAINED_TYPE, ctPackage.getTypes());\n\t\tscan(CtRole.COMMENT, ctPackage.getComments());\n\t\texit(ctPackage);\n\t}\n\n\tpublic void visitCtPackageReference(final CtPackageReference reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtParameter(final CtParameter<T> parameter) {\n\t\tenter(parameter);\n\t\tscan(CtRole.ANNOTATION, parameter.getAnnotations());\n\t\tscan(CtRole.TYPE, parameter.getType());\n\t\tscan(CtRole.COMMENT, parameter.getComments());\n\t\texit(parameter);\n\t}\n\n\tpublic <T> void visitCtParameterReference(final CtParameterReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\texit(reference);\n\t}\n\n\tpublic <R> void visitCtReturn(final CtReturn<R> returnStatement) {\n\t\tenter(returnStatement);\n\t\tscan(CtRole.ANNOTATION, returnStatement.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, returnStatement.getReturnedExpression());\n\t\tscan(CtRole.COMMENT, returnStatement.getComments());\n\t\texit(returnStatement);\n\t}\n\n\tpublic <R> void visitCtStatementList(final CtStatementList statements) {\n\t\tenter(statements);\n\t\tscan(CtRole.ANNOTATION, statements.getAnnotations());\n\t\tscan(CtRole.STATEMENT, statements.getStatements());\n\t\tscan(CtRole.COMMENT, statements.getComments());\n\t\texit(statements);\n\t}\n\n\tpublic <S> void visitCtSwitch(final CtSwitch<S> switchStatement) {\n\t\tenter(switchStatement);\n\t\tscan(CtRole.ANNOTATION, switchStatement.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, switchStatement.getSelector());\n\t\tscan(CtRole.CASE, switchStatement.getCases());\n\t\tscan(CtRole.COMMENT, switchStatement.getComments());\n\t\texit(switchStatement);\n\t}\n\n\tpublic void visitCtSynchronized(final CtSynchronized synchro) {\n\t\tenter(synchro);\n\t\tscan(CtRole.ANNOTATION, synchro.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, synchro.getExpression());\n\t\tscan(CtRole.BODY, synchro.getBlock());\n\t\tscan(CtRole.COMMENT, synchro.getComments());\n\t\texit(synchro);\n\t}\n\n\tpublic void visitCtThrow(final CtThrow throwStatement) {\n\t\tenter(throwStatement);\n\t\tscan(CtRole.ANNOTATION, throwStatement.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, throwStatement.getThrownExpression());\n\t\tscan(CtRole.COMMENT, throwStatement.getComments());\n\t\texit(throwStatement);\n\t}\n\n\tpublic void visitCtTry(final CtTry tryBlock) {\n\t\tenter(tryBlock);\n\t\tscan(CtRole.ANNOTATION, tryBlock.getAnnotations());\n\t\tscan(CtRole.BODY, tryBlock.getBody());\n\t\tscan(CtRole.CATCH, tryBlock.getCatchers());\n\t\tscan(CtRole.FINALIZER, tryBlock.getFinalizer());\n\t\tscan(CtRole.COMMENT, tryBlock.getComments());\n\t\texit(tryBlock);\n\t}\n\n\t@Override\n\tpublic void visitCtTryWithResource(final CtTryWithResource tryWithResource) {\n\t\tenter(tryWithResource);\n\t\tscan(CtRole.ANNOTATION, tryWithResource.getAnnotations());\n\t\tscan(CtRole.TRY_RESOURCE, tryWithResource.getResources());\n\t\tscan(CtRole.BODY, tryWithResource.getBody());\n\t\tscan(CtRole.CATCH, tryWithResource.getCatchers());\n\t\tscan(CtRole.FINALIZER, tryWithResource.getFinalizer());\n\t\tscan(CtRole.COMMENT, tryWithResource.getComments());\n\t\texit(tryWithResource);\n\t}\n\n\tpublic void visitCtTypeParameterReference(final CtTypeParameterReference ref) {\n\t\tenter(ref);\n\t\tscan(CtRole.PACKAGE_REF, ref.getPackage());\n\t\tscan(CtRole.DECLARING_TYPE, ref.getDeclaringType());\n\t\tscan(CtRole.ANNOTATION, ref.getAnnotations());\n\t\texit(ref);\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference wildcardReference) {\n\t\tenter(wildcardReference);\n\t\tscan(CtRole.PACKAGE_REF, wildcardReference.getPackage());\n\t\tscan(CtRole.DECLARING_TYPE, wildcardReference.getDeclaringType());\n\t\tscan(CtRole.ANNOTATION, wildcardReference.getAnnotations());\n\t\tscan(CtRole.BOUNDING_TYPE, wildcardReference.getBoundingType());\n\t\texit(wildcardReference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtIntersectionTypeReference(final CtIntersectionTypeReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.PACKAGE_REF, reference.getPackage());\n\t\tscan(CtRole.DECLARING_TYPE, reference.getDeclaringType());\n\t\t// TypeReferenceTest fails if actual type arguments are really not set-able on CtIntersectionTypeReference\n\t\tscan(CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\tscan(CtRole.BOUND, reference.getBounds());\n\t\texit(reference);\n\t}\n\n\tpublic <T> void visitCtTypeReference(final CtTypeReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.PACKAGE_REF, reference.getPackage());\n\t\tscan(CtRole.DECLARING_TYPE, reference.getDeclaringType());\n\t\tscan(CtRole.TYPE_ARGUMENT, reference.getActualTypeArguments());\n\t\tscan(CtRole.ANNOTATION, reference.getAnnotations());\n\t\tscan(CtRole.COMMENT, reference.getComments());\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeAccess(final CtTypeAccess<T> typeAccess) {\n\t\tenter(typeAccess);\n\t\tscan(CtRole.ANNOTATION, typeAccess.getAnnotations());\n\t\tscan(CtRole.CAST, typeAccess.getTypeCasts());\n\t\tscan(CtRole.ACCESSED_TYPE, typeAccess.getAccessedType());\n\t\tscan(CtRole.COMMENT, typeAccess.getComments());\n\t\texit(typeAccess);\n\t}\n\n\tpublic <T> void visitCtUnaryOperator(final CtUnaryOperator<T> operator) {\n\t\tenter(operator);\n\t\tscan(CtRole.ANNOTATION, operator.getAnnotations());\n\t\tscan(CtRole.TYPE, operator.getType());\n\t\tscan(CtRole.CAST, operator.getTypeCasts());\n\t\tscan(CtRole.EXPRESSION, operator.getOperand());\n\t\tscan(CtRole.COMMENT, operator.getComments());\n\t\texit(operator);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableRead(final CtVariableRead<T> variableRead) {\n\t\tenter(variableRead);\n\t\tscan(CtRole.ANNOTATION, variableRead.getAnnotations());\n\t\tscan(CtRole.CAST, variableRead.getTypeCasts());\n\t\tscan(CtRole.VARIABLE, variableRead.getVariable());\n\t\tscan(CtRole.COMMENT, variableRead.getComments());\n\t\texit(variableRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableWrite(final CtVariableWrite<T> variableWrite) {\n\t\tenter(variableWrite);\n\t\tscan(CtRole.ANNOTATION, variableWrite.getAnnotations());\n\t\tscan(CtRole.CAST, variableWrite.getTypeCasts());\n\t\tscan(CtRole.VARIABLE, variableWrite.getVariable());\n\t\tscan(CtRole.COMMENT, variableWrite.getComments());\n\t\texit(variableWrite);\n\t}\n\n\tpublic void visitCtWhile(final CtWhile whileLoop) {\n\t\tenter(whileLoop);\n\t\tscan(CtRole.ANNOTATION, whileLoop.getAnnotations());\n\t\tscan(CtRole.EXPRESSION, whileLoop.getLoopingExpression());\n\t\tscan(CtRole.BODY, whileLoop.getBody());\n\t\tscan(CtRole.COMMENT, whileLoop.getComments());\n\t\texit(whileLoop);\n\t}\n\n\tpublic <T> void visitCtCodeSnippetExpression(final CtCodeSnippetExpression<T> expression) {\n\t\tenter(expression);\n\t\tscan(CtRole.TYPE, expression.getType());\n\t\tscan(CtRole.COMMENT, expression.getComments());\n\t\tscan(CtRole.ANNOTATION, expression.getAnnotations());\n\t\tscan(CtRole.CAST, expression.getTypeCasts());\n\t\texit(expression);\n\t}\n\n\tpublic void visitCtCodeSnippetStatement(final CtCodeSnippetStatement statement) {\n\t\tenter(statement);\n\t\tscan(CtRole.COMMENT, statement.getComments());\n\t\tscan(CtRole.ANNOTATION, statement.getAnnotations());\n\t\texit(statement);\n\t}\n\n\tpublic <T> void visitCtUnboundVariableReference(final CtUnboundVariableReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(CtRole.TYPE, reference.getType());\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(final CtFieldRead<T> fieldRead) {\n\t\tenter(fieldRead);\n\t\tscan(CtRole.ANNOTATION, fieldRead.getAnnotations());\n\t\tscan(CtRole.CAST, fieldRead.getTypeCasts());\n\t\tscan(CtRole.TARGET, fieldRead.getTarget());\n\t\tscan(CtRole.VARIABLE, fieldRead.getVariable());\n\t\tscan(CtRole.COMMENT, fieldRead.getComments());\n\t\texit(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(final CtFieldWrite<T> fieldWrite) {\n\t\tenter(fieldWrite);\n\t\tscan(CtRole.ANNOTATION, fieldWrite.getAnnotations());\n\t\tscan(CtRole.CAST, fieldWrite.getTypeCasts());\n\t\tscan(CtRole.TARGET, fieldWrite.getTarget());\n\t\tscan(CtRole.VARIABLE, fieldWrite.getVariable());\n\t\tscan(CtRole.COMMENT, fieldWrite.getComments());\n\t\texit(fieldWrite);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtSuperAccess(final CtSuperAccess<T> f) {\n\t\tenter(f);\n\t\tscan(CtRole.COMMENT, f.getComments());\n\t\tscan(CtRole.ANNOTATION, f.getAnnotations());\n\t\tscan(CtRole.CAST, f.getTypeCasts());\n\t\tscan(CtRole.TARGET, f.getTarget());\n\t\tscan(CtRole.VARIABLE, f.getVariable());\n\t\texit(f);\n\t}\n\n\t@Override\n\tpublic void visitCtComment(final CtComment comment) {\n\t\tenter(comment);\n\t\tscan(CtRole.COMMENT, comment.getComments());\n\t\tscan(CtRole.ANNOTATION, comment.getAnnotations());\n\t\texit(comment);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDoc(final CtJavaDoc javaDoc) {\n\t\tenter(javaDoc);\n\t\tscan(CtRole.COMMENT, javaDoc.getComments());\n\t\tscan(CtRole.ANNOTATION, javaDoc.getAnnotations());\n\t\tscan(CtRole.COMMENT_TAG, javaDoc.getTags());\n\t\texit(javaDoc);\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDocTag(final CtJavaDocTag docTag) {\n\t\tenter(docTag);\n\t\tscan(CtRole.COMMENT, docTag.getComments());\n\t\tscan(CtRole.ANNOTATION, docTag.getAnnotations());\n\t\texit(docTag);\n\t}\n\n\t@Override\n\tpublic void visitCtImport(final CtImport ctImport) {\n\t\tenter(ctImport);\n\t\tscan(CtRole.IMPORT_REFERENCE, ctImport.getReference());\n\t\tscan(CtRole.ANNOTATION, ctImport.getAnnotations());\n\t\tscan(CtRole.COMMENT, ctImport.getComments());\n\t\texit(ctImport);\n\t}\n\n\t@Override\n\tpublic void visitCtModule(CtModule module) {\n\t\tenter(module);\n\t\tscan(CtRole.COMMENT, module.getComments());\n\t\tscan(CtRole.ANNOTATION, module.getAnnotations());\n\t\tscan(CtRole.MODULE_DIRECTIVE, module.getModuleDirectives());\n\t\tscan(CtRole.SUB_PACKAGE, module.getRootPackage());\n\t\texit(module);\n\t}\n\n\t@Override\n\tpublic void visitCtModuleReference(CtModuleReference moduleReference) {\n\t\tenter(moduleReference);\n\t\tscan(CtRole.ANNOTATION, moduleReference.getAnnotations());\n\t\texit(moduleReference);\n\t}\n\n\t@Override\n\tpublic void visitCtPackageExport(CtPackageExport moduleExport) {\n\t\tenter(moduleExport);\n\t\tscan(CtRole.COMMENT, moduleExport.getComments());\n\t\tscan(CtRole.PACKAGE_REF, moduleExport.getPackageReference());\n\t\tscan(CtRole.MODULE_REF, moduleExport.getTargetExport());\n\t\tscan(CtRole.ANNOTATION, moduleExport.getAnnotations());\n\t\texit(moduleExport);\n\t}\n\n\t@Override\n\tpublic void visitCtModuleRequirement(CtModuleRequirement moduleRequirement) {\n\t\tenter(moduleRequirement);\n\t\tscan(CtRole.COMMENT, moduleRequirement.getComments());\n\t\tscan(CtRole.MODULE_REF, moduleRequirement.getModuleReference());\n\t\tscan(CtRole.ANNOTATION, moduleRequirement.getAnnotations());\n\t\texit(moduleRequirement);\n\t}\n\n\t@Override\n\tpublic void visitCtProvidedService(CtProvidedService moduleProvidedService) {\n\t\tenter(moduleProvidedService);\n\t\tscan(CtRole.COMMENT, moduleProvidedService.getComments());\n\t\tscan(CtRole.SERVICE_TYPE, moduleProvidedService.getServiceType());\n\t\tscan(CtRole.IMPLEMENTATION_TYPE, moduleProvidedService.getImplementationTypes());\n\t\tscan(CtRole.ANNOTATION, moduleProvidedService.getAnnotations());\n\t\texit(moduleProvidedService);\n\t}\n\n\t@Override\n\tpublic void visitCtUsedService(CtUsedService usedService) {\n\t\tenter(usedService);\n\t\tscan(CtRole.COMMENT, usedService.getComments());\n\t\tscan(CtRole.SERVICE_TYPE, usedService.getServiceType());\n\t\tscan(CtRole.ANNOTATION, usedService.getAnnotations());\n\t\texit(usedService);\n\t}\n\n\t@Override\n\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\t\tenter(compilationUnit);\n\t\tscan(CtRole.COMMENT, compilationUnit.getComments());\n\t\tscan(CtRole.ANNOTATION, compilationUnit.getAnnotations());\n\t\tscan(CtRole.PACKAGE_DECLARATION, compilationUnit.getPackageDeclaration());\n\t\tscan(CtRole.DECLARED_IMPORT, compilationUnit.getImports());\n\t\tscan(CtRole.DECLARED_MODULE_REF, compilationUnit.getDeclaredModuleReference());\n\t\tscan(CtRole.DECLARED_TYPE_REF, compilationUnit.getDeclaredTypeReferences());\n\t\texit(compilationUnit);\n\t}\n\n\t@Override\n\tpublic void visitCtPackageDeclaration(CtPackageDeclaration packageDeclaration) {\n\t\tenter(packageDeclaration);\n\t\tscan(CtRole.COMMENT, packageDeclaration.getComments());\n\t\tscan(CtRole.ANNOTATION, packageDeclaration.getAnnotations());\n\t\tscan(CtRole.PACKAGE_REF, packageDeclaration.getReference());\n\t\texit(packageDeclaration);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeMemberWildcardImportReference(CtTypeMemberWildcardImportReference wildcardReference) {\n\t\tenter(wildcardReference);\n\t\tscan(CtRole.TYPE_REF, wildcardReference.getTypeReference());\n\t\texit(wildcardReference);\n\t}\n}\n\n"
    }, {
      "name" : "reflect/visitor/CtAbstractVisitor.java",
      "weight" : 344.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\n\nimport java.lang.annotation.Annotation;\n\n/** Provides an empty implementation of CtVIsitor.\n *  See {@link CtScanner} for a much more powerful implementation of CtVisitor.\n */\npublic abstract class CtAbstractVisitor implements CtVisitor {\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotation(\n\t\t\tCtAnnotation<A> annotation) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCodeSnippetExpression(\n\t\t\tCtCodeSnippetExpression<T> expression) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtCodeSnippetStatement(CtCodeSnippetStatement statement) {\n\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotationType(\n\t\t\tCtAnnotationType<A> annotationType) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtAnonymousExecutable(CtAnonymousExecutable anonymousExec) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayRead(CtArrayRead<T> arrayRead) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayWrite(CtArrayWrite<T> arrayWrite) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayTypeReference(CtArrayTypeReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAssert(CtAssert<T> asserted) {\n\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtAssignment(\n\t\t\tCtAssignment<T, A> assignement) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> operator) {\n\n\t}\n\n\t@Override\n\tpublic <R> void visitCtBlock(CtBlock<R> block) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtBreak(CtBreak breakStatement) {\n\n\t}\n\n\t@Override\n\tpublic <S> void visitCtCase(CtCase<S> caseStatement) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtCatch(CtCatch catchBlock) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameter(CtTypeParameter typeParameter) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConditional(CtConditional<T> conditional) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructor(CtConstructor<T> c) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtContinue(CtContinue continueStatement) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtDo(CtDo doLoop) {\n\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(\n\t\t\tCtExecutableReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtField(CtField<T> f) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtEnumValue(CtEnumValue<T> enumValue) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtFor(CtFor forLoop) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtForEach(CtForEach foreach) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtIf(CtIf ifElement) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInvocation(CtInvocation<T> invocation) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLiteral(CtLiteral<T> literal) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLocalVariableReference(\n\t\t\tCtLocalVariableReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtMethod(CtMethod<T> m) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtNewArray(CtNewArray<T> newArray) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructorCall(CtConstructorCall<T> ctConstructorCall) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtNewClass(CtNewClass<T> newClass) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLambda(CtLambda<T> lambda) {\n\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(\n\t\t\tCtExecutableReferenceExpression<T, E> expression) {\n\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtOperatorAssignment(CtOperatorAssignment<T, A> assignment) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtPackage(CtPackage ctPackage) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtPackageReference(CtPackageReference reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtParameter(CtParameter<T> parameter) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtParameterReference(CtParameterReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <R> void visitCtReturn(CtReturn<R> returnStatement) {\n\n\t}\n\n\t@Override\n\tpublic <R> void visitCtStatementList(CtStatementList statements) {\n\n\t}\n\n\t@Override\n\tpublic <S> void visitCtSwitch(CtSwitch<S> switchStatement) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtSynchronized(CtSynchronized synchro) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtThrow(CtThrow throwStatement) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtTry(CtTry tryBlock) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtTryWithResource(CtTryWithResource tryWithResource) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameterReference(CtTypeParameterReference ref) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference wildcardReference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeAccess(CtTypeAccess<T> typeAccess) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableRead(CtVariableRead<T> variableRead) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableWrite(CtVariableWrite<T> variableWrite) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtWhile(CtWhile whileLoop) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationFieldAccess(CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtThisAccess(CtThisAccess<T> thisAccess) {\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariableReference(CtCatchVariableReference<T> reference) {\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnboundVariableReference(CtUnboundVariableReference<T> reference) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {\n\n\t}\n\n\t@Override\n\tpublic <T> void visitCtSuperAccess(CtSuperAccess<T> f) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtComment(CtComment comment) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDoc(CtJavaDoc javadoc) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtJavaDocTag(CtJavaDocTag docTag) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtImport(CtImport ctImport) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtModule(CtModule module) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtModuleReference(CtModuleReference moduleReference) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtPackageExport(CtPackageExport moduleExport) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtModuleRequirement(CtModuleRequirement moduleRequirement) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtProvidedService(CtProvidedService moduleProvidedService) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtUsedService(CtUsedService usedService) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtCompilationUnit(CtCompilationUnit compilationUnit) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtPackageDeclaration(CtPackageDeclaration packageDeclaration) {\n\n\t}\n\n\t@Override\n\tpublic void visitCtTypeMemberWildcardImportReference(CtTypeMemberWildcardImportReference wildcardReference) {\n\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/DefaultTokenWriter.java",
      "weight" : 75.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.code.CtComment;\n\n/**\n * Implementation of {@link TokenWriter}, which writes all tokens to {@link PrinterHelper}\n */\npublic class DefaultTokenWriter implements TokenWriter {\n\n\tprivate final PrinterHelper printerHelper;\n\n\tpublic DefaultTokenWriter(PrinterHelper printerHelper) {\n\t\tthis.printerHelper = printerHelper;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeOperator(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeSeparator(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeLiteral(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeKeyword(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeIdentifier(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeCodeSnippet(String token) {\n\t\tprinterHelper.write(token);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeComment(CtComment comment) {\n\t\tCommentHelper.printComment(printerHelper, comment);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter writeln() {\n\t\tprinterHelper.writeln();\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter incTab() {\n\t\tprinterHelper.incTab();\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic DefaultTokenWriter decTab() {\n\t\tprinterHelper.decTab();\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic void reset() {\n\t\tprinterHelper.reset();\n\t}\n\n\t@Override\n\tpublic TokenWriter writeSpace() {\n\t\tprinterHelper.writeSpace();\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic PrinterHelper getPrinterHelper() {\n\t\treturn printerHelper;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn printerHelper.toString();\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtFunction.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * Abstraction for functions in the Spoon realm.\n * It is used in the query stack, for example by {@link CtQueryable#map(CtFunction)}\n * It is compatible with Java 8 lambdas, hence enable to write one-liner queries with lambdas.\n *\n * @param <T> the type of the input to the function\n * @param <R> the type of the result of the function\n */\npublic interface CtFunction<T, R> {\n\t/** Implement this method to transform the input typed by T into an object of type R */\n\tR apply(T input);\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtQueryImpl.java",
      "weight" : 441.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.filter.CtScannerFunction;\nimport spoon.support.util.RtHelper;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * The facade of {@link CtQuery} which represents a query bound to the {@link CtElement},\n * which is the constant input of this query.\n * It is used by {@link CtElement} implementations of {@link CtQueryable}.\n */\npublic class CtQueryImpl implements CtQuery {\n\n\t/**\n\t * All the constant inputs of this query.\n\t */\n\tprivate List<Object> inputs;\n\n\tprivate OutputFunctionWrapper outputStep = new OutputFunctionWrapper();\n\tprivate AbstractStep lastStep = outputStep;\n\tprivate AbstractStep firstStep = lastStep;\n\n\tprivate boolean terminated = false;\n\n\tpublic CtQueryImpl(Object... input) {\n\t\tsetInput(input);\n\t}\n\n\t/**\n\t * @return list of elements which will be used as input of the query\n\t */\n\tpublic List<Object> getInputs() {\n\t\treturn inputs == null ? Collections.emptyList() : inputs;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic CtQueryImpl setInput(Object... input) {\n\t\tif (inputs != null) {\n\t\t\tinputs.clear();\n\t\t}\n\t\treturn addInput(input);\n\t}\n\n\t/**\n\t * adds list of elements which will be used as input of the query too\n\t * @param input\n\t * @return this to support fluent API\n\t */\n\tpublic CtQueryImpl addInput(Object... input) {\n\t\tif (this.inputs == null) {\n\t\t\tthis.inputs = new ArrayList<>();\n\t\t}\n\t\tif (input != null) {\n\t\t\tCollections.addAll(this.inputs, input);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic CtQueryImpl addInput(Iterable<?> input) {\n\t\tif (this.inputs == null) {\n\t\t\tthis.inputs = new ArrayList<>();\n\t\t}\n\t\tif (input != null) {\n\t\t\tfor (Object in : input) {\n\t\t\t\tthis.inputs.add(in);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic <R> void forEach(CtConsumer<R> consumer) {\n\t\toutputStep.setNext(consumer);\n\t\tfor (Object input : inputs) {\n\t\t\tfirstStep.accept(input);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R> List<R> list() {\n\t\treturn (List<R>) list(Object.class);\n\t}\n\n\t@Override\n\tpublic <R> List<R> list(final Class<R> itemClass) {\n\t\tfinal List<R> list = new ArrayList<>();\n\t\tforEach(new CtConsumer<R>() {\n\t\t\t@Override\n\t\t\tpublic void accept(R out) {\n\t\t\t\tif (out != null && itemClass.isAssignableFrom(out.getClass())) {\n\t\t\t\t\tlist.add(out);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn list;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R> R first() {\n\t\treturn (R) first(Object.class);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R> R first(final Class<R> itemClass) {\n\t\tfinal Object[] result = new Object[1];\n\t\toutputStep.setNext(new CtConsumer<R>() {\n\t\t\t@Override\n\t\t\tpublic void accept(R out) {\n\t\t\t\tif (out != null && itemClass.isAssignableFrom(out.getClass())) {\n\t\t\t\t\tresult[0] = out;\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfor (Object input : inputs) {\n\t\t\tfirstStep.accept(input);\n\t\t\tif (isTerminated()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (R) result[0];\n\t}\n\n\tprivate boolean logging = false;\n\tprivate QueryFailurePolicy failurePolicy = QueryFailurePolicy.FAIL;\n\n\t@Override\n\tpublic <I> CtQueryImpl map(CtConsumableFunction<I> code) {\n\t\taddStep(new LazyFunctionWrapper(code));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic <I, R> CtQueryImpl map(CtFunction<I, R> function) {\n\t\taddStep(new FunctionWrapper(function));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic <R extends CtElement> CtQueryImpl filterChildren(Filter<R> filter) {\n\t\tmap(new CtScannerFunction());\n\t\tif (filter != null) {\n\t\t\tselect(filter);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic <R extends CtElement> CtQueryImpl select(final Filter<R> filter) {\n\t\tCtFunction fnc = new CtFunction<R, Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean apply(R input) {\n\t\t\t\treturn filter.matches(input);\n\t\t\t}\n\t\t};\n\t\tFunctionWrapper fw = new FunctionWrapper(fnc);\n\t\t//set the expected type by real filter and not by helper wrapper above\n\t\tfw.onCallbackSet(fnc.getClass().getName(), \"apply\", filter.getClass(), \"matches\", 1, 0);\n\t\taddStep(fw);\n\t\tstepFailurePolicy(QueryFailurePolicy.IGNORE);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean isTerminated() {\n\t\treturn terminated;\n\t}\n\t@Override\n\tpublic void terminate() {\n\t\tterminated = true;\n\t}\n\n\t/**\n\t * Evaluates this query, ignoring bound input - if any\n\t *\n\t * @param input represents the input element of the first mapping function of this query\n\t * @param outputConsumer method accept of the outputConsumer is called for each element produced by last mapping function of this query\n\t */\n\tpublic <I, R> void evaluate(I input, CtConsumer<R> outputConsumer) {\n\t\toutputStep.setNext(outputConsumer);\n\t\tfirstStep.accept(input);\n\t}\n\n\t@Override\n\tpublic CtQueryImpl name(String name) {\n\t\tlastStep.setName(name);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic CtQueryImpl failurePolicy(QueryFailurePolicy policy) {\n\t\tfailurePolicy = policy;\n\t\treturn this;\n\t}\n\n\tpublic CtQueryImpl stepFailurePolicy(QueryFailurePolicy policy) {\n\t\tlastStep.setLocalFailurePolicy(policy);\n\t\treturn this;\n\t}\n\t/**\n\t * Enable/disable logging for this query\n\t *\n\t * Note: it is not possible to enable logging of all queries globally by Launcher.LOGGER.isDebugEnabled()\n\t * because it causes StackOverflow.\n\t * Reason: Query chains are used internally during writing of log messages too. So it would write logs for ever...\n\t */\n\tpublic CtQueryImpl logging(boolean logging) {\n\t\tthis.logging = logging;\n\t\treturn this;\n\t}\n\n\tprotected void handleListenerSetQuery(Object target) {\n\t\tif (target instanceof CtQueryAware) {\n\t\t\t((CtQueryAware) target).setQuery(this);\n\t\t}\n\t}\n\n\tprivate void addStep(AbstractStep step) {\n\t\tstep.nextStep = outputStep;\n\t\tlastStep.nextStep = step;\n\t\tlastStep = step;\n\t\tif (firstStep == outputStep) {\n\t\t\tfirstStep = step;\n\t\t}\n\t\tstep.setName(String.valueOf(getStepIndex(step) + 1));\n\t}\n\n\tprivate int getStepIndex(AbstractStep step) {\n\t\tint idx = 0;\n\t\tAbstractStep s = firstStep;\n\t\twhile (s != outputStep) {\n\t\t\tif (s == step) {\n\t\t\t\treturn idx;\n\t\t\t}\n\t\t\ts = (AbstractStep) s.nextStep;\n\t\t\tidx++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate boolean isLogging() {\n\t\treturn logging;\n\t}\n\n\tprivate void log(AbstractStep step, String message, Object... parameters) {\n\t\tif (isLogging() && Launcher.LOGGER.isInfoEnabled()) {\n\t\t\tLauncher.LOGGER.info(getStepDescription(step, message, parameters));\n\t\t}\n\t}\n\n\tprivate String getStepDescription(AbstractStep step, String message, Object... parameters) {\n\t\tStringBuilder sb = new StringBuilder(\"Step \");\n\t\tsb.append(step.getName()).append(\") \");\n\t\tsb.append(message);\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tsb.append(\"\\nParameter \").append(i + 1).append(\") \");\n\t\t\tif (parameters[i] != null) {\n\t\t\t\tsb.append(parameters[i].getClass().getSimpleName());\n\t\t\t\tsb.append(\": \");\n\t\t\t}\n\t\t\tsb.append(parameters[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Holds optional name and local QueryFailurePolicy of each step\n\t */\n\tprivate abstract class AbstractStep implements CtConsumer<Object> {\n\t\tString name;\n\t\tQueryFailurePolicy localFailurePolicy = null;\n\t\tCtConsumer<Object> nextStep;\n\t\tClass<?> expectedClass;\n\t\tString cceStacktraceClass;\n\t\tString cceStacktraceMethodName;\n\n\t\t@Override\n\t\tpublic final void accept(Object input) {\n\t\t\tif (input == null || isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isAcceptableType(input) == false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tObject result;\n\t\t\ttry {\n\t\t\t\tresult = _accept(input);\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tonClassCastException(e, input);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result == null || isTerminated()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thandleResult(result, input);\n\t\t}\n\n\t\tprotected abstract Object _accept(Object input);\n\n\t\tprotected void handleResult(Object result, Object input) {\n\t\t}\n\n\t\t/**\n\t\t * @return name of this Step - for debugging purposes\n\t\t */\n\t\tprivate String getName() {\n\t\t\treturn name;\n\t\t}\n\t\t/**\n\t\t * @param name of the step - for debugging purposes\n\t\t */\n\t\tprivate void setName(String name) {\n\t\t\tthis.name = name;\n\t\t}\n\t\t/**\n\t\t * @return true if this step should throw {@link ClassCastException} in case of\n\t\t * step input type incompatibility\n\t\t */\n\t\tprivate boolean isFailOnCCE() {\n\t\t\tif (localFailurePolicy != null) {\n\t\t\t\treturn localFailurePolicy  == QueryFailurePolicy.FAIL;\n\t\t\t} else {\n\t\t\t\treturn failurePolicy == QueryFailurePolicy.FAIL;\n\t\t\t}\n\t\t}\n\n\t\tprivate void setLocalFailurePolicy(QueryFailurePolicy localFailurePolicy) {\n\t\t\tthis.localFailurePolicy = localFailurePolicy;\n\t\t}\n\n\t\t/**\n\t\t * check whether `input` can be used to call a function.\n\t\t * @param input the to be checked value\n\t\t * @return true if it can be used or if we do not know that yet\n\t\t */\n\t\tprotected boolean isAcceptableType(Object input) {\n\t\t\tif (isFailOnCCE()) {\n\t\t\t\t//do not check type if it has to fail on cce\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (expectedClass != null && expectedClass.isAssignableFrom(input.getClass()) == false) {\n\t\t\t\tif (isLogging()) {\n\t\t\t\t\tlog(this, input.getClass().getName() + \" cannot be cast to \" + expectedClass.getName(), input);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Sets up type checking following the type of input parameter of callback method\n\t\t * @param stackClass - name of class of method in the stacktrace, if ClassCastException is thrown on the input parameter of lambda expression\n\t\t * @param stackMethodName - name of method in the stacktrace, if ClassCastException is thrown on the input parameter of lambda expression\n\t\t * @param callbackClass - the class of callback method\n\t\t * @param callbackMethod - the name of callback method\n\t\t * @param nrOfParams - total number of input parameters of callback method\n\t\t * @param idxOfInputParam - index of input parameter, whose type has to be checked\n\t\t */\n\t\tprotected void onCallbackSet(String stackClass, String stackMethodName, Class<?> callbackClass, String callbackMethod, int nrOfParams, int idxOfInputParam) {\n\t\t\tthis.cceStacktraceClass = stackClass;\n\t\t\tthis.cceStacktraceMethodName = stackMethodName;\n\t\t\tif (callbackClass.getName().contains(\"$$Lambda$\")) {\n\t\t\t\t//lambda expressions does not provide runtime information about type of input parameter\n\t\t\t\t//clear it now. We can detect input type from first ClassCastException\n\t\t\t\tthis.expectedClass = null;\n\t\t\t} else {\n\t\t\t\tMethod method = RtHelper.getMethod(callbackClass, callbackMethod, nrOfParams);\n\t\t\t\tif (method == null) {\n\t\t\t\t\tthrow new SpoonException(\"The method \" + callbackMethod + \" with one parameter was not found on the class \" + callbackClass.getName());\n\t\t\t\t}\n\t\t\t\tthis.expectedClass = method.getParameterTypes()[idxOfInputParam];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Is used to log that invocation was not processed\n\t\t * @param e - the CCE caught during last call of callback\n\t\t * @param input - the value sent as input to last call of callback\n\t\t */\n\t\tprotected void onClassCastException(ClassCastException e, Object input) {\n\t\t\tif (isFailOnCCE() || expectedClass != null) {\n\t\t\t\t//expected class is known so it was checked before the call, so the CCE must be thrown by something else. Report it directly as it is. It is bug in client's code\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif (indexOfCallerInStack < 0) {\n\t\t\t\t//this is an exotic JVM, where we cannot detect type of parameter of Lambda expression\n\t\t\t\t//Silently ignore this CCE, which was may be expected or may be problem in client's code.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//we can detect whether CCE was thrown in client's code (unexpected - must be rethrown) or Query engine (expected - has to be ignored)\n\t\t\tStackTraceElement[] stackEles = e.getStackTrace();\n\t\t\tif (stackEles.length == 0) {\n\t\t\t\t/*\n\t\t\t\t * The java runtime detected that this ClassCastException is thrown often and recompiled code to use faster pre-alocated exception,\n\t\t\t\t * which doesn't provide stacktrace.\n\t\t\t\t * So exceptions, which doesn't provide stacktrace can be ignored too, because they were already ignored before many times.\n\t\t\t\t *\n\t\t\t\t * See http://www.oracle.com/technetwork/java/javase/relnotes-139183.html#vm\n\t\t\t\t *---------------------------------------------------------------------------------------------------------------\n\t\t\t\t * The compiler in the server VM now provides correct stack backtraces for all \"cold\" built-in exceptions.\n\t\t\t\t * For performance purposes, when such an exception is thrown a few times, the method may be recompiled.\n\t\t\t\t * After recompilation, the compiler may choose a faster tactic using preallocated exceptions that do not provide a stack trace.\n\t\t\t\t * To disable completely the use of preallocated exceptions, use this new flag: -XX:-OmitStackTraceInFastThrow.\n\t\t\t\t *---------------------------------------------------------------------------------------------------------------\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tStackTraceElement stackEle = stackEles[indexOfCallerInStack];\n\t\t\tif (stackEle.getMethodName().equals(cceStacktraceMethodName) && stackEle.getClassName().equals(cceStacktraceClass)) {\n\t\t\t\t/*\n\t\t\t\t * the CCE exception was thrown in the expected method - OK, it can be ignored\n\t\t\t\t * Detect type of parameter of Lambda expression from the CCE message and store it in expectedClass\n\t\t\t\t * so we can check expected type before next call and to avoid slow throwing of ClassCastException\n\t\t\t\t */\n\t\t\t\texpectedClass = detectTargetClassFromCCE(e, input);\n\t\t\t\tif (expectedClass == null) {\n\t\t\t\t\t/*\n\t\t\t\t\t * It wasn't able to detect expected class from the CCE.\n\t\t\t\t\t * OK, so we cannot optimize next call and we have to let JVM to throw next CCE, but it is only performance problem. Not functional.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tlog(this, e.getMessage(), input);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//Do not ignore this exception in client's code. It is not expected. It cannot be ignored.\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t/**\n\t * Wrapper around terminal {@link CtConsumer}, which accepts output of this query\n\t */\n\tprivate class OutputFunctionWrapper extends AbstractStep {\n\t\tOutputFunctionWrapper() {\n\t\t\tlocalFailurePolicy = QueryFailurePolicy.IGNORE;\n\t\t}\n\t\t@Override\n\t\tprotected Object _accept(Object element) {\n\t\t\tnextStep.accept(element);\n\t\t\treturn null;\n\t\t}\n\n\t\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t\t<R> void setNext(CtConsumer<R> out) {\n\t\t\t//we are preparing new query execution.\n\t\t\treset();\n\t\t\tnextStep = (CtConsumer) out;\n\t\t\thandleListenerSetQuery(nextStep);\n\t\t\tonCallbackSet(this.getClass().getName(), \"_accept\", nextStep.getClass(), \"accept\", 1, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Called before query is evaluated again\n\t */\n\tprotected void reset() {\n\t\tterminated = false;\n\t}\n\n\tprivate class LazyFunctionWrapper extends AbstractStep {\n\t\tprivate final CtConsumableFunction<Object> fnc;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tLazyFunctionWrapper(CtConsumableFunction<?> fnc) {\n\t\t\tthis.fnc = (CtConsumableFunction<Object>) fnc;\n\t\t\thandleListenerSetQuery(this.fnc);\n\t\t\tonCallbackSet(this.getClass().getName(), \"_accept\", fnc.getClass(), \"apply\", 2, 0);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object _accept(Object input) {\n\t\t\tfnc.apply(input, nextStep);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * a step which calls Function. Implements contract of {@link CtQuery#map(CtFunction)}\n\t */\n\tprivate class FunctionWrapper extends AbstractStep {\n\t\tprivate final CtFunction<Object, Object> fnc;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tFunctionWrapper(CtFunction<?, ?> code) {\n\t\t\tfnc = (CtFunction<Object, Object>) code;\n\t\t\thandleListenerSetQuery(fnc);\n\t\t\tonCallbackSet(this.getClass().getName(), \"_accept\", fnc.getClass(), \"apply\", 1, 0);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object _accept(Object input) {\n\t\t\treturn fnc.apply(input);\n\t\t}\n\n\t\t@Override\n\t\tprotected void handleResult(Object result, Object input) {\n\t\t\tif (result instanceof Boolean) {\n\t\t\t\t//the code is a predicate. send the input to output if result is true\n\t\t\t\tif ((Boolean) result) {\n\t\t\t\t\tnextStep.accept(input);\n\t\t\t\t} else {\n\t\t\t\t\tlog(this, \"Skipped element, because CtFunction#accept(input) returned false\", input);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result instanceof Iterable) {\n\t\t\t\t//send each item of Iterable to the next step\n\t\t\t\tfor (Object out : (Iterable<Object>) result) {\n\t\t\t\t\tnextStep.accept(out);\n\t\t\t\t\tif (isTerminated()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result.getClass().isArray()) {\n\t\t\t\t//send each item of Array to the next step\n\t\t\t\tfor (int i = 0; i < Array.getLength(result); i++) {\n\t\t\t\t\tnextStep.accept(Array.get(result, i));\n\t\t\t\t\tif (isTerminated()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnextStep.accept(result);\n\t\t}\n\t}\n\n\tprivate static final String JDK9_BASE_PREFIX = \"java.base/\";\n\n\t//Pre jdk11 ClassCastException message parsing\n\tprivate static final Pattern cceMessagePattern = Pattern.compile(\"(\\\\S+) cannot be cast to (\\\\S+)\");\n\n\t//In some implementation of jdk11 the message for ClassCastException is slightly different\n\tprivate static final Pattern cceMessagePattern2 = Pattern.compile(\"class (\\\\S+) cannot be cast to class (\\\\S+)(.*)\");\n\n\tprivate static final int indexOfCallerInStack = getIndexOfCallerInStackOfLambda();\n\t/**\n\t * JVM implementations reports exception in call of lambda in different way.\n\t * A) the to be called lambda expression whose input parameters are invalid is on top of stack trace\n\t * B) the to be called lambda expression whose input parameters are invalid is NOT in stack trace at all\n\t *\n\t * This method detects actual behavior of JVM, so the code, which decides whether ClassCastException is expected (part of filtering process)\n\t * or unexpected - thrown by clients wrong code works on all JVM implementations\n\t */\n\tprivate static int getIndexOfCallerInStackOfLambda() {\n\t\tCtConsumer<CtType<?>> f = (CtType<?> t) -> { };\n\t\tCtConsumer<Object> unchecked = (CtConsumer) f;\n\t\tObject obj = new Integer(1);\n\t\ttry {\n\t\t\tunchecked.accept(obj);\n\t\t\tthrow new SpoonException(\"The lambda expression with input type CtType must throw ClassCastException when input type is Integer. Basic CtQuery contract is violated by JVM!\");\n\t\t} catch (ClassCastException e) {\n\t\t\tStackTraceElement[] stack = e.getStackTrace();\n\t\t\tfor (int i = 0; i < stack.length; i++) {\n\t\t\t\tif (\"getIndexOfCallerInStackOfLambda\".equals(stack[i].getMethodName())) {\n\t\t\t\t\t//check whether we can detect type of lambda input parameter from CCE\n\t\t\t\t\tClass<?> detectedClass = detectTargetClassFromCCE(e, obj);\n\t\t\t\t\tif (detectedClass == null || CtType.class.equals(detectedClass) == false) {\n\t\t\t\t\t\t//we cannot detect type of lambda input parameter from ClassCastException on this JVM implementation\n\t\t\t\t\t\t//mark it by negative index, so the query engine will fall back to eating of all CCEs and slow implementation\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new SpoonException(\"Spoon cannot detect index of caller of lambda expression in stack trace.\", e);\n\t\t}\n\t}\n\n\tprivate static Class<?> processCCE(String objectClassName, String expectedClassName, Object input) {\n\t\tif (objectClassName.startsWith(JDK9_BASE_PREFIX)) {\n\t\t\tobjectClassName = objectClassName.substring(JDK9_BASE_PREFIX.length());\n\t\t}\n\t\tif (objectClassName.equals(input.getClass().getName())) {\n\t\t\ttry {\n\t\t\t\treturn Class.forName(expectedClassName);\n\t\t\t} catch (ClassNotFoundException e1) {\n\t\t\t\t/*\n\t\t\t\t * It wasn't able to load the expected class from the CCE.\n\t\t\t\t * OK, so we cannot optimize next call and we have to let JVM to throw next CCE, but it is only performance problem. Not functional.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static Class<?> detectTargetClassFromCCE(ClassCastException e, Object input) {\n\t\t//detect expected class from CCE message, because we have to quickly and silently ignore elements of other types\n\t\tString message = e.getMessage();\n\t\tif (message != null) {\n\t\t\tMatcher m = cceMessagePattern.matcher(message);\n\t\t\tif (m.matches()) {\n\t\t\t\treturn processCCE(m.group(1), m.group(2), input);\n\t\t\t} else {\n\t\t\t\tMatcher m2 = cceMessagePattern2.matcher(message);\n\t\t\t\tif (m2.matches()) {\n\t\t\t\t\treturn processCCE(m2.group(1), m2.group(2), input);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtConsumer.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * The functional interface used to receive objects.\n * It is used for example to receive results of the query in {@link CtQuery#forEach(CtConsumer)}\n *\n * @param <T> - the type of accepted elements\n */\npublic interface CtConsumer<T> {\n\t/** Implement this method to do something with object \"t\" passed as parameter */\n\tvoid accept(T t);\n}\n"
    }, {
      "name" : "reflect/visitor/chain/QueryFailurePolicy.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * Use in {@link CtQuery#failurePolicy(QueryFailurePolicy)} to define how to handle failure\n */\npublic enum QueryFailurePolicy {\n\t/**Throws ClassCastException when output type of previous step cannot be assigned to input type of next step*/\n\tFAIL,\n\t/**when output type of previous step cannot be assigned to input type of next step then such output is ignored*/\n\tIGNORE\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtQuery.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.Filter;\n\nimport java.util.List;\n\n/**\n * <p>CtQuery represents a query, which can be used to traverse a spoon model and collect\n * children elements in several ways.</p>\n *\n * <p>Creation: A query is created either from a {@link CtElement}, or it can be defined first from {@link Factory#createQuery()} and bound to root elements\n * afterwards using {@link CtQuery#setInput(Object...)}.</p>\n *\n * <p>Chaining: In a query several steps can be chained, by chaining calls to map functions. The non-null outputs of one step\n * are given as input to the next step. An iterable or array output is considered as a set of different inputs for the next step.</p>\n *\n * <p>Evaluation: A CtQuery is lazily evaluated once {@link CtQuery#list()} or {@link CtQuery#forEach(CtConsumer)} are called.</p>\n *\n */\npublic interface CtQuery extends CtQueryable {\n\n\t/**\n\t * Recursively scans all children elements of an input element.\n\t * The matched child element for which (filter.matches(element)==true) are sent to the next query step.\n\t * Essentially the same as {@link CtElement#getElements(Filter)} but more powerful, because it\n\t * can be chained with other subsequent queries.\n\t *\n\t * Note: the input element (the root of the query, `this` if you're in {@link CtElement}) is also checked and may thus be also sent to the next step.\n\t * The elements which throw {@link ClassCastException} during {@link Filter#matches(CtElement)}\n\t * are considered as **not matching**, ie. are excluded.\n\t *\n\t * @param filter used to filter scanned children elements of the AST tree.\n\t * \tIf null then all children elements pass to next step.\n\t * @return this to support fluent API\n\t */\n\t@Override\n\t<R extends CtElement> CtQuery filterChildren(Filter<R> filter);\n\n\t/**\n\t * The matched element for which (filter.matches(element)==true) is sent to the next query step.\n\t *\n\t * The elements which throw {@link ClassCastException} during {@link Filter#matches(CtElement)}\n\t * are considered as **not matching**, ie. are excluded.\n\t *\n\t * @param filter used to detect if input element can pass to next query step\n\t * @return this to support fluent API\n\t */\n\t<R extends CtElement> CtQuery select(Filter<R> filter);\n\n\t/**\n\t * Query elements based on a function, the behavior depends on the return type of the function.\n\t * <table summary=\"\">\n\t * <tr><td>Return type of `function`</td><td>Behavior</td></tr>\n\t * <tr><td>{@link Boolean}</td><td>Select elements if the returned value of `function` is true (as for {@link Filter}).</td></tr>\n\t * <tr><td>? extends {@link Object}</td><td>Send the returned value of `function` to the next step</td></tr>\n\t * <tr><td>{@link Iterable}</td><td>Send each item of the collection to the next step</td></tr>\n\t * <tr><td>{@link Object}[]</td><td>Send each item of the array to the next step</td></tr>\n\t * </table><br>\n\t *\n\t * @param function a Function with one parameter of type I returning a value of type R\n\t * @return this to support fluent API\n\t */\n\t@Override\n\t<I, R> CtQuery map(CtFunction<I, R> function);\n\n\t/**\n\t * Sets (binds) the input of the query.\n\t * If the query is created by {@link CtElement#map} or {@link CtElement#filterChildren(Filter)},\n\t * then the query is already bound to this element.\n\t * A new call of {@link CtQuery#setInput(Object...)} is always possible, it resets the current binding and sets the new one.\n\t *\n\t * @param input\n\t * @return this to support fluent API\n\t */\n\t<T extends CtQuery> T setInput(Object... input);\n\n\t/**\n\t * Actually evaluates the query and for each produced output element of the last step,\n\t * calls `consumer.accept(outputElement)`.\n\t *\n\t * This avoids to create useless intermediate lists.\n\t *\n     * @param consumer The consumer which accepts the results of the query\n\t */\n\t<R> void forEach(CtConsumer<R> consumer);\n\n\t/**\n\t * Actually evaluates the query and returns all the elements produced in the last step.<br>\n\t * Note: The type R of the list is not checked by the query. So use the type, which matches the results of your query,\n\t * otherwise the ClassCastException will be thrown when reading the list.\n\t * @return the list of elements collected by the query.\n\t * @see #forEach(CtConsumer) for an efficient way of manipulating the elements without creating an intermediate list.\n\t */\n\t<R> List<R> list();\n\n\t/**\n\t * Same as {@link CtQuery#list()}, but with static typing on the return type\n\t * and the final filtering, which matches only results, which are assignable from that return type.\n\t *\n\t * @return the list of elements collected by the query.\n\t */\n\t<R> List<R> list(Class<R> itemClass);\n\n\t/**\n\t * Actually evaluates the query and returns first elements produced in the last step.<br>\n\t * After the first element is found, the query evaluation is terminated.\n\t *\n\t * Note: The return type R is not checked by the query. So use the type, which matches the results of your query,\n\t * otherwise the ClassCastException will be thrown.\n\t * @return the first element found by the query.\n\t */\n\t<R> R first();\n\n\t/**\n\t * Same as {@link CtQuery#first()}, but with static typing on the return type\n\t * and the final filtering, which matches only the first result, which is assignable from that return type.\n\t *\n\t * @return the list of elements collected by the query.\n\t */\n\t<R> R first(Class<R> itemClass);\n\n\t/**\n\t * Defines whether this query will throw {@link ClassCastException}\n\t * when the output of the previous step cannot be cast to type of input of next step.\n\t * The default value is {@link QueryFailurePolicy#FAIL}, which means than exception is thrown when there is a mismatch<br>\n\t *\n\t * Note: The {@link CtQueryable#filterChildren(Filter)} step never throws {@link ClassCastException}\n\t *\n\t * @param policy the policy\n\t * @return this to support fluent API\n\t */\n\tCtQuery failurePolicy(QueryFailurePolicy policy);\n\n\t/**\n\t * Sets the name of current query, to identify the current step during debugging of a query\n\t * @param name\n\t * @return this to support fluent API\n\t */\n\tCtQuery name(String name);\n\n\t/**\n\t * Same as {@link CtQuery#map(CtFunction)}, but the returned object is not handled\n\t * by java's return statement, but by a call to {@link CtConsumer#accept(Object)}, this\n\t * allows efficient and easy to write chained processing, see {@link CtConsumableFunction}.\n\t *\n\t * @param queryStep\n\t * @return this to support fluent API\n\t */\n\t@Override\n\t<I> CtQuery map(CtConsumableFunction<I> queryStep);\n\n\t/**\n\t * Terminates the evaluation of this query.\n\t * The query still returns all results collected before termination.\n\t * This method should not throw an exception.\n\t */\n\tvoid terminate();\n\n\t/**\n\t * @return true if the evaluation has been terminated.\n\t */\n\tboolean isTerminated();\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtScannerListener.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\n/**\n * Responsible for performing an action when a scanner enters/exits a node while scanning the AST.\n */\npublic interface CtScannerListener {\n\t/**\n\t * Called before the scanner enters an element\n\t *\n\t * @param element the element about to be scanned.\n\t * @return a {@link ScanningMode} that drives how the scanner processes this element and its children.\n\t * For instance, returning {@link ScanningMode#SKIP_ALL} causes that element and all children to be skipped and {@link #exit(CtElement)} are be NOT called for that element.\n\t */\n\tdefault ScanningMode enter(CtElement element) {\n\t\treturn ScanningMode.NORMAL;\n\t}\n\n\t/**\n\t * Called before the scanner enters an element\n\t *\n\t * @param role the {@link CtRole}, which `element` has in its parent. It is null for the first scanned element\n\t * @param element the element about to be scanned.\n\t * @return a {@link ScanningMode} that drives how the scanner processes this element and its children.\n\t * For instance, returning {@link ScanningMode#SKIP_ALL} causes that element and all children to be skipped and {@link #exit(CtElement)} are be NOT called for that element.\n\t */\n\tdefault ScanningMode enter(CtRole role, CtElement element) {\n\t\treturn enter(element);\n\t}\n\n\t/**\n\t * This method is called after the element and all its children have been visited.\n\t * This method is NOT called if an exception is thrown in {@link #enter(CtElement)} or during the scanning of the element or any of its children element.\n\t * This method is NOT called for an element for which {@link #enter(CtElement)} returned {@link ScanningMode#SKIP_ALL}.\n\t *\n\t * @param element the element that has just been scanned.\n\t */\n\tdefault void exit(CtElement element) {\n\t}\n\t/**\n\t * This method is called after the element and all its children have been visited.\n\t * This method is NOT called if an exception is thrown in {@link #enter(CtElement)} or during the scanning of the element or any of its children element.\n\t * This method is NOT called for an element for which {@link #enter(CtElement)} returned {@link ScanningMode#SKIP_ALL}.\n\t *\n\t * @param role the {@link CtRole}, which `element` has in its parent. It is null for the first scanned element\n\t * @param element the element that has just been scanned.\n\t */\n\tdefault void exit(CtRole role, CtElement element) {\n\t\texit(element);\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtQueryable.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * Represents an object on which one can make queries.\n * It is implemented\n * <ol>\n * <li> by {@link CtElement} to allow creation of a new query on\n * children of an element.\n * <li> by {@link CtQuery} to allow reusable queries and chaining query steps.\n * </ol>\n *\n * The main methods are documented in CtQuery\n */\npublic interface CtQueryable {\n\n\t/**\n\t * @see CtQuery#filterChildren(Filter)\n\t */\n\t<R extends CtElement> CtQuery filterChildren(Filter<R> filter);\n\n\t/**\n\t * @see CtQuery#map(CtFunction)\n\t */\n\t<I, R> CtQuery map(CtFunction<I, R> function);\n\n\t/**\n\t * @see CtQuery#map(CtConsumableFunction)\n\t */\n\t<I> CtQuery map(CtConsumableFunction<I> queryStep);\n\n}\n"
    }, {
      "name" : "reflect/visitor/chain/ScanningMode.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * Defines how a {@link CtScannerListener} drives the scanning of {@link spoon.reflect.visitor.EarlyTerminatingScanner}\n */\npublic enum ScanningMode {\n\t/**\n\t * Continue with scanning in a normal way, the current element and all children are visited.\n\t */\n\tNORMAL(true, true),\n\t/**\n\t * Skip the current element and skip all its children.\n\t */\n\tSKIP_ALL(false, false),\n\t/**\n\t * Visit current element but skips all its children.\n\t */\n\tSKIP_CHILDREN(true, false);\n\n\tpublic final boolean visitElement;\n\tpublic final boolean visitChildren;\n\n\tScanningMode(boolean visitElement, boolean visitChildren) {\n\t\tthis.visitElement = visitElement;\n\t\tthis.visitChildren = visitChildren;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtConsumableFunction.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * Represents a function, as {@link CtFunction}. However, the main difference is that\n * while a {@link CtFunction} returns something with a standard Java return keyword,\n * a {@link CtConsumableFunction} returns something by passing the returned object\n * as parameter to the given outpuConsumer#accept. This enables to write efficient and concise code in certain situations.\n * It also enables one to emulate several returns, by simply calling several times accept, while not paying\n * the code or performance price of creating a list or an iterable object.\n *\n * It is typically used as parameter of {@link CtQueryable#map(CtConsumableFunction)}, can be written as one-liners\n * with Java8 lambdas:.`cls.map((CtClass&lt;?&gt; c, CtConsumer&lt;Object&gt; out)-&gt;out.accept(c.getParent()))`\n *\n * @param <T> the type of the input to the function\n */\npublic interface CtConsumableFunction<T> {\n\t/**\n\t * Evaluates the function on the given input.\n\t * @param input the input of the function\n\t * @param outputConsumer the consumer which accepts the results of this function.\n\t */\n\tvoid apply(T input, CtConsumer<Object> outputConsumer);\n}\n"
    }, {
      "name" : "reflect/visitor/chain/CtQueryAware.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor.chain;\n\n/**\n * Expert-only capability interface so as to write advanced {@link CtFunction} and {@link spoon.reflect.visitor.Filter}\n * that need to access the state of the top-level {@link CtQuery} instance\n * containing the function to be evaluated.\n *\n * Not meant to be implemented directly, only in conjunction with\n * {@link CtConsumableFunction}, {@link CtFunction} or {@link spoon.reflect.visitor.Filter}.\n */\npublic interface CtQueryAware {\n\t/**\n\t * This method is called when the filter/function is added as a step to a {@link CtQuery} by the query engine ({@link CtQueryImpl}).\n\t * @param query an instance registering this function/filter.\n\t */\n\tvoid setQuery(CtQuery query);\n}\n"
    }, {
      "name" : "reflect/visitor/MinimalImportScanner.java",
      "weight" : 73.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * A scanner dedicated to import only the necessary packages, @see spoon.test.variable.AccessFullyQualifiedTest\n *\n */\npublic class MinimalImportScanner extends ImportScannerImpl implements ImportScanner {\n\t/**\n\t * This method use @link{ImportScannerImpl#isTypeInCollision} to import a ref only if there is a collision\n\t * @param ref: the type we are testing, it can be a CtTypeReference, a CtFieldReference or a CtExecutableReference\n\t *\n\t * @return true if the ref should be imported.\n\t */\n\tprivate boolean shouldTypeBeImported(CtReference ref) {\n\t\t// we import the targetType by default to simplify and avoid conclict in inner classes\n\t\tif (ref.equals(targetType)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isTypeInCollision(ref, true);\n\t}\n\n\t@Override\n\tprotected boolean addClassImport(CtTypeReference<?> ref) {\n\t\tboolean shouldTypeBeImported = this.shouldTypeBeImported(ref);\n\n\t\tif (shouldTypeBeImported) {\n\t\t\treturn super.addClassImport(ref);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean addFieldImport(CtFieldReference ref) {\n\t\tif (ref.getDeclaringType() != null) {\n\t\t\tif (isImportedInClassImports(ref.getDeclaringType())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tboolean shouldTypeBeImported = this.shouldTypeBeImported(ref);\n\n\t\tif (shouldTypeBeImported) {\n\t\t\tif (this.fieldImports.containsKey(ref.getSimpleName())) {\n\t\t\t\treturn isImportedInFieldImports(ref);\n\t\t\t}\n\n\t\t\tfieldImports.put(ref.getSimpleName(), ref);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean addMethodImport(CtExecutableReference ref) {\n\t\tif (ref.getDeclaringType() != null) {\n\t\t\tif (isImportedInClassImports(ref.getDeclaringType())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tboolean shouldTypeBeImported = this.shouldTypeBeImported(ref);\n\n\t\tif (shouldTypeBeImported) {\n\t\t\tif (this.methodImports.containsKey(ref.getSimpleName())) {\n\t\t\t\treturn isImportedInMethodImports(ref);\n\t\t\t}\n\n\t\t\tmethodImports.put(ref.getSimpleName(), ref);\n\n\t\t\tif (ref.getDeclaringType() != null) {\n\t\t\t\tif (ref.getDeclaringType().getPackage() != null) {\n\t\t\t\t\tif (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n\t\t\t\t\t\taddClassImport(ref.getDeclaringType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tprotected boolean isImportedInClassImports(CtTypeReference<?> ref) {\n\t\tif (!(ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n\t\t\tCtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n\t\t\treturn exist.getQualifiedName().equals(ref.getQualifiedName());\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "reflect/visitor/LexicalScope.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.support.Experimental;\n\nimport java.util.function.Function;\n\n/**\n * Represents that a lexical scope in the language\n *\n * Note that scopes are changing after variable declaration. For example:\n *\n * void draw() {\n *  //scope1\n * int a;\n * //scope2\n * int b;\n * //scope3\n * }\n *\n * See https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping\n */\n@Experimental\npublic interface LexicalScope {\n\t/** adds an element to the scope */\n\tLexicalScope addNamedElement(CtNamedElement element);\n\n\t/**\n\t * @return the {@link CtElement} which represents the current scope\n\t */\n\tCtElement getScopeElement();\n\n\t/**\n\t * @param name to be searched simple name\n\t * @param fnc is called for each named element with same simple name, which is defined in this or parent {@link LexicalScope}.\n\t * \tFunction `fnc` is called as long as there are some matching elements and `fnc` returns null.\n\t * \tIf `fnc` returns not null value then searching is stopped and that value is a returned\n\t * @return the value returned by `fnc` or null\n\t */\n\t<T> T forEachElementByName(String name, Function<? super CtNamedElement, T> fnc);\n\n}\n"
    }, {
      "name" : "reflect/visitor/PrettyPrinter.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.visitor;\n\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This interface defines the pretty printers.\n */\npublic interface PrettyPrinter {\n\n\t/**\n\t * Prints the package info.\n\t * It always resets the printing context at the beginning of this process.\n\t */\n\tString printPackageInfo(CtPackage pack);\n\n\t/**\n\t * Prints the module info.\n\t * It always resets the printing context at the beginning of this process.\n\t */\n\tString printModuleInfo(CtModule module);\n\n\t/**\n\t * Gets the contents of the compilation unit.\n\t */\n\tString getResult();\n\n\t/**\n\t * Calculates the resulting source file for a list of types. The source\n\t * compilation unit is required for calculating the line numbers mapping.\n\t * It always resets the printing context at the beginning of this process.\n\t */\n\tvoid calculate(CtCompilationUnit sourceCompilationUnit, List<CtType<?>> types);\n\n\t/**\n\t * Gets the line number mapping between the generated code and the original\n\t * code.\n\t */\n\tMap<Integer, Integer> getLineNumberMapping();\n}\n"
    }, {
      "name" : "reflect/eval/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines some evaluators for the Spoon meta-model.</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.reflect.eval;\n"
    }, {
      "name" : "reflect/eval/PartialEvaluator.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect.eval;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * This interface defines a simple partial evaluator on the Spoon Java model. It\n * recursively transforms a meta-model element by partially evaluating it and\n * simplifies it when possible (i.e. when constant values are involved).\n */\npublic interface PartialEvaluator {\n\n\t/**\n\t * Partially evaluates an element and all its sub-elements.\n\t *\n\t * @param <R>\n\t * \t\tthe partially evaluated element type\n\t * @param element\n\t * \t\tthe element to be partially evaluated\n\t * @return the result of the partial evaluation\n\t */\n\t<R extends CtElement> R evaluate(R element);\n}\n"
    }, {
      "name" : "reflect/ModelElementContainerDefaultCapacities.java",
      "weight" : 28.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.reflect;\n\nimport java.util.ArrayList;\n\n/**\n * Recommended default capacities for containers (primarily {@link ArrayList})\n * of AST model elements. There are mostly only several linked elements, so\n * using default capacity (10, in case of {@code ArrayList}) is a memory waste.\n */\npublic final class ModelElementContainerDefaultCapacities {\n\t/*\n\t * Author Roman Leventov\n     *\n     * Some element types were analyzed through JDK 7 sources,\n     * others chosen for my feelings only.\n     *\n     * For those I have precise averages, I choose to take a ceiling of that\n     * average as the default capacity. This choice is biased towards performing\n     * less container resizes, rather deadly memory efficiency. Not sure this is\n     * the right choice, for most Spoon use-cases, but anyway this is better\n     * than ArrayList's default of 10.\n     */\n\n\t// JDK 7 average is 1.063 (methods), 1.207 (constructors)\n\tpublic static final int PARAMETERS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// > 1 very rarely\n\tpublic static final int CASTS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// JDK 7 average is 2.150\n\tpublic static final int BLOCK_STATEMENTS_CONTAINER_DEFAULT_CAPACITY = 3;\n\n\t// JDK 7 average is 1.652\n\tpublic static final int CASE_STATEMENTS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// > 1 very rarely\n\tpublic static final int FOR_INIT_STATEMENTS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// > 1 very rarely\n\tpublic static final int FOR_UPDATE_STATEMENTS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// 1-2\n\tpublic static final int CATCH_VARIABLE_MULTI_TYPES_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// > 1 very rarely\n\tpublic static final int NEW_ARRAY_DEFAULT_EXPRESSIONS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// JDK 7 average is 6.487\n\tpublic static final int SWITCH_CASES_CONTAINER_DEFAULT_CAPACITY = 7;\n\n\t// 1-2\n\tpublic static final int CATCH_CASES_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// > 1 very rarely\n\tpublic static final int RESOURCES_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// > 1 very rarely\n\tpublic static final int COMPILATION_UNIT_DECLARED_TYPES_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// TODO detect best default\n\tpublic static final int COMPILATION_UNIT_IMPORTS_CONTAINER_DEFAULT_CAPACITY = 10;\n\n\t// > 1 very rarely\n\tpublic static final int ANONYMOUS_EXECUTABLES_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// In JDK 7 only 1, if any\n\tpublic static final int CONSTRUCTOR_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\t// 1-2\n\tpublic static final int ANNOTATIONS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// 1-2\n\tpublic static final int COMMENT_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// 1-2\n\tpublic static final int METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// 1-2\n\tpublic static final int TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// 1-2\n\tpublic static final int CONSTRUCTOR_CALL_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY = 2;\n\n\t// JDK 7 average 3.861\n\tpublic static final int FIELDS_CONTAINER_DEFAULT_CAPACITY = 4;\n\n\t// > 1 very rarely\n\tpublic static final int TYPE_BOUNDS_CONTAINER_DEFAULT_CAPACITY = 1;\n\n\tprivate ModelElementContainerDefaultCapacities() {\n\t}\n}\n"
    } ]
  }, {
    "name" : "support",
    "children" : [ {
      "name" : "support/DefaultCoreFactory.java",
      "weight" : 998.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\n\nimport java.lang.annotation.Annotation;\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.CompoundSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.experimental.CtUnresolvedImport;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.factory.CoreFactory;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.SubFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.support.reflect.code.CtAnnotationFieldAccessImpl;\nimport spoon.support.reflect.code.CtArrayReadImpl;\nimport spoon.support.reflect.code.CtArrayWriteImpl;\nimport spoon.support.reflect.code.CtAssertImpl;\nimport spoon.support.reflect.code.CtAssignmentImpl;\nimport spoon.support.reflect.code.CtBinaryOperatorImpl;\nimport spoon.support.reflect.code.CtBlockImpl;\nimport spoon.support.reflect.code.CtBreakImpl;\nimport spoon.support.reflect.code.CtCaseImpl;\nimport spoon.support.reflect.code.CtCatchImpl;\nimport spoon.support.reflect.code.CtCatchVariableImpl;\nimport spoon.support.reflect.code.CtCodeSnippetExpressionImpl;\nimport spoon.support.reflect.code.CtCodeSnippetStatementImpl;\nimport spoon.support.reflect.code.CtCommentImpl;\nimport spoon.support.reflect.code.CtConditionalImpl;\nimport spoon.support.reflect.code.CtConstructorCallImpl;\nimport spoon.support.reflect.code.CtContinueImpl;\nimport spoon.support.reflect.code.CtDoImpl;\nimport spoon.support.reflect.code.CtExecutableReferenceExpressionImpl;\nimport spoon.support.reflect.code.CtFieldReadImpl;\nimport spoon.support.reflect.code.CtFieldWriteImpl;\nimport spoon.support.reflect.code.CtForEachImpl;\nimport spoon.support.reflect.code.CtForImpl;\nimport spoon.support.reflect.code.CtIfImpl;\nimport spoon.support.reflect.code.CtInvocationImpl;\nimport spoon.support.reflect.code.CtJavaDocImpl;\nimport spoon.support.reflect.code.CtJavaDocTagImpl;\nimport spoon.support.reflect.code.CtLambdaImpl;\nimport spoon.support.reflect.code.CtLiteralImpl;\nimport spoon.support.reflect.code.CtLocalVariableImpl;\nimport spoon.support.reflect.code.CtNewArrayImpl;\nimport spoon.support.reflect.code.CtNewClassImpl;\nimport spoon.support.reflect.code.CtOperatorAssignmentImpl;\nimport spoon.support.reflect.code.CtReturnImpl;\nimport spoon.support.reflect.code.CtStatementListImpl;\nimport spoon.support.reflect.code.CtSuperAccessImpl;\nimport spoon.support.reflect.code.CtSwitchImpl;\nimport spoon.support.reflect.code.CtSynchronizedImpl;\nimport spoon.support.reflect.code.CtThisAccessImpl;\nimport spoon.support.reflect.code.CtThrowImpl;\nimport spoon.support.reflect.code.CtTryImpl;\nimport spoon.support.reflect.code.CtTryWithResourceImpl;\nimport spoon.support.reflect.code.CtTypeAccessImpl;\nimport spoon.support.reflect.code.CtUnaryOperatorImpl;\nimport spoon.support.reflect.code.CtVariableReadImpl;\nimport spoon.support.reflect.code.CtVariableWriteImpl;\nimport spoon.support.reflect.code.CtWhileImpl;\nimport spoon.support.reflect.cu.CompilationUnitImpl;\nimport spoon.support.reflect.cu.position.BodyHolderSourcePositionImpl;\nimport spoon.support.reflect.cu.position.CompoundSourcePositionImpl;\nimport spoon.support.reflect.cu.position.DeclarationSourcePositionImpl;\nimport spoon.support.reflect.cu.position.SourcePositionImpl;\nimport spoon.support.reflect.declaration.CtAnnotationImpl;\nimport spoon.support.reflect.declaration.CtAnnotationMethodImpl;\nimport spoon.support.reflect.declaration.CtAnnotationTypeImpl;\nimport spoon.support.reflect.declaration.CtAnonymousExecutableImpl;\nimport spoon.support.reflect.declaration.CtClassImpl;\nimport spoon.support.reflect.declaration.CtConstructorImpl;\nimport spoon.support.reflect.declaration.CtEnumImpl;\nimport spoon.support.reflect.declaration.CtEnumValueImpl;\nimport spoon.support.reflect.declaration.CtFieldImpl;\nimport spoon.support.reflect.declaration.CtImportImpl;\nimport spoon.support.reflect.declaration.CtInterfaceImpl;\nimport spoon.support.reflect.declaration.CtMethodImpl;\nimport spoon.support.reflect.declaration.CtModuleImpl;\nimport spoon.support.reflect.declaration.CtModuleRequirementImpl;\nimport spoon.support.reflect.declaration.CtPackageDeclarationImpl;\nimport spoon.support.reflect.declaration.CtPackageExportImpl;\nimport spoon.support.reflect.declaration.CtPackageImpl;\nimport spoon.support.reflect.declaration.CtParameterImpl;\nimport spoon.support.reflect.declaration.CtProvidedServiceImpl;\nimport spoon.support.reflect.declaration.CtTypeParameterImpl;\nimport spoon.support.reflect.declaration.CtUsedServiceImpl;\nimport spoon.support.reflect.declaration.InvisibleArrayConstructorImpl;\nimport spoon.support.reflect.reference.CtArrayTypeReferenceImpl;\nimport spoon.support.reflect.reference.CtCatchVariableReferenceImpl;\nimport spoon.support.reflect.reference.CtExecutableReferenceImpl;\nimport spoon.support.reflect.reference.CtFieldReferenceImpl;\nimport spoon.support.reflect.reference.CtIntersectionTypeReferenceImpl;\nimport spoon.support.reflect.reference.CtLocalVariableReferenceImpl;\nimport spoon.support.reflect.reference.CtModuleReferenceImpl;\nimport spoon.support.reflect.reference.CtPackageReferenceImpl;\nimport spoon.support.reflect.reference.CtParameterReferenceImpl;\nimport spoon.support.reflect.reference.CtTypeParameterReferenceImpl;\nimport spoon.support.reflect.reference.CtTypeReferenceImpl;\nimport spoon.support.reflect.reference.CtUnboundVariableReferenceImpl;\nimport spoon.support.reflect.reference.CtWildcardReferenceImpl;\nimport spoon.support.reflect.reference.CtTypeMemberWildcardImportReferenceImpl;\nimport spoon.support.visitor.equals.CloneHelper;\n\n\n\n/**\n * This class implements a default core factory for Spoon's meta-model. This\n * implementation is done with regular Java classes (POJOs).\n */\npublic class DefaultCoreFactory extends SubFactory implements CoreFactory {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic DefaultCoreFactory() {\n\t\tsuper(null);\n\t}\n\n\t@Override\n\tpublic <T extends CtElement> T clone(T object) {\n\t\treturn CloneHelper.INSTANCE.clone(object);\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> CtAnnotation<A> createAnnotation() {\n\t\tCtAnnotation<A> e = new CtAnnotationImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T extends Annotation> CtAnnotationType<T> createAnnotationType() {\n\t\tCtAnnotationType<T> e = new CtAnnotationTypeImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\te.setParent(getMainFactory().Package().getRootPackage());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtAnonymousExecutable createAnonymousExecutable() {\n\t\tCtAnonymousExecutable e = new CtAnonymousExecutableImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtArrayRead<T> createArrayRead() {\n\t\tCtArrayRead<T> e = new CtArrayReadImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtArrayWrite<T> createArrayWrite() {\n\t\tCtArrayWrite<T> e = new CtArrayWriteImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtArrayTypeReference<T> createArrayTypeReference() {\n\t\tCtArrayTypeReference<T> e = new CtArrayTypeReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtAssert<T> createAssert() {\n\t\tCtAssert<T> e = new CtAssertImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T, A extends T> CtAssignment<T, A> createAssignment() {\n\t\tCtAssignment<T, A> e = new CtAssignmentImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtBinaryOperator<T> createBinaryOperator() {\n\t\tCtBinaryOperator<T> e = new CtBinaryOperatorImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <R> CtBlock<R> createBlock() {\n\t\tCtBlock<R> e = new CtBlockImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtBreak createBreak() {\n\t\tCtBreak e = new CtBreakImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <S> CtCase<S> createCase() {\n\t\tCtCase<S> e = new CtCaseImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtCatch createCatch() {\n\t\tCtCatch e = new CtCatchImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtClass<T> createClass() {\n\t\tCtClass<T> e = new CtClassImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\te.setParent(getMainFactory().Package().getRootPackage());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtTypeParameter createTypeParameter() {\n\t\tCtTypeParameter e = new CtTypeParameterImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtConditional<T> createConditional() {\n\t\tCtConditional<T> e = new CtConditionalImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtConstructor<T> createConstructor() {\n\t\tCtConstructor<T> e = new CtConstructorImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtConstructor<T> createInvisibleArrayConstructor() {\n\t\tCtConstructor<T> e = new InvisibleArrayConstructorImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtContinue createContinue() {\n\t\tCtContinue e = new CtContinueImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtDo createDo() {\n\t\tCtDo e = new CtDoImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> CtEnum<T> createEnum() {\n\t\tCtEnum<T> e = new CtEnumImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\te.setParent(getMainFactory().Package().getRootPackage());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtExecutableReference<T> createExecutableReference() {\n\t\tCtExecutableReference<T> e = new CtExecutableReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtField<T> createField() {\n\t\tCtField<T> e = new CtFieldImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtEnumValue<T> createEnumValue() {\n\t\tCtEnumValue<T> e = new CtEnumValueImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtFieldRead<T> createFieldRead() {\n\t\tCtFieldRead<T> e = new CtFieldReadImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtFieldWrite<T> createFieldWrite() {\n\t\tCtFieldWrite<T> e = new CtFieldWriteImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtAnnotationFieldAccess<T> createAnnotationFieldAccess() {\n\t\tCtAnnotationFieldAccess<T> e = new CtAnnotationFieldAccessImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtUnboundVariableReference<T> createUnboundVariableReference() {\n\t\tCtUnboundVariableReference e = new CtUnboundVariableReferenceImpl<T>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtFieldReference<T> createFieldReference() {\n\t\tCtFieldReference<T> e = new CtFieldReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtFor createFor() {\n\t\tCtFor e = new CtForImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtForEach createForEach() {\n\t\tCtForEach e = new CtForEachImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtIf createIf() {\n\t\tCtIf e = new CtIfImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtInterface<T> createInterface() {\n\t\tCtInterface<T> e = new CtInterfaceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\te.setParent(getMainFactory().Package().getRootPackage());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtInvocation<T> createInvocation() {\n\t\tCtInvocation<T> e = new CtInvocationImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtLiteral<T> createLiteral() {\n\t\tCtLiteral<T> e = new CtLiteralImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariable<T> createLocalVariable() {\n\t\tCtLocalVariable<T> e = new CtLocalVariableImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtLocalVariableReference<T> createLocalVariableReference() {\n\t\tCtLocalVariableReference<T> e = new CtLocalVariableReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariable<T> createCatchVariable() {\n\t\tCtCatchVariable<T> e = new CtCatchVariableImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtCatchVariableReference<T> createCatchVariableReference() {\n\t\tCtCatchVariableReference<T> e = new CtCatchVariableReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtMethod<T> createMethod() {\n\t\tCtMethod<T> e = new CtMethodImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtAnnotationMethod<T> createAnnotationMethod() {\n\t\tCtAnnotationMethod<T> e = new CtAnnotationMethodImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtNewArray<T> createNewArray() {\n\t\tCtNewArray<T> e = new CtNewArrayImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtConstructorCall<T> createConstructorCall() {\n\t\tCtConstructorCall<T> e = new CtConstructorCallImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtNewClass<T> createNewClass() {\n\t\tCtNewClass<T> e = new CtNewClassImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtLambda<T> createLambda() {\n\t\tCtLambda<T> e = new CtLambdaImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression() {\n\t\tCtExecutableReferenceExpression<T, E> e = new CtExecutableReferenceExpressionImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T, A extends T> CtOperatorAssignment<T, A> createOperatorAssignment() {\n\t\tCtOperatorAssignment<T, A> e = new CtOperatorAssignmentImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtPackage createPackage() {\n\t\tCtPackage e = new CtPackageImpl();\n\t\te.setFactory(getMainFactory());\n\t\te.setParent(getMainFactory().Package().getRootPackage());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtPackageReference createPackageReference() {\n\t\tCtPackageReference e = new CtPackageReferenceImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtParameter<T> createParameter() {\n\t\tCtParameter<T> e = new CtParameterImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtParameterReference<T> createParameterReference() {\n\t\tCtParameterReference<T> e = new CtParameterReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <R> CtReturn<R> createReturn() {\n\t\tCtReturn<R> e = new CtReturnImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <R> CtStatementList createStatementList() {\n\t\tCtStatementList e = new CtStatementListImpl<R>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <S> CtSwitch<S> createSwitch() {\n\t\tCtSwitch<S> e = new CtSwitchImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtSynchronized createSynchronized() {\n\t\tCtSynchronized e = new CtSynchronizedImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtThrow createThrow() {\n\t\tCtThrow e = new CtThrowImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtTry createTry() {\n\t\tCtTry e = new CtTryImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtTryWithResource createTryWithResource() {\n\t\tCtTryWithResource e = new CtTryWithResourceImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtTypeParameterReference createTypeParameterReference() {\n\t\tCtTypeParameterReference e = new CtTypeParameterReferenceImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtWildcardReference createWildcardReference() {\n\t\tCtWildcardReference e = new CtWildcardReferenceImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtIntersectionTypeReference<T> createIntersectionTypeReference() {\n\t\tCtIntersectionTypeReference<T> e = new CtIntersectionTypeReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtTypeReference<T> createTypeReference() {\n\t\tCtTypeReference<T> e = new CtTypeReferenceImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtTypeAccess<T> createTypeAccess() {\n\t\tCtTypeAccess<T> e = new CtTypeAccessImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtUnaryOperator<T> createUnaryOperator() {\n\t\tCtUnaryOperator<T> e = new CtUnaryOperatorImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtVariableRead<T> createVariableRead() {\n\t\tCtVariableRead<T> e = new CtVariableReadImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtVariableWrite<T> createVariableWrite() {\n\t\tCtVariableWrite<T> e = new CtVariableWriteImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtCodeSnippetExpression<T> createCodeSnippetExpression() {\n\t\tCtCodeSnippetExpression<T> e = new CtCodeSnippetExpressionImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtCodeSnippetStatement createCodeSnippetStatement() {\n\t\tCtCodeSnippetStatement e = new CtCodeSnippetStatementImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtComment createComment() {\n\t\tCtComment e = new CtCommentImpl();\n\t\te.setFactory(getMainFactory());\n\t\te.setCommentType(CtComment.CommentType.BLOCK);\n\t\te.setContent(\"\");\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtJavaDoc createJavaDoc() {\n\t\tCtJavaDoc e = new CtJavaDocImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtJavaDocTag createJavaDocTag() {\n\t\tCtJavaDocTag e = new CtJavaDocTagImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtWhile createWhile() {\n\t\tCtWhile e = new CtWhileImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtImport createImport() {\n\t\tCtImport e = new CtImportImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtImport createUnresolvedImport() {\n\t\tCtImport e = new CtUnresolvedImport();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtPackageDeclaration createPackageDeclaration() {\n\t\tCtPackageDeclaration e = new CtPackageDeclarationImpl();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic Factory getMainFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic void setMainFactory(Factory mainFactory) {\n\t\tthis.factory = mainFactory;\n\t}\n\n\t@Override\n\tpublic SourcePosition createSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int[] lineSeparatorPositions) {\n\t\treturn new SourcePositionImpl(compilationUnit, startSource, end, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic SourcePosition createPartialSourcePosition(CompilationUnit compilationUnit) {\n\t\treturn ((CompilationUnitImpl) compilationUnit).getOrCreatePartialSourcePosition();\n\t}\n\n\t@Override\n\tpublic CompoundSourcePosition createCompoundSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int declarationStart, int declarationEnd, int[] lineSeparatorPositions) {\n\t\treturn new CompoundSourcePositionImpl(compilationUnit, startSource, end, declarationStart, declarationEnd, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic DeclarationSourcePosition createDeclarationSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int[] lineSeparatorPositions) {\n\t\treturn new DeclarationSourcePositionImpl(compilationUnit, startSource, end, modifierStart, modifierEnd, declarationStart, declarationEnd, lineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic BodyHolderSourcePosition createBodyHolderSourcePosition(CompilationUnit compilationUnit, int startSource, int end, int modifierStart, int modifierEnd, int declarationStart, int declarationEnd, int bodyStart, int bodyEnd, int[] lineSeparatorPositions) {\n\t\treturn new BodyHolderSourcePositionImpl(compilationUnit,\n\t\t\t\tstartSource, end,\n\t\t\t\tmodifierStart, modifierEnd,\n\t\t\t\tdeclarationStart, declarationEnd,\n\t\t\t\tbodyStart, bodyEnd,\n\t\t\t\tlineSeparatorPositions);\n\t}\n\n\t@Override\n\tpublic CompilationUnit createCompilationUnit() {\n\t\tCompilationUnit cu = new CompilationUnitImpl();\n\t\tcu.setFactory(getMainFactory());\n\t\treturn cu;\n\t}\n\n\t@Override\n\tpublic <T> CtThisAccess<T> createThisAccess() {\n\t\tCtThisAccess<T> e = new CtThisAccessImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic <T> CtSuperAccess<T> createSuperAccess() {\n\t\tCtSuperAccess<T> e = new CtSuperAccessImpl<>();\n\t\te.setFactory(getMainFactory());\n\t\treturn e;\n\t}\n\n\t@Override\n\tpublic CtElement create(Class<? extends CtElement> klass) {\n\t\tif (klass.equals(spoon.reflect.code.CtAnnotationFieldAccess.class)) {\n\t\t\treturn createAnnotationFieldAccess();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtArrayRead.class)) {\n\t\t\treturn createArrayRead();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtArrayWrite.class)) {\n\t\t\treturn createArrayWrite();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtAssert.class)) {\n\t\t\treturn createAssert();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtAssignment.class)) {\n\t\t\treturn createAssignment();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtBinaryOperator.class)) {\n\t\t\treturn createBinaryOperator();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtBlock.class)) {\n\t\t\treturn createBlock();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtBreak.class)) {\n\t\t\treturn createBreak();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtCase.class)) {\n\t\t\treturn createCase();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtCatch.class)) {\n\t\t\treturn createCatch();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtCatchVariable.class)) {\n\t\t\treturn createCatchVariable();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtCodeSnippetExpression.class)) {\n\t\t\treturn createCodeSnippetExpression();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtCodeSnippetStatement.class)) {\n\t\t\treturn createCodeSnippetStatement();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtComment.class)) {\n\t\t\treturn createComment();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtJavaDoc.class)) {\n\t\t\treturn createJavaDoc();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtJavaDocTag.class)) {\n\t\t\treturn createJavaDocTag();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtConditional.class)) {\n\t\t\treturn createConditional();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtConstructorCall.class)) {\n\t\t\treturn createConstructorCall();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtContinue.class)) {\n\t\t\treturn createContinue();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtDo.class)) {\n\t\t\treturn createDo();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtExecutableReferenceExpression.class)) {\n\t\t\treturn createExecutableReferenceExpression();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtFieldRead.class)) {\n\t\t\treturn createFieldRead();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtFieldWrite.class)) {\n\t\t\treturn createFieldWrite();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtForEach.class)) {\n\t\t\treturn createForEach();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtFor.class)) {\n\t\t\treturn createFor();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtIf.class)) {\n\t\t\treturn createIf();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtInvocation.class)) {\n\t\t\treturn createInvocation();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtLambda.class)) {\n\t\t\treturn createLambda();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtLiteral.class)) {\n\t\t\treturn createLiteral();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtLocalVariable.class)) {\n\t\t\treturn createLocalVariable();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtNewArray.class)) {\n\t\t\treturn createNewArray();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtNewClass.class)) {\n\t\t\treturn createNewClass();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtOperatorAssignment.class)) {\n\t\t\treturn createOperatorAssignment();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtReturn.class)) {\n\t\t\treturn createReturn();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtStatementList.class)) {\n\t\t\treturn createStatementList();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtSuperAccess.class)) {\n\t\t\treturn createSuperAccess();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtSwitch.class)) {\n\t\t\treturn createSwitch();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtSynchronized.class)) {\n\t\t\treturn createSynchronized();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtThisAccess.class)) {\n\t\t\treturn createThisAccess();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtThrow.class)) {\n\t\t\treturn createThrow();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtTry.class)) {\n\t\t\treturn createTry();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtTryWithResource.class)) {\n\t\t\treturn createTryWithResource();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtTypeAccess.class)) {\n\t\t\treturn createTypeAccess();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtUnaryOperator.class)) {\n\t\t\treturn createUnaryOperator();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtVariableRead.class)) {\n\t\t\treturn createVariableRead();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtVariableWrite.class)) {\n\t\t\treturn createVariableWrite();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.code.CtWhile.class)) {\n\t\t\treturn createWhile();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtAnnotation.class)) {\n\t\t\treturn createAnnotation();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtAnnotationMethod.class)) {\n\t\t\treturn createAnnotationMethod();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtAnnotationType.class)) {\n\t\t\treturn createAnnotationType();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtAnonymousExecutable.class)) {\n\t\t\treturn createAnonymousExecutable();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtClass.class)) {\n\t\t\treturn createClass();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtConstructor.class)) {\n\t\t\treturn createConstructor();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtEnum.class)) {\n\t\t\treturn createEnum();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtEnumValue.class)) {\n\t\t\treturn createEnumValue();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtField.class)) {\n\t\t\treturn createField();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtInterface.class)) {\n\t\t\treturn createInterface();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtMethod.class)) {\n\t\t\treturn createMethod();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtPackage.class)) {\n\t\t\treturn createPackage();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtParameter.class)) {\n\t\t\treturn createParameter();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtTypeParameter.class)) {\n\t\t\treturn createTypeParameter();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtArrayTypeReference.class)) {\n\t\t\treturn createArrayTypeReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtCatchVariableReference.class)) {\n\t\t\treturn createCatchVariableReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtExecutableReference.class)) {\n\t\t\treturn createExecutableReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtFieldReference.class)) {\n\t\t\treturn createFieldReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtIntersectionTypeReference.class)) {\n\t\t\treturn createIntersectionTypeReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtLocalVariableReference.class)) {\n\t\t\treturn createLocalVariableReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtPackageReference.class)) {\n\t\t\treturn createPackageReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtParameterReference.class)) {\n\t\t\treturn createParameterReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtTypeParameterReference.class)) {\n\t\t\treturn createTypeParameterReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtTypeReference.class)) {\n\t\t\treturn createTypeReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtUnboundVariableReference.class)) {\n\t\t\treturn createUnboundVariableReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtWildcardReference.class)) {\n\t\t\treturn createWildcardReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtImport.class)) {\n\t\t\treturn createImport();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtModuleReference.class)) {\n\t\t\treturn createModuleReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.reference.CtTypeMemberWildcardImportReference.class)) {\n\t\t\treturn createTypeMemberWildcardImportReference();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtModule.class)) {\n\t\t\treturn createModule();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtModuleRequirement.class)) {\n\t\t\treturn createModuleRequirement();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtPackageExport.class)) {\n\t\t\treturn createPackageExport();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtProvidedService.class)) {\n\t\t\treturn createProvidedService();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtUsedService.class)) {\n\t\t\treturn createUsedService();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtCompilationUnit.class)) {\n\t\t\treturn createCompilationUnit();\n\t\t}\n\t\tif (klass.equals(spoon.reflect.declaration.CtPackageDeclaration.class)) {\n\t\t\treturn createPackageDeclaration();\n\t\t}\n\t\tthrow new IllegalArgumentException(\"not instantiable by CoreFactory(): \" + klass);\n\t}\n\n\t@Override\n\tpublic CtTypeMemberWildcardImportReference createTypeMemberWildcardImportReference() {\n\t\tCtTypeMemberWildcardImportReference result = new CtTypeMemberWildcardImportReferenceImpl();\n\t\tresult.setFactory(getMainFactory());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic CtModule createModule() {\n\t\tCtModule module = new CtModuleImpl();\n\t\tmodule.setFactory(getMainFactory());\n\t\tthis.getMainFactory().Module().getUnnamedModule().addModule(module);\n\t\treturn module;\n\t}\n\n\t@Override\n\tpublic CtModuleReference createModuleReference() {\n\t\tCtModuleReference moduleReference = new CtModuleReferenceImpl();\n\t\tmoduleReference.setFactory(getMainFactory());\n\t\treturn moduleReference;\n\t}\n\n\t@Override\n\tpublic CtModuleRequirement createModuleRequirement() {\n\t\tCtModuleRequirement moduleRequirement = new CtModuleRequirementImpl();\n\t\tmoduleRequirement.setFactory(getMainFactory());\n\t\treturn moduleRequirement;\n\t}\n\n\t@Override\n\tpublic CtPackageExport createPackageExport() {\n\t\tCtPackageExport moduleExport = new CtPackageExportImpl();\n\t\tmoduleExport.setFactory(getMainFactory());\n\t\treturn moduleExport;\n\t}\n\n\t@Override\n\tpublic CtProvidedService createProvidedService() {\n\t\tCtProvidedService moduleProvidedService = new CtProvidedServiceImpl();\n\t\tmoduleProvidedService.setFactory(getMainFactory());\n\t\treturn moduleProvidedService;\n\t}\n\n\t@Override\n\tpublic CtUsedService createUsedService() {\n\t\tCtUsedService ctUsedService = new CtUsedServiceImpl();\n\t\tctUsedService.setFactory(getMainFactory());\n\t\treturn ctUsedService;\n\t}\n}\n\n"
    }, {
      "name" : "support/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package contains some default implementations for commonly used processing tasks.</p>\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.support;\n"
    }, {
      "name" : "support/UnsettableProperty.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Tells that a metamodel property (ie a getter in metamodel interface) is unsettable because it does not make sense for a certain metamodel element.\n * This is used when the Java static type system cannot express this contract.\n * For instance, a catch variable cannot have a default expression.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD })\npublic @interface UnsettableProperty {\n}\n"
    }, {
      "name" : "support/StandardEnvironment.java",
      "weight" : 489.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\n\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.InvalidClassPathException;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.builder.EncodingProvider;\nimport spoon.processing.FileGenerator;\nimport spoon.processing.ProblemFixer;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.processing.ProcessorProperties;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.compiler.FileSystemFolder;\nimport spoon.support.compiler.SpoonProgress;\nimport spoon.support.modelobs.EmptyModelChangeListener;\nimport spoon.support.modelobs.FineModelChangeListener;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.function.Supplier;\n\n\n/**\n * This class implements a simple Spoon environment that reports messages in the\n * standard output stream (Java-compliant).\n */\npublic class StandardEnvironment implements Serializable, Environment {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static final int DEFAULT_CODE_COMPLIANCE_LEVEL = 8;\n\n\tprivate transient  FileGenerator<? extends CtElement> defaultFileGenerator;\n\n\tprivate int errorCount = 0;\n\n\ttransient ProcessingManager manager;\n\n\tprivate boolean processingStopped = false;\n\n\tprivate boolean autoImports = false;\n\n\tprivate int warningCount = 0;\n\n\tprivate String[] sourceClasspath = null;\n\n\tprivate boolean preserveLineNumbers = false;\n\n\tprivate boolean copyResources = true;\n\n\tprivate boolean enableComments = true;\n\n\tprivate transient  Logger logger = Launcher.LOGGER;\n\n\tprivate Level level = Level.OFF;\n\n\tprivate boolean shouldCompile = false;\n\n\tprivate boolean skipSelfChecks = false;\n\n\tprivate transient FineModelChangeListener modelChangeListener = new EmptyModelChangeListener();\n\n\tprivate transient Charset encoding = Charset.defaultCharset();\n\n\tprivate transient EncodingProvider encodingProvider;\n\n\tprivate int complianceLevel = DEFAULT_CODE_COMPLIANCE_LEVEL;\n\n\tprivate transient OutputDestinationHandler outputDestinationHandler = new DefaultOutputDestinationHandler(new File(Launcher.OUTPUTDIR), this);\n\n\tprivate OutputType outputType = OutputType.CLASSES;\n\n\tprivate Boolean noclasspath = null;\n\n\tprivate transient SpoonProgress spoonProgress = null;\n\n\tprivate CompressionType compressionType = CompressionType.GZIP;\n\n\tprivate boolean sniperMode = false;\n\n\tprivate boolean ignoreDuplicateDeclarations = false;\n\n\tprivate Supplier<PrettyPrinter> prettyPrinterCreator;\n\n\t/**\n\t * Creates a new environment with a <code>null</code> default file\n\t * generator.\n\t */\n\tpublic StandardEnvironment() {\n\t}\n\n\t@Override\n\tpublic void debugMessage(String message) {\n\t\tlogger.debug(message);\n\t}\n\n\t@Override\n\tpublic boolean isAutoImports() {\n\t\treturn autoImports;\n\t}\n\n\t@Override\n\tpublic void setAutoImports(boolean autoImports) {\n\t\tthis.autoImports = autoImports;\n\t\t// TODO: unexpected behaviour could occur, if we reset the autoimport AFTER the pretty printer is created...\n\t}\n\n\t@Override\n\tpublic FileGenerator<? extends CtElement> getDefaultFileGenerator() {\n\t\treturn defaultFileGenerator;\n\t}\n\n\t@Override\n\tpublic Level getLevel() {\n\t\treturn this.level;\n\t}\n\n\t@Override\n\tpublic void setLevel(String level) {\n\t\tthis.level = toLevel(level);\n\t\tlogger.setLevel(this.level);\n\t}\n\n\t@Override\n\tpublic boolean shouldCompile() {\n\t\treturn shouldCompile;\n\t}\n\n\t@Override\n\tpublic void setShouldCompile(boolean shouldCompile) {\n\t\tthis.shouldCompile = shouldCompile;\n\t}\n\n\t@Override\n\tpublic boolean checksAreSkipped() {\n\t\treturn skipSelfChecks;\n\t}\n\n\t@Override\n\tpublic void disableConsistencyChecks() {\n\t\tskipSelfChecks = true;\n\t}\n\n\tprivate Level toLevel(String level) {\n\t\tif (level == null || level.isEmpty()) {\n\t\t\tthrow new SpoonException(\"Wrong level given at Spoon.\");\n\t\t}\n\t\treturn Level.toLevel(level, Level.ALL);\n\t}\n\n\t@Override\n\tpublic ProcessingManager getManager() {\n\t\treturn manager;\n\t}\n\n\ttransient Map<String, ProcessorProperties> processorProperties = new TreeMap<>();\n\n\t@Override\n\tpublic ProcessorProperties getProcessorProperties(String processorName) {\n\t\tif (processorProperties.containsKey(processorName)) {\n\t\t\treturn processorProperties.get(processorName);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tells if the processing is stopped, generally because one of the\n\t * processors called {@link #setProcessingStopped(boolean)} after reporting\n\t * an error.\n\t */\n\t@Override\n\tpublic boolean isProcessingStopped() {\n\t\treturn processingStopped;\n\t}\n\n\tprivate void prefix(StringBuilder buffer, Level level) {\n\t\tif (level == Level.ERROR) {\n\t\t\tbuffer.append(\"error: \");\n\t\t\terrorCount++;\n\t\t} else if (level == Level.WARN) {\n\t\t\tbuffer.append(\"warning: \");\n\t\t\twarningCount++;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void report(Processor<?> processor, Level level, CtElement element, String message) {\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\tprefix(buffer, level);\n\n\t\t// Adding message\n\t\tbuffer.append(message);\n\n\t\t// Add sourceposition (javac format)\n\t\ttry {\n\t\t\tCtType<?> type = (element instanceof CtType) ? (CtType<?>) element : element.getParent(CtType.class);\n\t\t\tSourcePosition sp = element.getPosition();\n\n\t\t\tif (sp == null) {\n\t\t\t\tbuffer.append(\" (Unknown Source)\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(\" at \" + type.getQualifiedName() + \".\");\n\t\t\t\tCtExecutable<?> exe = (element instanceof CtExecutable) ? (CtExecutable<?>) element : element.getParent(CtExecutable.class);\n\t\t\t\tif (exe != null) {\n\t\t\t\t\tbuffer.append(exe.getSimpleName());\n\t\t\t\t}\n\t\t\t\tbuffer.append(\"(\" + sp.getFile().getName() + \":\" + sp.getLine() + \")\");\n\t\t\t}\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\tbuffer.append(\" (invalid parent)\");\n\t\t}\n\n\t\tprint(buffer.toString(), level);\n\t}\n\n\t@Override\n\tpublic void report(Processor<?> processor, Level level, CtElement element, String message, ProblemFixer<?>... fixes) {\n\t\treport(processor, level, element, message);\n\t}\n\n\t@Override\n\tpublic void report(Processor<?> processor, Level level, String message) {\n\t\tStringBuilder buffer = new StringBuilder();\n\n\t\tprefix(buffer, level);\n\t\t// Adding message\n\t\tbuffer.append(message);\n\t\tprint(buffer.toString(), level);\n\t}\n\n\tprivate void print(String message, Level level) {\n\t\tif (level.equals(Level.ERROR)) {\n\t\t\tlogger.error(message);\n\t\t} else if (level.equals(Level.WARN)) {\n\t\t\tlogger.warn(message);\n\t\t} else if (level.equals(Level.DEBUG)) {\n\t\t\tlogger.debug(message);\n\t\t} else if (level.equals(Level.INFO)) {\n\t\t\tlogger.info(message);\n\t\t}\n\t}\n\n\t/**\n\t * This method should be called to report the end of the processing.\n\t */\n\t@Override\n\tpublic void reportEnd() {\n\t\tlogger.info(\"end of processing: \");\n\t\tif (warningCount > 0) {\n\t\t\tlogger.info(warningCount + \" warning\");\n\t\t\tif (warningCount > 1) {\n\t\t\t\tlogger.info(\"s\");\n\t\t\t}\n\t\t\tif (errorCount > 0) {\n\t\t\t\tlogger.info(\", \");\n\t\t\t}\n\t\t}\n\t\tif (errorCount > 0) {\n\t\t\tlogger.info(errorCount + \" error\");\n\t\t\tif (errorCount > 1) {\n\t\t\t\tlogger.info(\"s\");\n\t\t\t}\n\t\t}\n\t\tif ((errorCount + warningCount) > 0) {\n\t\t\tlogger.info(\"\\n\");\n\t\t} else {\n\t\t\tlogger.info(\"no errors, no warnings\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void reportProgressMessage(String message) {\n\t\tlogger.info(message);\n\t}\n\n\tpublic void setDebug(boolean debug) {\n\t}\n\n\t@Override\n\tpublic void setDefaultFileGenerator(FileGenerator<? extends CtElement> defaultFileGenerator) {\n\t\tthis.defaultFileGenerator = defaultFileGenerator;\n\t}\n\n\t@Override\n\tpublic void setManager(ProcessingManager manager) {\n\t\tthis.manager = manager;\n\t}\n\n\t@Override\n\tpublic void setProcessingStopped(boolean processingStopped) {\n\t\tthis.processingStopped = processingStopped;\n\t}\n\n\tpublic void setVerbose(boolean verbose) {\n\t}\n\n\n\n\t@Override\n\tpublic int getComplianceLevel() {\n\t\treturn complianceLevel;\n\t}\n\n\t@Override\n\tpublic void setComplianceLevel(int level) {\n\t\tcomplianceLevel = level;\n\t}\n\n\t@Override\n\tpublic void setProcessorProperties(String processorName, ProcessorProperties prop) {\n\t\tprocessorProperties.put(processorName, prop);\n\t}\n\n\tboolean useTabulations = false;\n\n\t@Override\n\tpublic boolean isUsingTabulations() {\n\t\treturn useTabulations;\n\t}\n\n\t@Override\n\tpublic void useTabulations(boolean tabulation) {\n\t\tuseTabulations = tabulation;\n\t}\n\n\tint tabulationSize = 4;\n\n\t@Override\n\tpublic int getTabulationSize() {\n\t\treturn tabulationSize;\n\t}\n\n\t@Override\n\tpublic void setTabulationSize(int tabulationSize) {\n\t\tthis.tabulationSize = tabulationSize;\n\t}\n\n\tprivate transient  ClassLoader classloader;\n\t/*\n\t * cache class loader which loads classes from source class path\n\t * we must cache it to make all the loaded classes compatible\n\t * The cache is reset when setSourceClasspath(...) is called\n\t */\nprivate transient  ClassLoader inputClassloader;\n\n\t@Override\n\tpublic void setInputClassLoader(ClassLoader aClassLoader) {\n\t\tif (aClassLoader instanceof URLClassLoader) {\n\t\t\tfinal URL[] urls = ((URLClassLoader) aClassLoader).getURLs();\n\t\t\tif (urls != null && urls.length > 0) {\n\t\t\t\t// Check that the URLs are only file URLs\n\t\t\t\tboolean onlyFileURLs = true;\n\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\tif (!\"file\".equals(url.getProtocol())) {\n\t\t\t\t\t\tonlyFileURLs = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (onlyFileURLs) {\n\t\t\t\t\tList<String> classpath = new ArrayList<>();\n\t\t\t\t\tfor (URL url : urls) {\n\t\t\t\t\t\tclasspath.add(url.getPath());\n\t\t\t\t\t}\n\t\t\t\t\tsetSourceClasspath(classpath.toArray(new String[0]));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new SpoonException(\"Spoon does not support a URLClassLoader containing other resources than local file.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.classloader = aClassLoader;\n\t}\n\n\t@Override\n\tpublic ClassLoader getInputClassLoader() {\n\t\tif (classloader != null) {\n\t\t\treturn classloader;\n\t\t}\n\t\tif (inputClassloader == null) {\n\t\t\tinputClassloader = new URLClassLoader(urlClasspath(), Thread.currentThread().getContextClassLoader());\n\t\t}\n\t\treturn inputClassloader;\n\t}\n\n\t/**\n\t * Creates a URL class path from {@link Environment#getSourceClasspath()}\n\t */\n\tpublic URL[] urlClasspath() {\n\t\tString[] classpath = getSourceClasspath();\n\t\tint length = (classpath == null) ? 0 : classpath.length;\n\t\tURL[] urls = new URL[length];\n\t\tfor (int i = 0; i < length; i += 1) {\n\t\t\ttry {\n\t\t\t\turls[i] = new File(classpath[i]).toURI().toURL();\n\t\t\t} catch (MalformedURLException e) {\n\t\t\t\tthrow new IllegalStateException(\"Invalid classpath: \" + Arrays.toString(classpath), e);\n\t\t\t}\n\t\t}\n\t\treturn urls;\n\t}\n\n\t@Override\n\tpublic String[] getSourceClasspath() {\n\t\treturn sourceClasspath;\n\t}\n\n\t@Override\n\tpublic void setSourceClasspath(String[] sourceClasspath) {\n\t\tverifySourceClasspath(sourceClasspath);\n\t\tthis.sourceClasspath = sourceClasspath;\n\t\tthis.inputClassloader = null;\n\t}\n\n\tprivate void verifySourceClasspath(String[] sourceClasspath) throws InvalidClassPathException {\n\t\tfor (String classPathElem : sourceClasspath) {\n\t\t\t// preconditions\n\t\t\tFile classOrJarFolder = new File(classPathElem);\n\t\t\tif (!classOrJarFolder.exists()) {\n\t\t\t\tthrow new InvalidClassPathException(classPathElem + \" does not exist, it is not a valid folder\");\n\t\t\t}\n\n\t\t\tif (classOrJarFolder.isDirectory()) {\n\t\t\t\t// it should not contain a java file\n\t\t\t\tSpoonFolder tmp = new FileSystemFolder(classOrJarFolder);\n\t\t\t\tList<SpoonFile> javaFiles = tmp.getAllJavaFiles();\n\t\t\t\tif (!javaFiles.isEmpty()) {\n\t\t\t\t\tlogger.warn(\"You're trying to give source code in the classpath, this should be given to \" + \"addInputSource \" + javaFiles);\n\t\t\t\t}\n\t\t\t\tlogger.warn(\"You specified the directory \" + classOrJarFolder.getPath() + \" in source classpath, please note that only class files will be considered. Jars and subdirectories will be ignored.\");\n\t\t\t} else if (classOrJarFolder.getName().endsWith(\".class\")) {\n\t\t\t\tthrow new InvalidClassPathException(\".class files are not accepted in source classpath.\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getErrorCount() {\n\t\treturn errorCount;\n\t}\n\n\t@Override\n\tpublic int getWarningCount() {\n\t\treturn warningCount;\n\t}\n\n\t@Override\n\tpublic boolean isPreserveLineNumbers() {\n\t\treturn preserveLineNumbers;\n\t}\n\n\t@Override\n\tpublic void setPreserveLineNumbers(boolean preserveLineNumbers) {\n\t\tthis.preserveLineNumbers = preserveLineNumbers;\n\t}\n\n\t@Override\n\tpublic void setNoClasspath(boolean option) {\n\t\tnoclasspath = option;\n\t}\n\n\t@Override\n\tpublic boolean getNoClasspath() {\n\t\tif (this.noclasspath == null) {\n\t\t\tlogger.warn(\"Spoon is currently use with the default noClasspath option set as true. Read the documentation for more information: http://spoon.gforge.inria.fr/launcher.html#about-the-classpath\");\n\t\t\tthis.noclasspath = true;\n\t\t}\n\t\treturn noclasspath;\n\t}\n\n\t@Override\n\tpublic boolean isCopyResources() {\n\t\treturn copyResources;\n\t}\n\n\t@Override\n\tpublic void setCopyResources(boolean copyResources) {\n\t\tthis.copyResources = copyResources;\n\t}\n\n\t@Override\n\tpublic boolean isCommentsEnabled() {\n\t\treturn enableComments;\n\t}\n\n\t@Override\n\tpublic void setCommentEnabled(boolean commentEnabled) {\n\t\tthis.enableComments = commentEnabled;\n\t}\n\n\tprivate String binaryOutputDirectory = Launcher.SPOONED_CLASSES;\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(String s) {\n\t\tthis.binaryOutputDirectory = s;\n\n\t}\n\n\t@Override\n\tpublic String getBinaryOutputDirectory() {\n\t\treturn binaryOutputDirectory;\n\t}\n\n\t@Override\n\tpublic void setSourceOutputDirectory(File directory) {\n\t\tif (directory == null) {\n\t\t\tthrow new SpoonException(\"You must specify a directory.\");\n\t\t}\n\t\tif (directory.isFile()) {\n\t\t\tthrow new SpoonException(\"Output must be a directory\");\n\t\t}\n\n\t\ttry {\n\t\t\tthis.outputDestinationHandler = new DefaultOutputDestinationHandler(directory.getCanonicalFile(),\n\t\t\t\t\tthis);\n\t\t} catch (IOException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic File getSourceOutputDirectory() {\n\t\treturn this.outputDestinationHandler.getDefaultOutputDirectory();\n\t}\n\n\t@Override\n\tpublic void setOutputDestinationHandler(OutputDestinationHandler outputDestinationHandler) {\n\t\tthis.outputDestinationHandler = outputDestinationHandler;\n\t}\n\n\t@Override\n\tpublic OutputDestinationHandler getOutputDestinationHandler() {\n\t\treturn outputDestinationHandler;\n\t}\n\n\t@Override\n\tpublic FineModelChangeListener getModelChangeListener() {\n\t\treturn modelChangeListener;\n\t}\n\n\t@Override\n\tpublic void setModelChangeListener(FineModelChangeListener modelChangeListener) {\n\t\tthis.modelChangeListener = modelChangeListener;\n\t}\n\n\t@Override\n\tpublic Charset getEncoding() {\n\t\treturn this.encoding;\n\t}\n\n\t@Override\n\tpublic EncodingProvider getEncodingProvider() {\n\t\treturn encodingProvider;\n\t}\n\n\t@Override\n\tpublic void setEncoding(Charset encoding) {\n\t\tthis.encoding = encoding;\n\t}\n\n\t@Override\n\tpublic void setEncodingProvider(EncodingProvider encodingProvider) {\n\t\tthis.encodingProvider = encodingProvider;\n\t}\n\n\t@Override\n\tpublic void setOutputType(OutputType outputType) {\n\t\tthis.outputType = outputType;\n\t}\n\n\t@Override\n\tpublic OutputType getOutputType() {\n\t\treturn this.outputType;\n\t}\n\n\t@Override\n\tpublic SpoonProgress getSpoonProgress() {\n\t\treturn this.spoonProgress;\n\t}\n\n\t@Override\n\tpublic void setSpoonProgress(SpoonProgress spoonProgress) {\n\t\tthis.spoonProgress = spoonProgress;\n\t}\n\n\t@Override\n\tpublic CompressionType getCompressionType() {\n\t\treturn compressionType;\n\t}\n\n\t@Override\n\tpublic void setCompressionType(CompressionType serializationType) {\n\t\tthis.compressionType = serializationType;\n\t}\n\n\t@Override\n\tpublic PrettyPrinter createPrettyPrinter() {\n\t\tif (prettyPrinterCreator == null) {\n\t\t\t// DJPP is the default mode\n\t\t\t// fully backward compatible\n\t\t\treturn new DefaultJavaPrettyPrinter(this);\n\t\t}\n\t\treturn prettyPrinterCreator.get();\n\t}\n\n\t@Override\n\tpublic void setPrettyPrinterCreator(Supplier<PrettyPrinter> creator) {\n\t\tthis.prettyPrinterCreator = creator;\n\t}\n\n\t@Override\n\tpublic boolean isIgnoreDuplicateDeclarations() {\n\t\treturn ignoreDuplicateDeclarations;\n\t}\n\n\t@Override\n\tpublic void setIgnoreDuplicateDeclarations(boolean ignoreDuplicateDeclarations) {\n\t\tthis.ignoreDuplicateDeclarations = ignoreDuplicateDeclarations;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * This package provides support for the sniper mode: only the transformed part of classes is rewritten to disk. All the other code is kept as is (formatting, newlines) as the original code.\n *\n * Public class: {@link spoon.support.sniper.SniperJavaPrettyPrinter}, to use it:\n * <pre>\n *     \tlauncher.getEnvironment().setPrettyPrinterCreator(() -&gt; {\n * \t\t\treturn new SniperJavaPrettyPrinter(launcher.getEnvironment());}\n * \t\t);\n * </pre>\n * See https://github.com/INRIA/spoon/issues/1284\n */\npackage spoon.support.sniper;\n\n"
    }, {
      "name" : "support/sniper/internal/SourceFragment.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.support.Experimental;\n\n/**\n * Represents a part of source code.\n *\n * See https://github.com/INRIA/spoon/pull/2283\n */\n@Experimental\npublic interface SourceFragment  {\n\t/**\n\t * @return origin source code of whole fragment represented by this instance\n\t */\n\tString getSourceCode();\n}\n"
    }, {
      "name" : "support/sniper/internal/ElementSourceFragment.java",
      "weight" : 619.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.support.Experimental;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.cu.position.SourcePositionImpl;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\n/**\n * Represents a part of source code of an {@link CtElement}\n * It is connected into a tree of {@link ElementSourceFragment}s.\n * Use {@link SourcePositionHolder#getOriginalSourceFragment()} to get it.\n */\n@Experimental\npublic class ElementSourceFragment implements SourceFragment {\n\n\t/**\n\t * represents an {@link ElementSourceFragment}, which doesn't exist\n\t */\n\tpublic static final ElementSourceFragment NO_SOURCE_FRAGMENT = new ElementSourceFragment(null, null);\n\n\tprivate final SourcePositionHolder element;\n\tprivate final RoleHandler roleHandlerInParent;\n\tprivate ElementSourceFragment nextSibling;\n\tprivate ElementSourceFragment firstChild;\n\n\t/**\n\t * Creates a source fragment of {@link SourcePositionHolder}\n\t *\n\t * @param element target {@link SourcePositionHolder}\n\t * @param roleHandlerInParent The {@link RoleHandler}, which defines role of target `element` in it's parent\n\t */\n\tpublic ElementSourceFragment(SourcePositionHolder element, RoleHandler roleHandlerInParent) {\n\t\tthis.element = element;\n\t\tthis.roleHandlerInParent = roleHandlerInParent;\n\t}\n\n\t/**\n\t * @return offset of first character which belongs to this fragment\n\t */\n\tpublic int getStart() {\n\t\tif (firstChild != null) {\n\t\t\treturn Math.min(getSourcePosition().getSourceStart(), firstChild.getStart());\n\t\t}\n\t\treturn getSourcePosition().getSourceStart();\n\t}\n\n\t/**\n\t * @return offset of character after this fragment\n\t */\n\tpublic int getEnd() {\n\t\tif (firstChild != null) {\n\t\t\treturn Math.max(getSourcePosition().getSourceEnd() + 1, firstChild.getLastSibling().getEnd());\n\t\t}\n\t\treturn getSourcePosition().getSourceEnd() + 1;\n\t}\n\n\t/**\n\t * @return {@link SourcePosition} of this fragment\n\t */\n\tpublic SourcePosition getSourcePosition() {\n\t\treturn element.getPosition();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"|\" + getStart() + \", \" + getEnd() + \"|\" + getSourceCode() + \"|\";\n\t}\n\n\t/**\n\t * @return origin source code of this fragment\n\t */\n\t@Override\n\tpublic String getSourceCode() {\n\t\treturn getSourceCode(getStart(), getEnd());\n\t}\n\n\t/**\n\t * @param start start offset relative to compilation unit\n\t * @param end end offset (after last character) relative to compilation unit\n\t * @return source code of this Fragment between start/end offsets\n\t */\n\tpublic String getSourceCode(int start, int end) {\n\t\tString src = getOriginalSourceCode();\n\t\tif (src != null) {\n\t\t\treturn src.substring(start, end);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return true if position points to same compilation unit (source file) as this SourceFragment\n\t */\n\tprivate boolean isFromSameSource(SourcePosition position) {\n\t\treturn getSourcePosition().getCompilationUnit().equals(position.getCompilationUnit());\n\t}\n\n\t/**\n\t * Builds tree of {@link SourcePosition}s of `element` and all it's children\n\t * @param element the root element of the tree\n\t */\n\tpublic void addTreeOfSourceFragmentsOfElement(CtElement element) {\n\t\tDeque<ElementSourceFragment> parents = new ArrayDeque<>();\n\t\tparents.push(this);\n\t\t/*\n\t\t * scan all children of `element` and build tree of SourceFragments\n\t\t * Note: we cannot skip implicit elements,\n\t\t * because CtBlock can be implicit but contains non implicit elements, which has to be processed.\n\t\t */\n\t\tnew EarlyTerminatingScanner<Void>() {\n\t\t\t@Override\n\t\t\tprotected void enter(CtElement e) {\n\t\t\t\tif (e instanceof CtCompilationUnit) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tElementSourceFragment newFragment = addChild(parents.peek(), scannedRole, e);\n\t\t\t\tif (newFragment != null) {\n\t\t\t\t\tparents.push(newFragment);\n\t\t\t\t\tif (e instanceof CtModifiable) {\n\t\t\t\t\t\tCtModifiable modifiable = (CtModifiable) e;\n\t\t\t\t\t\tSet<CtExtendedModifier> modifiers = modifiable.getExtendedModifiers();\n\t\t\t\t\t\tfor (CtExtendedModifier ctExtendedModifier : modifiers) {\n\t\t\t\t\t\t\taddChild(newFragment, CtRole.MODIFIER, ctExtendedModifier);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void exit(CtElement e) {\n\t\t\t\tif (e instanceof CtCompilationUnit) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tElementSourceFragment topFragment = parents.peek();\n\t\t\t\tif (topFragment != null && topFragment.getElement() == e) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t.setVisitCompilationUnitContent(true)\n\t\t.scan(element.getRoleInParent(), element);\n\t}\n\t/**\n\t * @param parentFragment the parent {@link ElementSourceFragment}, which will receive {@link ElementSourceFragment} made for `otherElement`\n\t * @param roleInParent the {@link CtRole} of `otherElement` in scope of element of `parentFragment`\n\t * @param otherElement {@link SourcePositionHolder} whose {@link ElementSourceFragment} has to be added to `parentFragment`\n\t * @return new {@link ElementSourceFragment} created for `otherElement` or null if `otherElement` has no source position or doesn't belong to the same compilation unit\n\t */\n\tprivate ElementSourceFragment addChild(ElementSourceFragment parentFragment, CtRole roleInParent, SourcePositionHolder otherElement) {\n\t\tSourcePosition otherSourcePosition = otherElement.getPosition();\n\t\tif (otherSourcePosition instanceof SourcePositionImpl && otherSourcePosition.getCompilationUnit() != null) {\n\t\t\tif (parentFragment.isFromSameSource(otherSourcePosition)) {\n\t\t\t\tElementSourceFragment otherFragment = new ElementSourceFragment(otherElement, parentFragment.getRoleHandler(roleInParent, otherElement));\n\t\t\t\t//parent and child are from the same file. So we can connect their positions into one tree\n\t\t\t\tCMP cmp = parentFragment.compare(otherFragment);\n\t\t\t\tif (cmp == CMP.OTHER_IS_CHILD) {\n\t\t\t\t\t//child belongs under parent - OK\n\t\t\t\t\tparentFragment.addChild(otherFragment);\n\t\t\t\t\treturn otherFragment;\n\t\t\t\t} else {\n\t\t\t\t\tif (cmp == CMP.OTHER_IS_AFTER || cmp == CMP.OTHER_IS_BEFORE) {\n\t\t\t\t\t\tif (otherElement instanceof CtComment) {\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * comments of elements are sometime not included in source position of element.\n\t\t\t\t\t\t\t * because comments are ignored tokens for java compiler, which computes start/end of elements\n\t\t\t\t\t\t\t * Example:\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * \t\t//a comment\n\t\t\t\t\t\t\t * \t\taStatement();\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (otherFragment.getStart() == 0) {\n\t\t\t\t\t\t\t\t//it is CompilationUnit comment, which is before package and imports, so it doesn't belong to class\n\t\t\t\t\t\t\t\t//No problem. Simply add comment at correct position into SourceFragment tree, starting from ROOT\n\t\t\t\t\t\t\t\taddChild(otherFragment);\n\t\t\t\t\t\t\t\treturn otherFragment;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//add this child into parent's source fragment and extend that parent source fragment\n\t\t\t\t\t\t\tparentFragment.addChild(otherFragment);\n\t\t\t\t\t\t\treturn otherFragment;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//the source position of child element is not included in source position of parent element\n\t\t\t\t\t//I (Pavel) am not sure how to handle it, so let's wait until it happens...\n//\t\t\t\t\t\tif (otherElement instanceof CtAnnotation<?>) {\n//\t\t\t\t\t\t\t/*\n//\t\t\t\t\t\t\t * it can happen for annotations of type TYPE_USE and FIELD\n//\t\t\t\t\t\t\t * In such case the annotation belongs to 2 elements\n//\t\t\t\t\t\t\t * And one of them cannot have matching source position - OK\n//\t\t\t\t\t\t\t */\n//\t\t\t\t\t\t\treturn null;\n//\t\t\t\t\t\t}\n\t\t\t\t\t//something is wrong ...\n\t\t\t\t\tthrow new SpoonException(\"The SourcePosition of elements are not consistent\\nparentFragment: \" + parentFragment + \"\\notherFragment: \" + otherFragment);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"SourcePosition from unexpected compilation unit: \" + otherSourcePosition + \" expected is: \" + parentFragment.getSourcePosition());\n\t\t\t}\n\t\t}\n\t\t//do not connect that undefined source position\n\t\treturn null;\n\t}\n\n\tprivate RoleHandler getRoleHandler(CtRole roleInParent, SourcePositionHolder otherElement) {\n\t\tSourcePositionHolder parent = element;\n\t\tif (parent == null) {\n\t\t\tif (otherElement instanceof CtElement) {\n\t\t\t\tparent = ((CtElement) otherElement).getParent();\n\t\t\t}\n\t\t}\n\t\tif (parent instanceof CtElement) {\n\t\t\tCtElement ele = (CtElement) parent;\n\t\t\treturn RoleHandlerHelper.getRoleHandler(ele.getClass(), roleInParent);\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * adds `other` {@link ElementSourceFragment} into tree of {@link ElementSourceFragment}s represented by this root element\n\t *\n\t * @param other to be added {@link ElementSourceFragment}\n\t * @return new root of the tree of the {@link ElementSourceFragment}s. It can be be this or `other`\n\t */\n\tpublic ElementSourceFragment add(ElementSourceFragment other) {\n\t\tif (this == other) {\n\t\t\tthrow new SpoonException(\"SourceFragment#add must not be called twice for the same SourceFragment\");\n\t\t\t//optionally we might accept that and simply return this\n\t\t}\n\t\tCMP cmp = this.compare(other);\n\t\tswitch (cmp) {\n\t\tcase OTHER_IS_AFTER:\n\t\t\t//other is after this\n\t\t\taddNextSibling(other);\n\t\t\treturn this;\n\t\tcase OTHER_IS_BEFORE:\n\t\t\t//other is before this\n\t\t\tother.addNextSibling(this);\n\t\t\treturn other;\n\t\tcase OTHER_IS_CHILD:\n\t\t\t//other is child of this\n\t\t\taddChild(other);\n\t\t\treturn this;\n\t\tcase OTHER_IS_PARENT:\n\t\t\t//other is parent of this, merge this and all siblings of `this` as children and siblings of `other`\n\t\t\tother.merge(this);\n\t\t\treturn other;\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected compare result: \" + cmp);\n\t}\n\n\tprivate void merge(ElementSourceFragment tobeMerged) {\n\t\twhile (tobeMerged != null) {\n\t\t\tElementSourceFragment nextTobeMerged = tobeMerged.getNextSibling();\n\t\t\t//disconnect tobeMerged from nextSiblings before we add it. So it is added individually and not with wrong siblings too\n\t\t\ttobeMerged.nextSibling = null;\n\t\t\tadd(tobeMerged);\n\t\t\ttobeMerged = nextTobeMerged;\n\t\t}\n\t}\n\n\t/**\n\t * adds `fragment` as child fragment of this fragment. If child is located before or after this fragment,\n\t * then start/end of this fragment is moved\n\t * @param fragment to be add\n\t */\n\tpublic void addChild(ElementSourceFragment fragment) {\n\t\tif (firstChild == null) {\n\t\t\tfirstChild = fragment;\n\t\t} else {\n\t\t\tfirstChild = firstChild.add(fragment);\n\t\t}\n\t\tif (fragment.getElement() instanceof CtElement) {\n\t\t\tCtElement fragmentEleParent = ((CtElement) fragment.getElement()).getParent();\n\t\t\tif (element != fragmentEleParent && !(element instanceof CtCompilationUnit) && fragmentEleParent.getPosition().isValidPosition()) {\n\t\t\t\tthrow new SpoonException(\"Inconsistent child fragment \" + fragment.getElement().getClass() + \" has unexpected parent \" + element.getClass());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void addNextSibling(ElementSourceFragment sibling) {\n\t\tif (nextSibling == null) {\n\t\t\tnextSibling = sibling;\n\t\t} else {\n\t\t\tnextSibling = nextSibling.add(sibling);\n\t\t}\n\t}\n\n\tprivate ElementSourceFragment getLastSibling() {\n\t\tElementSourceFragment lastSibling = this;\n\t\twhile (lastSibling.nextSibling != null) {\n\t\t\tlastSibling = lastSibling.nextSibling;\n\t\t}\n\t\treturn lastSibling;\n\t}\n\n\tprivate enum CMP {\n\t\tOTHER_IS_BEFORE,\n\t\tOTHER_IS_AFTER,\n\t\tOTHER_IS_CHILD,\n\t\tOTHER_IS_PARENT\n\t}\n\n\t/**\n\t * compares this and other\n\t * @param other other {@link SourcePosition}\n\t * @return CMP\n\t * throws {@link SpoonException} if intervals overlap or start/end is negative\n\t */\n\tprivate CMP compare(ElementSourceFragment other) {\n\t\tif (other == this) {\n\t\t\tthrow new SpoonException(\"SourcePositionImpl#addNextSibling must not be called twice for the same SourcePosition\");\n\t\t}\n\t\tif (getEnd() <= other.getStart()) {\n\t\t\t//other is after this\n\t\t\treturn CMP.OTHER_IS_AFTER;\n\t\t}\n\t\tif (other.getEnd() <= getStart()) {\n\t\t\t//other is before this\n\t\t\treturn CMP.OTHER_IS_BEFORE;\n\t\t}\n\t\tif (getStart() <= other.getStart() && getEnd() >= other.getEnd()) {\n\t\t\t//other is child of this\n\t\t\treturn CMP.OTHER_IS_CHILD;\n\t\t}\n\t\tif (getStart() >= other.getStart() && getEnd() <= other.getEnd()) {\n\t\t\t//other is parent of this\n\t\t\treturn CMP.OTHER_IS_PARENT;\n\t\t}\n\t\t//the fragments overlap - it is not allowed\n\t\tthrow new SpoonException(\"Cannot compare this: [\" + getStart() + \", \" + getEnd() + \"] with other: [\\\"\" + other.getStart() + \"\\\", \\\"\" + other.getEnd() + \"\\\"]\");\n\t}\n\n\t/**\n\t * @return {@link ElementSourceFragment} which belongs to the same parent and is next in the sources\n\t */\n\tpublic ElementSourceFragment getNextSibling() {\n\t\treturn nextSibling;\n\t}\n\n\t/**\n\t * @return {@link ElementSourceFragment}, which is first child of this fragment\n\t */\n\tpublic ElementSourceFragment getFirstChild() {\n\t\treturn firstChild;\n\t}\n\n\t/**\n\t * Searches the tree of fragments for the {@link ElementSourceFragment} with expected `element`,\n\t * which contains `start` and `end` source interval.\n\t * It searches in siblings and children of this {@link ElementSourceFragment} recursively.\n\t * @param element the {@link SourcePositionHolder} of fragment it is looking for or null for any element\n\t * @param start the start offset of searched fragment\n\t * @param end the offset of next character after the end of searched fragment\n\t *\n\t * @return {@link ElementSourceFragment} which represents the root of the CtElement whose sources are in interval [start, end]\n\t */\n\tpublic ElementSourceFragment getSourceFragmentOf(SourcePositionHolder element, int start, int end) {\n\t\tint myEnd = getEnd();\n\t\tif (myEnd <= start) {\n\t\t\t//search in next sibling\n\t\t\tif (nextSibling == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn getRootFragmentOfElement(nextSibling.getSourceFragmentOf(element, start, end));\n\t\t}\n\t\tint myStart = getStart();\n\t\tif (myStart <= start) {\n\t\t\tif (myEnd >= end) {\n\t\t\t\tif (myStart == start && myEnd == end) {\n\t\t\t\t\t//we have found exact match\n\t\t\t\t\tif (element != null && getElement() != element) {\n\t\t\t\t\t\tif (firstChild == null) {\n\t\t\t\t\t\t\tthrow new SpoonException(\"There is no source fragment for element \" + element.getClass() + \". There is one for class \" + getElement().getClass());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn firstChild.getSourceFragmentOf(element, start, end);\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t//it is the child\n\t\t\t\tif (firstChild == null) {\n\t\t\t\t\tif (element != null && getElement() != element) {\n\t\t\t\t\t\tthrow new SpoonException(\"There is no source fragment for element \" + element.getClass() + \". There is one for class \" + getElement().getClass());\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tElementSourceFragment child = getRootFragmentOfElement(firstChild.getSourceFragmentOf(element, start, end));\n\t\t\t\tif (child != null) {\n\t\t\t\t\t//all children are smaller then this element\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t\t//so this fragment is last one which wraps whole element\n\t\t\t\tif (element != null && getElement() != element) {\n\t\t\t\t\tthrow new SpoonException(\"There is no source fragment for element \" + element.getClass() + \". There is one for class \" + getElement().getClass());\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t//start - end overlaps over multiple fragments\n\t\t\tthrow new SpoonException(\"Invalid start/end interval. It overlaps multiple fragments.\");\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate ElementSourceFragment getRootFragmentOfElement(ElementSourceFragment childFragment) {\n\t\tif (childFragment != null && getElement() != null && childFragment.getElement() == getElement()) {\n\t\t\t//child fragment and this fragment have same element. Return this fragment,\n\t\t\t//because we have to return root fragment of CtElement\n\t\t\treturn this;\n\t\t}\n\t\treturn childFragment;\n\t}\n\t/**\n\t * @return {@link CtElement} whose source code is contained in this fragment.\n\t * May be null\n\t */\n\tpublic SourcePositionHolder getElement() {\n\t\treturn element;\n\t}\n\n\t/**\n\t * Note: the List of children is flat. The child fragments of collections (parameters, type members, ...) are next to each other.\n\t * @return list of child fragments of this {@link ElementSourceFragment}.\n\t */\n\tpublic List<SourceFragment> getChildrenFragments() {\n\t\tif (element instanceof CtLiteral) {\n\t\t\treturn Collections.singletonList(new TokenSourceFragment(getSourceCode(), TokenType.LITERAL));\n\t\t}\n\t\tList<SourceFragment> children = new ArrayList<>();\n\t\tint off = getStart();\n\t\tElementSourceFragment child = getFirstChild();\n\t\twhile (child != null) {\n\t\t\tforEachConstantFragment(off, child.getStart(), cf -> children.add(cf));\n\t\t\tchildren.add(child);\n\t\t\toff = child.getEnd();\n\t\t\tchild = child.getNextSibling();\n\t\t}\n\t\tforEachConstantFragment(off, getEnd(), cf -> children.add(cf));\n\t\treturn children;\n\t}\n\n\t/**\n\t * Detects all child fragments of this {@link ElementSourceFragment}.\n\t * Note: the List of children contains one {@link CollectionSourceFragment} for each collection of fragments (parameters, type members, ...).\n\t * Note: the {@link CollectionSourceFragment} may contain a mix of fragments of different roles, when they overlap.\n\t * For example this code contains mix of annotations and modifiers\n\t * <code>public @Deprecated static @Ignored void method()</code>\n\t * @return list of child fragments of this {@link ElementSourceFragment} where fragments,\n\t * which belongs to the same collection are grouped into {@link CollectionSourceFragment}\n\t */\n\tpublic List<SourceFragment> getGroupedChildrenFragments() {\n\t\tList<SourceFragment> flatChildren = getChildrenFragments();\n\t\tList<SourceFragment> result = new ArrayList<>();\n\t\tint i = 0;\n\t\twhile (i < flatChildren.size()) {\n\t\t\tSourceFragment child = flatChildren.get(i);\n\t\t\tif (child instanceof TokenSourceFragment) {\n\t\t\t\tresult.add(child);\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t} else if (child instanceof ElementSourceFragment) {\n\t\t\t\tElementSourceFragment esf = (ElementSourceFragment) child;\n\t\t\t\tContainerKind kind = esf.getContainerKindInParent();\n\t\t\t\tif (kind == ContainerKind.SINGLE) {\n\t\t\t\t\t//it is root element or there is always only one child instance in parent\n\t\t\t\t\tresult.add(child);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//there can be 0, 1 or more items of children of the same role\n\t\t\t\t//search for another element of the same role\n\t\t\t\tSet<CtRole> foundRoles = new HashSet<>();\n\t\t\t\tfoundRoles.add(checkNotNull(esf.getRoleInParent()));\n\t\t\t\tList<SourceFragment> childrenInSameCollection = new ArrayList<>();\n\t\t\t\t//but first include prefix whitespace\n\t\t\t\tSourceFragment spaceChild = removeSuffixSpace(result);\n\t\t\t\tif (spaceChild != null) {\n\t\t\t\t\tchildrenInSameCollection.add(spaceChild);\n\t\t\t\t}\n\t\t\t\tchildrenInSameCollection.add(esf);\n\t\t\t\tint lastOfSameRole = findIndexOfLastChildTokenOfRoleHandler(flatChildren, i, esf.getRoleInParent());\n\t\t\t\t//search for other roles in that interval\n\t\t\t\ti++;\n\t\t\t\twhile (i <= lastOfSameRole) {\n\t\t\t\t\tchild = flatChildren.get(i);\n\t\t\t\t\tchildrenInSameCollection.add(child);\n\t\t\t\t\tCtRole role = null;\n\t\t\t\t\tif (child instanceof ElementSourceFragment) {\n\t\t\t\t\t\tElementSourceFragment esf2 = (ElementSourceFragment) child;\n\t\t\t\t\t\trole = esf2.getRoleInParent();\n\t\t\t\t\t}\n\t\t\t\t\tif (role != null && role != CtRole.COMMENT && foundRoles.add(role)) {\n\t\t\t\t\t\t//there is another role in same block, search for last one\n\t\t\t\t\t\tlastOfSameRole = Math.max(lastOfSameRole, findIndexOfLastChildTokenOfRoleHandler(flatChildren, i + 1, role));\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t//add suffix space\n\t\t\t\t/*\n\t\t\t\tif (i < flatChildren.size()) {\n\t\t\t\t\tSourceFragment nextChild = flatChildren.get(i);\n\t\t\t\t\tif (isSpaceFragment(nextChild)) {\n\t\t\t\t\t\tchildrenInSameCollection.add(nextChild);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tresult.add(new CollectionSourceFragment(childrenInSameCollection));\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"Unexpected SourceFragment of type \" + child.getClass());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate SourceFragment removeSuffixSpace(List<SourceFragment> list) {\n\t\tif (list.size() > 0) {\n\t\t\tSourceFragment lastChild = list.get(list.size() - 1);\n\t\t\tif (isSpaceFragment(lastChild)) {\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t\treturn lastChild;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate <T> T checkNotNull(T o) {\n\t\tif (o == null) {\n\t\t\tthrow new SpoonException(\"Unexpected null value\");\n\t\t}\n\t\treturn o;\n\t}\n\n\tprivate static int findIndexOfLastChildTokenOfRoleHandler(List<SourceFragment> childFragments, int start, CtRole role) {\n\t\treturn findIndexOfPreviousFragment(childFragments, start,\n\t\t\t\tfilter(ElementSourceFragment.class, fragment -> fragment.getRoleInParent() == role));\n\t}\n\n\tprivate enum CharType {\n\t\tSPACE,\n\t\tNON_SPACE;\n\n\t\tstatic CharType fromChar(char c) {\n\t\t\treturn Character.isWhitespace(c) ? SPACE : NON_SPACE;\n\t\t}\n\t}\n\n\tprivate static final Set<String> separators = new HashSet<>(Arrays.asList(\"->\", \"::\", \"...\"));\n\tstatic {\n\t\t\"(){}[];,.:@=<>?&|\".chars().forEach(c -> separators.add(new String(Character.toChars(c))));\n\t}\n\tprivate static final Set<String> operators = new HashSet<>(Arrays.asList(\n\t\t\t\"=\",\n\t\t\t\">\",\n\t\t\t\"<\",\n\t\t\t\"!\",\n\t\t\t\"~\",\n\t\t\t\"?\",\n\t\t\t\":\",\n\t\t\t\"==\",\n\t\t\t\"<=\",\n\t\t\t\">=\",\n\t\t\t\"!=\",\n\t\t\t\"&&\",\n\t\t\t\"||\",\n\t\t\t\"++\",\n\t\t\t\"--\",\n\t\t\t\"+\",\n\t\t\t\"-\",\n\t\t\t\"*\",\n\t\t\t\"/\",\n\t\t\t\"&\",\n\t\t\t\"|\",\n\t\t\t\"^\",\n\t\t\t\"%\",\n\t\t\t\"<<\", \">>\", \">>>\",\n\n\t\t\t\"+=\",\n\t\t\t\"-=\",\n\t\t\t\"*=\",\n\t\t\t\"/=\",\n\t\t\t\"&=\",\n\t\t\t\"|=\",\n\t\t\t\"^=\",\n\t\t\t\"%=\",\n\t\t\t\"<<=\",\n\t\t\t\">>=\",\n\t\t\t\">>>=\"/*,\n\t\t\tit is handled as keyword here\n\t\t\t\"instanceof\"\n\t\t\t*/\n\t));\n\n\tprivate static final String[] javaKeywordsJoined = {\n\t\t\t\"abstract continue for new switch\",\n\t\t\t\"assert default goto package synchronized\",\n\t\t\t\"boolean do if private this\",\n\t\t\t\"break double implements protected throw\",\n\t\t\t\"byte else import public throws\",\n\t\t\t\"case enum instanceof return transient\",\n\t\t\t\"catch extends int short try\",\n\t\t\t\"char final interface static void\",\n\t\t\t\"class finally long strictfp volatile\",\n\t\t\t\"const float native super while\"\n\t};\n\n\tprivate static final Set<String> javaKeywords = new HashSet<>();\n\tstatic {\n\t\tfor (String str : javaKeywordsJoined) {\n\t\t\tStringTokenizer st = new StringTokenizer(str, \" \");\n\t\t\twhile (st.hasMoreTokens()) {\n\t\t\t\tjavaKeywords.add(st.nextToken());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static final List<StringMatcher> matchers = new ArrayList<>();\n\tstatic {\n\t\tseparators.forEach(s -> matchers.add(new StringMatcher(s, TokenType.SEPARATOR)));\n\t\toperators.forEach(s -> matchers.add(new StringMatcher(s, TokenType.OPERATOR)));\n\t}\n\n\t/**\n\t * Calls `consumer` once for each constant {@link SourceFragment} found in source code between `start` and `end`\n\t */\n\tprivate void forEachConstantFragment(int start, int end, Consumer<SourceFragment> consumer) {\n\t\tif (start == end) {\n\t\t\treturn;\n\t\t}\n\t\tif (start > end) {\n\t\t\tthrow new SpoonException(\"Inconsistent start/end. Start=\" + start + \" is greater then End=\" + end);\n\t\t}\n\t\tString sourceCode = getOriginalSourceCode();\n\t\tStringBuilder buff = new StringBuilder();\n\t\tCharType lastType = null;\n\t\tint off = start;\n\t\twhile (off < end) {\n\t\t\tchar c = sourceCode.charAt(off);\n\t\t\tCharType type = CharType.fromChar(c);\n\t\t\tif (type != lastType) {\n\t\t\t\tif (lastType != null) {\n\t\t\t\t\tonCharSequence(lastType, buff, consumer);\n\t\t\t\t\tbuff.setLength(0);\n\t\t\t\t}\n\t\t\t\tlastType = type;\n\t\t\t}\n\t\t\tbuff.append(c);\n\t\t\toff++;\n\t\t}\n\t\tonCharSequence(lastType, buff, consumer);\n\t}\n\n\tprivate void onCharSequence(CharType type, StringBuilder buff, Consumer<SourceFragment> consumer) {\n\t\tif (type == CharType.SPACE) {\n\t\t\tconsumer.accept(new TokenSourceFragment(buff.toString(), TokenType.SPACE));\n\t\t\treturn;\n\t\t}\n\t\tchar[] str = new char[buff.length()];\n\t\tbuff.getChars(0, buff.length(), str, 0);\n\t\tint off = 0;\n\t\twhile (off < str.length) {\n\t\t\t//detect java identifier or keyword\n\t\t\tint lenOfIdentifier = detectJavaIdentifier(str, off);\n\t\t\tif (lenOfIdentifier > 0) {\n\t\t\t\tString identifier = new String(str, off, lenOfIdentifier);\n\t\t\t\tif (javaKeywords.contains(identifier)) {\n\t\t\t\t\t//it is a java keyword\n\t\t\t\t\tconsumer.accept(new TokenSourceFragment(identifier, TokenType.KEYWORD));\n\t\t\t\t} else {\n\t\t\t\t\t//it is a java identifier\n\t\t\t\t\tconsumer.accept(new TokenSourceFragment(identifier, TokenType.IDENTIFIER));\n\t\t\t\t}\n\t\t\t\toff += lenOfIdentifier;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//detect longest match in matchers\n\t\t\tStringMatcher longestMatcher = null;\n\t\t\tfor (StringMatcher strMatcher : matchers) {\n\t\t\t\tif (strMatcher.isMatch(str, off)) {\n\t\t\t\t\tlongestMatcher = strMatcher.getLonger(longestMatcher);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (longestMatcher == null) {\n\t\t\t\tthrow new SpoonException(\"Unexpected source text: \" + buff.toString());\n\t\t\t}\n\t\t\tconsumer.accept(new TokenSourceFragment(longestMatcher.toString(), longestMatcher.getType()));\n\t\t\toff += longestMatcher.getLength();\n\t\t}\n\t}\n\n\t/**\n\t * @return number of characters in buff starting from start which are java identifier\n\t */\n\tprivate int detectJavaIdentifier(char[] buff, int start) {\n\t\tint len = buff.length;\n\t\tint o = start;\n\t\tif (start <= len) {\n\t\t\tchar c = buff[o];\n\t\t\tif (Character.isJavaIdentifierStart(c)) {\n\t\t\t\to++;\n\t\t\t\twhile (o < len) {\n\t\t\t\t\tc = buff[o];\n\t\t\t\t\tif (Character.isJavaIdentifierPart(c) == false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn o - start;\n\t}\n\n\tprivate String getOriginalSourceCode() {\n\t\tCompilationUnit cu = getSourcePosition().getCompilationUnit();\n\t\tif (cu != null) {\n\t\t\treturn cu.getOriginalSourceCode();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static final class StringMatcher {\n\t\tprivate final TokenType type;\n\t\tprivate final char[] chars;\n\n\t\tprivate StringMatcher(final String str, TokenType type) {\n\t\t\tthis.type = type;\n\t\t\tchars = str.toCharArray();\n\t\t}\n\n\t\tpublic boolean isMatch(final char[] buffer, int pos) {\n\t\t\tfinal int len = chars.length;\n\t\t\tif (pos + len > buffer.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < chars.length; i++, pos++) {\n\t\t\t\tif (chars[i] != buffer[pos]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn new String(chars);\n\t\t}\n\n\t\tpublic int getLength() {\n\t\t\treturn chars.length;\n\t\t}\n\n\t\tpublic StringMatcher getLonger(StringMatcher m) {\n\t\t\tif (m != null && m.getLength() > getLength()) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic TokenType getType() {\n\t\t\treturn type;\n\t\t}\n\t}\n\n\t/**\n\t * @return role of the element of this fragment in scope of it's parent\n\t */\n\tpublic CtRole getRoleInParent() {\n\t\treturn roleHandlerInParent != null ? roleHandlerInParent.getRole() : null;\n\t}\n\n\t/**\n\t * @return the {@link ContainerKind} of the attribute which holds the element of this fragment in it's parent\n\t */\n\tpublic ContainerKind getContainerKindInParent() {\n\t\tif (roleHandlerInParent != null) {\n\t\t\tif (roleHandlerInParent.getRole() != CtRole.COMMENT) {\n\t\t\t\treturn roleHandlerInParent.getContainerKind();\n\t\t\t}\n\t\t}\n\t\treturn ContainerKind.SINGLE;\n\t}\n\t/**\n\t * looks for next fragment whose {@link Predicate} `test` returns true\n\t * @param start - the index of first to be checked fragment\n\t * @return index of found fragment, or -1 if not found\n\t */\n\tstatic int findIndexOfNextFragment(List<SourceFragment> fragments, int start, Predicate<SourceFragment> test) {\n\t\twhile (start < fragments.size()) {\n\t\t\tSourceFragment fragment = fragments.get(start);\n\t\t\tif (test.test(fragment)) {\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param start the index of element with lower index which is checked and may be returned\n\t * @param test a {@link Predicate}, which is evaluated for each item of `fragments` starting from last one and ending with item in index `start`\n\t * @return index of found fragment, or -1 if not found\n\t */\n\tstatic int findIndexOfPreviousFragment(List<SourceFragment> fragments, int start, Predicate<SourceFragment> test) {\n\t\tint i = fragments.size() - 1;\n\t\twhile (i >= start) {\n\t\t\tif (test.test(fragments.get(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param predicate the {@link Predicate}, which has to be checkd for each item of {@link CollectionSourceFragment}\n\t * @return {@link Predicate} which calls `predicate` for each item of {@link CollectionSourceFragment}\n\t * Returned {@link Predicate} returns true only if `predicate` returns true on at least one item\n\t */\n\tstatic Predicate<SourceFragment> checkCollectionItems(Predicate<SourceFragment> predicate) {\n\t\treturn (SourceFragment fragment) -> {\n\t\t\tif (fragment instanceof CollectionSourceFragment) {\n\t\t\t\tCollectionSourceFragment collectionFragment = (CollectionSourceFragment) fragment;\n\t\t\t\tfor (SourceFragment itemFragment : collectionFragment.getItems()) {\n\t\t\t\t\tif (predicate.test(itemFragment)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn predicate.test(fragment);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @param predicate to be called {@link Predicate}\n\t * @return {@link Predicate} which calls `predicate` only for {@link SourceFragment}s of of type `clazz` and returns false for others\n\t */\n\tstatic <T extends SourceFragment> Predicate<SourceFragment> filter(Class<T> clazz, Predicate<T> predicate) {\n\t\treturn fragment -> {\n\t\t\tif (clazz.isInstance(fragment)) {\n\t\t\t\treturn predicate.test((T) fragment);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\n\t/**\n\t * @return true if {@link SourceFragment} represents a white space\n\t */\n\tstatic boolean isSpaceFragment(SourceFragment fragment) {\n\t\treturn fragment instanceof TokenSourceFragment && ((TokenSourceFragment) fragment).getType() == TokenType.SPACE;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/SourceFragmentContextNormal.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\n/**\n * Knows how to print modified {@link CtElement} by the way that origin formatting is kept as much as possible.\n * There are two streams of source fragments\n * 1) stream of origin source fragments\n * 2) stream of tokens produced by {@link DefaultJavaPrettyPrinter} in spaces between printing of child {@link CtElement}s\n *\n * Note: some fragments are optional and some are mandatory. For example:\n * &lt;T&gt; void method(T p);\n * and after remove of type parameter and method parameter....\n * void method();\n * The type parameter brackets were removed, while parameter brackets are kept.\n * Only DJPP knows whether it has to be displayed or not. So algorithm is like this:\n * <ul>\n * <li> print origin source token only after this token is printed by DJPP\n * <li> if DJPP doesn't prints some token then the same token must be ignored in origin source code too\n * </ul>\n *\n * Handling of spaces before and after tokens:\n * <ul>\n * <li> spaces belong to both surrounding elements. So they are printed only if both elements are printed\n * <li> if the elements are moved, then spaces are moved together with the follow up element\n * <li> if the elements E1 and E2 are separated by sequence of E1, Spaces1, Separator, Spaces2, E2\n * then Spaces1 belongs to E1 and Spaces2 belongs to element E2.\n * </ul>\n */\npublic class SourceFragmentContextNormal extends AbstractSourceFragmentContext {\n\t/**\n\t * @param mutableTokenWriter {@link MutableTokenWriter}, which is used for printing\n\t * @param rootFragment the {@link ElementSourceFragment}, which represents whole elements. E.g. whole type or method\n\t * @param changeResolver\n\t */\n\tpublic SourceFragmentContextNormal(MutableTokenWriter mutableTokenWriter, ElementSourceFragment rootFragment, ChangeResolver changeResolver) {\n\t\tsuper(mutableTokenWriter, changeResolver, rootFragment.getGroupedChildrenFragments());\n\t}\n\n\t@Override\n\tpublic boolean matchesPrinterEvent(PrinterEvent event) {\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic void onFinished() {\n\t\t//we are at the end of this element. Printer just tries to print something out of this context.\n\t\tif (mutableTokenWriter.isMuted() == false) {\n\t\t\t//print fragment suffix\n\t\t\tprintSpaces(childFragments.size());\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/SourceFragmentContextList.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport static spoon.support.sniper.internal.ElementSourceFragment.isSpaceFragment;\n\n/**\n * Handles printing of changes of the ordered list of elements.\n * E.g. list of type members of type\n * Such lists must be printed in same order like they are in defined in Spoon model.\n */\npublic class SourceFragmentContextList extends AbstractSourceFragmentContextCollection {\n\t/**\n\t * @param mutableTokenWriter {@link MutableTokenWriter}, which is used for printing\n\t * @param element the {@link CtElement} whose list attribute is handled\n\t * @param fragments the List of fragments, which represents whole list of elements. E.g. body of method or all type members of type\n\t * @param changeResolver {@link ChangeResolver}, which can be used to detect changes of list items\n\t */\n\tpublic SourceFragmentContextList(MutableTokenWriter mutableTokenWriter, CtElement element, List<SourceFragment> fragments, ChangeResolver changeResolver) {\n\t\tsuper(mutableTokenWriter, fragments, changeResolver);\n\t}\n\n\t@Override\n\tprotected int findIndexOfNextChildTokenOfEvent(PrinterEvent event) {\n\t\tif (event instanceof ElementPrinterEvent) {\n\t\t\t// in case of collection search for exact item of the collection\n\t\t\tElementPrinterEvent elementEvent = (ElementPrinterEvent) event;\n\t\t\treturn findIndexOfNextChildTokenOfElement(elementEvent.getElement());\n\t\t}\n\t\treturn super.findIndexOfNextChildTokenOfEvent(event);\n\t}\n\n\t@Override\n\tprotected void printOriginSpacesUntilFragmentIndex(int index) {\n\t\tsuper.printOriginSpacesUntilFragmentIndex(getLastWhiteSpaceBefore(index), index);\n\t}\n\n\t/**\n\t * @return index of last child fragment which contains space, which is before `index`\n\t */\n\tprivate int getLastWhiteSpaceBefore(int index) {\n\t\tfor (int i = index - 1; i >= 0; i--) {\n\t\t\tSourceFragment fragment = childFragments.get(i);\n\t\t\tif (isSpaceFragment(fragment)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn i + 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/SourceFragmentContextPrettyPrint.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\n/**\n * A {@link SourceFragmentContext}, which prints the element using standard pretty printing\n */\npublic class SourceFragmentContextPrettyPrint implements SourceFragmentContext {\n\t/**\n\t * This context is used to force normal pretty printing of element\n\t */\n\tpublic static final SourceFragmentContextPrettyPrint INSTANCE = new SourceFragmentContextPrettyPrint();\n\n\tprivate SourceFragmentContextPrettyPrint() {\n\t}\n\n\t@Override\n\tpublic void onPrintEvent(PrinterEvent event) {\n\t\tevent.print(null);\n\t}\n\n\t@Override\n\tpublic void onFinished() {\n\t}\n\n\t@Override\n\tpublic boolean matchesPrinterEvent(PrinterEvent event) {\n\t\treturn true;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/AbstractSourceFragmentContextCollection.java",
      "weight" : 59.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.List;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.path.CtRole;\n\nimport static spoon.support.sniper.internal.ElementSourceFragment.isSpaceFragment;\n\n/**\n * There are these types of collections: ordered or unordered and with separator and without separator\n * `ordered` collections have order of items defined by spoon model\n * `unordered` collection have order of items defined by some other internal rules.\n *   This order can be completely different to order of items in origin sources\n *\n * `with separator` collections have items separated by a separator. For example by a comma `,`\n * `without separator` collections have items separated by a whitespace char(s) only.\n */\nabstract class AbstractSourceFragmentContextCollection extends AbstractSourceFragmentContext {\n\n\tprotected AbstractSourceFragmentContextCollection(MutableTokenWriter mutableTokenWriter, List<SourceFragment> fragments, ChangeResolver changeResolver) {\n\t\tsuper(mutableTokenWriter, changeResolver, fragments);\n\t}\n\n\t@Override\n\tpublic boolean matchesPrinterEvent(PrinterEvent event) {\n\t\tCtRole role = event.getRole();\n\t\tif (!hasNextChildToken()) {\n\t\t\t//there are no more tokens to process. Leave this context\n\t\t\treturn false;\n\t\t}\n\t\tif (event.isWhitespace() || role == CtRole.COMMENT) {\n\t\t\treturn true;\n\t\t}\n\t\tif (role != null) {\n\t\t\t//the collection context accepts event as long as it is for same role\n\t\t\treturn findIndexOfNextChildTokenOfRole(0, role) >= 0;\n\t\t} else if (event.getElement() instanceof CtCompilationUnit) {\n\t\t\treturn findIndexOfNextChildTokenOfElement(event.getElement()) >= 0;\n\t\t}\n\t\tif (event instanceof TokenPrinterEvent) {\n\t\t\tTokenPrinterEvent tpe = (TokenPrinterEvent) event;\n\t\t\tif (tpe.getType() == TokenType.IDENTIFIER) {\n\t\t\t\treturn findIndexOfNextChildTokenByType(TokenType.IDENTIFIER) >= 0;\n\t\t\t}\n\t\t\treturn findIndexOfNextChildTokenByValue(event.getToken()) >= 0;\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected PrintEvent: \" + event.getClass());\n\t\t}\n\t}\n\n\t@Override\n\tprotected Boolean isFragmentModified(SourceFragment fragment) {\n\t\t//we cannot fast detect if it is modified using our changeResolver.\n\t\t//So return null. The code later will detect it including modified roles.\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return the suffix whitespaces at the end of collection of elements\n\t */\n\tprotected String getSuffixSpace() {\n\t\tif (childFragments.size() > 0) {\n\t\t\tSourceFragment item = childFragments.get(childFragments.size() - 1);\n\t\t\tif (isSpaceFragment(item)) {\n\t\t\t\treturn item.getSourceCode();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void onFinished() {\n\t\t//we are at the end of the list of elements. Printer just tries to print something out of this context.\n\t\tif (mutableTokenWriter.isMuted() == false) {\n\t\t\t//print list suffix\n\t\t\tString suffix = getSuffixSpace();\n\t\t\tif (suffix != null) {\n\t\t\t\t//we have origin source code for that list suffix\n\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(suffix);\n\t\t\t\tseparatorActions.clear();\n\t\t\t}\n\t\t}\n\t\tmutableTokenWriter.setMuted(false);\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/ElementPrinterEvent.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.path.CtRole;\n\n/**\n * Represents an action of Printer, which prints whole element\n */\npublic abstract class ElementPrinterEvent implements PrinterEvent {\n\tprivate final CtRole role;\n\tprivate final SourcePositionHolder element;\n\n\tpublic ElementPrinterEvent(CtRole role, SourcePositionHolder element) {\n\t\tthis.role = role;\n\t\tthis.element = element;\n\t}\n\n\t@Override\n\tpublic CtRole getRole() {\n\t\treturn role;\n\t}\n\n\t@Override\n\tpublic SourcePositionHolder getElement() {\n\t\treturn element;\n\t}\n\n\t@Override\n\tpublic String getToken() {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic boolean isWhitespace() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn role.name() + \"->\" + element.toString();\n\t}\n}\n\n"
    }, {
      "name" : "support/sniper/internal/TokenWriterProxy.java",
      "weight" : 78.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.visitor.PrinterHelper;\nimport spoon.reflect.visitor.TokenWriter;\n\n/**\n * Wraps a `tokenWriter` by an implementation which intercepts all {@link TokenWriter} writeXxx(String) calls\n * and calls {@link TokenWriterProxy.Listener#onTokenWriterWrite(TokenType, String, CtComment, Runnable)}\n * where {@link Runnable} can be used to invoke same event on the wrapped {@link TokenWriter}\n */\npublic class TokenWriterProxy implements TokenWriter {\n\t/**\n\t * Listens for each call of {@link TokenWriter}\n\t */\n\tpublic interface Listener {\n\t\t/**\n\t\t * Called once for each call of {@link TokenWriter} method\n\t\t * @param tokenType identifies the called method\n\t\t * @param token the sent token. May be null\n\t\t * @param comment the sent comment. Is null for tokenType != {@link TokenType#COMMENT}\n\t\t * @param printAction a {@link Runnable}, which can be used to run wrapped {@link TokenWriter} method\n\t\t */\n\t\tvoid onTokenWriterWrite(TokenType tokenType, String token, CtComment comment, Runnable printAction);\n\t}\n\n\tprivate final Listener listener;\n\tprivate final TokenWriter delegate;\n\n\tpublic TokenWriterProxy(Listener listener, TokenWriter delegate) {\n\t\tthis.listener = listener;\n\t\tthis.delegate = delegate;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeSeparator(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.SEPARATOR, token, null, () -> delegate.writeSeparator(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeOperator(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.OPERATOR, token, null, () -> delegate.writeOperator(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeLiteral(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.LITERAL, token, null, () -> delegate.writeLiteral(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeKeyword(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.KEYWORD, token, null, () -> delegate.writeKeyword(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeIdentifier(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.IDENTIFIER, token, null, () -> delegate.writeIdentifier(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeCodeSnippet(String token) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.CODE_SNIPPET, token, null, () -> delegate.writeCodeSnippet(token));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeComment(CtComment comment) {\n\t\tthis.listener.onTokenWriterWrite(TokenType.COMMENT, null, comment, () -> delegate.writeComment(comment));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeln() {\n\t\tthis.listener.onTokenWriterWrite(TokenType.NEW_LINE, \"\\n\", null, () -> delegate.writeln());\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter incTab() {\n\t\tthis.listener.onTokenWriterWrite(TokenType.INC_TAB, null, null, () -> delegate.incTab());\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic TokenWriter decTab() {\n\t\tthis.listener.onTokenWriterWrite(TokenType.DEC_TAB, null, null, () -> delegate.decTab());\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic PrinterHelper getPrinterHelper() {\n\t\treturn delegate.getPrinterHelper();\n\t}\n\n\t@Override\n\tpublic void reset() {\n\t\tdelegate.reset();\n\t}\n\n\t@Override\n\tpublic TokenWriter writeSpace() {\n\t\tthis.listener.onTokenWriterWrite(TokenType.SPACE, \" \", null, () -> delegate.writeSpace());\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/TokenSourceFragment.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.support.Experimental;\n\n/**\n * a {@link SourceFragment} of some primitive String token,\n * like separator, operator, whitespace, ...\n */\n@Experimental\npublic class TokenSourceFragment implements SourceFragment {\n\n\tprivate final String source;\n\tprivate final TokenType type;\n\n\tpublic TokenSourceFragment(String source, TokenType type) {\n\t\tthis.source = source;\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic String getSourceCode() {\n\t\treturn source;\n\t}\n\n\t/**\n\t * @return type of token of this fragment\n\t */\n\tpublic TokenType getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"|\" + getSourceCode() + \"|\";\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/SourceFragmentContextSet.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\n/**\n * Handles printing of changes of the unordered Set of elements.\n * E.g. set of modifiers and annotations or set of super interfaces\n * Such sets must be printed in same order like they were in origin source code\n *\n * If anything is modified (add/remove/modify element) in such collection,\n * then collection is printed in the order defined by {@link DefaultJavaPrettyPrinter}.\n * The not modified items of collection are printed using origin sources\n */\npublic class SourceFragmentContextSet extends AbstractSourceFragmentContextCollection {\n\t/**\n\t * @param mutableTokenWriter {@link MutableTokenWriter}, which is used for printing\n\t * @param element the {@link CtElement} whose list attribute is handled\n\t */\n\tpublic SourceFragmentContextSet(MutableTokenWriter mutableTokenWriter, CtElement element, List<SourceFragment> fragments, ChangeResolver changeResolver) {\n\t\tsuper(mutableTokenWriter, fragments, changeResolver);\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/TokenPrinterEvent.java",
      "weight" : 51.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.path.CtRole;\n\n/**\n * Represents an action of Printer, which prints a token\n */\npublic abstract class TokenPrinterEvent implements PrinterEvent {\n\tprivate final TokenType type;\n\tprivate final String token;\n\tprivate final CtComment comment;\n\n\tpublic TokenPrinterEvent(TokenType type, String token, CtComment comment) {\n\t\tthis.type = type;\n\t\tthis.token = token;\n\t\tthis.comment = comment;\n\t}\n\n\t@Override\n\tpublic CtRole getRole() {\n\t\tif (type == TokenType.COMMENT) {\n\t\t\treturn CtRole.COMMENT;\n\t\t}\n\t\tif (isModifierKeyword(type, token)) {\n\t\t\treturn CtRole.MODIFIER;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic SourcePositionHolder getElement() {\n\t\treturn comment;\n\t}\n\n\t@Override\n\tpublic String getToken() {\n\t\treturn token;\n\t}\n\n\tprivate static final Set<String> modifierKeywords = new HashSet<>(Arrays.asList(\n\t\t\t\"public\", \"protected\", \"private\", \"static\", \"default\", \"final\"));\n\n\tstatic boolean isModifierKeyword(TokenType tokenType, String token) {\n\t\treturn tokenType == TokenType.KEYWORD && modifierKeywords.contains(token);\n\t}\n\n\t@Override\n\tpublic boolean isWhitespace() {\n\t\treturn type.isWhiteSpace();\n\t}\n\n\tpublic TokenType getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn type.name() + \": \\'\" + token + \"\\'\";\n\t}\n}\n\n"
    }, {
      "name" : "support/sniper/internal/DirectPrinterHelper.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.visitor.PrinterHelper;\n\n/**\n * Extension of {@link PrinterHelper}, which allows direct printing of source fragments\n */\npublic class DirectPrinterHelper extends PrinterHelper {\n\n\tDirectPrinterHelper(Environment env) {\n\t\tsuper(env);\n\t}\n\n\t/**\n\t * Prints `text` directly into output buffer ignoring any Environment rules.\n\t * @param text to be printed string\n\t */\n\tpublic void directPrint(String text) {\n\t\tautoWriteTabs();\n\t\tint len = text.length();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tchar c = text.charAt(i);\n\t\t\t//avoid automatic writing of tabs in the middle of text\n\t\t\tshouldWriteTabs = false;\n\t\t\twrite(c);\n\t\t}\n\t}\n\n\t/**\n\t * Allows to set the protected field of {@link PrinterHelper#shouldWriteTabs}.\n\t *\n\t * @param shouldWriteTabs true if we just printed EndOfLine and we should print tabs if next character is not another EndOfLine\n\t */\n\tvoid setShouldWriteTabs(boolean shouldWriteTabs) {\n\t\tthis.shouldWriteTabs = shouldWriteTabs;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/ChangeResolver.java",
      "weight" : 58.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.Collections;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.support.modelobs.ChangeCollector;\nimport spoon.support.reflect.CtExtendedModifier;\n\n/**\n * Helper which provides details about changes on provided `element`\n */\npublic class ChangeResolver {\n\tprivate final ChangeCollector changeCollector;\n\tprivate final CtElement element;\n\tprivate final Set<CtRole> changedRoles;\n\n\tpublic ChangeResolver(ChangeCollector changeCollector, CtElement element) {\n\t\tthis.changeCollector = changeCollector;\n\t\tthis.element = element;\n\t\tchangedRoles = element != null ? changeCollector.getChanges(element) : null;\n\t}\n\n\t/**\n\t * @return true if `element` still exist in the printed model. false if it was removed or was never there\n\t */\n\tpublic boolean isElementExists(SourcePositionHolder element) {\n\t\tif (element instanceof CtExtendedModifier) {\n\t\t\tCtExtendedModifier modifier = (CtExtendedModifier) element;\n\t\t\tif (this.element instanceof CtModifiable) {\n\t\t\t\treturn ((CtModifiable) this.element).hasModifier(modifier.getKind());\n\t\t\t}\n\t\t}\n\t\tEarlyTerminatingScanner<Boolean> scanner = new EarlyTerminatingScanner<Boolean>() {\n\t\t\t@Override\n\t\t\tprotected void enter(CtElement e) {\n\t\t\t\tif (element == e) {\n\t\t\t\t\tsetResult(Boolean.TRUE);\n\t\t\t\t\tterminate();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tscanner.scan(this.element);\n\t\treturn scanner.getResult() == Boolean.TRUE;\n\t}\n\n\t/**\n\t * @param element to be checked element\n\t * @return Set of {@link CtRole}s, which are modified for `element`\n\t */\n\tpublic Set<CtRole> getChanges(SourcePositionHolder element) {\n\t\tif (element instanceof CtElement) {\n\t\t\treturn changeCollector.getChanges((CtElement) element);\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\t/**\n\t * @param ctRole to be checked {@link CtRole}\n\t * @return true if `ctRole` of scope `element` is modified\n\t */\n\tpublic boolean isRoleModified(CtRole ctRole) {\n\t\tif (changedRoles == null) {\n\t\t\tthrow new SpoonException(\"changedRoles are not initialized for this ChangeResolver. Use getChanges(...) instead\");\n\t\t}\n\t\treturn changedRoles.contains(ctRole);\n\t}\n\n\t/**\n\t * @return true if scope `element` is changed\n\t */\n\tpublic boolean hasChangedRole() {\n\t\treturn changedRoles.size() > 0;\n\t}\n\n\t/**\n\t * @return {@link ChangeCollector}\n\t */\n\tpublic ChangeCollector getChangeCollector() {\n\t\treturn changeCollector;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/CollectionSourceFragment.java",
      "weight" : 47.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.List;\n\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.Experimental;\n\n/**\n * {@link SourceFragment} of List or Set of {@link ElementSourceFragment}s which belong to collection role.\n * For example list of Type members or list of parameters, etc.\n * Or set of modifiers and annotations\n */\n@Experimental\npublic class CollectionSourceFragment implements SourceFragment {\n\n\tprivate final List<SourceFragment> items;\n\n\tpublic CollectionSourceFragment(List<SourceFragment> items) {\n\t\tthis.items = items;\n\t}\n\n\t@Override\n\tpublic String getSourceCode() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (SourceFragment childSourceFragment : items) {\n\t\t\tsb.append(childSourceFragment.getSourceCode());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * @return child source fragments of this collection\n\t */\n\tpublic List<SourceFragment> getItems() {\n\t\treturn items;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn items.toString();\n\t}\n\n\t/**\n\t * @return true if collection contains only children of one role handler with container kind LIST\n\t */\n\tpublic boolean isOrdered() {\n\t\tCtRole role = null;\n\t\tfor (SourceFragment childSourceFragment : items) {\n\t\t\tif (childSourceFragment instanceof ElementSourceFragment) {\n\t\t\t\tElementSourceFragment esf = (ElementSourceFragment) childSourceFragment;\n\t\t\t\tif (role == null) {\n\t\t\t\t\trole = esf.getRoleInParent();\n\t\t\t\t\tContainerKind kind = esf.getContainerKindInParent();\n\t\t\t\t\tif (kind != ContainerKind.LIST) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (role != esf.getRoleInParent()) {\n\t\t\t\t\t\t//the collection contains elements of different roles. It cannot be ordered\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t//else there is another element of the same role - ok\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//there are only elements of one role of container kind LIST\n\t\treturn true;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/PrinterEvent.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\n/**\n * Represents an action of PrettyPrinter\n */\npublic interface PrinterEvent  {\n\n\t/**\n\t * @return role of printed source code of element in scope of its parent\n\t */\n\tCtRole getRole();\n\n\t/**\n\t * Prints source code by {@link DefaultJavaPrettyPrinter} ignoring origin {@link SourceFragment}s\n\t * @param muted\n\t * \t\ttrue if origin sources are already printed and we are just calling {@link DefaultJavaPrettyPrinter}\n\t * \t\t\tto keep it's state consistent.\n\t *  \tfalse if {@link DefaultJavaPrettyPrinter} will really print into output.\n\t *  \tnull if `muted` status should be kept as it is\n\t */\n\tvoid print(Boolean muted);\n\n\t/**\n\t * We have a source fragment of to be printed element.\n\t * Print unmodified parts of this source `fragment`\n\t * @param fragment\n\t * @param isModified true if at least some part of `SourceFragment` is modified.\n\t * \tfalse if whole `SourceFragment` including all children is not modified.\n\t */\n\tvoid printSourceFragment(SourceFragment fragment, Boolean isModified);\n\n\t/**\n\t * @return printed element or null if printing a primitive token\n\t */\n\tSourcePositionHolder getElement();\n\n\t/**\n\t * @return printed token or null if printing complex element or comment\n\t */\n\tString getToken();\n\n\t/**\n\t * @return true if printing white space token. It means New line, space or TAB.\n\t */\n\tboolean isWhitespace();\n}\n"
    }, {
      "name" : "support/sniper/internal/AbstractSourceFragmentContext.java",
      "weight" : 166.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport static spoon.support.sniper.internal.ElementSourceFragment.findIndexOfNextFragment;\nimport static spoon.support.sniper.internal.ElementSourceFragment.filter;\nimport static spoon.support.sniper.internal.ElementSourceFragment.checkCollectionItems;\nimport static spoon.support.sniper.internal.ElementSourceFragment.isSpaceFragment;\n\n/**\n * Knows how to handle actually printed {@link CtElement} or it's part\n */\nabstract class AbstractSourceFragmentContext implements SourceFragmentContext {\n\tprotected final MutableTokenWriter mutableTokenWriter;\n\tprotected final List<SourceFragment> childFragments;\n\tprotected final ChangeResolver changeResolver;\n\t//no child fragment is current at the beginning\n\tprivate int childFragmentIdx = -1;\n\t//this list of skipped tokens, which writes spaces and EOL.\n\t//If next element is in origin, then use origin separator actions and ignore this list\n\t//If next element is new, then run collected separator actions to print DJPP separators\n\tprotected final List<Runnable> separatorActions = new ArrayList<>();\n\n\tprotected AbstractSourceFragmentContext(MutableTokenWriter mutableTokenWriter, ChangeResolver changeResolver, List<SourceFragment> childFragments) {\n\t\tthis.mutableTokenWriter = mutableTokenWriter;\n\t\tthis.changeResolver = changeResolver;\n\t\tthis.childFragments = childFragments;\n\t}\n\n\t@Override\n\tpublic void onPrintEvent(PrinterEvent event) {\n\t\tif (event instanceof TokenPrinterEvent) {\n\t\t\tTokenPrinterEvent tpe = (TokenPrinterEvent) event;\n\t\t\tif (tpe.getType().isTab()) {\n\t\t\t\t//TODO may be we should send origin tabs from origin sources too?\n\t\t\t\t//to have printed elements aligned same like origin sources and not like DJPP would like it\n\t\t\t\t//but may be it is not good idea\n\n\t\t\t\t//send all inc/dec tab to printer helper to have configured expected indentation\n\t\t\t\tevent.print(null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (tpe.getType().isWhiteSpace()) {\n\t\t\t\t//collect all DJPP separators for future use or ignore\n\t\t\t\tseparatorActions.add(() -> event.print(false));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint fragmentIndex = findIndexOfNextChildTokenOfEvent(event);\n\t\tif (fragmentIndex < 0) {\n\t\t\t/*\n\t\t\t * the token did not exist in origin sources. Print spaces made by DJPP\n\t\t\t * It can happen e.g. when type parameter like &lt;T&gt; was added. Then bracket tokens are not in origin sources\n\t\t\t */\n\t\t\tprintSpaces(-1);\n\t\t\tevent.print(false);\n\t\t\treturn;\n\t\t}\n\t\t//we have origin sources for this element\n\t\tif (event.getRole() == CtRole.COMMENT) {\n\t\t\t//note: DJPP sends comments in wrong order/wrong place.\n\t\t\t//so skip printing of this comment\n\t\t\t//comment will be printed at place where it belongs to - together with spaces\n\t\t\treturn;\n\t\t}\n\t\tonPrintFoundFragment(event, fragmentIndex);\n\t}\n\n\t/**\n\t * prints not modified or partially modified origin source fragment\n\t * @param event a pretty printer event\n\t * @param fragmentIndex a index of {@link SourceFragment} in scope of {@link #childFragments} of this context\n\t */\n\tprivate void onPrintFoundFragment(PrinterEvent event, int fragmentIndex) {\n\t\tprintSpaces(fragmentIndex);\n\t\tsetChildFragmentIdx(fragmentIndex);\n\t\tSourceFragment fragment = childFragments.get(fragmentIndex);\n\t\tevent.printSourceFragment(fragment, isFragmentModified(fragment));\n\t}\n\n\t/**\n\t * Prints spaces before fragment with index `fragmentIndex`\n\t * @param fragmentIndex index of fragment whose prefix spaces has to be printed or -1 if origin source fragment was not found\n\t */\n\tprotected void printSpaces(int fragmentIndex) {\n\t\tif (fragmentIndex < 0) {\n\t\t\t/*\n\t\t\t * the token did not exist in origin sources. Print spaces made by DJPP\n\t\t\t * It can happen e.g. when type parameter like &lt;T&gt; was added. Then bracket tokens are not in origin sources\n\t\t\t */\n\t\t\tprintStandardSpaces();\n\t\t} else {\n\t\t\tprintOriginSpacesUntilFragmentIndex(fragmentIndex);\n\t\t}\n\t}\n\n\t/**\n\t * @param fragment\n\t * @return true if at least part of `fragment` is modified.\n\t * \tfalse if whole `fragment` is not modified.\n\t * \tnull if it is not possible to detect it here. Then it will be detected later.\n\t */\n\tprotected Boolean isFragmentModified(SourceFragment fragment) {\n\t\tif (fragment instanceof TokenSourceFragment) {\n\t\t\tswitch (((TokenSourceFragment) fragment).getType()) {\n\t\t\t//we do not know the role of the identifier token, so we do not know whether it is modified or not\n\t\t\tcase IDENTIFIER:\n\t\t\t\treturn null;\n\t\t\tcase COMMENT:\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\t//all others are constant tokens, which cannot be modified\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t} else if (fragment instanceof ElementSourceFragment) {\n\t\t\treturn changeResolver.isRoleModified(((ElementSourceFragment) fragment).getRoleInParent());\n\t\t} else if (fragment instanceof CollectionSourceFragment) {\n\t\t\tCollectionSourceFragment csf = (CollectionSourceFragment) fragment;\n\t\t\tfor (SourceFragment sourceFragment : csf.getItems()) {\n\t\t\t\tBoolean modified = isFragmentModified(sourceFragment);\n\t\t\t\tif (modified != Boolean.FALSE) {\n\t\t\t\t\treturn modified;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Boolean.FALSE;\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected SourceFragment type \" + fragment.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * Prints origin whitespaces including comments which prefixes the fragment on index `index`,\n\t * starting with not yet processed spaces\n\t * @param index of non white space fragment\n\t */\n\tprotected void printOriginSpacesUntilFragmentIndex(int index) {\n\t\tprintOriginSpacesUntilFragmentIndex(childFragmentIdx + 1, index);\n\t}\n\n\t/**\n\t * Prints origin whitespaces including comments which prefixes the fragment on index `index`,\n\t * starting with fragment on `fromIndex`\n\t * @param fromIndex index of first processed fragment\n\t * @param toIndex index of first not processed fragment.\n\t */\n\tprotected void printOriginSpacesUntilFragmentIndex(int fromIndex, int toIndex) {\n\t\t//print all not yet printed comments which still exist in parent\n\t\tboolean canPrintSpace = true;\n\t\tboolean skipSpaceAfterDeletedElement = false;\n\t\tfor (int i = fromIndex; i < toIndex; i++) {\n\t\t\tSourceFragment fragment = childFragments.get(i);\n\t\t\tif (fragment instanceof ElementSourceFragment) {\n\t\t\t\tElementSourceFragment sourceFragment = (ElementSourceFragment) fragment;\n\t\t\t\tif (sourceFragment.getElement() instanceof CtComment) {\n\t\t\t\t\tCtComment comment = (CtComment) sourceFragment.getElement();\n\t\t\t\t\tif (changeResolver.isElementExists(comment)) {\n\t\t\t\t\t\t//comment still exist\n\t\t\t\t\t\tif (changeResolver.getChanges(comment).size() > 0) {\n\t\t\t\t\t\t\t//comment is modified print it normally\n\t\t\t\t\t\t\tmutableTokenWriter.writeComment(comment);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//comment is not modified write origin sources\n\t\t\t\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(fragment.getSourceCode());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we printed the comment, so we can print next space too\n\t\t\t\t\t\tcanPrintSpace = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//comment was remove\n\t\t\t\t\t\t//avoid printing of spaces between removed comments\n\t\t\t\t\t\tcanPrintSpace = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isSpaceFragment(fragment) && canPrintSpace) {\n\t\t\t\tif (!skipSpaceAfterDeletedElement) {\n\t\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(fragment.getSourceCode());\n\t\t\t\t} else {\n\t\t\t\t\tskipSpaceAfterDeletedElement = false;\n\t\t\t\t}\n\t\t\t\t//all whitespaces are in one fragment, so do not print next spaces without any comment in between\n\t\t\t\tcanPrintSpace = false;\n\t\t\t} else {\n\t\t\t\t//there are some non empty tokens, which were not printed (were removed from model)\n\t\t\t\t//do not print next space, which represents the separator between removed tokens and next token\n\t\t\t\tskipSpaceAfterDeletedElement = true;\n\t\t\t}\n\t\t}\n\t\tsetChildFragmentIdx(toIndex - 1);\n\t\tseparatorActions.clear();\n\t}\n\n\t/**\n\t * Remembers index of last processed fragment\n\t * @param idx index of last processed fragment\n\t */\n\tprotected void setChildFragmentIdx(int idx) {\n\t\tchildFragmentIdx = idx;\n\t}\n\n\t/**\n\t * @return true if there is more child tokens to be processed.\n\t * \tfalse if all tokens were processed\n\t */\n\tprotected boolean hasNextChildToken() {\n\t\treturn childFragmentIdx + 1 < childFragments.size();\n\t}\n\n\t/**\n\t * looks for next child token which contains exactly same token\n\t * @param token String of searched token\n\t * @return index of first same token or -1 if not found\n\t */\n\tprotected int findIndexOfNextChildTokenByValue(String token) {\n\t\treturn findIndexOfNextFragment(childFragments, childFragmentIdx + 1, fragment -> Objects.equals(token, fragment.getSourceCode()));\n\t}\n\t/**\n\t * looks for next child token which contains expected token type\n\t * @param type {@link TokenType} of search token\n\t * @return index of token with same type or -1 if not found\n\t */\n\tprotected int findIndexOfNextChildTokenByType(TokenType type) {\n\t\treturn findIndexOfNextFragment(childFragments, childFragmentIdx + 1, filter(TokenSourceFragment.class, fragment -> type == fragment.getType()));\n\t}\n\t/**\n\t * looks for next child token which has role `role`\n\t * @param role {@link CtRole} of searched token\n\t * @return index of first token with same role or -1 if not found\n\t */\n\tprotected int findIndexOfNextChildTokenOfRole(int start, CtRole role) {\n\t\treturn findIndexOfNextFragment(childFragments, start, checkCollectionItems(filter(ElementSourceFragment.class, elementFragment -> elementFragment.getRoleInParent() == role)));\n\t}\n\n\t/**\n\t * looks for next child token, which has element `element\n\t * @param element element of searched token\n\t * @return index of first token with same element or -1 if not found\n\t */\n\tprotected int findIndexOfNextChildTokenOfElement(SourcePositionHolder element) {\n\t\treturn findIndexOfNextFragment(childFragments, childFragmentIdx + 1, checkCollectionItems(filter(ElementSourceFragment.class, elementFragment -> elementFragment.getElement() == element)));\n\t}\n\n\t/**\n\t * looks for next child token, which fits to {@link PrinterEvent} `event`\n\t * @param event {@link PrinterEvent} whose token it searches for\n\t * @return index of first token which fits to {@link PrinterEvent} or -1 if not found\n\t */\n\tprotected int findIndexOfNextChildTokenOfEvent(PrinterEvent event) {\n\t\tCtRole role = event.getRole();\n\t\tif (role != null) {\n\t\t\tif (role == CtRole.COMMENT) {\n\t\t\t\treturn findIndexOfNextChildTokenOfElement(event.getElement());\n\t\t\t}\n\t\t\treturn findIndexOfNextChildTokenOfRole(childFragmentIdx + 1, role);\n\t\t}\n\t\tif (event instanceof TokenPrinterEvent) {\n\t\t\tTokenPrinterEvent tpe = (TokenPrinterEvent) event;\n\t\t\tif (tpe.getType() == TokenType.IDENTIFIER) {\n\t\t\t\treturn findIndexOfNextChildTokenByType(TokenType.IDENTIFIER);\n\t\t\t}\n\t\t\treturn findIndexOfNextChildTokenByValue(event.getToken());\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected PrintEvent: \" + event.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * print all tokens, which represents white spaces\n\t * and then forget them, so we can collect next white spaces\n\t */\n\tprotected void printStandardSpaces() {\n\t\tfor (Runnable runnable : separatorActions) {\n\t\t\trunnable.run();\n\t\t}\n\t\tseparatorActions.clear();\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/TokenType.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.visitor.TokenWriter;\n\n/**\n * Type of {@link TokenSourceFragment} token.\n * Note: These types mirrors the methods of {@link TokenWriter}\n */\npublic enum TokenType {\n\n\tSEPARATOR(false, false),\n\tOPERATOR(false, false),\n\tLITERAL(false, false),\n\tKEYWORD(false, false),\n\tIDENTIFIER(false, false),\n\tCODE_SNIPPET(false, false),\n\tCOMMENT(false, false),\n\tNEW_LINE(true, false),\n\tINC_TAB(true, true),\n\tDEC_TAB(true, true),\n\tSPACE(true, false);\n\n\tprivate final boolean whiteSpace;\n\tprivate final boolean tab;\n\n\tTokenType(boolean whiteSpace, boolean tab) {\n\t\tthis.whiteSpace = whiteSpace;\n\t\tthis.tab = tab;\n\t}\n\tboolean isWhiteSpace() {\n\t\treturn whiteSpace;\n\t}\n\tpublic boolean isTab() {\n\t\treturn tab;\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/MutableTokenWriter.java",
      "weight" : 130.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.visitor.DefaultTokenWriter;\nimport spoon.reflect.visitor.TokenWriter;\n\n/**\n * {@link TokenWriter} which simply delegates\n * to {@link DefaultTokenWriter} with the decorator pattern, until {@link #setMuted(boolean)} is called with true\n * Then all tokens are ignored.\n */\npublic class MutableTokenWriter implements TokenWriter {\n\tprivate final TokenWriter delegate;\n\tprivate boolean muted = false;\n\n\tpublic MutableTokenWriter(Environment env) {\n\t\tthis.delegate = new DefaultTokenWriter(new DirectPrinterHelper(env));\n\t}\n\n\t/**\n\t * @return true if tokens are ignored. false if they are forwarded to `delegate`\n\t */\n\tpublic boolean isMuted() {\n\t\treturn muted;\n\t}\n\n\t/**\n\t * @param muted true if tokens are ignored. false if they are forwarded to `delegate`\n\t */\n\tpublic void setMuted(boolean muted) {\n\t\tthis.muted = muted;\n\t}\n\n\t@Override\n\tpublic TokenWriter writeSeparator(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeSeparator(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeOperator(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeOperator(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeLiteral(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeLiteral(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeKeyword(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeKeyword(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeIdentifier(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeIdentifier(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeCodeSnippet(String token) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeCodeSnippet(token);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeComment(CtComment comment) {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeComment(comment);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter writeln() {\n\t\tif (isMuted()) {\n\t\t\t//if new line is muted, then direct printer helper already wrote EOL and indentation\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeln();\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter incTab() {\n\t\tif (isMuted()) {\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.incTab();\n\t\treturn this;\n\t}\n\t@Override\n\tpublic TokenWriter decTab() {\n\t\tif (isMuted()) {\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.decTab();\n\t\treturn this;\n\t}\n\t@Override\n\tpublic DirectPrinterHelper getPrinterHelper() {\n\t\treturn (DirectPrinterHelper) delegate.getPrinterHelper();\n\t}\n\t@Override\n\tpublic void reset() {\n\t\tif (isMuted()) {\n\t\t\treturn;\n\t\t}\n\t\tdelegate.reset();\n\t}\n\t@Override\n\tpublic TokenWriter writeSpace() {\n\t\tif (isMuted()) {\n\t\t\tgetPrinterHelper().setShouldWriteTabs(false);\n\t\t\treturn this;\n\t\t}\n\t\tdelegate.writeSpace();\n\t\treturn this;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn delegate.toString();\n\t}\n}\n"
    }, {
      "name" : "support/sniper/internal/SourceFragmentContext.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper.internal;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\n/**\n * Knows how to handle actually printed {@link CtElement} or its part\n */\npublic interface SourceFragmentContext {\n\t/**\n\t * Called when {@link DefaultJavaPrettyPrinter} starts an operation\n\t * @param event the {@link DefaultJavaPrettyPrinter} event\n\t */\n\tvoid onPrintEvent(PrinterEvent event);\n\n\t/**\n\t * Called when printing using this context is going to finish\n\t */\n\tvoid onFinished();\n\n\t/**\n\t * @return true if this context can handle `role`\n\t */\n\tboolean matchesPrinterEvent(PrinterEvent event);\n}\n"
    }, {
      "name" : "support/sniper/SniperJavaPrettyPrinter.java",
      "weight" : 258.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.sniper;\n\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\n\nimport spoon.OutputType;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.reflect.visitor.TokenWriter;\nimport spoon.support.Experimental;\nimport spoon.support.modelobs.ChangeCollector;\nimport spoon.support.sniper.internal.ChangeResolver;\nimport spoon.support.sniper.internal.CollectionSourceFragment;\nimport spoon.support.sniper.internal.ElementPrinterEvent;\nimport spoon.support.sniper.internal.ElementSourceFragment;\nimport spoon.support.sniper.internal.MutableTokenWriter;\nimport spoon.support.sniper.internal.PrinterEvent;\nimport spoon.support.sniper.internal.SourceFragment;\nimport spoon.support.sniper.internal.SourceFragmentContext;\nimport spoon.support.sniper.internal.SourceFragmentContextList;\nimport spoon.support.sniper.internal.SourceFragmentContextNormal;\nimport spoon.support.sniper.internal.SourceFragmentContextPrettyPrint;\nimport spoon.support.sniper.internal.SourceFragmentContextSet;\nimport spoon.support.sniper.internal.TokenPrinterEvent;\nimport spoon.support.sniper.internal.TokenType;\nimport spoon.support.sniper.internal.TokenWriterProxy;\n\n/**\n * {@link PrettyPrinter} implementation, which copies as much as possible from the origin sources\n * and tries to only print the changed elements.\n */\n@Experimental\npublic class SniperJavaPrettyPrinter extends DefaultJavaPrettyPrinter {\n\n\tprivate final MutableTokenWriter mutableTokenWriter;\n\tprivate ChangeResolver changeResolver;\n\tprivate final Deque<SourceFragmentContext> sourceFragmentContextStack = new ArrayDeque<>();\n\n\t/**\n\t * Creates a new {@link PrettyPrinter} which copies origin sources and prints only changes.\n\t */\n\tpublic SniperJavaPrettyPrinter(Environment env) {\n\t\tsuper(env);\n\t\t// required for sniper mode\n\t\tenv.useTabulations(true);\n\t\tenv.setCommentEnabled(true);\n\t\tenv.setOutputType(OutputType.COMPILATION_UNITS);\n\t\t//create a TokenWriter which can be configured to ignore tokens coming from DJPP\n\t\tmutableTokenWriter = new MutableTokenWriter(env);\n\t\t//wrap that TokenWriter to listen on all incoming events and set wrapped version to DJPP\n\t\tsetPrinterTokenWriter(createTokenWriterListener(mutableTokenWriter));\n\t}\n\n\t/**\n\t * @return {@link ChangeCollector} registered in spoon environment\n\t */\n\tprivate ChangeCollector getChangeCollector() {\n\t\tChangeCollector changeCollector = ChangeCollector.getChangeCollector(env);\n\t\tif (changeCollector == null) {\n\t\t\tthrow new SpoonException(ChangeCollector.class.getSimpleName() + \" was not attached to the Environment\");\n\t\t}\n\t\treturn changeCollector;\n\t}\n\n\t/**\n\t * @return new or cached instance of root ChangeResolver\n\t */\n\tprivate ChangeResolver getChangeResolver() {\n\t\tif (changeResolver == null) {\n\t\t\tchangeResolver = new ChangeResolver(getChangeCollector(), null);\n\t\t}\n\t\treturn changeResolver;\n\t}\n\n\t/**\n\t * wrap a `tokenWriter` by a proxy which intercepts all {@link TokenWriter} writeXxx(String) calls\n\t * and calls {@link #onTokenWriterWrite(TokenType, String, CtComment, Runnable)}\n\t * where {@link Runnable} can be used to invoke same event on the wrapped {@link TokenWriter}\n\t * @param tokenWriter to be wrapped {@link TokenWriter}\n\t * @return a proxy of {@link TokenWriter}\n\t */\n\tprivate TokenWriter createTokenWriterListener(TokenWriter tokenWriter) {\n\t\treturn new TokenWriterProxy(this::onTokenWriterWrite, tokenWriter);\n\t}\n\n\t@Override\n\tpublic void calculate(CtCompilationUnit sourceCompilationUnit, List<CtType<?>> types) {\n\t\t//use line separator of origin source file\n\t\tsetLineSeparator(detectLineSeparator(sourceCompilationUnit.getOriginalSourceCode()));\n\t\tsuper.calculate(sourceCompilationUnit, types);\n\t}\n\n\tprivate static final String CR = \"\\r\";\n\tprivate static final String CRLF = \"\\r\\n\";\n\tprivate static final String LF = \"\\n\";\n\n\t/**\n\t * Detect line separator used in origin code\n\t * @return character sequence used as line separator in `text`\n\t */\n\tprivate String detectLineSeparator(String text) {\n\t\tif (text != null) {\n\t\t\tint len = text.length();\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tchar c = text.charAt(i);\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\treturn LF;\n\t\t\t\t} else if (c == '\\r') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (i < len && text.charAt(i) == '\\n') {\n\t\t\t\t\t\treturn CRLF;\n\t\t\t\t\t}\n\t\t\t\t\treturn CR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn System.getProperty(\"line.separator\");\n\t}\n\n\t@Override\n\tpublic DefaultJavaPrettyPrinter writeHeader(List<CtType<?>> types, Collection<CtImport> imports) {\n\t\t//run compilation unit header using pretty printer. The sniper mode is not supported for header yet.\n\t\trunInContext(SourceFragmentContextPrettyPrint.INSTANCE,\n\t\t\t\t() -> super.writeHeader(types, imports));\n\t\treturn this;\n\t}\n\n\t@Override\n\tprotected void printTypes(List<CtType<?>> types) {\n\t\tElementSourceFragment rootFragment = sourceCompilationUnit.getOriginalSourceFragment();\n\t\trunInContext(new SourceFragmentContextList(mutableTokenWriter, null, rootFragment.getChildrenFragments(), getChangeResolver()),\n\t\t\t\t() -> {\n\t\t\t\t\tfor (CtType<?> t : types) {\n\t\t\t\t\t\tscan(t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\t/**\n\t * Called for each printed token\n\t * @param tokenType the type of {@link TokenWriter} method\n\t * @param token the actual token value. It may be null for some `tokenWriterMethodName`\n\t * @param comment the comment when `tokenType` == `COMMENT`\n\t * @param printAction the executor of the action, we are listening for. Call it send token to output\n\t */\n\tvoid onTokenWriterWrite(TokenType tokenType, String token, CtComment comment, Runnable printAction) {\n\t\tonPrintEvent(new TokenPrinterEvent(tokenType, token, comment) {\n\t\t\t@Override\n\t\t\tpublic void print(Boolean muted) {\n\t\t\t\trunInMutedState(muted, printAction);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void printSourceFragment(SourceFragment fragment, Boolean isModified) {\n\t\t\t\tboolean isCollectionStarted = false;\n\t\t\t\tif (fragment instanceof CollectionSourceFragment) {\n\t\t\t\t\tCollectionSourceFragment csf = (CollectionSourceFragment) fragment;\n\t\t\t\t\t//we started scanning of collection of elements\n\t\t\t\t\tSourceFragmentContext listContext = csf.isOrdered()\n\t\t\t\t\t\t\t? new SourceFragmentContextList(mutableTokenWriter, null, csf.getItems(), changeResolver)\n\t\t\t\t\t\t\t: new SourceFragmentContextSet(mutableTokenWriter, null, csf.getItems(), changeResolver);\n\t\t\t\t\t//push the context of this collection\n\t\t\t\t\tsourceFragmentContextStack.push(listContext);\n\t\t\t\t\tisCollectionStarted = true;\n\t\t\t\t}\n\t\t\t\tif (isModified == null || isModified) {\n\t\t\t\t\t//print origin token\n\t\t\t\t\tprintAction.run();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(fragment.getSourceCode());\n\t\t\t\tif (isCollectionStarted) {\n\t\t\t\t\tmutableTokenWriter.setMuted(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * Called whenever {@link DefaultJavaPrettyPrinter} scans/prints an element\n\t */\n\t@Override\n\tpublic SniperJavaPrettyPrinter scan(CtElement element) {\n\t\tif (element != null) {\n\t\t\tCtRole role = getRoleInCompilationUnit(element);\n\t\t\tonPrintEvent(new ElementPrinterEvent(role, element) {\n\t\t\t\t@Override\n\t\t\t\tpublic void print(Boolean muted) {\n\t\t\t\t\tsuperScanInContext(element, SourceFragmentContextPrettyPrint.INSTANCE, muted);\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void printSourceFragment(SourceFragment fragment, Boolean isModified) {\n\t\t\t\t\tscanInternal(role, element, fragment, isModified);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate CtRole getRoleInCompilationUnit(CtElement element) {\n\t\tCtRole role = element.getRoleInParent();\n\t\tif (role == CtRole.CONTAINED_TYPE) {\n\t\t\trole = CtRole.DECLARED_TYPE;\n\t\t}\n\t\treturn role;\n\t}\n\n\t/**\n\t * Called whenever {@link DefaultJavaPrettyPrinter} scans/prints an element or writes a token\n\t */\n\tprivate void onPrintEvent(PrinterEvent event) {\n\t\tSourceFragmentContext sfc = detectCurrentContext(event);\n\t\tif (sfc == null) {\n\t\t\tthrow new SpoonException(\"Missing SourceFragmentContext\");\n\t\t}\n\t\t//there is an context let it handle scanning\n\t\tif (mutableTokenWriter.isMuted()) {\n\t\t\t//it is already muted by an parent. Simply scan and ignore all tokens,\n\t\t\tevent.print(null);\n\t\t\treturn;\n\t\t}\n\t\t//let context handle the event\n\t\tsfc.onPrintEvent(event);\n\t}\n\n\t/**\n\t * Checks if `event` can be still handled by the current context.\n\t * If not then finish current context and enter parent context\n\t * @param event a to be processed {@link PrinterEvent}\n\t * @return context which can be used to process `event`\n\t */\n\tprivate SourceFragmentContext detectCurrentContext(PrinterEvent event) {\n\t\tSourceFragmentContext sfc;\n\t\twhile ((sfc = sourceFragmentContextStack.peek()) != null && sfc.matchesPrinterEvent(event) == false) {\n\t\t\t//this context handles only subset of roles, which just finished\n\t\t\t//leave it and return back to parent context\n\t\t\tsourceFragmentContextStack.pop();\n\t\t\tsfc.onFinished();\n\t\t}\n\t\treturn sfc;\n\t}\n\n\t/**\n\t * scans the `element` which exist on `role` in it's parent\n\t * @param role {@link CtRole} of `element` in scope of it's parent\n\t * @param element a scanned element\n\t * @param fragment origin source fragment of element\n\t * @param isFragmentModified true if any part of `fragment` is modified, false if whole fragment is not modified, null if caller doesn't know\n\t */\n\tprivate void scanInternal(CtRole role, CtElement element, SourceFragment fragment, Boolean isFragmentModified) {\n\t\tif (mutableTokenWriter.isMuted()) {\n\t\t\tthrow new SpoonException(\"Unexpected state of sniper pretty printer. TokenWriter is muted.\");\n\t\t}\n\t\t//it is not muted yet, so this element or any sibling is modified\n\t\tif (fragment == null) {\n\t\t\tthrow new SpoonException(\"Missing source fragment. Call PrintEvent#print instead.\");\n\t\t}\n\t\t//we have sources of fragment\n\t\tif (fragment instanceof CollectionSourceFragment) {\n\t\t\tCollectionSourceFragment csf = (CollectionSourceFragment) fragment;\n\t\t\t//we started scanning of collection of elements\n\t\t\tSourceFragmentContext listContext = csf.isOrdered()\n\t\t\t\t\t? new SourceFragmentContextList(mutableTokenWriter, element, csf.getItems(), changeResolver)\n\t\t\t\t\t: new SourceFragmentContextSet(mutableTokenWriter, element, csf.getItems(), changeResolver);\n\t\t\t//push the context of this collection\n\t\t\tsourceFragmentContextStack.push(listContext);\n\t\t\t//and scan first element of that collection again in new context of that collection\n\t\t\tif (isFragmentModified == Boolean.FALSE) {\n\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(fragment.getSourceCode());\n\t\t\t\t//and mute the token writer and let DJPP scan it and ignore everything\n\t\t\t\tmutableTokenWriter.setMuted(true);\n\t\t\t\t//TODO check if DJPP needs this call somewhere (because of some state)... may be we can skip this scan completely??\n\t\t\t\tscan(element);\n\t\t\t\t//and keep it muted until SourceFragmentContextList is finished\n\t\t\t} else {\n\t\t\t\tscan(element);\n\t\t\t}\n\t\t} else if (fragment instanceof ElementSourceFragment) {\n\t\t\tElementSourceFragment sourceFragment = (ElementSourceFragment) fragment;\n\t\t\t//it is fragment with single value\n\t\t\tChangeResolver changeResolver = null;\n\t\t\tif (isFragmentModified == null) {\n\t\t\t\tchangeResolver = new ChangeResolver(getChangeCollector(), element);\n\t\t\t\tisFragmentModified = changeResolver.hasChangedRole();\n\t\t\t}\n\t\t\tif (isFragmentModified == false) {\n\t\t\t\t//nothing is changed, we can print origin sources of this element\n\t\t\t\tmutableTokenWriter.getPrinterHelper().directPrint(fragment.getSourceCode());\n\t\t\t\t//and mute the token writer and let DJPP scan it and ignore everything\n\t\t\t\t//TODO check if DJPP needs this call somewhere (because of some state)... may be we can skip this scan completely??\n\t\t\t\tsuperScanInContext(element, SourceFragmentContextPrettyPrint.INSTANCE, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//check what roles of this element are changed\n\t\t\tif (changeResolver == null) {\n\t\t\t\tchangeResolver = new ChangeResolver(getChangeCollector(), element);\n\t\t\t}\n\t\t\t//changeResolver.hasChangedRole() is false when element is added\n\t\t\t//something is changed in this element\n\t\t\tsuperScanInContext(element, new SourceFragmentContextNormal(mutableTokenWriter, sourceFragment, changeResolver), false);\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unsupported fragment type: \" + fragment.getClass());\n\t\t}\n\t}\n\n\t/**\n\t * Call normal java printing in defined `context`\n\t * @param element to be printed element\n\t * @param context to be used context\n\t * @param muted whether it has to be processed using\n\t * \ttrue - muted,\n\t * \tfalse - not muted\n\t * \tnull - same like before\n\t */\n\tprivate void superScanInContext(CtElement element, SourceFragmentContext context, Boolean muted) {\n\t\trunInContext(context,\n\t\t\t\t() -> runInMutedState(muted,\n\t\t\t\t\t\t() -> super.scan(element)));\n\t}\n\n\t/**\n\t * Run `code` in scope of `context`\n\t * @param context a to be entered `context`\n\t * @param code a to be processed {@link Runnable}\n\t */\n\tprivate void runInContext(SourceFragmentContext context, Runnable code) {\n\t\tsourceFragmentContextStack.push(context);\n\t\ttry {\n\t\t\tcode.run();\n\t\t} finally {\n\t\t\t//remove `context` and all it's child contexts\n\t\t\twhile (true) {\n\t\t\t\tif (sourceFragmentContextStack.isEmpty()) {\n\t\t\t\t\tthrow new SpoonException(\"Inconsistent sourceFragmentContextStack\");\n\t\t\t\t}\n\t\t\t\tSourceFragmentContext c = sourceFragmentContextStack.pop();\n\t\t\t\tc.onFinished();\n\t\t\t\tif (c == context) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Run code using {@link MutableTokenWriter} in defined state.\n\t * After this function leaves, the muted status is restored.\n\t * @param muted required muted status\n\t * @param code to be processed {@link Runnable}\n\t */\n\tprivate void runInMutedState(Boolean muted, Runnable code) {\n\t\tboolean originMuted = mutableTokenWriter.isMuted();\n\t\tif (muted == null) {\n\t\t\tmuted = originMuted;\n\t\t}\n\t\ttry {\n\t\t\tmutableTokenWriter.setMuted(muted);\n\t\t\tcode.run();\n\t\t} finally {\n\t\t\t//assure that muted status did not changed in between\n\t\t\tif (mutableTokenWriter.isMuted() != muted) {\n\t\t\t\tif (mutableTokenWriter.isMuted()) {\n\t\t\t\t\tthrow new SpoonException(\"Unexpected state: Token writer is muted after scanning\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new SpoonException(\"Unexpected state: Token writer is not muted after scanning\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutableTokenWriter.setMuted(originMuted);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/SpoonClassNotFoundException.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.SpoonException;\n\n/** Spoon-specific ClassNotFoundException (mostly encapsulates a ClassNotFoundException or a NoClassDefFoundError\n * as a runtime exception)\n */\npublic class SpoonClassNotFoundException extends SpoonException {\n\tpublic SpoonClassNotFoundException(String msg, Throwable cnfe) {\n\t\tsuper(msg, cnfe);\n\t}\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic SpoonClassNotFoundException() {\n\t}\n\n\tpublic SpoonClassNotFoundException(String msg) {\n\t\tsuper(msg);\n\t}\n}\n"
    }, {
      "name" : "support/OutputDestinationHandler.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\nimport java.io.File;\nimport java.nio.file.Path;\n\npublic interface OutputDestinationHandler {\n\n\tPath getOutputPath(CtModule module, CtPackage pack, CtType type);\n\n\tFile getDefaultOutputDirectory();\n}\n"
    }, {
      "name" : "support/QueueProcessingManager.java",
      "weight" : 107.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.SpoonException;\nimport spoon.processing.ProcessInterruption;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.compiler.SpoonProgress;\nimport spoon.support.visitor.ProcessingVisitor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n/**\n * This processing manager applies the processors one by one from the given root element.\n * for p : processors\n *   p.process(el)\n * Default processor in Spoon\n */\npublic class QueueProcessingManager implements ProcessingManager {\n\tProcessor<?> current;\n\n\tFactory factory;\n\n\tQueue<Processor<?>> processors;\n\n\tProcessingVisitor visitor;\n\n\t/**\n\t * Creates a new processing manager that maintains a queue of processors to\n\t * be applied to a given factory.\n\t *\n\t * @param factory\n\t * \t\tthe factory on which the processing applies (contains the\n\t * \t\tmeta-model)\n\t */\n\tpublic QueueProcessingManager(Factory factory) {\n\t\tsetFactory(factory);\n\t}\n\n\t@Override\n\tpublic void addProcessor(Class<? extends Processor<?>> type) {\n\t\ttry {\n\t\t\tProcessor<?> p = type.newInstance();\n\t\t\taddProcessor(p);\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(\"Unable to instantiate processor \\\"\" + type.getName() + \"\\\" - Your processor should have a constructor with no arguments\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean addProcessor(Processor<?> p) {\n\t\tp.setFactory(getFactory());\n\t\treturn getProcessors().add(p);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void addProcessor(String qualifiedName) {\n\t\ttry {\n\t\t\taddProcessor((Class<? extends Processor<?>>) getFactory().getEnvironment().getInputClassLoader().loadClass(qualifiedName));\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new SpoonException(\"Unable to load processor \\\"\" + qualifiedName + \"\\\" - Check your classpath.\", e);\n\t\t}\n\t}\n\n\tpublic Processor<?> getCurrentProcessor() {\n\t\treturn current;\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic Queue<Processor<?>> getProcessors() {\n\t\tif (processors == null) {\n\t\t\tprocessors = new LinkedList<>();\n\t\t}\n\t\treturn processors;\n\t}\n\n\tprotected ProcessingVisitor getVisitor() {\n\t\tif (visitor == null) {\n\t\t\tvisitor = new ProcessingVisitor(getFactory());\n\t\t}\n\t\treturn visitor;\n\t}\n\n\t@Override\n\tpublic void process(Collection<? extends CtElement> elements) {\n\t\tProcessor<?> p;\n\t\t// copy so that one can reuse the processing manager\n\t\t// among different processing steps\n\t\tQueue<Processor<?>> processors = new LinkedList<>(getProcessors());\n\t\tif (factory.getEnvironment().getSpoonProgress() != null) {\n\t\t\tfactory.getEnvironment().getSpoonProgress().start(SpoonProgress.Process.PROCESS);\n\t\t}\n\t\tint i = 0;\n\t\twhile ((p = processors.poll()) != null) {\n\t\t\ttry {\n\t\t\t\tgetFactory().getEnvironment().reportProgressMessage(p.getClass().getName());\n\t\t\t\tcurrent = p;\n\t\t\t\tp.init(); // load the properties\n\t\t\t\tp.process();\n\t\t\t\tfor (CtElement e : new ArrayList<>(elements)) {\n\t\t\t\t\tgetVisitor().setProcessor(p);\n\t\t\t\t\tgetVisitor().scan(e);\n\t\t\t\t}\n\t\t\t} catch (ProcessInterruption ignore) {\n\t\t\t} finally {\n\t\t\t\tp.processingDone();\n\t\t\t\tif (factory.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\t\tfactory.getEnvironment().getSpoonProgress().step(SpoonProgress.Process.PROCESS, p.getClass().getName(), ++i, getProcessors().size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (factory.getEnvironment().getSpoonProgress() != null) {\n\t\t\tfactory.getEnvironment().getSpoonProgress().end(SpoonProgress.Process.PROCESS);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void process(CtElement element) {\n\t\tList<CtElement> l = new ArrayList<>();\n\t\tl.add(element);\n\t\tprocess(l);\n\t}\n\n\t@Override\n\tpublic void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t\tfactory.getEnvironment().setManager(this);\n\t}\n\n}\n"
    }, {
      "name" : "support/gui/SpoonObjectFieldsTable.java",
      "weight" : 116.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.gui;\n\n\nimport java.awt.BorderLayout;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.table.AbstractTableModel;\nimport spoon.Launcher;\n\n\npublic class SpoonObjectFieldsTable extends JFrame {\n\tpublic class SpoonObjectTableModel extends AbstractTableModel {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\ttransient List<Field> field;\n\n\t\ttransient Object o;\n\n\t\tpublic SpoonObjectTableModel(Object o) {\n\n\t\t\tthis.o = o;\n\t\t\tfield = new ArrayList<>();\n\n\t\t\tscanFields(o.getClass());\n\t\t}\n\n\t\t@Override\n\t\tpublic int getColumnCount() {\n\t\t\treturn columnsName.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getColumnName(int column) {\n\t\t\treturn columnsName[column];\n\t\t}\n\n\t\t@Override\n\t\tpublic int getRowCount() {\n\t\t\treturn field.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getValueAt(int rowIndex, int columnIndex) {\n\t\t\tField m = field.get(rowIndex);\n\t\t\tswitch (columnIndex) {\n\t\t\tcase (0):\n\t\t\t\treturn m.getName();\n\t\t\tcase (1):\n\t\t\t\treturn m.getType().getCanonicalName();\n\t\t\tcase (2):\n\t\t\t\ttry {\n\t\t\t\t\tObject val = m.get(o);\n\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\treturn val.getClass().getCanonicalName();\n\t\t\t\t\t}\n\t\t\t\t} catch (IllegalArgumentException | IllegalAccessException e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase (3):\n\t\t\t\ttry {\n\t\t\t\t\treturn m.get(o);\n\t\t\t\t} catch (IllegalArgumentException | IllegalAccessException e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic void scanFields(Class<?> c) {\n\t\t\tfor (Field f : c.getDeclaredFields()) {\n\t\t\t\tf.setAccessible(true);\n\t\t\t\tif (!Modifier.isStatic(f.getModifiers())) {\n\t\t\t\t\tfield.add(f);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c.getSuperclass() != null) {\n\t\t\t\tscanFields(c.getSuperclass());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static final String[] columnsName = {\n\t\t\t\"Name\", \"FieldType\", \"currentType\", \"Value\"\n\t};\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate JPanel jContentPane = null;\n\n\tprivate JScrollPane jScrollPane = null;\n\n\tprivate JTable jTable = null;\n\n\tprivate transient  Object o;\n\n\t/**\n\t * This is the default constructor\n\t */\n\tpublic SpoonObjectFieldsTable(Object o) {\n\t\tthis.o = o;\n\t\tinitialize();\n\t}\n\n\t/**\n\t * This method initializes jContentPane\n\t *\n\t * @return javax.swing.JPanel\n\t */\n\tprivate JPanel getJContentPane() {\n\t\tif (jContentPane == null) {\n\t\t\tjContentPane = new JPanel();\n\t\t\tjContentPane.setLayout(new BorderLayout());\n\t\t\tjContentPane.add(getJScrollPane(), java.awt.BorderLayout.CENTER);\n\t\t}\n\t\treturn jContentPane;\n\t}\n\n\t/**\n\t * This method initializes jScrollPane\n\t *\n\t * @return javax.swing.JScrollPane\n\t */\n\tprivate JScrollPane getJScrollPane() {\n\t\tif (jScrollPane == null) {\n\t\t\tjScrollPane = new JScrollPane();\n\t\t\tjScrollPane.setViewportView(getJTable());\n\t\t}\n\t\treturn jScrollPane;\n\t}\n\n\t/**\n\t * This method initializes jTable\n\t *\n\t * @return javax.swing.JTable\n\t */\n\tprivate JTable getJTable() {\n\t\tif (jTable == null) {\n\t\t\tjTable = new JTable(new SpoonObjectTableModel(o));\n\t\t}\n\t\treturn jTable;\n\t}\n\n\t/**\n\t * This method initializes this\n\t *\n\t * @return void\n\t */\n\tprivate void initialize() {\n\t\tthis.setSize(320, 240);\n\t\tthis.setLocation((getGraphicsConfiguration().getDevice().getDisplayMode().getWidth() - getWidth()) / 2,\n\t\t\t\t(getGraphicsConfiguration().getDevice().getDisplayMode().getHeight() - getHeight()) / 2);\n\t\tthis.setContentPane(getJContentPane());\n\t\tthis.setTitle(o.getClass().getSimpleName());\n\t\tthis.setVisible(true);\n\t\tthis.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n\t}\n\n}\n\n"
    }, {
      "name" : "support/gui/SpoonTreeBuilder.java",
      "weight" : 66.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.gui;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtScanner;\n\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class SpoonTreeBuilder extends CtScanner {\n\tDeque<DefaultMutableTreeNode> nodes;\n\n\tDefaultMutableTreeNode root;\n\n\tpublic SpoonTreeBuilder() {\n\t\troot = new DefaultMutableTreeNode(\"Spoon Tree Root\");\n\t\tnodes = new ArrayDeque<>();\n\t\tnodes.push(root);\n\t}\n\n\tprivate void createNode(Object o, CtRole roleInParent) {\n\t\tString prefix = roleInParent == null ? \"\" : roleInParent.getCamelCaseName() + \": \";\n\t\tDefaultMutableTreeNode node = new DefaultMutableTreeNode(o) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\tprivate String getASTNodeName() {\n\t\t\t\t// the end user needs to know the interface, not the implementation\n\t\t\t\treturn getUserObject().getClass().getSimpleName().replaceAll(\"Impl$\", \"\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\tString nodeName;\n\t\t\t\tif (getUserObject() instanceof CtNamedElement) {\n\t\t\t\t\tnodeName = getASTNodeName()\n\t\t\t\t\t\t\t+ \" - \"\n\t\t\t\t\t\t\t+ ((CtNamedElement) getUserObject())\n\t\t\t\t\t\t\t.getSimpleName();\n\t\t\t\t} else {\n\t\t\t\t\tString objectRepresentation;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tobjectRepresentation = getUserObject().toString();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tobjectRepresentation = \"Failed:\" + e.getMessage();\n\t\t\t\t\t}\n\t\t\t\t\tnodeName = getASTNodeName() + \" - \"\t+ objectRepresentation;\n\t\t\t\t}\n\t\t\t\treturn prefix + nodeName;\n\t\t\t}\n\t\t};\n\t\tnodes.peek().add(node);\n\t\tnodes.push(node);\n\t}\n\n\tprivate CtRole roleInParent;\n\t@Override\n\tpublic void scan(CtRole role, CtElement element) {\n\t\troleInParent = role;\n\t\tsuper.scan(role, element);\n\t}\n\n\t@Override\n\tpublic void enter(CtElement element) {\n\t\tcreateNode(element, roleInParent);\n\t\tsuper.enter(element);\n\t}\n\n\t@Override\n\tpublic void exit(CtElement element) {\n\t\tnodes.pop();\n\t\tsuper.exit(element);\n\t}\n\n\tpublic DefaultMutableTreeNode getRoot() {\n\t\treturn root;\n\t}\n\n}\n"
    }, {
      "name" : "support/gui/SpoonModelTree.java",
      "weight" : 282.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.gui;\n\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport javax.swing.JFileChooser;\nimport javax.swing.JFrame;\nimport javax.swing.JMenuItem;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JPopupMenu;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTree;\nimport javax.swing.SwingUtilities;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport javax.swing.tree.TreeNode;\nimport javax.swing.tree.TreePath;\n\nimport spoon.Launcher;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.SerializationModelStreamer;\n\npublic class SpoonModelTree extends JFrame implements KeyListener,\n\t\tMouseListener {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tEnumeration<?> enume;\n\n\tprivate Factory factory;\n\n\tprivate JPanel jContentPane = null;\n\n\tprivate JScrollPane jScrollPane = null;\n\n\tprivate JTree jTree = null;\n\n\tJPopupMenu menu;\n\n\tprivate DefaultMutableTreeNode root; // @jve:decl-index=0:visual-constraint=\"207,57\"\n\n\tString searchValue;\n\n\t/**\n\t * This is the default constructor\n\t */\n\tpublic SpoonModelTree(Factory factory) {\n\t\tSpoonTreeBuilder cst = new SpoonTreeBuilder();\n\t\tcst.scan(factory.Package().getRootPackage());\n\t\tthis.factory = factory;\n\t\troot = cst.getRoot();\n\t\tinitialize();\n\t}\n\n\tpublic SpoonModelTree(CtElement rootElement) {\n\t\tSpoonTreeBuilder cst = new SpoonTreeBuilder();\n\t\tcst.scan(rootElement);\n\t\tthis.factory = rootElement.getFactory();\n\t\troot = cst.getRoot();\n\t\tinitialize();\n\t}\n\n\t/**\n\t * This method initializes jContentPane\n\t *\n\t * @return javax.swing.JPanel\n\t */\n\tprivate JPanel getJContentPane() {\n\t\tif (jContentPane == null) {\n\t\t\tGridLayout gridLayout = new GridLayout();\n\t\t\tgridLayout.setRows(1);\n\t\t\tjContentPane = new JPanel();\n\t\t\tjContentPane.setLayout(gridLayout);\n\t\t\tjContentPane.add(getJScrollPane(), null);\n\t\t}\n\t\treturn jContentPane;\n\t}\n\n\t/**\n\t * This method initializes jScrollPane\n\t *\n\t * @return javax.swing.JScrollPane\n\t */\n\tprivate JScrollPane getJScrollPane() {\n\t\tif (jScrollPane == null) {\n\t\t\tjScrollPane = new JScrollPane();\n\t\t\tjScrollPane.setViewportView(getJTree());\n\t\t}\n\t\treturn jScrollPane;\n\t}\n\n\t/**\n\t * This method initializes jTree\n\t *\n\t * @return javax.swing.JTree\n\t */\n\tprivate JTree getJTree() {\n\t\tif (jTree == null) {\n\t\t\tjTree = new JTree(root);\n\t\t\tjTree.addKeyListener(this);\n\t\t\tjTree.addMouseListener(this);\n\t\t}\n\t\treturn jTree;\n\t}\n\n\tprivate JPopupMenu getMenu() {\n\t\tif (menu == null) {\n\t\t\tmenu = new JPopupMenu();\n\n\t\t\tJMenuItem item = new JMenuItem(\"Save\");\n\t\t\titem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\n\t\t\t\t\tJFileChooser chooser = new JFileChooser();\n\t\t\t\t\tchooser.setFileSelectionMode(JFileChooser.FILES_ONLY);\n\t\t\t\t\tboolean cont = chooser.showSaveDialog(SpoonModelTree.this) == JFileChooser.APPROVE_OPTION;\n\t\t\t\t\tif (cont) {\n\t\t\t\t\t\tSerializationModelStreamer ser = new SerializationModelStreamer();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tser.save(factory, new FileOutputStream(chooser\n\t\t\t\t\t\t\t\t\t.getSelectedFile()));\n\t\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t\t\tLauncher.LOGGER.error(e1.getMessage(), e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmenu.add(item);\n\t\t\tmenu.addSeparator();\n\n\t\t\t// show reflect table\n\t\t\titem = new JMenuItem(\"Reflect\");\n\t\t\titem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) jTree\n\t\t\t\t\t\t\t.getLastSelectedPathComponent();\n\t\t\t\t\tif (node == null) {\n\t\t\t\t\t\tnode = root;\n\t\t\t\t\t}\n\t\t\t\t\tnew SpoonObjectFieldsTable(node.getUserObject());\n\t\t\t\t}\n\t\t\t});\n\t\t\tmenu.add(item);\n\n\t\t\tmenu.addSeparator();\n\n\t\t\t// Search value\n\t\t\titem = new JMenuItem(\"Search\");\n\t\t\titem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tsearch();\n\t\t\t\t}\n\t\t\t});\n\t\t\tmenu.add(item);\n\n\t\t\t// Search value\n\t\t\titem = new JMenuItem(\"Search next\");\n\t\t\titem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tnext();\n\t\t\t\t}\n\t\t\t});\n\t\t\tmenu.add(item);\n\n\t\t\tmenu.addSeparator();\n\n\t\t\t// Expand all\n\t\t\titem = new JMenuItem(\"Expand all\");\n\t\t\titem.addActionListener(new ActionListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) jTree\n\t\t\t\t\t\t\t.getLastSelectedPathComponent();\n\t\t\t\t\tif (node == null) {\n\t\t\t\t\t\tnode = root;\n\t\t\t\t\t}\n\t\t\t\t\texpandAll(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\tmenu.add(item);\n\t\t}\n\t\treturn menu;\n\t}\n\n\t/**\n\t * This method initializes this\n\t *\n\t * @return void\n\t */\n\tprivate void initialize() {\n\t\tthis.setSize(640, 480);\n\t\tthis.setLocation((getGraphicsConfiguration().getDevice()\n\t\t\t\t.getDisplayMode().getWidth() - getWidth()) / 2,\n\t\t\t\t(getGraphicsConfiguration().getDevice().getDisplayMode()\n\t\t\t\t\t\t.getHeight() - getHeight()) / 2);\n\n\t\tsetContentPane(getJContentPane());\n\t\tsetTitle(\"Spoon\");\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void keyPressed(KeyEvent e) {\n\n\t}\n\n\t@Override\n\tpublic void keyReleased(KeyEvent e) {\n\n\t}\n\n\t@Override\n\tpublic void keyTyped(KeyEvent e) {\n\t\tswitch (e.getKeyChar()) {\n\t\tcase ('s'):\n\n\t\t\tbreak;\n\t\tcase ('n'):\n\t\t\tnext();\n\t\t\tbreak;\n\t\tcase ('o'):\n\t\t\tif (jTree.getLastSelectedPathComponent() != null) {\n\t\t\t\tnew SpoonObjectFieldsTable(((DefaultMutableTreeNode) jTree\n\t\t\t\t\t\t.getLastSelectedPathComponent()).getUserObject());\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprivate void maybeShowPopup(MouseEvent e) {\n\t\tif (e.isPopupTrigger()) {\n\t\t\tgetMenu().show(e.getComponent(), e.getX(), e.getY());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void mouseClicked(MouseEvent e) {\n\n\t}\n\n\t@Override\n\tpublic void mouseEntered(MouseEvent e) {\n\t}\n\n\t@Override\n\tpublic void mouseExited(MouseEvent e) {\n\t}\n\n\t@Override\n\tpublic void mousePressed(MouseEvent e) {\n\t\tgetJTree().setSelectionRow(\n\t\t\t\tgetJTree().getClosestRowForLocation(e.getX(), e.getY()));\n\t\tmaybeShowPopup(e);\n\t}\n\n\t@Override\n\tpublic void mouseReleased(MouseEvent e) {\n\t\tmaybeShowPopup(e);\n\t}\n\n\t/** move to the next node matching the search criterion */\n\tpublic DefaultMutableTreeNode next() {\n\t\tDefaultMutableTreeNode current;\n\t\twhile ((enume != null) && enume.hasMoreElements()) {\n\t\t\tcurrent = (DefaultMutableTreeNode) enume.nextElement();\n\t\t\tif ((current.getUserObject() != null)\n\t\t\t\t\t&& current.getUserObject().toString().contains(searchValue)) {\n\t\t\t\tsetVisible(current);\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** shows a dialog to enter the value to search for in the AST */\n\tpublic DefaultMutableTreeNode search() {\n\t\tsearchValue = JOptionPane.showInputDialog(this,\n\t\t\t\t\"Enter value to search:\", \"Search\");\n\n\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) jTree\n\t\t\t\t.getLastSelectedPathComponent();\n\t\tif (node == null) {\n\t\t\tnode = root;\n\t\t}\n\t\tenume = node.depthFirstEnumeration();\n\n\t\tif (searchValue != null) {\n\t\t\treturn next();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/** expand all AST nodes in the GUI */\n\tpublic DefaultMutableTreeNode expandAll(final DefaultMutableTreeNode node) {\n\t\tif (node == null || node.isLeaf()) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal ExecutorService executor = Executors.newSingleThreadExecutor();\n\t\texecutor.execute(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tQueue<DefaultMutableTreeNode> q = new LinkedList<>();\n\t\t\t\t\tq.add(node);\n\t\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\t\tfinal DefaultMutableTreeNode n = q.poll();\n\t\t\t\t\t\texpand(n);\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tEnumeration<TreeNode> children = n.children();\n\t\t\t\t\t\twhile (children.hasMoreElements()) {\n\t\t\t\t\t\t\tDefaultMutableTreeNode child = (DefaultMutableTreeNode) children.nextElement();\n\t\t\t\t\t\t\tif (!child.isLeaf() && child.getChildCount() > 0) {\n\t\t\t\t\t\t\t\tq.offer(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\texecutor.shutdownNow();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn node;\n\t}\n\n\tpublic void expand(final DefaultMutableTreeNode node) {\n\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tTreePath path = new TreePath(node.getPath());\n\t\t\t\tif (!jTree.isExpanded(path)) {\n\t\t\t\t\tjTree.expandPath(path);\n\t\t\t\t\tjTree.updateUI();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void setVisible(DefaultMutableTreeNode node) {\n\t\tTreePath path = new TreePath(node.getPath());\n\t\tgetJTree().scrollPathToVisible(path);\n\t\tgetJTree().setSelectionPath(path);\n\t}\n\n}\n"
    }, {
      "name" : "support/DerivedProperty.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.reflect.declaration.CtType;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Tells that a metamodel property is derived, ie computed from the value of another property.\n *\n * For instance {@link CtType#getFields()}  is derived from {@link CtType#getTypeMembers()}\n *\n * It can be put on getter and setters.\n *\n * Contracts:\n * - A setter with @DerivedProperty only triggers one single model intercession event,\n *   on the element primarily responsible for handling the state from which this dervied property is computed.\n * - A getter with @DerivedProperty is never called in CtScanner and derived classes (clone, replace)\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD })\npublic @interface DerivedProperty {\n}\n"
    }, {
      "name" : "support/compiler/VirtualFile.java",
      "weight" : 63.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\n\npublic class VirtualFile implements SpoonFile {\n\tpublic static final String VIRTUAL_FILE_NAME = \"virtual_file\";\n\n\tString content;\n\n\tString name = VIRTUAL_FILE_NAME;\n\n\tpublic VirtualFile(String content) {\n\t\tthis.content = content;\n\t}\n\n\tpublic VirtualFile(String contents, String name) {\n\t\tthis(contents);\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic InputStream getContent() {\n\t\treturn new ByteArrayInputStream(content.getBytes());\n\t}\n\n\t@Override\n\tpublic char[] getContentChars(Environment env) {\n\t\treturn content.toCharArray();\n\t}\n\n\t@Override\n\tpublic boolean isJava() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\treturn new VirtualFolder();\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isActualFile() {\n\t\treturn false;\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/VirtualFolder.java",
      "weight" : 85.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\n\npublic class VirtualFolder implements SpoonFolder {\n\tprotected final Set<SpoonFile> files = new HashSet<>();\n\n\t@Override\n\tpublic void addFile(SpoonFile o) {\n\t\tfiles.add(o);\n\t}\n\n\t@Override\n\tpublic void addFolder(SpoonFolder o) {\n\t\tfor (SpoonFile f : o.getAllFiles()) {\n\t\t\tif (f.isFile()) {\n\t\t\t\tfiles.add(f);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllFiles() {\n\t\t// there are never folders added to files in this class so just return a List here.\n\t\t// The files are already deduplicated based on Set logic.\n\t\treturn new ArrayList<>(files);\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllJavaFiles() {\n\t\tList<SpoonFile> result = new ArrayList<>();\n\n\t\tfor (SpoonFile f : getAllFiles()) {\n\t\t\tif (f.isJava()) {\n\t\t\t\tresult.add(f);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getFiles() {\n\t\treturn Collections.unmodifiableList(new ArrayList<>(files));\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"Virtual directory\";\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<SpoonFolder> getSubFolders() {\n\t\tList<SpoonFolder> result = new ArrayList<>();\n\t\tfor (SpoonFile f : getAllFiles()) {\n\t\t\tSpoonFolder folder = f.getParent();\n\t\t\tif (folder != null && !result.contains(folder)) {\n\t\t\t\tresult.add(folder);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(result);\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\t// it has to be real path for snippet building\n\t\treturn \".\";\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"<virtual folder>: \" + super.toString();\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/SpoonProgress.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\n/**\n * is the interface to follow the progress of the creation of the Spoon model.\n */\npublic interface SpoonProgress {\n\n\tenum Process {\n\t\tCOMPILE,\n\t\tCOMMENT,\n\t\tMODEL,\n\t\tIMPORT,\n\t\tCOMMENT_LINKING,\n\t\tPROCESS,\n\t\tPRINT\n\t}\n\n\t/**\n\t * is called when a new process is started\n\t * @param process the started process\n\t */\n\tvoid start(Process process);\n\n\t/**\n\t * is called when a step in the precess is started\n\t * @param process the current process\n\t * @param task the task that has been processed\n\t * @param taskId the task id\n\t * @param nbTask the number of task in the process\n\t */\n\tvoid step(Process process, String task, int taskId, int nbTask);\n\n\t/**\n\t * is called when a step in the precess is started\n\t * @param process the current process\n\t * @param task the task that has been processed\n\t */\n\tvoid step(Process process, String task);\n\n\t/**\n\t * is called when a new process is started\n\t * @param process the finished process\n\t */\n\tvoid end(Process process);\n\n}\n"
    }, {
      "name" : "support/compiler/FileSystemFolder.java",
      "weight" : 129.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResourceHelper;\n\npublic class FileSystemFolder implements SpoonFolder {\n\n\tFile file;\n\n\tpublic FileSystemFolder(File file) {\n\t\tif (!file.isDirectory()) {\n\t\t\tthrow new SpoonException(\"Not a directory \" + file);\n\t\t}\n\t\ttry {\n\t\t\tthis.file = file.getCanonicalFile();\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\tpublic FileSystemFolder(String path) {\n\t\tthis(new File(path));\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllFiles() {\n\t\tList<SpoonFile> all = new ArrayList<>(getFiles());\n\t\tfor (SpoonFolder f : getSubFolders()) {\n\t\t\tall.addAll(f.getAllFiles());\n\t\t}\n\t\treturn all;\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getFiles() {\n\t\tList<SpoonFile> files;\n\t\tfiles = new ArrayList<>();\n\t\tfor (File f : file.listFiles()) {\n\t\t\tif (SpoonResourceHelper.isFile(f)) {\n\t\t\t\tfiles.add(new FileSystemFile(f));\n\t\t\t}\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn file.getName();\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\ttry {\n\t\t\treturn SpoonResourceHelper.createFolder(file.getParentFile());\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<SpoonFolder> getSubFolders() {\n\t\tList<SpoonFolder> subFolders;\n\t\tsubFolders = new ArrayList<>();\n\t\tfor (File f : file.listFiles()) {\n\t\t\tif (!(SpoonResourceHelper.isArchive(f) || f.isFile())) {\n\t\t\t\ttry {\n\t\t\t\t\tsubFolders.add(SpoonResourceHelper.createFolder(f));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn subFolders;\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getPath();\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllJavaFiles() {\n\t\tList<SpoonFile> files = new ArrayList<>();\n\t\tfor (SpoonFile f : getFiles()) {\n\t\t\tif (f.isJava()) {\n\t\t\t\tfiles.add(f);\n\t\t\t}\n\t\t}\n\t\tfor (SpoonFolder fol : getSubFolders()) {\n\t\t\tfiles.addAll(fol.getAllJavaFiles());\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\t\treturn file.getPath();\n\t\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn file.getParentFile();\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn file;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn toString().equals(obj.toString());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t@Override\n\tpublic void addFile(SpoonFile source) {\n\t\tthrow new UnsupportedOperationException(\"not possible a real folder\");\n\t}\n\n\t@Override\n\tpublic void addFolder(SpoonFolder source) {\n\t\tthrow new UnsupportedOperationException(\"not possible a real folder\");\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/FileSystemFile.java",
      "weight" : 94.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\n\npublic class FileSystemFile implements SpoonFile {\n\n\tFile file;\n\n\tpublic FileSystemFile(String path) {\n\t\tthis(new File(path));\n\t}\n\n\tpublic FileSystemFile(File file) {\n\t\ttry {\n\t\t\tthis.file = file.getCanonicalFile();\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic InputStream getContent() {\n\t\ttry {\n\t\t\tif (!this.file.exists()) {\n\t\t\t\tthrow new FileNotFoundException(\"The following file does not exist: \" + this.file.getCanonicalPath());\n\t\t\t}\n\t\t\treturn new FileInputStream(file);\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn file.getName();\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\ttry {\n\t\t\treturn SpoonResourceHelper.createFolder(file.getParentFile());\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn file.getParentFile();\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isJava() {\n\t\treturn getName().endsWith(\".java\");\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\ttry {\n\t\t\treturn file.getCanonicalPath();\n\t\t} catch (Exception e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\treturn file.getPath();\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn file.getPath();\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn SpoonResourceHelper.isArchive(file);\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn file;\n\t}\n\n\t@Override\n\tpublic boolean isActualFile() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn toFile().equals(((SpoonResource) obj).toFile());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toFile().hashCode();\n\t}\n}\n"
    }, {
      "name" : "support/compiler/SnippetCompilationHelper.java",
      "weight" : 128.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport spoon.SpoonModelBuilder;\nimport spoon.compiler.ModelBuildingException;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.path.CtPath;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.compiler.jdt.JDTSnippetCompiler;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/** Helper class for working with snippets */\npublic class SnippetCompilationHelper {\n\n\tprivate SnippetCompilationHelper() { }\n\n\tprivate static final String WRAPPER_CLASS_NAME = \"Wrapper\";\n\tprivate static final String WRAPPER_METHOD_NAME = \"wrap\";\n\n\t/**\n\t * Takes the class given as parameter, pretty-prints it, get the JDT'ast and the corrspondong Spoon AST\n\t * and finally replace all children of initialClass by the the fresh ones.\n\t *\n\t * This results that all snippets are now full-fledged ASTs.\n\t *\n\t */\n\tpublic static void compileAndReplaceSnippetsIn(CtType<?> initialClass) {\n\n\t\tMap<CtPath, CtElement> elements2before = new HashMap<>();\n\t\tMap<CtPath, CtElement> elements2after = new HashMap<>();\n\t\tfor (Object o : initialClass.filterChildren(new TypeFilter<>(CtCodeSnippet.class)).list()) {\n\t\t\tCtElement el = (CtElement) o;\n\t\t\telements2before.put(el.getPath(), el);\n\t\t}\n\t\tFactory f = initialClass.getFactory();\n\n\t\t// we need to slightly play with the modifiers\n\t\tSet<ModifierKind> backup = EnumSet.noneOf(ModifierKind.class);\n\t\tbackup.addAll(initialClass.getModifiers());\n\t\tinitialClass.removeModifier(ModifierKind.PUBLIC);\n\n\t\t// we need to delete the current class from its package\n\t\t// otherwsise the new type is not added because it has the same fully qualified name\n\t\tinitialClass.delete();\n\n\t\ttry {\n\t\t\tbuild(f, \"package \" + initialClass.getPackage().getQualifiedName() + \";\" + initialClass.toString());\n\t\t} finally {\n\t\t\t// restore modifiers\n\t\t\tinitialClass.setModifiers(backup);\n\t\t}\n\n\t\t// we get the newly created class\n\t\tCtType<?> newClass = f.Type().get(initialClass.getQualifiedName());\n\n\t\t// we find the snippets that are now ASTs\n\t\tfor (CtPath p : elements2before.keySet()) {\n\t\t\telements2after.put(p, p.evaluateOn(f.getModel().getRootPackage()).iterator().next());\n\t\t}\n\n\t\t// and we replace the new class in the factory by the initial one\n\t\tnewClass.replace(initialClass);\n\n\t\t// and we replace the snippets\n\t\tfor (Map.Entry<CtPath, CtElement> ctPath : elements2before.entrySet()) {\n\t\t\tCtElement toReplace = ctPath.getValue();\n\t\t\ttoReplace.replace(elements2after.get(ctPath.getKey()));\n\t\t}\n\t}\n\n\tpublic static CtStatement compileStatement(CtCodeSnippetStatement st)\n\t\t\tthrows SnippetCompilationError {\n\t\treturn internalCompileStatement(st, st.getFactory().Type().VOID_PRIMITIVE);\n\t}\n\n\tpublic static CtStatement compileStatement(CtCodeSnippetStatement st, CtTypeReference returnType)\n\t\t\tthrows SnippetCompilationError {\n\t\treturn internalCompileStatement(st, returnType);\n\t}\n\n\tprivate static CtStatement internalCompileStatement(CtElement st, CtTypeReference returnType) {\n\t\tFactory f = st.getFactory();\n\n\t\tString contents = createWrapperContent(st, f, returnType);\n\n\t\tbuild(f, contents);\n\n\t\tCtType<?> c = f.Type().get(WRAPPER_CLASS_NAME);\n\n\t\t// Get the part we want\n\n\t\tCtMethod<?> wrapper = c.getMethod(WRAPPER_METHOD_NAME);\n\n\t\tList<CtStatement> statements = wrapper.getBody().getStatements();\n\t\tCtStatement ret = statements.get(statements.size() - 1);\n\n\t\t// Clean up\n\t\tc.getPackage().removeType(c);\n\n\t\t//disconnect element from the parent, so it can be added to another model\n\t\tret.delete();\n\t\tret.setParent(null);\n\n\t\tif (ret instanceof CtClass) {\n\t\t\tCtClass klass = (CtClass) ret;\n\t\t\tret.getFactory().Package().getRootPackage().addType(klass);\n\t\t\tklass.setSimpleName(klass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> CtExpression<T> compileExpression(\n\t\t\tCtCodeSnippetExpression<T> expr) throws SnippetCompilationError {\n\n\t\tCtReturn<T> ret = (CtReturn<T>) internalCompileStatement(expr, expr.getFactory().Type().OBJECT);\n\n\t\tCtExpression<T> returnedExpression = ret.getReturnedExpression();\n\n\t\t// this compiled expression is not in a parent, ready to be used\n\t\treturnedExpression.delete();\n\t\treturnedExpression.setParent(null);\n\n\t\treturn returnedExpression;\n\t}\n\n\tprivate static void build(Factory f, String contents) {\n\t\t// Build contents\n\t\tSpoonModelBuilder builder = new JDTSnippetCompiler(f, contents);\n\t\ttry {\n\t\t\tbuilder.build();\n\t\t} catch (Exception e) {\n\t\t\tthrow new ModelBuildingException(\"snippet compilation error while compiling: \" + contents, e);\n\t\t}\n\t}\n\n\tprivate static String createWrapperContent(final CtElement element, final Factory f, final CtTypeReference returnType) {\n\t\tCtClass<?> w = f.Class().create(WRAPPER_CLASS_NAME);\n\n\t\tCtBlock body = f.Core().createBlock();\n\n\t\tif (element instanceof CtStatement) {\n\t\t\tbody.addStatement((CtStatement) element);\n\t\t} else if (element instanceof CtExpression) {\n\t\t\tCtReturn ret = f.Core().createReturn();\n\t\t\tret.setReturnedExpression((CtExpression) element);\n\t\t\tbody.addStatement(ret);\n\t\t}\n\n\t\tSet<ModifierKind> modifiers = EnumSet.of(ModifierKind.STATIC);\n\n\t\tSet<CtTypeReference<? extends Throwable>> thrownTypes = new HashSet<>();\n\t\tthrownTypes.add(f.Class().<Throwable>get(Throwable.class).getReference());\n\t\tf.Method().create(\n\t\t\t\tw,\n\t\t\t\tmodifiers,\n\t\t\t\treturnType,\n\t\t\t\tWRAPPER_METHOD_NAME,\n\t\t\t\tCtElementImpl.<CtParameter<?>>emptyList(),\n\t\t\t\tthrownTypes,\n\t\t\t\tbody);\n\n\t\tString contents = w.toString();\n\t\t// Clean up (delete wrapper from factory) after it is printed. The DefaultJavaPrettyPrinter needs w in model to be able to print it correctly\n\t\tw.getPackage().removeType(w);\n\n\t\treturn contents;\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/SnippetCompilationError.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport spoon.SpoonException;\n\npublic class SnippetCompilationError extends SpoonException {\n\n\tprivate static final long serialVersionUID = 7805276558728052328L;\n\n\tpublic List<String> problems;\n\n\tpublic SnippetCompilationError(List<String> problems) {\n\t\tthis.problems = problems;\n\t}\n\n\tpublic SnippetCompilationError(String string) {\n\t\tsuper(string);\n\t\tthis.problems = new ArrayList<>();\n\t\tthis.problems.add(string);\n\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/ZipFolder.java",
      "weight" : 151.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport spoon.Launcher;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResourceHelper;\n\npublic class ZipFolder implements SpoonFolder {\n\n\tFile file;\n\n\tList<SpoonFile> files;\n\n\tpublic ZipFolder(File file) throws IOException {\n\t\tif (!file.isFile()) {\n\t\t\tthrow new IOException(file.getName() + \" is not a valid zip file\");\n\t\t}\n\t\tthis.file = file;\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllFiles() {\n\t\treturn getFiles();\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getAllJavaFiles() {\n\t\tList<SpoonFile> files = new ArrayList<>();\n\n\t\tfor (SpoonFile f : getFiles()) {\n\t\t\tif (f.isJava()) {\n\t\t\t\tfiles.add(f);\n\t\t\t}\n\t\t}\n\n\t\t// no subfolder, skipping\n\t\t// for (CtFolder fol : getSubFolder())\n\t\t// files.addAll(fol.getAllJavaFile());\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic List<SpoonFile> getFiles() {\n\t\t// Indexing content\n\t\tif (files == null) {\n\t\t\tfiles = new ArrayList<>();\n\t\t\tfinal int buffer = 2048;\n\t\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(file)));\n\t\t\t\tByteArrayOutputStream output = new ByteArrayOutputStream(buffer)) {\n\t\t\t\tZipEntry entry;\n\t\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\t\t// deflate in buffer\n\t\t\t\t\tint count;\n\t\t\t\t\tbyte[] data = new byte[buffer];\n\t\t\t\t\twhile ((count = zipInput.read(data, 0, buffer)) != -1) {\n\t\t\t\t\t\toutput.write(data, 0, count);\n\t\t\t\t\t}\n\t\t\t\t\tfiles.add(new ZipFile(this, entry.getName(), output.toByteArray()));\n\t\t\t\t\toutput.reset();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn file.getName();\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\ttry {\n\t\t\treturn SpoonResourceHelper.createFolder(file.getParentFile());\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<SpoonFolder> getSubFolders() {\n\t\treturn new ArrayList<>(0);\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getPath();\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\ttry {\n\t\t\treturn file.getCanonicalPath();\n\t\t} catch (Exception e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\treturn file.getPath();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn file.getParentFile();\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn file;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn toString().equals(obj.toString());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n\t@Override\n\tpublic void addFile(SpoonFile source) {\n\t\tthrow new UnsupportedOperationException(\"not possible a real folder\");\n\t}\n\n\t@Override\n\tpublic void addFolder(SpoonFolder source) {\n\t\tthrow new UnsupportedOperationException(\"not possible a real folder\");\n\t}\n\n\t/** physically extracts on disk all files of this zip file in the destinationDir `destDir` */\n\tpublic void extract(File destDir) {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(file)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile f = new File(destDir + File.separator + entry.getName());\n\t\t\t\tif (entry.isDirectory()) { // if it's a directory, create it\n\t\t\t\t\tf.mkdir();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// deflate in buffer\n\t\t\t\tfinal int buffer = 2048;\n\t\t\t\t// Force parent directory creation, sometimes directory was not yet handled\n\t\t\t\tf.getParentFile().mkdirs();\n\t\t\t\t// in the zip entry iteration\n\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(f))) {\n\t\t\t\t\tint count;\n\t\t\t\t\tbyte[] data = new byte[buffer];\n\t\t\t\t\twhile ((count = zipInput.read(data, 0, buffer)) != -1) {\n\t\t\t\t\t\toutput.write(data, 0, count);\n\t\t\t\t\t}\n\t\t\t\t\toutput.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/compiler/ProgressLogger.java",
      "weight" : 34.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport spoon.support.StandardEnvironment;\n\nimport java.util.GregorianCalendar;\n\npublic class ProgressLogger implements SpoonProgress {\n\tprivate long stepTimer;\n\tprivate long timer;\n\tprivate StandardEnvironment environment;\n\n\tpublic ProgressLogger(StandardEnvironment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t@Override\n\tpublic void start(Process process) {\n\t\tenvironment.debugMessage(\"Start \" + process);\n\t\ttimer = getCurrentTimeInMillis();\n\t\tstepTimer = timer;\n\t}\n\n\t@Override\n\tpublic void step(Process process, String task, int taskId, int nbTask) {\n\t\tenvironment.debugMessage(\"Step \" + process + \" \" + taskId + \"/\" + nbTask + \" \" + task + \" in \" + (getCurrentTimeInMillis() - timer) + \" ms\");\n\t\ttimer = getCurrentTimeInMillis();\n\t}\n\n\t@Override\n\tpublic void step(Process process, String task) {\n\t\tenvironment.debugMessage(\"Step \" + process + \" \" + task + \" in \" + (getCurrentTimeInMillis() - timer) + \" ms\");\n\t\ttimer = getCurrentTimeInMillis();\n\t}\n\n\t@Override\n\tpublic void end(Process process) {\n\t\tenvironment.debugMessage(\"End \" + process + \" in \" + (getCurrentTimeInMillis() - stepTimer) + \" ms\");\n\t}\n\n\tprivate long getCurrentTimeInMillis() {\n\t\treturn new GregorianCalendar().getTimeInMillis();\n\t}\n}\n"
    }, {
      "name" : "support/compiler/SpoonPom.java",
      "weight" : 401.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport org.apache.log4j.Logger;\nimport org.apache.maven.model.Build;\nimport org.apache.maven.model.BuildBase;\nimport org.apache.maven.model.Model;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.Profile;\nimport org.apache.maven.model.io.xpp3.MavenXpp3Reader;\nimport org.apache.maven.shared.invoker.DefaultInvocationRequest;\nimport org.apache.maven.shared.invoker.DefaultInvoker;\nimport org.apache.maven.shared.invoker.InvocationRequest;\nimport org.apache.maven.shared.invoker.Invoker;\nimport org.apache.maven.shared.invoker.MavenInvocationException;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\nimport org.codehaus.plexus.util.xml.pull.XmlPullParserException;\nimport spoon.Launcher;\nimport spoon.MavenLauncher;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SpoonPom implements SpoonResource {\n\tstatic String mavenVersionParsing = \"Maven home: \";\n\tstatic String spoonClasspathTmpFileName = \"spoon.classpath.tmp\";\n\tstatic String spoonClasspathTmpFileNameApp = \"spoon.classpath-app.tmp\";\n\tstatic String spoonClasspathTmpFileNameTest = \"spoon.classpath-test.tmp\";\n\tstatic long classpathTmpFilesTTL = 60 * 60 * 1000L; // 1h in ms\n\tList<SpoonPom> modules = new ArrayList<>();\n\tModel model;\n\tSpoonPom parent;\n\tFile pomFile;\n\tFile directory;\n\tMavenLauncher.SOURCE_TYPE sourceType;\n\tEnvironment environment;\n\n\t/**\n\t * Extract the information from the pom\n\t * @param path the path to the pom\n\t * @throws IOException when the file does not exist\n\t * @throws XmlPullParserException when the file is corrupted\n\t */\n\tpublic SpoonPom(String path, MavenLauncher.SOURCE_TYPE sourceType, Environment environment) throws IOException, XmlPullParserException {\n\t\tthis(path, null, sourceType, environment);\n\t}\n\n\t/**\n\t * Extract the information from the pom\n\t * @param path the path to the pom\n\t * @param parent the parent pom\n\t * @throws IOException when the file does not exist\n\t * @throws XmlPullParserException when the file is corrupted\n\t */\n\tpublic SpoonPom(String path, SpoonPom parent, MavenLauncher.SOURCE_TYPE sourceType, Environment environment) throws IOException, XmlPullParserException {\n\t\tthis.parent = parent;\n\t\tthis.sourceType = sourceType;\n\t\tthis.environment = environment;\n\t\tif (!path.endsWith(\".xml\") && !path.endsWith(\".pom\")) {\n\t\t\tpath = Paths.get(path, \"pom.xml\").toString();\n\t\t}\n\t\tthis.pomFile = new File(path);\n\t\tif (!pomFile.exists()) {\n\t\t\tthrow new IOException(\"Pom does not exists.\");\n\t\t}\n\t\tthis.directory = pomFile.getParentFile();\n\t\tMavenXpp3Reader pomReader = new MavenXpp3Reader();\n\t\ttry (FileReader reader = new FileReader(pomFile)) {\n\t\t\tthis.model = pomReader.read(reader);\n\t\t\tfor (String module : model.getModules()) {\n\t\t\t\taddModule(new SpoonPom(Paths.get(pomFile.getParent(), module).toString(), this, sourceType, environment));\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new IOException(\"Pom does not exists.\");\n\t\t}\n\t}\n\n\tprivate void addModule(SpoonPom module) {\n\t\tmodules.add(module);\n\t}\n\n\t/**\n\t * Get the Project Object Model\n\t * @return the Project Object Model\n\t */\n\tpublic Model getModel() {\n\t\treturn model;\n\t}\n\n\t/**\n\t * Get the list of source directories of the project\n\t * @return the list of source directories\n\t */\n\tpublic List<File> getSourceDirectories() {\n\t\tList<File> output = new ArrayList<>();\n\t\tString sourcePath = null;\n\n\t\tBuild build = model.getBuild();\n\t\tif (build != null) {\n\t\t\tsourcePath = build.getSourceDirectory();\n\t\t}\n\t\tif (sourcePath == null) {\n\t\t\tsourcePath = Paths.get(directory.getAbsolutePath(), \"src\", \"main\", \"java\").toString();\n\t\t}\n\t\tFile source = new File(sourcePath);\n\t\tif (source.exists()) {\n\t\t\toutput.add(source);\n\t\t}\n\t\tFile generatedSource = Paths.get(directory.getAbsolutePath(), \"target\", \"generated-sources\").toFile();\n\t\tif (generatedSource.exists()) {\n\t\t\toutput.add(generatedSource);\n\t\t}\n\t\tfor (SpoonPom module : modules) {\n\t\t\toutput.addAll(module.getSourceDirectories());\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Get the list of test directories of the project\n\t * @return the list of test directories\n\t */\n\tpublic List<File> getTestDirectories() {\n\t\tList<File> output = new ArrayList<>();\n\t\tString sourcePath = null;\n\n\t\tBuild build = model.getBuild();\n\t\tif (build != null) {\n\t\t\tsourcePath = build.getTestSourceDirectory();\n\t\t}\n\t\tif (sourcePath == null) {\n\t\t\tsourcePath = Paths.get(directory.getAbsolutePath(), \"src\", \"test\", \"java\").toString();\n\t\t}\n\t\tFile source = new File(sourcePath);\n\t\tif (source.exists()) {\n\t\t\toutput.add(source);\n\t\t}\n\t\tFile generatedSource = Paths.get(directory.getAbsolutePath(), \"target\", \"generated-test-sources\").toFile();\n\t\tif (generatedSource.exists()) {\n\t\t\toutput.add(generatedSource);\n\t\t}\n\t\tfor (SpoonPom module : modules) {\n\t\t\toutput.addAll(module.getTestDirectories());\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Get the list of classpath files generated by maven\n\t * @return the list of classpath files\n\t */\n\tpublic List<File> getClasspathTmpFiles(String fileName) {\n\t\tList<File> output = new ArrayList<>();\n\t\tFile tmp = new File(directory, fileName);\n\t\tif (tmp.exists() && tmp.isFile()) {\n\t\t\toutput.add(tmp);\n\t\t}\n\t\tfor (SpoonPom module : modules) {\n\t\t\toutput.addAll(module.getClasspathTmpFiles(fileName));\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Pattern corresponding to maven properties ${propertyName}\n\tprivate static Pattern mavenProperty = Pattern.compile(\"\\\\$\\\\{.*\\\\}\");\n\n\t/**\n\t * Extract the variable from a string\n\t */\n\tprivate String extractVariable(String value) {\n\t\tString val = value;\n\t\tif (value != null && value.contains(\"$\")) {\n\t\t\tMatcher matcher = mavenProperty.matcher(value);\n\t\t\twhile (matcher.find()) {\n\t\t\t\tString var = matcher.group();\n\t\t\t\tval = val.replace(var, getProperty(var.substring(2, var.length() - 1)));\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t * Get the value of a property\n\t * @param key the key of the property\n\t * @return the property value if key exists or null\n\t */\n\tprivate String getProperty(String key) {\n\t\tif (\"project.version\".equals(key)  || \"pom.version\".equals(key)) {\n\t\t\tif (model.getVersion() != null) {\n\t\t\t\treturn model.getVersion();\n\t\t\t} else if (model.getParent() != null) {\n\t\t\t\treturn model.getParent().getVersion();\n\t\t\t}\n\t\t} else if (\"project.groupId\".equals(key) || \"pom.groupId\".equals(key)) {\n\t\t\tif (model.getGroupId() != null) {\n\t\t\t\treturn model.getGroupId();\n\t\t\t} else if (model.getParent() != null) {\n\t\t\t\treturn model.getParent().getGroupId();\n\t\t\t}\n\t\t} else if (\"project.artifactId\".equals(key)  || \"pom.artifactId\".equals(key)) {\n\t\t\tif (model.getArtifactId() != null) {\n\t\t\t\treturn model.getArtifactId();\n\t\t\t} else if (model.getParent() != null) {\n\t\t\t\treturn model.getParent().getArtifactId();\n\t\t\t}\n\t\t}\n\t\tString value = extractVariable(model.getProperties().getProperty(key));\n\t\tif (value == null) {\n\t\t\tif (parent == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn parent.getProperty(key);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Get the source version of the project\n\t * @return the source version of the project\n\t */\n\tpublic int getSourceVersion() {\n\t\tString javaVersion = null;\n\t\tif (model.getBuild() != null) {\n\t\t\tjavaVersion = getSourceVersion(model.getBuild());\n\t\t}\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\tfor (Profile profile: model.getProfiles()) {\n\t\t\tif (profile.getActivation() != null && profile.getActivation().isActiveByDefault()) {\n\t\t\t\tjavaVersion = getSourceVersion(profile.getBuild());\n\t\t\t}\n\t\t}\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\tjavaVersion = getProperty(\"java.version\");\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\tjavaVersion = getProperty(\"java.src.version\");\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\tjavaVersion = getProperty(\"maven.compiler.source\");\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\tjavaVersion = getProperty(\"maven.compile.source\");\n\t\tif (javaVersion != null) {\n\t\t\treturn correctJavaVersion(javaVersion);\n\t\t}\n\t\t// return the current compliance level of spoon\n\t\treturn environment.getComplianceLevel();\n\t}\n\n\tprivate int correctJavaVersion(String javaVersion) {\n\t\tString version = extractVariable(javaVersion);\n\t\treturn Integer.parseInt((version.contains(\".\") ? version.substring(2) : version));\n\t}\n\n\tprivate String getSourceVersion(BuildBase build) {\n\t\tfor (Plugin plugin : build.getPlugins()) {\n\t\t\tif (!\"maven-compiler-plugin\".equals(plugin.getArtifactId())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tXpp3Dom configuration = (Xpp3Dom) plugin.getConfiguration();\n\t\t\tif (configuration != null) {\n\t\t\t\tXpp3Dom source = configuration.getChild(\"source\");\n\t\t\t\tif (source != null) {\n\t\t\t\t\treturn source.getValue();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(model.getGroupId());\n\t\tsb.append(\":\");\n\t\tsb.append(model.getArtifactId());\n\t\tsb.append(\":\");\n\t\tsb.append(model.getVersion());\n\t\tif (modules.isEmpty()) {\n\t\t\treturn sb.toString();\n\t\t}\n\t\tsb.append(\" {\\n\");\n\t\tfor (SpoonPom spoonPom : modules) {\n\t\t\tString child = spoonPom.toString();\n\t\t\tfor (String s : child.split(\"\\n\")) {\n\t\t\t\tsb.append(\"\\t\");\n\t\t\t\tsb.append(s);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"}\");\n\t\treturn sb.toString();\n\t}\n\n\tprivate void generateClassPathFile(File mvnHome, MavenLauncher.SOURCE_TYPE sourceType, Logger LOGGER, boolean forceRefresh) {\n\t\t// Check if classpath file already exist and is recent enough (1h)\n\t\tFile classpathFile = new File(directory, getSpoonClasspathTmpFileName(sourceType));\n\t\tDate date = new Date();\n\t\tlong time = date.getTime();\n\t\tif (forceRefresh || !classpathFile.exists() || ((time - classpathFile.lastModified()) > classpathTmpFilesTTL)) {\n\t\t\t//Run mvn dependency:build-classpath -Dmdep.outputFile=\"spoon.classpath.tmp\"\n\t\t\t//This should write the classpath used by maven in spoon.classpath.tmp\n\t\t\tInvocationRequest request = new DefaultInvocationRequest();\n\t\t\trequest.setBatchMode(true);\n\t\t\trequest.setPomFile(pomFile);\n\t\t\trequest.setGoals(Collections.singletonList(\"dependency:build-classpath\"));\n\t\t\tProperties properties = new Properties();\n\t\t\tif (sourceType == MavenLauncher.SOURCE_TYPE.APP_SOURCE) {\n\t\t\t\tproperties.setProperty(\"includeScope\", \"runtime\");\n\t\t\t}\n\t\t\tproperties.setProperty(\"mdep.outputFile\", getSpoonClasspathTmpFileName(sourceType));\n\t\t\trequest.setProperties(properties);\n\n\t\t\tif (LOGGER != null) {\n\t\t\t\trequest.getOutputHandler(s -> LOGGER.debug(s));\n\t\t\t\trequest.getErrorHandler(s -> LOGGER.debug(s));\n\t\t\t}\n\n\t\t\tInvoker invoker = new DefaultInvoker();\n\t\t\tinvoker.setMavenHome(mvnHome);\n\t\t\tinvoker.setWorkingDirectory(directory);\n\t\t\tinvoker.setErrorHandler(s -> LOGGER.debug(s));\n\t\t\tinvoker.setOutputHandler(s -> LOGGER.debug(s));\n\t\t\ttry {\n\t\t\t\tinvoker.execute(request);\n\t\t\t} catch (MavenInvocationException e) {\n\t\t\t\tthrow new SpoonException(\"Maven invocation failed to build a classpath.\");\n\t\t\t}\n\t\t\tclasspathFile.setLastModified(time);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param classPathFiles File[] containing the classpath elements separated with ':'\n\t *                       It can be an array of file instead of an unique one for multi module projects.\n\t */\n\tprivate static String[] readClassPath(File... classPathFiles) throws IOException {\n\t\tList<String> classpathElements = new ArrayList<>();\n\n\t\t//Read the content of spoon.classpath.tmp\n\t\tfor (File classPathFile: classPathFiles) {\n\t\t\ttry (BufferedReader br = new BufferedReader(new FileReader(classPathFile))) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tString line = br.readLine();\n\t\t\t\twhile (line != null) {\n\t\t\t\t\tsb.append(line);\n\t\t\t\t\tline = br.readLine();\n\t\t\t\t}\n\t\t\t\tif (!\"\".equals(sb.toString())) {\n\t\t\t\t\tString[] classpath = sb.toString().split(File.pathSeparator);\n\t\t\t\t\tfor (String cpe : classpath) {\n\t\t\t\t\t\tif (!classpathElements.contains(cpe)) {\n\t\t\t\t\t\t\tclasspathElements.add(cpe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classpathElements.toArray(new String[0]);\n\t}\n\n\tprivate static String guessMavenHome() {\n\t\tString mvnHome = null;\n\t\ttry {\n\t\t\tString[] cmd;\n\t\t\tif (System.getProperty(\"os.name\").contains(\"Windows\")) {\n\t\t\t\tcmd = new String[]{\"mvn.cmd\", \"-version\"};\n\t\t\t} else {\n\t\t\t\tcmd = new String[]{\"mvn\", \"-version\"};\n\t\t\t}\n\t\t\tProcess p = Runtime.getRuntime().exec(cmd);\n\t\t\ttry (BufferedReader output = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n\t\t\t\tString line;\n\n\t\t\t\twhile ((line = output.readLine()) != null) {\n\t\t\t\t\tif (line.contains(mavenVersionParsing)) {\n\t\t\t\t\t\treturn line.replace(mavenVersionParsing, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp.waitFor();\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(\"Maven home detection has failed.\");\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new SpoonException(\"Maven home detection was interrupted.\");\n\t\t}\n\t\treturn mvnHome;\n\t}\n\n\t/**\n\t * Call maven invoker to generate the classpath. Either M2_HOME must be\n\t * initialized, or the command mvn must be in PATH.\n\t *\n\t * @param mvnHome the path to the m2repository\n\t * @param sourceType the source type (App, test, or all)\n\t * @param LOGGER Logger used for maven output\n\t * @param forceRefresh if true forces the invocation of maven to regenerate classpath\n\t */\n\tpublic String[] buildClassPath(String mvnHome, MavenLauncher.SOURCE_TYPE sourceType, Logger LOGGER, boolean forceRefresh) {\n\t\tif (mvnHome == null) {\n\t\t\tmvnHome = guessMavenHome();\n\t\t\tif (mvnHome == null) {\n\t\t\t\tthrow new SpoonException(\"M2_HOME must be initialized to use this MavenLauncher constructor.\");\n\t\t\t}\n\t\t}\n\t\tgenerateClassPathFile(new File(mvnHome), sourceType, LOGGER, forceRefresh);\n\n\t\tList<File> classPathPrints;\n\t\tString[] classpath;\n\t\ttry {\n\t\t\tclassPathPrints = getClasspathTmpFiles(getSpoonClasspathTmpFileName(sourceType));\n\t\t\tFile[] classPathPrintFiles = new File[classPathPrints.size()];\n\t\t\tclassPathPrintFiles = classPathPrints.toArray(classPathPrintFiles);\n\t\t\tclasspath = readClassPath(classPathPrintFiles);\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(\"Failed to generate class path for \" + pomFile.getAbsolutePath() + \".\");\n\t\t}\n\t\treturn classpath;\n\t}\n\n\tprivate static String getSpoonClasspathTmpFileName(MavenLauncher.SOURCE_TYPE sourceType) {\n\t\t// As the temporary file containing the classpath is re-generated only\n\t\t// once per hour, we need a different file for different dependency\n\t\t// resolution scopes.\n\t\tif (MavenLauncher.SOURCE_TYPE.TEST_SOURCE == sourceType) {\n\t\t\treturn spoonClasspathTmpFileNameTest;\n\t\t} else if (MavenLauncher.SOURCE_TYPE.APP_SOURCE == sourceType) {\n\t\t\treturn spoonClasspathTmpFileNameApp;\n\t\t} else {\n\t\t\treturn spoonClasspathTmpFileName;\n\t\t}\n\t}\n\n\t/**\n\t * Get the parent model\n\t * @return the parent model\n\t */\n\tpublic SpoonPom getParentPom() {\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Get the parent directory\n\t * @return the parent directory\n\t */\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\ttry {\n\t\t\treturn SpoonResourceHelper.createFolder(directory);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn directory;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"pom\";\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\treturn pomFile.getPath();\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn pomFile;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/PositionBuilder.java",
      "weight" : 604.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\nimport org.eclipse.jdt.internal.compiler.ast.Javadoc;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeParameter;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.factory.CoreFactory;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.compiler.jdt.ContextBuilder.CastInfo;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getModifiers;\n\n/**\n * Created by bdanglot on 07/07/16.\n */\npublic class PositionBuilder {\n\n\tprivate final JDTTreeBuilder jdtTreeBuilder;\n\n\tpublic PositionBuilder(JDTTreeBuilder jdtTreeBuilder) {\n\t\tthis.jdtTreeBuilder = jdtTreeBuilder;\n\t}\n\n\tSourcePosition buildPosition(int sourceStart, int sourceEnd) {\n\t\tCompilationUnit cu = this.jdtTreeBuilder.getContextBuilder().compilationUnitSpoon;\n\t\tfinal int[] lineSeparatorPositions = this.jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\t\treturn this.jdtTreeBuilder.getFactory().Core().createSourcePosition(cu, sourceStart, sourceEnd, lineSeparatorPositions);\n\t}\n\n\tSourcePosition buildPositionCtElement(CtElement e, ASTNode node) {\n\t\tif (e instanceof CtCatch) {\n\t\t\t//we cannot compute position of CtCatch, because we do not know position of it's body yet\n\t\t\t//it is computed later by #buildPosition(CtCatch)\n\t\t\treturn SourcePosition.NOPOSITION;\n\t\t}\n\t\tCoreFactory cf = this.jdtTreeBuilder.getFactory().Core();\n\t\tCompilationUnit cu = this.jdtTreeBuilder.getContextBuilder().compilationUnitSpoon;\n\t\tint[] lineSeparatorPositions = jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\t\tchar[] contents = jdtTreeBuilder.getContextBuilder().getCompilationUnitContents();\n\n\t\tint sourceStart = node.sourceStart;\n\t\tint sourceEnd = node.sourceEnd;\n\t\tif ((node instanceof Annotation)) {\n\t\t\tAnnotation ann = (Annotation) node;\n\t\t\tint declEnd = ann.declarationSourceEnd;\n\n\t\t\tif (declEnd > 0) {\n\t\t\t\tsourceEnd = declEnd;\n\t\t\t}\n\t\t} else if ((node instanceof Expression)) {\n\t\t\tExpression expression = (Expression) node;\n\t\t\tint statementEnd = expression.statementEnd;\n\n\t\t\tif (statementEnd > 0) {\n\t\t\t\tsourceEnd = statementEnd;\n\t\t\t}\n\n\t\t\tif (this.jdtTreeBuilder.getContextBuilder().isBuildTypeCast && e instanceof CtTypeReference) {\n\t\t\t\t//the type cast reference must be enclosed with brackets\n\t\t\t\tint declarationSourceStart = sourceStart;\n\t\t\t\tint declarationSourceEnd = sourceEnd;\n\t\t\t\tdeclarationSourceStart = findPrevNonWhitespace(contents, getParentsSourceStart(), declarationSourceStart - 1);\n\t\t\t\tif (contents[declarationSourceStart] != '(') {\n\t\t\t\t\treturn handlePositionProblem(\"Unexpected character \\'\" + contents[declarationSourceStart] + \"\\' at start of cast expression on offset: \" + declarationSourceStart);\n\t\t\t\t}\n\t\t\t\tdeclarationSourceEnd = findNextNonWhitespace(contents, contents.length - 1, declarationSourceEnd + 1);\n\t\t\t\tif (contents[declarationSourceEnd] != ')') {\n\t\t\t\t\treturn handlePositionProblem(\"Unexpected character \\'\" + contents[declarationSourceStart] + \"\\' at end of cast expression on offset: \" + declarationSourceEnd);\n\t\t\t\t}\n\t\t\t\treturn cf.createCompoundSourcePosition(cu,\n\t\t\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\t\t\tlineSeparatorPositions);\n\t\t\t}\n\n\t\t\tList<CastInfo> casts = this.jdtTreeBuilder.getContextBuilder().casts;\n\n\t\t\tif (!casts.isEmpty() && e instanceof CtExpression) {\n\t\t\t\tint declarationSourceStart = sourceStart;\n\t\t\t\tint declarationSourceEnd = sourceEnd;\n\t\t\t\tSourcePosition pos = casts.get(0).typeRef.getPosition();\n\t\t\t\tif (pos.isValidPosition()) {\n\t\t\t\t\tdeclarationSourceStart = pos.getSourceStart();\n\t\t\t\t\tint nrOfBrackets = getNrOfFirstCastExpressionBrackets();\n\t\t\t\t\twhile (nrOfBrackets > 0) {\n\t\t\t\t\t\tdeclarationSourceStart = findPrevNonWhitespace(contents, getParentsSourceStart(), declarationSourceStart - 1);\n\t\t\t\t\t\tif (declarationSourceStart < 0) {\n\t\t\t\t\t\t\treturn handlePositionProblem(\"Cannot found beginning of cast expression until offset: \" + getParentsSourceStart());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (contents[declarationSourceStart] != '(') {\n\t\t\t\t\t\t\treturn handlePositionProblem(\"Unexpected character \\'\" + contents[declarationSourceStart] + \"\\' at start of expression on offset: \" + declarationSourceStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnrOfBrackets--;\n\t\t\t\t\t}\n\t\t\t\t\tnrOfBrackets = getNrOfCastExpressionBrackets();\n\t\t\t\t\twhile (nrOfBrackets > 0) {\n\t\t\t\t\t\tdeclarationSourceEnd = findNextNonWhitespace(contents, contents.length - 1, declarationSourceEnd + 1);\n\t\t\t\t\t\tif (contents[declarationSourceEnd] != ')') {\n\t\t\t\t\t\t\treturn handlePositionProblem(\"Unexpected character \\'\" + contents[declarationSourceStart] + \"\\' at end of expression on offset: \" + declarationSourceEnd);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnrOfBrackets--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn cf.createCompoundSourcePosition(cu,\n\t\t\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\t\t\tlineSeparatorPositions);\n\t\t\t}\n\t\t}\n\n\t\tif (node instanceof TypeParameter) {\n\t\t\tTypeParameter typeParameter = (TypeParameter) node;\n\t\t\tsourceStart = typeParameter.declarationSourceStart;\n\t\t\tsourceEnd = typeParameter.declarationSourceEnd;\n\t\t\tif (typeParameter.type != null) {\n\t\t\t\tsourceEnd = getSourceEndOfTypeReference(contents, typeParameter.type, sourceEnd);\n\t\t\t}\n\t\t} else if (node instanceof AbstractVariableDeclaration) {\n\t\t\tAbstractVariableDeclaration variableDeclaration = (AbstractVariableDeclaration) node;\n\t\t\tint modifiersSourceStart = variableDeclaration.modifiersSourceStart;\n\t\t\tint declarationSourceStart = variableDeclaration.declarationSourceStart;\n\t\t\tint declarationSourceEnd = variableDeclaration.declarationSourceEnd;\n\t\t\tif (declarationSourceStart == 0 && declarationSourceEnd == 0) {\n\t\t\t\treturn SourcePosition.NOPOSITION;\n\t\t\t}\n\t\t\tif (e instanceof CtCatchVariable) {\n\t\t\t\t/* compiler delivers wrong declarationSourceStart in case like: */\n\t\t\t\t//... catch/*2*/ ( /*3*/ final @Deprecated /*4*/ ClassCastException /*5*/ e /*6*/) /*7*/ {\n\t\t\t\t/*\n\t\t\t\t * the declarationSourceStart should be after the '(', but sometime it is before\n\t\t\t\t * So we have to compute correct offset here\n\t\t\t\t */\n\t\t\t\tCtTry tryStatement = this.jdtTreeBuilder.getContextBuilder().getParentElementOfType(CtTry.class);\n\t\t\t\tint endOfTry = tryStatement.getPosition().getSourceEnd();\n\t\t\t\t//offset of the bracket before catch\n\t\t\t\tint lastBracket = getEndOfLastTryBlock(tryStatement, 0);\n\t\t\t\tint catchStart = findNextNonWhitespace(contents, endOfTry, lastBracket + 1);\n\t\t\t\tif (CATCH.equals(new String(contents, catchStart, CATCH.length())) == false) {\n\t\t\t\t\treturn handlePositionProblem(\"Unexpected beginning of catch statement on offset: \" + catchStart);\n\t\t\t\t}\n\t\t\t\tint bracketStart = findNextNonWhitespace(contents, endOfTry, catchStart + CATCH.length());\n\t\t\t\tif (bracketStart < 0) {\n\t\t\t\t\treturn handlePositionProblem(\"Unexpected end of file instead of \\'(\\' after catch statement on offset: \" + catchStart);\n\t\t\t\t}\n\t\t\t\tif (contents[bracketStart] != '(') {\n\t\t\t\t\treturn handlePositionProblem(\"Unexpected character \" + contents[bracketStart] + \" instead of \\'(\\' after catch statement on offset: \" + bracketStart);\n\t\t\t\t}\n\t\t\t\tdeclarationSourceStart = bracketStart + 1;\n\t\t\t}\n\t\t\tCtElement parent = this.jdtTreeBuilder.getContextBuilder().getContextElementOnLevel(1);\n\t\t\tif (parent instanceof CtForEach) {\n\t\t\t\tCtForEach forEach = (CtForEach) parent;\n\t\t\t\t//compiler deliver wrong local variable position when for(...:...) starts with line comment\n\t\t\t\tint parentStart = parent.getPosition().getSourceStart();\n\t\t\t\tif (contents[parentStart] != 'f' || contents[parentStart + 1] != 'o' || contents[parentStart + 2] != 'r') {\n\t\t\t\t\treturn handlePositionProblem(\"Expected keyword for at offset: \" + parentStart);\n\t\t\t\t}\n\t\t\t\tint bracketOff = findNextNonWhitespace(contents, forEach.getPosition().getSourceEnd(), parentStart + 3);\n\t\t\t\tif (bracketOff < 0 || contents[bracketOff] != '(') {\n\t\t\t\t\treturn handlePositionProblem(\"Expected character after \\'for\\' instead of \\'(\\' at offset: \" + (parentStart + 3));\n\t\t\t\t}\n\t\t\t\tdeclarationSourceStart = bracketOff + 1;\n\t\t\t\tdeclarationSourceEnd = sourceEnd;\n\t\t\t}\n\n\t\t\tif (variableDeclaration instanceof Argument && variableDeclaration.type instanceof ArrayTypeReference) {\n\t\t\t\t//handle type declarations like `String[] arg` `String arg[]` and `String []arg[]`\n\t\t\t\tArrayTypeReference arrTypeRef = (ArrayTypeReference) variableDeclaration.type;\n\t\t\t\tint dimensions = arrTypeRef.dimensions();\n\t\t\t\tif (dimensions > 0) {\n\t\t\t\t\t//count number of brackets between type and variable name\n\t\t\t\t\tint foundDimensions = getNrOfDimensions(contents, declarationSourceStart, declarationSourceEnd);\n\t\t\t\t\twhile (dimensions > foundDimensions) {\n\t\t\t\t\t\t//some brackets are after the variable name\n\t\t\t\t\t\tdeclarationSourceEnd = findNextChar(contents, contents.length, declarationSourceEnd + 1, ']');\n\t\t\t\t\t\tif (declarationSourceEnd < 0) {\n\t\t\t\t\t\t\treturn handlePositionProblem(\"Unexpected array type declaration on offset: \" + declarationSourceStart);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundDimensions++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (modifiersSourceStart <= 0) {\n\t\t\t\tmodifiersSourceStart = findNextNonWhitespace(contents, contents.length - 1, declarationSourceStart);\n\t\t\t}\n\t\t\tint modifiersSourceEnd;\n\t\t\tif (variableDeclaration.type != null) {\n\t\t\t\tmodifiersSourceEnd = findPrevNonWhitespace(contents, declarationSourceStart, variableDeclaration.type.sourceStart() - 1);\n\t\t\t} else if (variableDeclaration instanceof Initializer) {\n\t\t\t\tmodifiersSourceEnd = ((Initializer) variableDeclaration).block.sourceStart - 1;\n\t\t\t} else {\n\t\t\t\t// variable that has no type such as TypeParameter\n\t\t\t\tmodifiersSourceEnd = declarationSourceStart - 1;\n\t\t\t}\n\n\t\t\t// when no modifier\n\t\t\tif (modifiersSourceStart > modifiersSourceEnd) {\n\t\t\t\tmodifiersSourceEnd = modifiersSourceStart - 1;\n\t\t\t}  else if (e instanceof CtModifiable) {\n\t\t\t\tsetModifiersPosition((CtModifiable) e, modifiersSourceStart, modifiersSourceEnd);\n\t\t\t}\n\n\t\t\treturn cf.createDeclarationSourcePosition(cu,\n\t\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\t\tmodifiersSourceStart, modifiersSourceEnd,\n\t\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\t\tlineSeparatorPositions);\n\t\t} else if (node instanceof TypeDeclaration && e instanceof CtPackage) {\n\t\t\t// the position returned by JTD is equals to 0\n\t\t\treturn cf.createSourcePosition(cu, 0, contents.length - 1, lineSeparatorPositions);\n\t\t} else if (node instanceof TypeDeclaration) {\n\t\t\tTypeDeclaration typeDeclaration = (TypeDeclaration) node;\n\n\t\t\tint declarationSourceStart = typeDeclaration.declarationSourceStart;\n\t\t\tint declarationSourceEnd = typeDeclaration.declarationSourceEnd;\n\t\t\tint modifiersSourceStart = typeDeclaration.modifiersSourceStart;\n\t\t\tint bodyStart = typeDeclaration.bodyStart;\n\t\t\tint bodyEnd = typeDeclaration.bodyEnd;\n\n\t\t\tint modifiersSourceEnd;\n\t\t\tif (typeDeclaration.name.length == 0) {\n\t\t\t\t//it is anonymous type\n\t\t\t\tif (contents[bodyStart] != '{') {\n\t\t\t\t\t//adjust bodyStart of annonymous type in definition of enum value\n\t\t\t\t\tif (bodyStart < 1 || contents[bodyStart - 1] != '{') {\n\t\t\t\t\t\tthrow new SpoonException(\"Cannot found body start at offset \" + bodyStart + \" of annonymous class with sources:\\n\" + new String(contents));\n\t\t\t\t\t}\n\t\t\t\t\tbodyStart--;\n\t\t\t\t}\n\t\t\t\tdeclarationSourceStart = modifiersSourceStart = sourceStart = bodyStart;\n\t\t\t\tif (contents[bodyEnd] != '}') {\n\t\t\t\t\t//adjust bodyEnd of annonymous type in definition of enum value\n\t\t\t\t\tif (contents[bodyEnd + 1] != '}') {\n\t\t\t\t\t\tthrow new SpoonException(\"Cannot found body end at offset \" + bodyEnd + \" of annonymous class with sources:\\n\" + new String(contents));\n\t\t\t\t\t}\n\t\t\t\t\tbodyEnd++;\n\t\t\t\t}\n\t\t\t\tdeclarationSourceEnd = bodyEnd;\n\t\t\t\t//there is no name of annonymous class\n\t\t\t\tsourceEnd = sourceStart - 1;\n\t\t\t\t//there are no modifiers of annonymous class\n\t\t\t\tmodifiersSourceEnd = modifiersSourceStart - 1;\n\t\t\t\tbodyStart++;\n\t\t\t} else {\n\t\t\t\tif (modifiersSourceStart <= 0) {\n\t\t\t\t\tmodifiersSourceStart = declarationSourceStart;\n\t\t\t\t}\n\t\t\t\t//look for start of first keyword before the type keyword e.g. \"class\". `sourceStart` points at first char of type name\n\t\t\t\tmodifiersSourceEnd = findPrevNonWhitespace(contents, modifiersSourceStart - 1,\n\t\t\t\t\t\t\t\t\t\t\tfindPrevWhitespace(contents, modifiersSourceStart - 1,\n\t\t\t\t\t\t\t\t\t\t\t\tfindPrevNonWhitespace(contents, modifiersSourceStart - 1, sourceStart - 1)));\n\t\t\t\tif (e instanceof CtModifiable) {\n\t\t\t\t\tsetModifiersPosition((CtModifiable) e, modifiersSourceStart, modifiersSourceEnd);\n\t\t\t\t}\n\t\t\t\tif (modifiersSourceEnd < modifiersSourceStart) {\n\t\t\t\t\t//there is no modifier\n\t\t\t\t\tmodifiersSourceEnd = modifiersSourceStart - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cf.createBodyHolderSourcePosition(cu, sourceStart, sourceEnd,\n\t\t\t\t\tmodifiersSourceStart, modifiersSourceEnd,\n\t\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\t\tbodyStart - 1, bodyEnd,\n\t\t\t\t\tlineSeparatorPositions);\n\t\t} else if (node instanceof AbstractMethodDeclaration) {\n\t\t\tAbstractMethodDeclaration methodDeclaration = (AbstractMethodDeclaration) node;\n\t\t\tint bodyStart = methodDeclaration.bodyStart;\n\t\t\tint bodyEnd = methodDeclaration.bodyEnd;\n\t\t\tint declarationSourceStart = methodDeclaration.declarationSourceStart;\n\t\t\tint declarationSourceEnd = methodDeclaration.declarationSourceEnd;\n\t\t\tint modifiersSourceStart = methodDeclaration.modifiersSourceStart;\n\n\t\t\tif (modifiersSourceStart <= 0) {\n\t\t\t\tmodifiersSourceStart = declarationSourceStart;\n\t\t\t}\n\n\t\t\tif (node instanceof AnnotationMethodDeclaration && bodyStart == bodyEnd) {\n\t\t\t\t//The \";\" at the end of annotation method declaration is not part of body\n\t\t\t\t//let it behave same like in abstract MethodDeclaration\n\t\t\t\tbodyEnd--;\n\t\t\t}\n\n\t\t\tJavadoc javadoc = methodDeclaration.javadoc;\n\t\t\tif (javadoc != null && javadoc.sourceEnd() > declarationSourceStart) {\n\t\t\t\tmodifiersSourceStart = javadoc.sourceEnd() + 1;\n\t\t\t}\n\n\t\t\tint modifiersSourceEnd = sourceStart - 1;\n\n\t\t\tif (e instanceof CtModifiable) {\n\t\t\t\tsetModifiersPosition((CtModifiable) e, modifiersSourceStart, declarationSourceEnd);\n\t\t\t}\n\n\t\t\tif (methodDeclaration instanceof MethodDeclaration && ((MethodDeclaration) methodDeclaration).returnType != null) {\n\t\t\t\tmodifiersSourceEnd = ((MethodDeclaration) methodDeclaration).returnType.sourceStart() - 2;\n\t\t\t}\n\n\t\t\tTypeParameter[] typeParameters = methodDeclaration.typeParameters();\n\t\t\tif (typeParameters != null && typeParameters.length > 0) {\n\t\t\t\tmodifiersSourceEnd = typeParameters[0].declarationSourceStart - 3;\n\t\t\t}\n\n\t\t\tif (getModifiers(methodDeclaration.modifiers, false, true).isEmpty()) {\n\t\t\t\tmodifiersSourceEnd = modifiersSourceStart - 1;\n\t\t\t}\n\n\n\t\t\tsourceEnd = sourceStart + methodDeclaration.selector.length - 1;\n\t\t\tif (bodyStart == 0) {\n\t\t\t\treturn cf.createPartialSourcePosition(cu);\n\t\t\t}\n\t\t\tif (e instanceof CtStatementList) {\n\t\t\t\treturn cf.createSourcePosition(cu, bodyStart - 1, bodyEnd + 1, lineSeparatorPositions);\n\t\t\t} else {\n\t\t\t\t//include brackets if they are there\n\t\t\t\tif (contents[bodyStart - 1] == '{') {\n\t\t\t\t\tbodyStart--;\n\t\t\t\t\tif (contents[bodyEnd + 1] == '}') {\n\t\t\t\t\t\tbodyEnd++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (bodyStart < bodyEnd) {\n\t\t\t\t\t\t\treturn handlePositionProblem(\"Missing body end in\\n\" + new String(contents, sourceStart, sourceEnd - sourceStart));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn cf.createBodyHolderSourcePosition(cu,\n\t\t\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\t\t\tmodifiersSourceStart, modifiersSourceEnd,\n\t\t\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\t\t\tbodyStart, bodyEnd,\n\t\t\t\t\t\tlineSeparatorPositions);\n\t\t\t}\n\t\t} else if (e instanceof CtCatchVariable) {\n\t\t\tASTPair pair = this.jdtTreeBuilder.getContextBuilder().getParentContextOfType(CtCatch.class);\n\t\t\tif (pair == null) {\n\t\t\t\treturn handlePositionProblem(\"There is no CtCatch parent for CtCatchVariable\");\n\t\t\t}\n\t\t\t//build position with appropriate context\n\t\t\treturn buildPositionCtElement(e, (Argument) pair.node);\n\t\t} else if (node instanceof TypeReference) {\n\t\t\tsourceEnd = getSourceEndOfTypeReference(contents, (TypeReference) node, sourceEnd);\n\t\t} else if (node instanceof AllocationExpression) {\n\t\t\tAllocationExpression allocationExpression = (AllocationExpression) node;\n\t\t\tif (allocationExpression.enumConstant != null) {\n\t\t\t\tFieldDeclaration fieldDeclaration = allocationExpression.enumConstant;\n\t\t\t\t//1) skip comments\n\t\t\t\tsourceStart = findNextNonWhitespace(contents, sourceEnd, sourceStart);\n\t\t\t\t//2) move to beginning of enum construction\n\t\t\t\tsourceStart += fieldDeclaration.name.length;\n\t\t\t}\n\t\t} else if (node instanceof CaseStatement) {\n\t\t\tsourceEnd = findNextNonWhitespace(contents, contents.length - 1, sourceEnd + 1);\n\t\t\tif (sourceEnd < 0) {\n\t\t\t\treturn handlePositionProblem(\"Unexpected end of file in CtCase on: \" + sourceStart);\n\t\t\t}\n\t\t\tif (contents[sourceEnd] != ':') {\n\t\t\t\treturn handlePositionProblem(\"Unexpected character \" + contents[sourceEnd] + \" instead of \\':\\' in CtCase on: \" + sourceEnd);\n\t\t\t}\n\t\t}\n\n\t\tif (e instanceof CtModifiable) {\n\t\t\tsetModifiersPosition((CtModifiable) e, sourceStart, sourceEnd);\n\t\t}\n\t\tif (sourceStart == 0 && sourceEnd == 0) {\n\t\t\treturn SourcePosition.NOPOSITION;\n\t\t}\n\t\treturn cf.createSourcePosition(cu, sourceStart, sourceEnd, lineSeparatorPositions);\n\t}\n\n\tprivate int getParentsSourceStart() {\n\t\tIterator<ASTPair> iter = this.jdtTreeBuilder.getContextBuilder().stack.iterator();\n\t\tif (iter.hasNext()) {\n\t\t\titer.next();\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tASTPair pair = iter.next();\n\t\t\t\tSourcePosition pos = pair.element.getPosition();\n\t\t\t\tif (pos.isValidPosition()) {\n\t\t\t\t\treturn pos.getSourceStart();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprivate int getNrOfDimensions(char[] contents, int start, int end) {\n\t\tint nrDims = 0;\n\t\twhile ((start = findNextNonWhitespace(contents, end, start)) >= 0) {\n\t\t\tif (contents[start] == ']') {\n\t\t\t\tnrDims++;\n\t\t\t}\n\t\t\tif (contents[start] == '.' && start + 2 <= end && contents[start + 1] == '.' && contents[start + 2] == '.') {\n\t\t\t\t//String...arg is same like String[] arg, so it is counted as dimension too\n\t\t\t\tstart = start + 2;\n\t\t\t\tnrDims++;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\treturn nrDims;\n\t}\n\n\tprivate static final String CATCH = \"catch\";\n\n\tSourcePosition buildPosition(CtCatch catcher) {\n\t\tint[] lineSeparatorPositions = jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\n\t\tCtTry tryElement = catcher.getParent(CtTry.class);\n\t\t//offset after last bracket before catch\n\t\tint declarationStart = getEndOfLastTryBlock(tryElement, 1) + 1;\n\t\tDeclarationSourcePosition paramPos = (DeclarationSourcePosition) catcher.getParameter().getPosition();\n\t\tint bodyStart = catcher.getBody().getPosition().getSourceStart();\n\t\tint bodyEnd = catcher.getBody().getPosition().getSourceEnd();\n\t\treturn catcher.getFactory().Core().createBodyHolderSourcePosition(\n\t\t\t\ttryElement.getPosition().getCompilationUnit(),\n\t\t\t\t//on the place of name there is catch variable\n\t\t\t\tparamPos.getSourceStart(), paramPos.getSourceEnd(),\n\t\t\t\t//catch has no modifiers, They are in catch variable\n\t\t\t\tdeclarationStart, declarationStart - 1,\n\t\t\t\tdeclarationStart, bodyEnd,\n\t\t\t\tbodyStart, bodyEnd,\n\t\t\t\tlineSeparatorPositions);\n\t}\n\n\tSourcePosition buildPosition(CtCase<?> child) {\n\t\tList<CtStatement> statements = child.getStatements();\n\t\tSourcePosition oldPosition = child.getPosition();\n\t\tif (statements.isEmpty()) {\n\t\t\t//There are no statements. Keep origin position\n\t\t\treturn oldPosition;\n\t\t}\n\t\tint[] lineSeparatorPositions = this.jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\n\t\tint bodyStart = child.getPosition().getSourceEnd() + 1;\n\t\tint bodyEnd = statements.get(statements.size() - 1).getPosition().getSourceEnd();\n\t\treturn child.getFactory().Core().createBodyHolderSourcePosition(\n\t\t\t\toldPosition.getCompilationUnit(),\n\t\t\t\toldPosition.getSourceStart(), oldPosition.getSourceEnd(),\n\t\t\t\toldPosition.getSourceStart(), oldPosition.getSourceStart() - 1,\n\t\t\t\toldPosition.getSourceStart(), bodyEnd,\n\t\t\t\tbodyStart, bodyEnd,\n\t\t\t\tlineSeparatorPositions);\n\t}\n\n\t/**\n\t * @param tryElement\n\t * @param negIdx 0 - last block, 1 - one before last block, ...\n\t * @return\n\t */\n\tprivate int getEndOfLastTryBlock(CtTry tryElement, int negIdx) {\n\t\t//offset where we can start to search for catch\n\t\tint endOfLastBlock = tryElement.getBody().getPosition().getSourceEnd();\n\t\tif (tryElement.getCatchers().size() > negIdx) {\n\t\t\tCtCatch prevCatcher = tryElement.getCatchers().get(tryElement.getCatchers().size() - 1 - negIdx);\n\t\t\tendOfLastBlock = prevCatcher.getPosition().getSourceEnd();\n\t\t}\n\t\treturn endOfLastBlock;\n\t}\n\n\tprivate int getNrOfFirstCastExpressionBrackets() {\n\t\treturn this.jdtTreeBuilder.getContextBuilder().casts.get(0).nrOfBrackets;\n\t}\n\n\tprivate int getNrOfCastExpressionBrackets() {\n\t\tint nr = 0;\n\t\tfor (CastInfo castInfo : this.jdtTreeBuilder.getContextBuilder().casts) {\n\t\t\tnr += castInfo.nrOfBrackets;\n\t\t}\n\t\treturn nr;\n\t}\n\n\tprivate void setModifiersPosition(CtModifiable e, int start, int end) {\n\t\tCoreFactory cf = this.jdtTreeBuilder.getFactory().Core();\n\t\tCompilationUnit cu = this.jdtTreeBuilder.getContextBuilder().compilationUnitSpoon;\n\t\tchar[] contents = jdtTreeBuilder.getContextBuilder().getCompilationUnitContents();\n\n\t\tSet<CtExtendedModifier> modifiers = e.getExtendedModifiers();\n\t\tMap<String, CtExtendedModifier> explicitModifiersByName = new HashMap<>();\n\t\tfor (CtExtendedModifier modifier: modifiers) {\n\t\t\tif (modifier.isImplicit()) {\n\t\t\t\tmodifier.setPosition(cf.createPartialSourcePosition(cu));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (explicitModifiersByName.put(modifier.getKind().toString(), modifier) != null) {\n\t\t\t\tthrow new SpoonException(\"The modifier \" + modifier.getKind().toString() + \" found twice\");\n\t\t\t}\n\t\t}\n\n\t\t//move end after the last char\n\t\tend++;\n\t\twhile (start < end && explicitModifiersByName.size() > 0) {\n\t\t\tint o1 = findNextNonWhitespace(contents, end - 1, start);\n\t\t\tif (o1 == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint o2 = findNextWhitespace(contents, end - 1, o1);\n\t\t\tif (o2 == -1) {\n\t\t\t\to2 = end;\n\t\t\t}\n\t\t\tString modifierName = String.valueOf(contents, o1, o2 - o1);\n\t\t\tCtExtendedModifier modifier = explicitModifiersByName.remove(modifierName);\n\t\t\tif (modifier != null) {\n\t\t\t\tmodifier.setPosition(cf.createSourcePosition(cu, o1, o2 - 1, jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions()));\n\t\t\t}\n\t\t\tstart = o2;\n\t\t}\n\t\tif (explicitModifiersByName.size() > 0) {\n\t\t\tthrow new SpoonException(\"Position of CtExtendedModifiers: [\" + String.join(\", \", explicitModifiersByName.keySet()) + \"] not found in \" + String.valueOf(contents, start, end - start));\n\t\t}\n\t}\n\n\tprivate int getSourceEndOfTypeReference(char[] contents, TypeReference node, int sourceEnd) {\n\t\t//e.g. SomeType<String,T>\n\t\tTypeReference[][] typeArgs = node.getTypeArguments();\n\t\tif (typeArgs != null && typeArgs.length > 0) {\n\t\t\tTypeReference[] trs = typeArgs[typeArgs.length - 1];\n\t\t\tif (trs != null && trs.length > 0) {\n\t\t\t\tTypeReference tr = trs[trs.length - 1];\n\t\t\t\tif (sourceEnd < tr.sourceEnd) {\n\t\t\t\t\t//the sourceEnd of reference is smaller then source of type argument of this reference\n\t\t\t\t\t//move sourceEnd so that type argument is included in sources\n\t\t\t\t\t//TODO handle comments correctly here. E.g. List<T /*ccc*/ >\n\t\t\t\t\tsourceEnd = findNextNonWhitespace(contents, contents.length - 1, getSourceEndOfTypeReference(contents, tr, tr.sourceEnd) + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//SomeType<>\n\t\t\t\tint startIdx = findNextNonWhitespace(contents, contents.length - 1, sourceEnd + 1);\n\t\t\t\tif (startIdx != -1 && contents[startIdx] == '<') {\n\t\t\t\t\tint endIdx = findNextNonWhitespace(contents, contents.length - 1, startIdx + 1);\n\t\t\t\t\tif (endIdx != -1 && contents[endIdx] == '>') {\n\t\t\t\t\t\tsourceEnd = endIdx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (node instanceof Wildcard) {\n\t\t\tWildcard wildcard = (Wildcard) node;\n\t\t\tif (wildcard.bound != null) {\n\t\t\t\tsourceEnd = getSourceEndOfTypeReference(contents, wildcard.bound, sourceEnd);\n\t\t\t}\n\t\t}\n\t\treturn sourceEnd;\n\t}\n\n\t/**\n\t * @return index of first character `expectedChar`, searching forward..\n\t * Can return 'off' if it is `expectedChar`. returns -1 if not found\n\t * Note: all kinds of java comments are understood as whitespace.\n\t * The search must start out of comment or on the first character of the comment\n\t */\n\tstatic int findNextChar(char[] contents, int maxOff, int off, char expectedChar) {\n\t\twhile ((off = findNextNonWhitespace(contents, maxOff, off)) >= 0) {\n\t\t\tif (contents[off] == expectedChar) {\n\t\t\t\treturn off;\n\t\t\t}\n\t\t\toff++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param maxOff maximum acceptable return value\n\t * @return index of first non whitespace char, searching forward.\n\t * Can return 'off' if it is non whitespace.\n\t * Note: all kinds of java comments are understood as whitespace too.\n\t * The search must start out of comment or on the first character of the comment\n\t */\n\tstatic int findNextNonWhitespace(char[] content, int maxOff, int off) {\n\t\treturn findNextNonWhitespace(true, content, maxOff, off);\n\t}\n\tstatic int findNextNonWhitespace(boolean commentIsWhiteSpace, char[] content, int maxOff, int off) {\n\t\tmaxOff = Math.min(maxOff, content.length - 1);\n\t\twhile (off >= 0 && off <= maxOff) {\n\t\t\tchar c = content[off];\n\t\t\tif (Character.isWhitespace(c) == false) {\n\t\t\t\t//non whitespace found\n\t\t\t\tint endOfCommentOff = commentIsWhiteSpace ? getEndOfComment(content, maxOff, off) : -1;\n\t\t\t\tif (endOfCommentOff == -1) {\n\t\t\t\t\t//it is not a comment. Finish\n\t\t\t\t\treturn off;\n\t\t\t\t}\n\t\t\t\t//it is a comment move to the end of comment and continue\n\t\t\t\toff = endOfCommentOff;\n\t\t\t}\n\t\t\toff++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param maxOff maximum acceptable return value\n\t * @return index of first whitespace char, searching forward. Return -1 if there is no white space.\n\t * Can return `off` if it is already a non whitespace.\n\t * Note: all kinds of java comments are understood as whitespace too. Then it returns offset of the first character of the comment\n\t */\n\tstatic int findNextWhitespace(char[] content, int maxOff, int off) {\n\t\tmaxOff = Math.min(maxOff, content.length - 1);\n\t\twhile (off >= 0 && off <= maxOff) {\n\t\t\tchar c = content[off];\n\t\t\tif (Character.isWhitespace(c) || getEndOfComment(content, maxOff, off) >= 0) {\n\t\t\t\t//it is whitespace or comment starts there\n\t\t\t\treturn off;\n\t\t\t}\n\t\t\toff++;\n\t\t}\n\t\treturn -1;\n\t}\n\t/**\n\t * @param minOff the minimal acceptable return value\n\t * @return index of first non whitespace char, searching backward. Can return `off` if it is already a non whitespace.\n\t * Note: all kinds of java comments are understood as whitespace too. Then it returns offset of the first non whitespace character before the comment\n\t */\n\tstatic int findPrevNonWhitespace(char[] content, int minOff, int off) {\n\t\tminOff = Math.max(0, minOff);\n\t\twhile (off >= minOff) {\n\t\t\tchar c = content[off];\n\t\t\t//first check a comment and then whitesapce\n\t\t\t//because line comment \"// ...  \\n\" ends with EOL, which would be eat by isWhitespace and the comment detection would fail then\n\t\t\tint startOfCommentOff = getStartOfComment(content, minOff, off);\n\t\t\tif (startOfCommentOff >= 0) {\n\t\t\t\toff = startOfCommentOff;\n\t\t\t} else if (Character.isWhitespace(c) == false) {\n\t\t\t\t//non whitespace found.\n\t\t\t\treturn off;\n\t\t\t}\n\t\t\toff--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param minOff the minimal acceptable return value\n\t * @return index of first whitespace char, searching backward. Can return off if it is whitespace.\n\t * Note: all kinds of java comments are understood as whitespace too. Then it returns offset of the last comment character.\n\t * in case of line comment it returns last character of EOL which ends the comment\n\t */\n\tstatic int findPrevWhitespace(char[] content, int minOff, int off) {\n\t\tminOff = Math.max(0, minOff);\n\t\twhile (off >= minOff) {\n\t\t\tchar c = content[off];\n\t\t\tif (Character.isWhitespace(c) || getStartOfComment(content, minOff, off) >= 0) {\n\t\t\t\treturn off;\n\t\t\t}\n\t\t\toff--;\n\t\t}\n\t\treturn -1;\n\t}\n\t/**\n\t * @param maxOff maximum acceptable return value\n\t * @return if the off points at start of comment then it returns offset which points on last character of the comment\n\t * if the off does not point at start of comment then it returns -1\n\t */\n\tstatic int getEndOfComment(char[] content, int maxOff, int off) {\n\t\tmaxOff = Math.min(maxOff, content.length - 1);\n\t\tif (off + 1 <= maxOff) {\n\t\t\tif (content[off] == '/' && content[off + 1] == '*') {\n\t\t\t\t// +3, because we are searching for first possible '/' and not for '*'\n\t\t\t\t//this is shortest comment: /**/\n\t\t\t\toff = off + 3;\n\t\t\t\twhile (off <= maxOff) {\n\t\t\t\t\tif (content[off] == '/' && content[off - 1] == '*') {\n\t\t\t\t\t\t//we have found end of this comment\n\t\t\t\t\t\treturn off;\n\t\t\t\t\t}\n\t\t\t\t\toff++;\n\t\t\t\t}\n\t\t\t\t//the content ended. Comment ends with end of file too\n\t\t\t\treturn off;\n\t\t\t} else if (content[off] == '/' && content[off + 1] == '/') {\n\t\t\t\twhile (off <= maxOff) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Handle all 3 kinds of EOLs\n\t\t\t\t\t * \\r\\n\n\t\t\t\t\t * \\r\n\t\t\t\t\t * \\n\n\t\t\t\t\t */\n\t\t\t\t\tif (content[off] == '\\n') {\n\t\t\t\t\t\treturn off;\n\t\t\t\t\t}\n\t\t\t\t\tif (content[off] == '\\r') {\n\t\t\t\t\t\t//we have found end of this comment\n\t\t\t\t\t\t//skip windows \\n too if any\n\t\t\t\t\t\tif (off < maxOff && content[off + 1] == '\\n') {\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn off;\n\t\t\t\t\t}\n\t\t\t\t\toff++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @param minOff minimum offset where it should search for start of comment\n\t * @return if the off points at end of comment then it returns offset which points on first character of the comment\n\t * if the off does not point at the end of comment then it returns -1\n\t */\n\tstatic int getStartOfComment(char[] content, int minOff, int off) {\n\t\tif (off < 2) {\n\t\t\t//there cannot start comment\n\t\t\treturn -1;\n\t\t}\n\t\tif ((content[off] == '/' && content[off - 1] == '*')\n\t\t\t\t|| content[off] == '\\n'\n\t\t\t\t|| content[off] == '\\r') {\n\t\t\t//it is probably end of some comment. Not that it is not enough to search for /* recursivelly\n\t\t\t//because there may be something like: comment starts here: /* /* /* and not here: /*  */\n\t\t\t//or something like this\n//\t\t\t/*// */ this code is not in comment EOL\n\t\t\t//so search for comment from beginning of `minOff`\n\t\t\tint maxOff = off;\n\t\t\toff = minOff;\n\t\t\twhile (off <= maxOff) {\n\t\t\t\tint endOfComment = getEndOfComment(content, maxOff, off);\n\t\t\t\tif (endOfComment >= 0) {\n\t\t\t\t\t//it detected a comment\n\t\t\t\t\tif (endOfComment == maxOff) {\n\t\t\t\t\t\t//off points to start of comment which ends on maxOff. We found it\n\t\t\t\t\t\treturn off;\n\t\t\t\t\t}\n\t\t\t\t\t//else we have found some previous comment\n\t\t\t\t\t//jump over it and continue searching\n\t\t\t\t\toff = endOfComment;\n\t\t\t\t}\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate SourcePosition handlePositionProblem(String errorMessage) {\n\t\tif (jdtTreeBuilder.getFactory().getEnvironment().checksAreSkipped()) {\n\t\t\tjdtTreeBuilder.getFactory().getEnvironment().debugMessage(\"Source position detection failed: \" + errorMessage);\n\t\t\treturn SourcePosition.NOPOSITION;\n\t\t}\n\t\tthrow new SpoonException(\"Source position detection failed: \" + errorMessage);\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTImportBuilder.java",
      "weight" : 122.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\n\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.visitor.filter.NamedElementFilter;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Created by urli on 08/08/2017.\n */\nclass JDTImportBuilder {\n\n\tprivate final CompilationUnitDeclaration declarationUnit;\n\tprivate String filePath;\n\tprivate CompilationUnit spoonUnit;\n\tprivate ICompilationUnit sourceUnit;\n\tprivate Factory factory;\n\tprivate Set<CtImport> imports;\n\n\tJDTImportBuilder(CompilationUnitDeclaration declarationUnit,  Factory factory) {\n\t\tthis.declarationUnit = declarationUnit;\n\t\tthis.factory = factory;\n\t\tthis.sourceUnit = declarationUnit.compilationResult.compilationUnit;\n\t\tthis.filePath = CharOperation.charToString(sourceUnit.getFileName());\n\t\t// get the CU: it has already been built during model building in JDTBasedSpoonCompiler\n\t\tthis.spoonUnit = JDTTreeBuilder.getOrCreateCompilationUnit(declarationUnit, factory);\n\t\tthis.imports = new HashSet<>();\n\t}\n\n\t// package visible method in a package visible class, not in the public API\n\tvoid build() {\n\t\t// sets the imports of the Spoon compilation unit corresponding to `declarationUnit`\n\n\t\tif (declarationUnit.imports == null || declarationUnit.imports.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ImportReference importRef : declarationUnit.imports) {\n\t\t\tString importName = importRef.toString();\n\t\t\tif (!importRef.isStatic()) {\n\t\t\t\tif (importName.endsWith(\"*\")) {\n\t\t\t\t\tint lastDot = importName.lastIndexOf('.');\n\t\t\t\t\tString packageName = importName.substring(0, lastDot);\n\n\t\t\t\t\t// only get package from the model by traversing from rootPackage the model\n\t\t\t\t\t// it does not use reflection to achieve that\n\t\t\t\t\tCtPackage ctPackage = this.factory.Package().get(packageName);\n\n\t\t\t\t\tif (ctPackage != null) {\n\t\t\t\t\t\tthis.imports.add(createImportWithPosition(ctPackage.getReference(), importRef));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (factory.getEnvironment().getNoClasspath()) {\n\t\t\t\t\t\t\tthis.imports.add(createUnresolvedImportWithPosition(importName, false, importRef));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tCtType klass = this.getOrLoadClass(importName);\n\t\t\t\t\tif (klass != null) {\n\t\t\t\t\t\tthis.imports.add(createImportWithPosition(klass.getReference(), importRef));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (factory.getEnvironment().getNoClasspath()) {\n\t\t\t\t\t\t\tthis.imports.add(createUnresolvedImportWithPosition(importName, false, importRef));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint lastDot = importName.lastIndexOf('.');\n\t\t\t\tString className = importName.substring(0, lastDot);\n\t\t\t\tString methodOrFieldName = importName.substring(lastDot + 1);\n\n\t\t\t\tCtType klass = this.getOrLoadClass(className);\n\t\t\t\tif (klass != null) {\n\t\t\t\t\tif (\"*\".equals(methodOrFieldName)) {\n\t\t\t\t\t\tthis.imports.add(createImportWithPosition(factory.Type().createTypeMemberWildcardImportReference(klass.getReference()), importRef));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tList<CtNamedElement> methodOrFields = klass.getElements(new NamedElementFilter<>(CtNamedElement.class, methodOrFieldName));\n\n\t\t\t\t\t\tif (!methodOrFields.isEmpty()) {\n\t\t\t\t\t\t\tCtNamedElement methodOrField = methodOrFields.get(0);\n\t\t\t\t\t\t\tthis.imports.add(createImportWithPosition(methodOrField.getReference(), importRef));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (factory.getEnvironment().getNoClasspath()) {\n\t\t\t\t\t\tthis.imports.add(createUnresolvedImportWithPosition(importName, true, importRef));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tspoonUnit.setImports(this.imports);\n\t}\n\n\tprivate CtImport createImportWithPosition(CtReference ref, ImportReference importRef) {\n\t\tchar[] content = sourceUnit.getContents();\n\t\tCtImport imprt = factory.Type().createImport(ref);\n\t\t//include comment before import\n\t\tint declStart = importRef.declarationSourceStart;\n\t\tint commentStart = PositionBuilder.findNextNonWhitespace(false, content, declStart, PositionBuilder.findPrevNonWhitespace(content, 0, declStart - 1) + 1);\n\t\timprt.setPosition(factory.Core().createCompoundSourcePosition(spoonUnit, importRef.sourceStart(), importRef.sourceEnd(), commentStart, importRef.declarationEnd, spoonUnit.getLineSeparatorPositions()));\n\t\timprt.getReference().setPosition(factory.Core().createSourcePosition(spoonUnit, importRef.sourceStart(), importRef.sourceEnd(), spoonUnit.getLineSeparatorPositions()));\n\t\treturn imprt;\n\t}\n\n\tprivate CtImport createUnresolvedImportWithPosition(String ref, boolean isStatic, ImportReference importRef) {\n\t\tchar[] content = sourceUnit.getContents();\n\t\tCtImport imprt = factory.Type().createUnresolvedImport(ref, isStatic);\n\t\t//include comment before import\n\t\tint declStart = importRef.declarationSourceStart;\n\t\tint commentStart = PositionBuilder.findNextNonWhitespace(false, content, declStart, PositionBuilder.findPrevNonWhitespace(content, 0, declStart - 1) + 1);\n\t\timprt.setPosition(factory.Core().createCompoundSourcePosition(spoonUnit, importRef.sourceStart(), importRef.sourceEnd(), commentStart, importRef.declarationEnd, spoonUnit.getLineSeparatorPositions()));\n\t\treturn imprt;\n\t}\n\n\tprivate CtType getOrLoadClass(String className) {\n\t\tCtType klass = this.factory.Type().get(className);\n\n\t\tif (klass == null) {\n\t\t\tklass = this.factory.Interface().get(className);\n\n\t\t\tif (klass == null) {\n\t\t\t\ttry {\n\t\t\t\t\tClass zeClass = this.getClass().getClassLoader().loadClass(className);\n\t\t\t\t\tklass = this.factory.Type().get(zeClass);\n\t\t\t\t\treturn klass;\n\t\t\t\t} catch (NoClassDefFoundError | ClassNotFoundException e) {\n\t\t\t\t\t// in some cases we want to import an inner class.\n\t\t\t\t\tif (!className.contains(CtType.INNERTTYPE_SEPARATOR) && className.contains(CtPackage.PACKAGE_SEPARATOR)) {\n\t\t\t\t\t\tint lastIndexOfDot = className.lastIndexOf(CtPackage.PACKAGE_SEPARATOR);\n\t\t\t\t\t\tString classNameWithInnerSep = className.substring(0, lastIndexOfDot) + CtType.INNERTTYPE_SEPARATOR + className.substring(lastIndexOfDot + 1);\n\t\t\t\t\t\treturn getOrLoadClass(classNameWithInnerSep);\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn klass;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/ContextBuilder.java",
      "weight" : 299.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\n\nimport spoon.Launcher;\nimport spoon.compiler.Environment;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.ClassFactory;\nimport spoon.reflect.factory.CoreFactory;\nimport spoon.reflect.factory.FieldFactory;\nimport spoon.reflect.factory.InterfaceFactory;\nimport spoon.reflect.factory.TypeFactory;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.support.Internal;\nimport spoon.support.SpoonClassNotFoundException;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.EnumSet;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;\nimport static java.lang.String.format;\n\n@Internal\npublic class ContextBuilder {\n\n\tDeque<String> annotationValueName = new ArrayDeque<>();\n\n\tpublic static class CastInfo {\n\t\tint nrOfBrackets;\n\t\tCtTypeReference<?> typeRef;\n\t}\n\n\tList<CastInfo> casts = new ArrayList<>(CASTS_CONTAINER_DEFAULT_CAPACITY);\n\n\tCompilationUnitDeclaration compilationunitdeclaration;\n\n\tCompilationUnit compilationUnitSpoon;\n\n\tboolean isBuildLambda = false;\n\n\tboolean isBuildTypeCast = false;\n\n\tboolean ignoreComputeImports = false;\n\n\t/**\n\t * Stack of all parents elements\n\t */\n\tDeque<ASTPair> stack = new ArrayDeque<>();\n\n\tprivate final JDTTreeBuilder jdtTreeBuilder;\n\n\tContextBuilder(JDTTreeBuilder jdtTreeBuilder) {\n\t\tthis.jdtTreeBuilder = jdtTreeBuilder;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid enter(CtElement e, ASTNode node) {\n\t\tstack.push(new ASTPair(e, node));\n\t\tif (!(e instanceof CtPackage) || (compilationUnitSpoon.getFile() != null && compilationUnitSpoon.getFile().getName().equals(DefaultJavaPrettyPrinter.JAVA_PACKAGE_DECLARATION))) {\n\t\t\tif (compilationunitdeclaration != null && !e.isImplicit()) {\n\t\t\t\ttry {\n\t\t\t\t\te.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPositionCtElement(e, node));\n\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\te.setPosition(SourcePosition.NOPOSITION);\n\t\t\t\t\tLauncher.LOGGER.warn(\"PositionBuilder failed for element \" + e.toString(), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tASTPair pair = stack.peek();\n\t\tCtElement current = pair.element;\n\n\t\tif (current instanceof CtExpression) {\n\t\t\twhile (!casts.isEmpty()) {\n\t\t\t\t((CtExpression<?>) current).addTypeCast(casts.remove(0).typeRef);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (e instanceof CtTypedElement && !(e instanceof CtConstructorCall) && !(e instanceof CtCatchVariable) && node instanceof Expression) {\n\t\t\t\tif (((CtTypedElement<?>) e).getType() == null) {\n\t\t\t\t\t((CtTypedElement<Object>) e).setType(this.jdtTreeBuilder.getReferencesBuilder().getTypeReference(((Expression) node).resolvedType));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (UnsupportedOperationException ignore) {\n\t\t\t// For some element, we throw an UnsupportedOperationException when we call setType().\n\t\t}\n\n\t}\n\n\tvoid exit(ASTNode node) {\n\t\tASTPair pair = stack.pop();\n\t\tif (pair.node != node) {\n\t\t\tthrow new RuntimeException(\"Inconsistent Stack \" + node + \"\\n\" + pair.node);\n\t\t}\n\t\tCtElement current = pair.element;\n\t\tif (!stack.isEmpty()) {\n\t\t\tthis.jdtTreeBuilder.getExiter().setChild(current);\n\t\t\tthis.jdtTreeBuilder.getExiter().setChild(pair.node);\n\t\t\tASTPair parentPair = stack.peek();\n\t\t\tthis.jdtTreeBuilder.getExiter().setParent(parentPair.node);\n\t\t\t//visit ParentExiter using parent Spoon node, while it has access to parent's JDT node and child Spoon and JDT node\n\t\t\tthis.jdtTreeBuilder.getExiter().scan(parentPair.element);\n\t\t}\n\t}\n\n\tCtElement getContextElementOnLevel(int level) {\n\t\tfor (ASTPair pair : stack) {\n\t\t\tif (level == 0) {\n\t\t\t\treturn pair.element;\n\t\t\t}\n\t\t\tlevel--;\n\t\t}\n\t\treturn null;\n\t}\n\n\t<T extends CtElement> T getParentElementOfType(Class<T> clazz) {\n\t\tfor (ASTPair pair : stack) {\n\t\t\tif (clazz.isInstance(pair.element)) {\n\t\t\t\treturn (T) pair.element;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tASTPair getParentContextOfType(Class<? extends CtElement> clazz) {\n\t\tfor (ASTPair pair : stack) {\n\t\t\tif (clazz.isInstance(pair.element)) {\n\t\t\t\treturn pair;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtLocalVariable<T> getLocalVariableDeclaration(final String name) {\n\t\tfinal Class<CtLocalVariable<T>> clazz = (Class<CtLocalVariable<T>>)\n\t\t\t\tjdtTreeBuilder.getFactory().Core().createLocalVariable().getClass();\n\t\tfinal CtLocalVariable<T> localVariable =\n\t\t\t\tthis.<T, CtLocalVariable<T>>getVariableDeclaration(name, clazz);\n\t\tif (localVariable == null) {\n\t\t\t// note: this happens when using the new try(vardelc) structure\n\t\t\tthis.jdtTreeBuilder.getLogger().error(\n\t\t\t\t\tformat(\"Could not find declaration for local variable %s at %s\",\n\t\t\t\t\t\t\tname, stack.peek().element.getPosition()));\n\t\t}\n\t\treturn localVariable;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtCatchVariable<T> getCatchVariableDeclaration(final String name) {\n\t\tfinal Class<CtCatchVariable<T>> clazz = (Class<CtCatchVariable<T>>)\n\t\t\t\tjdtTreeBuilder.getFactory().Core().createCatchVariable().getClass();\n\t\tfinal CtCatchVariable<T> catchVariable =\n\t\t\t\tthis.<T, CtCatchVariable<T>>getVariableDeclaration(name, clazz);\n\t\tif (catchVariable == null) {\n\t\t\t// note: this happens when using the new try(vardelc) structure\n\t\t\tthis.jdtTreeBuilder.getLogger().error(\n\t\t\t\t\tformat(\"Could not find declaration for catch variable %s at %s\",\n\t\t\t\t\t\t\tname, stack.peek().element.getPosition()));\n\t\t}\n\t\treturn catchVariable;\n\t}\n\n\t<T> CtVariable<T> getVariableDeclaration(final String name) {\n\t\tfinal CtVariable<T> variable = this.<T, CtVariable<T>>getVariableDeclaration(name, null);\n\t\tif (variable == null) {\n\t\t\t// note: this happens when using the new try(vardelc) structure\n\t\t\t// note: this can happen when identifier is not a variable name but e.g. a Type name.\n\t\t\tthis.jdtTreeBuilder.getLogger().debug(\n\t\t\t\t\tformat(\"Could not find declaration for variable %s at %s.\",\n\t\t\t\t\t\t\tname, stack.peek().element.getPosition()));\n\t\t}\n\t\treturn variable;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate <T, U extends CtVariable<T>> U getVariableDeclaration(\n\t\t\tfinal String name, final Class<U> clazz) {\n\t\tfinal CoreFactory coreFactory = jdtTreeBuilder.getFactory().Core();\n\t\tfinal TypeFactory typeFactory = jdtTreeBuilder.getFactory().Type();\n\t\tfinal ClassFactory classFactory = jdtTreeBuilder.getFactory().Class();\n\t\tfinal InterfaceFactory interfaceFactory = jdtTreeBuilder.getFactory().Interface();\n\t\tfinal FieldFactory fieldFactory = jdtTreeBuilder.getFactory().Field();\n\t\tfinal ReferenceBuilder referenceBuilder = jdtTreeBuilder.getReferencesBuilder();\n\t\tfinal Environment environment = jdtTreeBuilder.getFactory().getEnvironment();\n\t\t// there is some extra work to do if we are looking for CtFields (and subclasses)\n\t\tfinal boolean lookingForFields = clazz == null\n\t\t\t\t|| coreFactory.createField().getClass().isAssignableFrom(clazz);\n\n\t\t// try to find the variable on stack beginning with the most recent element\n\t\tfor (final ASTPair astPair : stack) {\n\t\t\t// the variable may have been declared directly by one of these elements\n\t\t\tfinal ScopeRespectingVariableScanner<U> scanner =\n\t\t\t\t\tnew ScopeRespectingVariableScanner(name, clazz);\n\t\t\tastPair.element.accept(scanner);\n\t\t\tif (scanner.getResult() != null) {\n\t\t\t\treturn scanner.getResult();\n\t\t\t}\n\n\t\t\t// the variable may have been declared in a super class/interface\n\t\t\tif (lookingForFields && astPair.node instanceof TypeDeclaration) {\n\t\t\t\tfinal TypeDeclaration nodeDeclaration = (TypeDeclaration) astPair.node;\n\t\t\t\tfinal Deque<ReferenceBinding> referenceBindings = new ArrayDeque<>();\n\t\t\t\t// add super class if any\n\t\t\t\tif (nodeDeclaration.superclass != null\n\t\t\t\t\t\t&& nodeDeclaration.superclass.resolvedType instanceof ReferenceBinding) {\n\t\t\t\t\treferenceBindings.push((ReferenceBinding) nodeDeclaration.superclass.resolvedType);\n\t\t\t\t}\n\t\t\t\t// add interfaces if any\n\t\t\t\tif (nodeDeclaration.superInterfaces != null) {\n\t\t\t\t\tfor (final TypeReference tr : nodeDeclaration.superInterfaces) {\n\t\t\t\t\t\tif (tr.resolvedType instanceof ReferenceBinding) {\n\t\t\t\t\t\t\treferenceBindings.push((ReferenceBinding) tr.resolvedType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (!referenceBindings.isEmpty()) {\n\t\t\t\t\tfinal ReferenceBinding referenceBinding = referenceBindings.pop();\n\t\t\t\t\tfor (final FieldBinding fieldBinding : referenceBinding.fields()) {\n\t\t\t\t\t\tif (name.equals(new String(fieldBinding.readableName()))) {\n\t\t\t\t\t\t\tfinal String qualifiedNameOfParent =\n\t\t\t\t\t\t\t\t\tnew String(referenceBinding.readableName());\n\t\t\t\t\t\t\tfinal CtType parentOfField = referenceBinding.isClass()\n\t\t\t\t\t\t\t\t\t? classFactory.create(qualifiedNameOfParent)\n\t\t\t\t\t\t\t\t\t: interfaceFactory.create(qualifiedNameOfParent);\n\t\t\t\t\t\t\tU field = (U) fieldFactory.create(parentOfField,\n\t\t\t\t\t\t\t\t\tEnumSet.noneOf(ModifierKind.class),\n\t\t\t\t\t\t\t\t\treferenceBuilder.getTypeReference(fieldBinding.type),\n\t\t\t\t\t\t\t\t\tname);\n\t\t\t\t\t\t\treturn field.setExtendedModifiers(JDTTreeBuilderQuery.getModifiers(fieldBinding.modifiers, true, false));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// add super class if any\n\t\t\t\t\tfinal ReferenceBinding superclass = referenceBinding.superclass();\n\t\t\t\t\tif (superclass != null) {\n\t\t\t\t\t\treferenceBindings.push(superclass);\n\t\t\t\t\t}\n\t\t\t\t\t// add interfaces if any\n\t\t\t\t\tfinal ReferenceBinding[] interfaces = referenceBinding.superInterfaces();\n\t\t\t\t\tif (interfaces != null) {\n\t\t\t\t\t\tfor (ReferenceBinding rb : interfaces) {\n\t\t\t\t\t\t\treferenceBindings.push(rb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the variable may have been imported statically from another class/interface\n\t\tif (lookingForFields) {\n\t\t\tfinal CtReference potentialReferenceToField =\n\t\t\t\t\treferenceBuilder.getDeclaringReferenceFromImports(name.toCharArray());\n\t\t\tif (potentialReferenceToField instanceof CtTypeReference) {\n\t\t\t\tfinal CtTypeReference typeReference = (CtTypeReference) potentialReferenceToField;\n\t\t\t\ttry {\n\t\t\t\t\tfinal Class classOfType = typeReference.getActualClass();\n\t\t\t\t\tif (classOfType != null) {\n\t\t\t\t\t\tfinal CtType declaringTypeOfField = typeReference.isInterface()\n\t\t\t\t\t\t\t\t? interfaceFactory.get(classOfType) : classFactory.get(classOfType);\n\t\t\t\t\t\tfinal CtField field = declaringTypeOfField.getField(name);\n\t\t\t\t\t\tif (field != null) {\n\t\t\t\t\t\t\treturn (U) field;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (final SpoonClassNotFoundException scnfe) {\n\t\t\t\t\t// in noclasspath mode we do some heuristics to determine if `name` could be a\n\t\t\t\t\t// field that has been imported statically from another class (or interface).\n\t\t\t\t\tif (environment.getNoClasspath()) {\n\t\t\t\t\t\t// if `potentialReferenceToField` is a `CtTypeReference` then `name` must\n\t\t\t\t\t\t// have been imported statically. Otherwise, `potentialReferenceToField`\n\t\t\t\t\t\t// would be a CtPackageReference!\n\n\t\t\t\t\t\t// if `name` consists only of upper case characters separated by '_', we\n\t\t\t\t\t\t// assume a constant value according to JLS.\n\t\t\t\t\t\tif (name.toUpperCase().equals(name)) {\n\t\t\t\t\t\t\tfinal CtType parentOfField =\n\t\t\t\t\t\t\t\t\tclassFactory.create(typeReference.getQualifiedName());\n\t\t\t\t\t\t\t// it is the best thing we can do\n\t\t\t\t\t\t\tfinal CtField field = coreFactory.createField();\n\t\t\t\t\t\t\tfield.setParent(parentOfField);\n\t\t\t\t\t\t\tfield.setSimpleName(name);\n\t\t\t\t\t\t\t// it is the best thing we can do\n\t\t\t\t\t\t\tfield.setType(typeFactory.nullType());\n\t\t\t\t\t\t\treturn (U) field;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * An {@link EarlyTerminatingScanner} that is supposed to find a {@link CtVariable} with\n\t * specific name respecting the current scope given by {@link ContextBuilder#stack}.\n\n\t * @param <T> The actual type of the {@link CtVariable} we are looking for. Examples include\n\t *            {@link CtLocalVariable}, {@link CtField}, and so on.\n\t */\n\tprivate class ScopeRespectingVariableScanner<T extends CtVariable>\n\t\t\textends EarlyTerminatingScanner<T> {\n\n\t\t/**\n\t\t * The class object of {@link T} that is required to filter particular elements in\n\t\t * {@link #scan(CtElement)}.\n\t\t */\n\t\tprivate final Class<T> clazz;\n\n\t\t/**\n\t\t * The name of the variable we are looking for ({@link CtVariable#getSimpleName()}).\n\t\t */\n\t\tfinal String name;\n\n\t\t/**\n\t\t * Creates a new {@link EarlyTerminatingScanner} that tries to find a {@link CtVariable}\n\t\t * with name {@code pName} (using {@link CtVariable#getSimpleName()}) and upper type bound\n\t\t * {@code pType}.\n\t\t *\n\t\t * @param pName\tThe name of the variable we are looking for.\n\t\t * @param pType\t{@link T}'s class object ({@link Object#getClass()}). {@link null} values\n\t\t *              are permitted and indicate that we are looking for any subclass of\n\t\t *              {@link CtVariable} (including {@link CtVariable} itself).\n\t\t */\n\t\tScopeRespectingVariableScanner(final String pName, final Class<T> pType) {\n\t\t\tclazz =  (Class<T>) (pType == null ? CtVariable.class : pType);\n\t\t\tname = pName;\n\t\t}\n\n\t\t@Override\n\t\tpublic void scan(final CtElement element) {\n\t\t\tif (element != null && clazz.isAssignableFrom(element.getClass())) {\n\t\t\t\tfinal T potentialVariable = (T) element;\n\t\t\t\tif (name.equals(potentialVariable.getSimpleName())) {\n\t\t\t\t\t// Since the AST is not completely available yet, we can not check if element's\n\t\t\t\t\t// parent (ep) contains the innermost element of `stack` (ie). Therefore, we\n\t\t\t\t\t// have to check if one of the following condition holds:\n\t\t\t\t\t//\n\t\t\t\t\t//    1) Does `stack` contain `ep`?\n\t\t\t\t\t//    2) Is `ep` the body of one of `stack`'s CtExecutable elements?\n\t\t\t\t\t//\n\t\t\t\t\t// The first condition is easy to see. If `stack` contains `ep` then `ep` and\n\t\t\t\t\t// all it's declared variables are in scope of `ie`. Unfortunately, there is a\n\t\t\t\t\t// special case in which a variable (a CtLocalVariable) has been declared in a\n\t\t\t\t\t// block (CtBlock) of, for instance, a method. Such a block is not contained in\n\t\t\t\t\t// `stack`. This peculiarity calls for the second condition.\n\t\t\t\t\tfinal CtElement parentOfPotentialVariable = potentialVariable.getParent();\n\t\t\t\t\tfor (final ASTPair astPair : stack) {\n\t\t\t\t\t\tif (astPair.element == parentOfPotentialVariable) {\n\t\t\t\t\t\t\tfinish(potentialVariable);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (astPair.element instanceof CtExecutable) {\n\t\t\t\t\t\t\tfinal CtExecutable executable = (CtExecutable) astPair.element;\n\t\t\t\t\t\t\tif (executable.getBody() == parentOfPotentialVariable) {\n\t\t\t\t\t\t\t\tfinish(potentialVariable);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.scan(element);\n\t\t}\n\n\t\tprivate void finish(final  T element) {\n\t\t\tsetResult(element);\n\t\t\tterminate();\n\t\t}\n\t}\n\n\t/**\n\t * @return line separator positions of actually processed compilation unit\n\t */\n\tpublic int[] getCompilationUnitLineSeparatorPositions() {\n\t\treturn compilationunitdeclaration.compilationResult.lineSeparatorPositions;\n\t}\n\n\t/**\n\t * @return char content of actually processed compilation unit\n\t */\n\tpublic char[] getCompilationUnitContents() {\n\t\treturn compilationunitdeclaration.compilationResult.compilationUnit.getContents();\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/CompilationUnitWrapper.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass CompilationUnitWrapper extends CompilationUnit {\n\n\tprivate CtType type;\n\n\tCompilationUnitWrapper(CtType type) {\n\t\t// char[] contents, String fileName, String encoding, String destinationPath, boolean ignoreOptionalProblems\n\t\tsuper(null,\n\t\t\t\ttype.getSimpleName() + \".java\",\n\t\t\t\ttype.getFactory().getEnvironment().getEncoding().displayName(),\n\t\t\t\ttype.getFactory().getEnvironment().getBinaryOutputDirectory(),\n\t\t\t\tfalse, null);\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic char[] getContents() {\n\t\tDefaultJavaPrettyPrinter printer = new DefaultJavaPrettyPrinter(type.getFactory().getEnvironment());\n\t\tList<CtType<?>> types = new ArrayList<>();\n\t\ttypes.add(type);\n\t\tprinter.calculate(type.getPosition().getCompilationUnit(), types);\n\n\t\treturn printer.getResult().toCharArray();\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTTreeBuilderHelper.java",
      "weight" : 533.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.ExportsStatement;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleReference;\nimport org.eclipse.jdt.internal.compiler.ast.OpensStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ProvidesStatement;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;\nimport org.eclipse.jdt.internal.compiler.ast.RequiresStatement;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.UsesStatement;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.factory.CoreFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getModifiers;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.isLhsAssignment;\n\npublic class JDTTreeBuilderHelper {\n\tprivate final JDTTreeBuilder jdtTreeBuilder;\n\n\tJDTTreeBuilderHelper(JDTTreeBuilder jdtTreeBuilder) {\n\t\tthis.jdtTreeBuilder = jdtTreeBuilder;\n\t}\n\n\t/**\n\t * Computes the anonymous simple name from its fully qualified type name.\n\t *\n\t * @param anonymousQualifiedName\n\t * \t\tQualified name which contains the anonymous name.\n\t * @return Anonymous simple name.\n\t */\n\tstatic String computeAnonymousName(char[] anonymousQualifiedName) {\n\t\tfinal String poolName = CharOperation.charToString(anonymousQualifiedName);\n\t\treturn poolName.substring(poolName.lastIndexOf(CtType.INNERTTYPE_SEPARATOR) + 1);\n\t}\n\n\t/**\n\t * Creates a qualified type name from a two-dimensional array.\n\t *\n\t * @param typeName\n\t * \t\ttwo-dimensional array which represents the qualified name expected.\n\t * @return Qualified name.\n\t */\n\tstatic String createQualifiedTypeName(char[][] typeName) {\n\t\tStringBuilder s = new StringBuilder();\n\t\tfor (int i = 0; i < typeName.length - 1; i++) {\n\t\t\ts.append(CharOperation.charToString(typeName[i])).append(\".\");\n\t\t}\n\t\ts.append(CharOperation.charToString(typeName[typeName.length - 1]));\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t * Creates a catch variable from a type reference.\n\t *\n\t * @param typeReference\n\t * \t\tCorresponds to the exception type declared in the catch.\n\t * @return a catch variable.\n\t */\n\tCtCatchVariable<Throwable> createCatchVariable(TypeReference typeReference) {\n\t\tfinal Argument jdtCatch = (Argument) jdtTreeBuilder.getContextBuilder().stack.peekFirst().node;\n\t\tfinal Set<CtExtendedModifier> modifiers = getModifiers(jdtCatch.modifiers, false, false);\n\n\t\tCtCatchVariable<Throwable> result = jdtTreeBuilder.getFactory().Core().createCatchVariable();\n\t\tresult.<CtCatchVariable>setSimpleName(CharOperation.charToString(jdtCatch.name)).setExtendedModifiers(modifiers);\n\t\tif (typeReference instanceof UnionTypeReference) {\n\t\t\t//do not set type of variable yet. It will be initialized later by visit of multiple types. Each call then ADDs one type\n\t\t\treturn result;\n\t\t} else {\n\t\t\tCtTypeReference ctTypeReference = jdtTreeBuilder.getReferencesBuilder().<Throwable>getTypeReference(typeReference.resolvedType);\n\t\t\treturn result.<CtCatchVariable>setType(ctTypeReference);\n\t\t}\n\t}\n\n\t/**\n\t * Creates variable access from a {@link CtVariableReference}. Think to move this method\n\t * in the {@link spoon.reflect.factory.CodeFactory} if you think that is a good idea.\n\t */\n\tpublic <T> CtVariableAccess<T> createVariableAccess(CtVariableReference<T> variableReference, boolean isReadAccess) {\n\t\tCtVariableAccess<T> variableAccess;\n\t\tif (isReadAccess) {\n\t\t\tvariableAccess = jdtTreeBuilder.getFactory().Core().createVariableWrite();\n\t\t} else {\n\t\t\tvariableAccess = jdtTreeBuilder.getFactory().Core().createVariableRead();\n\t\t}\n\t\treturn variableAccess.setVariable(variableReference);\n\t}\n\n\t/**\n\t * Creates a variable access from its single name.\n\t *\n\t * @param singleNameReference\n\t * \t\tUsed to build a variable reference which will be contained in the variable access.\n\t * @return a variable access.\n\t */\n\t<T> CtVariableAccess<T> createVariableAccess(SingleNameReference singleNameReference) {\n\t\tCtVariableAccess<T> va;\n\t\tif (isLhsAssignment(jdtTreeBuilder.getContextBuilder(), singleNameReference)) {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createVariableWrite();\n\t\t} else {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createVariableRead();\n\t\t}\n\t\tva.setVariable(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference((VariableBinding) singleNameReference.binding));\n\t\treturn va;\n\t}\n\n\t/**\n\t * Analyzes if {@code singleNameReference} points to a {@link CtVariable} visible in current\n\t * scope and, if existent, returns its corresponding {@link CtVariableAccess}. Returns\n\t * {@code null} if {@code singleNameReference} could not be resolved as variable access. Since\n\t * we are in noclasspath mode this function may also return {@code null} if\n\t * {@code singleNameReference} points to a variable declared by an unknown class.\n\t *\n\t * @param singleNameReference\n\t * \t\tThe potential variable access.\n\t * @return A {@link CtVariableAccess} if {@code singleNameReference} points to a variable\n\t * \t\tvisible in current scope, {@code null} otherwise.\n\t */\n\t<T> CtVariableAccess<T> createVariableAccessNoClasspath(SingleNameReference singleNameReference) {\n\t\tfinal CoreFactory coreFactory = jdtTreeBuilder.getFactory().Core();\n\t\tfinal ContextBuilder contextBuilder = jdtTreeBuilder.getContextBuilder();\n\t\tfinal ReferenceBuilder referenceBuilder = jdtTreeBuilder.getReferencesBuilder();\n\t\tfinal PositionBuilder positionBuilder = jdtTreeBuilder.getPositionBuilder();\n\n\t\tfinal String name = CharOperation.charToString(singleNameReference.token);\n\t\tfinal CtVariable<T> variable = contextBuilder.getVariableDeclaration(name);\n\t\tif (variable == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal CtVariableReference<T> variableReference;\n\t\tfinal CtVariableAccess<T> variableAccess;\n\t\tif (variable instanceof CtParameter) {\n\t\t\t// create variable of concrete type to avoid type casting while calling methods\n\t\t\tfinal CtParameterReference<T> parameterReference = coreFactory.createParameterReference();\n\t\t\tif (variable.getParent() instanceof CtLambda) {\n\t\t\t\t// nothing\n\n\t\t\t} else {\n\t\t\t\t// Unfortunately, we can not use `variable.getReference()` here as some parent\n\t\t\t\t// references (in terms of Java objects) have not been set up yet. Thus, we need to\n\t\t\t\t// create the required parameter reference by our own.\n\n\t\t\t\t// Since the given parameter has not been declared in a lambda expression it must\n\t\t\t\t// have been declared by a method/constructor.\n\t\t\t\tfinal CtExecutable executable = (CtExecutable) variable.getParent();\n\n\t\t\t\t// find executable's corresponding jdt element\n\t\t\t\tAbstractMethodDeclaration executableJDT = null;\n\t\t\t\tfor (final ASTPair astPair : contextBuilder.stack) {\n\t\t\t\t\tif (astPair.element == executable) {\n\t\t\t\t\t\texecutableJDT = (AbstractMethodDeclaration) astPair.node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert executableJDT != null;\n\n\t\t\t\t// create a reference to executable's declaring class\n\t\t\t\tfinal CtTypeReference declaringReferenceOfExecutable =\n\t\t\t\t\t\t// `binding` may be null for anonymous classes which means we have to\n\t\t\t\t\t\t// create an 'empty' type reference since we have no further information\n\t\t\t\t\t\t// available\n\t\t\t\t\t\texecutableJDT.binding == null ? coreFactory.createTypeReference()\n\t\t\t\t\t\t\t\t: referenceBuilder.getTypeReference(executableJDT.binding.declaringClass);\n\t\t\t}\n\t\t\tvariableReference = parameterReference;\n\t\t\tvariableAccess = isLhsAssignment(contextBuilder, singleNameReference)\n\t\t\t\t\t? coreFactory.<T>createVariableWrite() : coreFactory.<T>createVariableRead();\n\t\t} else if (variable instanceof CtField) {\n\t\t\tvariableReference = variable.getReference();\n\t\t\tvariableAccess = isLhsAssignment(contextBuilder, singleNameReference)\n\t\t\t\t\t? coreFactory.<T>createFieldWrite() : coreFactory.<T>createFieldRead();\n\t\t} else { // CtLocalVariable, CtCatchVariable, ...\n\t\t\tvariableReference = variable.getReference();\n\t\t\tvariableAccess = isLhsAssignment(contextBuilder, singleNameReference)\n\t\t\t\t\t? coreFactory.<T>createVariableWrite() : coreFactory.<T>createVariableRead();\n\t\t}\n\t\tvariableReference.setSimpleName(name);\n\t\tvariableReference.setPosition(positionBuilder.buildPosition(\n\t\t\t\tsingleNameReference.sourceStart(), singleNameReference.sourceEnd()));\n\t\tvariableAccess.setVariable(variableReference);\n\t\treturn variableAccess;\n\t}\n\n\t/**\n\t * Creates a variable or a field access from its qualified name.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tUsed to build the variable access. See all sub methods of this class to understand its usage.\n\t * @return a variable access.\n\t */\n\t<T> CtVariableAccess<T> createVariableAccess(QualifiedNameReference qualifiedNameReference) {\n\t\tlong[] positions = qualifiedNameReference.sourcePositions;\n\t\tint sourceStart = qualifiedNameReference.sourceStart();\n\t\tint sourceEnd = qualifiedNameReference.sourceEnd();\n\t\tif (qualifiedNameReference.indexOfFirstFieldBinding < positions.length) {\n\t\t\tsourceEnd = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding] >>> 32) - 2;\n\t\t}\n\t\tCtVariableAccess<T> va;\n\t\tCtVariableReference<T> ref;\n\t\tboolean fromAssignment = isLhsAssignment(jdtTreeBuilder.getContextBuilder(), qualifiedNameReference);\n\t\tboolean isOtherBinding = qualifiedNameReference.otherBindings == null || qualifiedNameReference.otherBindings.length == 0;\n\t\tif (qualifiedNameReference.binding instanceof FieldBinding) {\n\t\t\tref = jdtTreeBuilder.getReferencesBuilder().getVariableReference(qualifiedNameReference.fieldBinding());\n\t\t\tref.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(getVariableReferenceSourceStart(sourceStart, sourceEnd), sourceEnd));\n\n\t\t\tva = createFieldAccess(ref, createTargetFieldAccess(qualifiedNameReference, (CtFieldReference<Object>) ref), isOtherBinding && fromAssignment);\n\t\t} else {\n\t\t\tref = jdtTreeBuilder.getReferencesBuilder().getVariableReference((VariableBinding) qualifiedNameReference.binding);\n\t\t\tref.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(getVariableReferenceSourceStart(sourceStart, sourceEnd), sourceEnd));\n\n\t\t\tva = createVariableAccess(ref, isOtherBinding && fromAssignment);\n\t\t}\n\n\t\tif (qualifiedNameReference.otherBindings != null) {\n\t\t\tint i = 0; //positions index;\n\t\t\tva.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\t\tsourceStart = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding - 1] >>> 32);\n\t\t\tfor (FieldBinding b : qualifiedNameReference.otherBindings) {\n\t\t\t\tisOtherBinding = qualifiedNameReference.otherBindings.length == i + 1;\n\t\t\t\tCtFieldAccess<T> other = createFieldAccess(\n\t\t\t\t\t\tjdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(b, qualifiedNameReference.tokens[i + 1]), va, isOtherBinding && fromAssignment);\n\t\t\t\t//set source position of fa\n\t\t\t\tif (i + qualifiedNameReference.indexOfFirstFieldBinding >= qualifiedNameReference.otherBindings.length) {\n\t\t\t\t\tsourceEnd = qualifiedNameReference.sourceEnd();\n\t\t\t\t} else {\n\t\t\t\t\tsourceEnd = (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding + i + 1] >>> 32) - 2;\n\t\t\t\t}\n\t\t\t\tother.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\t\t\tva = other;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else if (!(qualifiedNameReference.binding instanceof FieldBinding) && qualifiedNameReference.tokens.length > 1) {\n\t\t\tsourceStart = (int) (positions[0] >>> 32);\n\t\t\tfor (int i = 1; i < qualifiedNameReference.tokens.length; i++) {\n\t\t\t\tisOtherBinding = qualifiedNameReference.tokens.length == i + 1;\n\t\t\t\tCtFieldAccess<T> other = createFieldAccess(//\n\t\t\t\t\t\tjdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(null, qualifiedNameReference.tokens[i]), va, isOtherBinding && fromAssignment);\n\t\t\t\t//set source position of va;\n\t\t\t\tsourceEnd = (int) (positions[i]);\n\t\t\t\tva.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\t\t\tva = other;\n\t\t\t}\n\t\t}\n\t\tva.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(qualifiedNameReference.sourceStart(), qualifiedNameReference.sourceEnd()));\n\t\treturn va;\n\t}\n\n\tprivate int getVariableReferenceSourceStart(int sourceStart, int sourceEnd) {\n\t\tchar[] contents = jdtTreeBuilder.getContextBuilder().getCompilationUnitContents();\n\t\t//search for last dot, which is not contained in comment\n\t\tint lastIdentifierStart = sourceStart;\n\t\twhile (true) {\n\t\t\tint dotIdx = PositionBuilder.findNextChar(contents, sourceEnd, lastIdentifierStart, '.');\n\t\t\tif (dotIdx < 0) {\n\t\t\t\treturn lastIdentifierStart;\n\t\t\t}\n\t\t\tlastIdentifierStart = dotIdx + 1;\n\t\t}\n\t}\n\n\t/**\n\t * Creates variable access from a {@link CtVariableReference}. Think to move this method\n\t * in the {@link spoon.reflect.factory.CodeFactory} if you think that is a good idea.\n\t */\n\tpublic <T> CtFieldAccess<T> createFieldAccess(CtVariableReference<T> variableReference, CtExpression<?> target, boolean isReadAccess) {\n\t\tCtFieldAccess<T> fieldAccess;\n\t\tif (isReadAccess) {\n\t\t\tfieldAccess = jdtTreeBuilder.getFactory().Core().createFieldWrite();\n\t\t} else {\n\t\t\tfieldAccess = jdtTreeBuilder.getFactory().Core().createFieldRead();\n\t\t}\n\t\tfieldAccess.setVariable(variableReference);\n\t\tfieldAccess.setTarget(target);\n\t\treturn fieldAccess;\n\t}\n\n\t/**\n\t * Creates a field access from its single name.\n\t *\n\t * @param singleNameReference\n\t * \t\tUsed to build a variable reference and a target which will be contained in the field access.\n\t * @return a field access.\n\t */\n\t<T> CtFieldAccess<T> createFieldAccess(SingleNameReference singleNameReference) {\n\t\tCtFieldAccess<T> va;\n\t\tif (isLhsAssignment(jdtTreeBuilder.getContextBuilder(), singleNameReference)) {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createFieldWrite();\n\t\t} else {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createFieldRead();\n\t\t}\n\t\tva.setVariable(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(singleNameReference.fieldBinding().original()));\n\t\tif (va.getVariable() != null) {\n\t\t\tfinal CtFieldReference<T> ref = va.getVariable();\n\t\t\tif (ref.isStatic() && !ref.getDeclaringType().isAnonymous()) {\n\t\t\t\tva.setTarget(jdtTreeBuilder.getFactory().Code().createTypeAccess(ref.getDeclaringType()));\n\t\t\t} else if (!ref.isStatic()) {\n\t\t\t\tva.setTarget(jdtTreeBuilder.getFactory().Code().createThisAccess(jdtTreeBuilder.getReferencesBuilder().getTypeReference(singleNameReference.actualReceiverType), true));\n\t\t\t}\n\t\t}\n\t\treturn va;\n\t}\n\n\t/**\n\t * In no classpath mode, when we build a field access, we have a binding typed by ProblemBinding.\n\t * This binding doesn't contain all information but we can get some of them.\n\t *\n\t * @param singleNameReference\n\t * \t\tUsed to get the problem binding of the field access and the name of the declaring type.\n\t * @return a field access.\n\t */\n\t<T> CtFieldAccess<T> createFieldAccessNoClasspath(SingleNameReference singleNameReference) {\n\t\tCtFieldAccess<T> va;\n\t\tif (isLhsAssignment(jdtTreeBuilder.getContextBuilder(), singleNameReference)) {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createFieldWrite();\n\t\t} else {\n\t\t\tva = jdtTreeBuilder.getFactory().Core().createFieldRead();\n\t\t}\n\t\tva.setVariable(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference((ProblemBinding) singleNameReference.binding));\n\t\tfinal CtReference declaring = jdtTreeBuilder.getReferencesBuilder().getDeclaringReferenceFromImports(singleNameReference.token);\n\t\tif (declaring instanceof CtTypeReference && va.getVariable() != null) {\n\t\t\tfinal CtTypeReference<Object> declaringRef = (CtTypeReference<Object>) declaring;\n\t\t\tva.setTarget(jdtTreeBuilder.getFactory().Code().createTypeAccess(declaringRef));\n\t\t\tva.getVariable().setDeclaringType(declaringRef);\n\t\t\tva.getVariable().setStatic(true);\n\t\t}\n\t\treturn va;\n\t}\n\n\t/**\n\t * In no classpath mode, when we build a field access, we have a binding typed by ProblemBinding.\n\t * We try to get all information we can get from this binding.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tUsed to get the problem binding of the field access and the name of the declaring type.\n\t * @return a field access.\n\t */\n\t<T> CtFieldAccess<T> createFieldAccessNoClasspath(QualifiedNameReference qualifiedNameReference) {\n\t\tboolean fromAssignment = isLhsAssignment(jdtTreeBuilder.getContextBuilder(), qualifiedNameReference);\n\t\tCtFieldAccess<T> fieldAccess = createFieldAccess(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference((ProblemBinding) qualifiedNameReference.binding), null, fromAssignment);\n\t\t// In no classpath mode and with qualified name, the type given by JDT is wrong...\n\t\tfinal char[][] declaringClass = CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 1);\n\t\tfinal MissingTypeBinding declaringType = jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.createMissingType(null, declaringClass);\n\t\tfinal CtTypeReference<T> declaringRef = jdtTreeBuilder.getReferencesBuilder().getTypeReference(declaringType);\n\t\tfieldAccess.getVariable().setDeclaringType(declaringRef);\n\t\tfieldAccess.getVariable().setStatic(true);\n\t\tfieldAccess.setTarget(jdtTreeBuilder.getFactory().Code().createTypeAccess(declaringRef));\n\t\t// In no classpath mode and with qualified name, the binding doesn't have a good name.\n\t\tfieldAccess.getVariable()\n\t\t\t\t.setSimpleName(createQualifiedTypeName(CharOperation.subarray(qualifiedNameReference.tokens, qualifiedNameReference.tokens.length - 1, qualifiedNameReference.tokens.length)));\n\t\treturn fieldAccess;\n\t}\n\n\t/**\n\t * Creates a field access from a field reference.\n\t *\n\t * @param fieldReference\n\t * \t\tUsed to build the spoon variable reference and the type of the field access.\n\t * @return a field access.\n\t */\n\t<T> CtFieldAccess<T> createFieldAccess(FieldReference fieldReference) {\n\t\tCtFieldAccess<T> fieldAccess;\n\t\tif (isLhsAssignment(jdtTreeBuilder.getContextBuilder(), fieldReference)) {\n\t\t\tfieldAccess = jdtTreeBuilder.getFactory().Core().createFieldWrite();\n\t\t} else {\n\t\t\tfieldAccess = jdtTreeBuilder.getFactory().Core().createFieldRead();\n\t\t}\n\t\tfieldAccess.setVariable(jdtTreeBuilder.getReferencesBuilder().<T>getVariableReference(fieldReference.binding, fieldReference.token));\n\t\tfieldAccess.setType(jdtTreeBuilder.getReferencesBuilder().<T>getTypeReference(fieldReference.resolvedType));\n\t\treturn fieldAccess;\n\t}\n\n\t/**\n\t * Creates a type access from its qualified name and with a field reference.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tUsed to update the field reference if necessary.\n\t * @param fieldReference\n\t * \t\tUsed to get its declaring class and to put it in the type access.\n\t * @return a type access.\n\t */\n\tCtTypeAccess<?> createTypeAccess(QualifiedNameReference qualifiedNameReference, CtFieldReference<?> fieldReference) {\n\t\tfinal TypeBinding receiverType = qualifiedNameReference.actualReceiverType;\n\t\tif (receiverType != null) {\n\t\t\tfinal CtTypeReference<Object> qualifiedRef = jdtTreeBuilder.getReferencesBuilder().getQualifiedTypeReference(\n\t\t\t\t\tqualifiedNameReference.tokens, receiverType, qualifiedNameReference.fieldBinding().declaringClass.enclosingType(), new JDTTreeBuilder.OnAccessListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean onAccess(char[][] tokens, int index) {\n\t\t\t\t\t\t\treturn !CharOperation.equals(tokens[index + 1], tokens[tokens.length - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\tif (qualifiedRef != null) {\n\t\t\t\tfieldReference.setDeclaringType(qualifiedRef);\n\t\t\t} else {\n\t\t\t\tfieldReference.setDeclaringType(jdtTreeBuilder.getReferencesBuilder().getTypeReference(receiverType));\n\t\t\t}\n\t\t}\n\n\t\tCtTypeAccess<?> typeAccess = jdtTreeBuilder.getFactory().Code().createTypeAccess(fieldReference.getDeclaringType());\n\t\tif (qualifiedNameReference.indexOfFirstFieldBinding > 1) {\n\t\t\t// the array sourcePositions contains the position of each element of the qualifiedNameReference\n\t\t\t// the last element contains the position of the field\n\t\t\tlong[] positions = qualifiedNameReference.sourcePositions;\n\t\t\ttypeAccess.setPosition(\n\t\t\t\t\tjdtTreeBuilder.getPositionBuilder().buildPosition(qualifiedNameReference.sourceStart(), (int) (positions[qualifiedNameReference.indexOfFirstFieldBinding - 1] >>> 32) - 2));\n\t\t} else {\n\t\t\ttypeAccess.setImplicit(qualifiedNameReference.isImplicitThis());\n\t\t}\n\n\t\treturn typeAccess;\n\t}\n\n\t/**\n\t * Creates a type access from its qualified name.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tUsed to get the declaring class of this type. This qualified type should have a type as target.\n\t * @return a type access.\n\t */\n\t<T> CtTypeAccess<T> createTypeAccessNoClasspath(QualifiedNameReference qualifiedNameReference) {\n\t\tCtTypeReference<T> typeReference;\n\t\tif (qualifiedNameReference.binding instanceof ProblemBinding) {\n\t\t\ttypeReference = jdtTreeBuilder.getFactory().Type().<T>createReference(CharOperation.toString(qualifiedNameReference.tokens));\n\t\t} else if (qualifiedNameReference.binding instanceof FieldBinding) {\n\t\t\tfinal ReferenceBinding declaringClass = ((FieldBinding) qualifiedNameReference.binding).declaringClass;\n\t\t\ttypeReference = jdtTreeBuilder.getReferencesBuilder().<T>getTypeReference(declaringClass);\n\t\t} else {\n\t\t\t// TODO try to determine package/class boundary by upper case\n\t\t\tchar[][] packageName = CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 1);\n\t\t\tchar[][] className = CharOperation.subarray(qualifiedNameReference.tokens, qualifiedNameReference.tokens.length - 1, qualifiedNameReference.tokens.length);\n\t\t\tif (packageName.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal PackageBinding aPackage = jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.createPackage(packageName);\n\t\t\t\t\tfinal MissingTypeBinding declaringType = jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.createMissingType(aPackage, className);\n\n\t\t\t\t\ttypeReference = jdtTreeBuilder.getReferencesBuilder().getTypeReference(declaringType);\n\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\ttypeReference = jdtTreeBuilder.getFactory().Type().createReference(qualifiedNameReference.toString());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttypeReference = jdtTreeBuilder.getFactory().Type().createReference(qualifiedNameReference.toString());\n\t\t\t}\n\t\t}\n\t\tfinal CtTypeAccess<T> typeAccess = jdtTreeBuilder.getFactory().Code().createTypeAccess(typeReference);\n\n\t\tint sourceStart = qualifiedNameReference.sourceStart();\n\t\tint sourceEnd = qualifiedNameReference.sourceEnd();\n\t\ttypeAccess.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\n\t\treturn typeAccess;\n\t}\n\n\t/**\n\t * Creates a type access from its single name.\n\t *\n\t * @param singleNameReference\n\t * \t\tUsed to get the simple name of the type.\n\t * @return a type access.\n\t */\n\t<T> CtTypeAccess<T> createTypeAccessNoClasspath(SingleNameReference singleNameReference) {\n\t\tfinal CtTypeReference<T> typeReference = jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\tif (singleNameReference.binding == null) {\n\t\t\ttypeReference.setSimpleName(CharOperation.charToString(singleNameReference.token));\n\t\t} else {\n\t\t\ttypeReference.setSimpleName(CharOperation.charToString(singleNameReference.binding.readableName()));\n\t\t}\n\t\tjdtTreeBuilder.getReferencesBuilder().setPackageOrDeclaringType(typeReference, jdtTreeBuilder.getReferencesBuilder().getDeclaringReferenceFromImports(singleNameReference.token));\n\t\treturn jdtTreeBuilder.getFactory().Code().createTypeAccess(typeReference);\n\t}\n\n\t/**\n\t * Creates the target of a field access.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tUsed to get the declaring class of the target.\n\t * @param ref\n\t * \t\tUsed in a static context.\n\t * @return an expression.\n\t */\n\tCtExpression<?> createTargetFieldAccess(QualifiedNameReference qualifiedNameReference, CtFieldReference<Object> ref) {\n\t\tCtExpression<?> target = null;\n\t\tif (JDTTreeBuilderQuery.isValidProblemBindingField(qualifiedNameReference)) {\n\t\t\ttarget = createTypeAccessNoClasspath(qualifiedNameReference);\n\t\t} else if (ref.isStatic()) {\n\t\t\ttarget = createTypeAccess(qualifiedNameReference, ref);\n\t\t} else if (!ref.isStatic() && !ref.getDeclaringType().isAnonymous()) {\n\t\t\ttarget = jdtTreeBuilder.getFactory().Code().createThisAccess(jdtTreeBuilder.getReferencesBuilder().<Object>getTypeReference(qualifiedNameReference.actualReceiverType), true);\n\t\t}\n\t\treturn target;\n\t}\n\n\t/**\n\t * Creates a parameter. If the argument have a type == null, we get the type from its binding. A type == null is possible when\n\t * this type is implicit like in a lambda where you don't need to specify the type of parameters.\n\t *\n\t * @param argument\n\t * \t\tUsed to get the name of the parameter, the modifiers, know if it is a var args parameter.\n\t * @return a parameter.\n\t */\n\t<T> CtParameter<T> createParameter(Argument argument) {\n\t\tCtParameter<T> p = jdtTreeBuilder.getFactory().Core().createParameter();\n\t\tp.setSimpleName(CharOperation.charToString(argument.name));\n\t\tp.setVarArgs(argument.isVarArgs());\n\t\tp.setExtendedModifiers(getModifiers(argument.modifiers, false, false));\n\t\tif (argument.binding != null && argument.binding.type != null && argument.type == null) {\n\t\t\tp.setType(jdtTreeBuilder.getReferencesBuilder().<T>getTypeReference(argument.binding.type));\n\t\t\tp.getType().setImplicit(argument.type == null);\n\t\t\tif (p.getType() instanceof CtArrayTypeReference) {\n\t\t\t\t((CtArrayTypeReference) p.getType()).getComponentType().setImplicit(argument.type == null);\n\t\t\t}\n\t\t}\n\t\treturn p;\n\t}\n\n\t/**\n\t * Creates an executable reference expression.\n\t *\n\t * @param referenceExpression\n\t * \t\tUsed to get the executable reference.\n\t * @return an executable reference expression.\n\t */\n\t<T, E extends CtExpression<?>> CtExecutableReferenceExpression<T, E> createExecutableReferenceExpression(ReferenceExpression referenceExpression) {\n\t\tCtExecutableReferenceExpression<T, E> executableRef = jdtTreeBuilder.getFactory().Core().createExecutableReferenceExpression();\n\t\tCtExecutableReference<T> executableReference = jdtTreeBuilder.getReferencesBuilder().getExecutableReference(referenceExpression.binding);\n\t\tif (executableReference == null) {\n\t\t\t// No classpath mode.\n\t\t\texecutableReference = jdtTreeBuilder.getFactory().Core().createExecutableReference();\n\t\t\texecutableReference.setSimpleName(CharOperation.charToString(referenceExpression.selector));\n\t\t\texecutableReference.setDeclaringType(jdtTreeBuilder.getReferencesBuilder().getTypeReference(referenceExpression.lhs.resolvedType));\n\t\t}\n\t\tfinal CtTypeReference<T> declaringType = (CtTypeReference<T>) executableReference.getDeclaringType();\n\t\texecutableReference.setType(declaringType == null ? null : declaringType.clone());\n\t\texecutableRef.setExecutable(executableReference);\n\t\treturn executableRef;\n\t}\n\n\t/**\n\t * Creates a class, an enum, an interface or a annotation type.\n\t *\n\t * @return a type.\n\t */\n\tCtType<?> createType(TypeDeclaration typeDeclaration) {\n\t\tCtType<?> type;\n\t\tif ((typeDeclaration.modifiers & ClassFileConstants.AccAnnotation) != 0) {\n\t\t\ttype = jdtTreeBuilder.getFactory().Core().<java.lang.annotation.Annotation>createAnnotationType();\n\t\t} else if ((typeDeclaration.modifiers & ClassFileConstants.AccEnum) != 0) {\n\t\t\ttype = jdtTreeBuilder.getFactory().Core().createEnum();\n\t\t} else if ((typeDeclaration.modifiers & ClassFileConstants.AccInterface) != 0) {\n\t\t\ttype = jdtTreeBuilder.getFactory().Core().createInterface();\n\t\t} else {\n\t\t\ttype = jdtTreeBuilder.getFactory().Core().createClass();\n\t\t}\n\n\t\t// Setting modifiers\n\t\ttype.setExtendedModifiers(getModifiers(typeDeclaration.modifiers, false, false));\n\n\t\tjdtTreeBuilder.getContextBuilder().enter(type, typeDeclaration);\n\n\t\tif (typeDeclaration.superInterfaces != null) {\n\t\t\tfor (TypeReference ref : typeDeclaration.superInterfaces) {\n\t\t\t\tfinal CtTypeReference superInterface = jdtTreeBuilder.references.buildTypeReference(ref, null);\n\t\t\t\ttype.addSuperInterface(superInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (type instanceof CtClass) {\n\t\t\tif (typeDeclaration.superclass != null) {\n\t\t\t\t((CtClass) type).setSuperclass(jdtTreeBuilder.references.buildTypeReference(typeDeclaration.superclass, typeDeclaration.scope));\n\t\t\t}\n\t\t\tif (typeDeclaration.binding.isAnonymousType() || (typeDeclaration.binding instanceof LocalTypeBinding && typeDeclaration.binding.enclosingMethod() != null)) {\n\t\t\t\ttype.setSimpleName(computeAnonymousName(typeDeclaration.binding.constantPoolName()));\n\t\t\t} else {\n\t\t\t\ttype.setSimpleName(new String(typeDeclaration.name));\n\t\t\t}\n\t\t} else {\n\t\t\ttype.setSimpleName(new String(typeDeclaration.name));\n\t\t}\n\n\t\treturn type;\n\t}\n\n\t/**\n\t * Creates an entire object CtModule from a module declaration.\n\t * @return a CtModule\n\t */\n\tCtModule createModule(ModuleDeclaration moduleDeclaration) {\n\t\tCtModule module = jdtTreeBuilder.getFactory().Module().getOrCreate(new String(moduleDeclaration.moduleName));\n\t\tmodule.setIsOpenModule(moduleDeclaration.isOpen());\n\t\tjdtTreeBuilder.getContextBuilder().enter(module, moduleDeclaration);\n\n\t\tif (moduleDeclaration.requires != null && moduleDeclaration.requires.length > 0) {\n\t\t\tList<CtModuleRequirement> moduleRequirements = new ArrayList<>();\n\t\t\tfor (RequiresStatement requiresStatement : moduleDeclaration.requires) {\n\t\t\t\tmoduleRequirements.add(this.createModuleRequirement(requiresStatement));\n\t\t\t}\n\n\t\t\tmodule.setRequiredModules(moduleRequirements);\n\t\t}\n\n\t\tif (moduleDeclaration.exports != null && moduleDeclaration.exports.length > 0) {\n\t\t\tList<CtPackageExport> moduleExports = new ArrayList<>();\n\t\t\tfor (ExportsStatement exportsStatement : moduleDeclaration.exports) {\n\t\t\t\tmoduleExports.add(this.createModuleExport(exportsStatement));\n\t\t\t}\n\n\t\t\tmodule.setExportedPackages(moduleExports);\n\t\t}\n\n\t\tif (moduleDeclaration.opens != null && moduleDeclaration.opens.length > 0) {\n\t\t\tList<CtPackageExport> moduleOpens = new ArrayList<>();\n\t\t\tfor (OpensStatement opensStatement : moduleDeclaration.opens) {\n\t\t\t\tmoduleOpens.add(this.createModuleExport(opensStatement));\n\t\t\t}\n\n\t\t\tmodule.setOpenedPackages(moduleOpens);\n\t\t}\n\n\t\tif (moduleDeclaration.uses != null && moduleDeclaration.uses.length > 0) {\n\t\t\tList<CtUsedService> consumedServices = new ArrayList<>();\n\t\t\tfor (UsesStatement consumedService : moduleDeclaration.uses) {\n\t\t\t\tconsumedServices.add(this.createUsedService(consumedService));\n\t\t\t}\n\n\t\t\tmodule.setUsedServices(consumedServices);\n\t\t}\n\n\t\tif (moduleDeclaration.services != null && moduleDeclaration.services.length > 0) {\n\t\t\tList<CtProvidedService> moduleProvidedServices = new ArrayList<>();\n\t\t\tfor (ProvidesStatement providesStatement : moduleDeclaration.services) {\n\t\t\t\tmoduleProvidedServices.add(this.createModuleProvidedService(providesStatement));\n\t\t\t}\n\n\t\t\tmodule.setProvidedServices(moduleProvidedServices);\n\t\t}\n\t\tmodule.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(moduleDeclaration.declarationSourceStart, moduleDeclaration.declarationSourceEnd));\n\t\treturn module;\n\t}\n\n\tCtUsedService createUsedService(UsesStatement usesStatement) {\n\t\tCtTypeReference typeReference = this.jdtTreeBuilder.references.getTypeReference(usesStatement.serviceInterface);\n\t\tCtUsedService usedService = this.jdtTreeBuilder.getFactory().Module().createUsedService(typeReference);\n\t\tusedService.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(usesStatement.sourceStart, usesStatement.sourceEnd));\n\t\treturn usedService;\n\t}\n\n\tCtModuleRequirement createModuleRequirement(RequiresStatement requiresStatement) {\n\t\tint sourceStart = requiresStatement.sourceStart;\n\t\tint sourceEnd = requiresStatement.sourceEnd;\n\n\t\tCtModuleReference ctModuleReference = jdtTreeBuilder.references.getModuleReference(requiresStatement.module);\n\t\tCtModuleRequirement moduleRequirement = jdtTreeBuilder.getFactory().Module().createModuleRequirement(ctModuleReference);\n\n\t\tSet<CtModuleRequirement.RequiresModifier> modifiers = new HashSet<>();\n\t\tif (requiresStatement.isStatic()) {\n\t\t\tmodifiers.add(CtModuleRequirement.RequiresModifier.STATIC);\n\t\t}\n\t\tif (requiresStatement.isTransitive()) {\n\t\t\tmodifiers.add(CtModuleRequirement.RequiresModifier.TRANSITIVE);\n\t\t}\n\t\tmoduleRequirement.setRequiresModifiers(modifiers);\n\t\tmoduleRequirement.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\treturn moduleRequirement;\n\t}\n\n\tCtPackageExport createModuleExport(ExportsStatement exportsStatement) {\n\t\tString packageName = new String(exportsStatement.pkgName);\n\t\tint sourceStart = exportsStatement.sourceStart;\n\t\tint sourceEnd = exportsStatement.sourceEnd;\n\n\t\tCtPackageReference ctPackageReference = jdtTreeBuilder.references.getPackageReference(packageName);\n\t\tCtPackageExport moduleExport = jdtTreeBuilder.getFactory().Module().createPackageExport(ctPackageReference);\n\n\t\tif (exportsStatement.targets != null && exportsStatement.targets.length > 0) {\n\t\t\tList<CtModuleReference> moduleReferences = new ArrayList<>();\n\n\t\t\tfor (ModuleReference moduleReference : exportsStatement.targets) {\n\t\t\t\tmoduleReferences.add(this.jdtTreeBuilder.references.getModuleReference(moduleReference));\n\t\t\t}\n\n\t\t\tmoduleExport.setTargetExport(moduleReferences);\n\t\t}\n\n\t\tmoduleExport.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\treturn moduleExport;\n\t}\n\n\tCtPackageExport createModuleExport(OpensStatement opensStatement) {\n\t\tString packageName = new String(opensStatement.pkgName);\n\t\tint sourceStart = opensStatement.sourceStart;\n\t\tint sourceEnd = opensStatement.sourceEnd;\n\n\t\tCtPackageReference ctPackageReference = jdtTreeBuilder.references.getPackageReference(packageName);\n\t\tCtPackageExport moduleExport = jdtTreeBuilder.getFactory().Module().createPackageExport(ctPackageReference);\n\n\t\tif (opensStatement.targets != null && opensStatement.targets.length > 0) {\n\t\t\tList<CtModuleReference> moduleReferences = new ArrayList<>();\n\n\t\t\tfor (ModuleReference moduleReference : opensStatement.targets) {\n\t\t\t\tmoduleReferences.add(this.jdtTreeBuilder.references.getModuleReference(moduleReference));\n\t\t\t}\n\n\t\t\tmoduleExport.setTargetExport(moduleReferences);\n\t\t}\n\n\t\tmoduleExport.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\treturn moduleExport;\n\t}\n\n\tCtProvidedService createModuleProvidedService(ProvidesStatement providesStatement) {\n\t\tint sourceStart = providesStatement.sourceStart;\n\t\tint sourceEnd = providesStatement.sourceEnd;\n\n\t\tCtTypeReference provideService = this.jdtTreeBuilder.references.getTypeReference(providesStatement.serviceInterface);\n\t\tList<CtTypeReference> implementations = new ArrayList<>();\n\n\t\tfor (TypeReference typeReference : providesStatement.implementations) {\n\t\t\timplementations.add(this.jdtTreeBuilder.references.getTypeReference(typeReference));\n\t\t}\n\n\t\tCtProvidedService providedService = this.jdtTreeBuilder.getFactory().Module().createProvidedService(provideService);\n\t\tprovidedService.setImplementationTypes(implementations);\n\t\tprovidedService.setPosition(this.jdtTreeBuilder.getPositionBuilder().buildPosition(sourceStart, sourceEnd));\n\t\treturn providedService;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/ParentExiter.java",
      "weight" : 822.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AbstractVariableDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Statement;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation;\nimport org.eclipse.jdt.internal.compiler.ast.TypeParameter;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtLoop;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtAnnotatedElementType;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\nimport spoon.reflect.visitor.CtScanner;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@SuppressWarnings(\"unchecked\")\npublic class ParentExiter extends CtInheritanceScanner {\n\n\tprivate final JDTTreeBuilder jdtTreeBuilder;\n\n\tprivate CtElement child;\n\tprivate ASTNode childJDT;\n\tprivate ASTNode parentJDT;\n\tprivate Map<CtTypedElement<?>, List<CtAnnotation>> annotationsMap = new HashMap<>();\n\n\t/**\n\t * @param jdtTreeBuilder\n\t */\n\tParentExiter(JDTTreeBuilder jdtTreeBuilder) {\n\t\tthis.jdtTreeBuilder = jdtTreeBuilder;\n\t}\n\n\tpublic void setChild(CtElement child) {\n\t\tthis.child = child;\n\t}\n\n\tpublic void setChild(ASTNode child) {\n\t\tthis.childJDT = child;\n\t}\n\n\tpublic void setParent(ASTNode parent) {\n\t\tthis.parentJDT = parent;\n\t}\n\n\t@Override\n\tpublic void scanCtElement(CtElement e) {\n\t\tif (child instanceof CtAnnotation && this.jdtTreeBuilder.getContextBuilder().annotationValueName.isEmpty()) {\n\t\t\t// we check if the current element can have the annotation attached\n\t\t\tCtAnnotatedElementType annotatedElementType = CtAnnotation.getAnnotatedElementTypeForCtElement(e);\n\t\t\tannotatedElementType = (e instanceof CtTypeParameter || e instanceof CtTypeParameterReference) ? CtAnnotatedElementType.TYPE_USE : annotatedElementType;\n\n\t\t\t// in case of noclasspath, we cannot be 100% sure, so we guess it must be attached...\n\t\t\tif (this.jdtTreeBuilder.getFactory().getEnvironment().getNoClasspath() || (annotatedElementType != null && JDTTreeBuilderQuery.hasAnnotationWithType((Annotation) childJDT, annotatedElementType))) {\n\t\t\t\te.addAnnotation((CtAnnotation<?>) child);\n\t\t\t}\n\n\t\t\t// in this case the annotation should be (also) attached to the type\n\t\t\tif (e instanceof CtTypedElement && JDTTreeBuilderQuery.hasAnnotationWithType((Annotation) childJDT, CtAnnotatedElementType.TYPE_USE)) {\n\t\t\t\tList<CtAnnotation> annotations = new ArrayList<>();\n\t\t\t\tif (!annotationsMap.containsKey(e)) {\n\t\t\t\t\tannotationsMap.put((CtTypedElement<?>) e, annotations);\n\t\t\t\t} else {\n\t\t\t\t\tannotations = annotationsMap.get(e);\n\t\t\t\t}\n\t\t\t\tannotations.add((CtAnnotation) child.clone());\n\t\t\t\tannotationsMap.put((CtTypedElement<?>) e, annotations);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void substituteAnnotation(CtTypedElement ele) {\n\t\tif (annotationsMap.containsKey(ele)) {\n\t\t\tList<CtAnnotation> annotations = annotationsMap.get(ele);\n\t\t\tfor (CtAnnotation annotation : annotations) {\n\n\t\t\t\t// in case of noclasspath we attached previously the element:\n\t\t\t\t// if we are here, we may have find an element for whom it's a better place\n\t\t\t\tif (this.jdtTreeBuilder.getFactory().getEnvironment().getNoClasspath() && annotation.isParentInitialized()) {\n\t\t\t\t\tCtElement parent = annotation.getParent();\n\t\t\t\t\tparent.removeAnnotation(annotation);\n\t\t\t\t}\n\n\t\t\t\tif (!ele.getType().getAnnotations().contains(annotation)) {\n\t\t\t\t\tele.getType().addAnnotation(annotation.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t\tannotationsMap.remove(ele);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R> void scanCtExecutable(CtExecutable<R> e) {\n\t\tif (child instanceof CtTypeAccess) {\n\t\t\te.addThrownType(((CtTypeAccess) child).getAccessedType());\n\t\t\treturn;\n\t\t} else if (child instanceof CtParameter) {\n\t\t\te.addParameter((CtParameter<?>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtBlock && !(e instanceof CtMethod || e instanceof CtConstructor)) {\n\t\t\te.setBody((CtBlock<R>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.scanCtExecutable(e);\n\t}\n\n\t@Override\n\tpublic void scanCtFormalTypeDeclarer(CtFormalTypeDeclarer e) {\n\t\tif (childJDT instanceof TypeParameter && child instanceof CtTypeParameter) {\n\t\t\te.addFormalCtTypeParameter((CtTypeParameter) child);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scanCtLoop(CtLoop loop) {\n\t\tif (loop.getBody() == null && child instanceof CtStatement) {\n\t\t\tCtStatement child = (CtStatement) this.child;\n\t\t\tif (!(this.child instanceof CtBlock)) {\n\t\t\t\tchild = jdtTreeBuilder.getFactory().Code().createCtBlock(child);\n\t\t\t\tchild.setImplicit(true);\n\t\t\t}\n\t\t\tloop.setBody(child);\n\t\t}\n\t\tsuper.scanCtLoop(loop);\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void scanCtTargetedExpression(CtTargetedExpression<T, E> targetedExpression) {\n\t\tif (child instanceof CtExpression) {\n\t\t\ttargetedExpression.setTarget((E) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.scanCtTargetedExpression(targetedExpression);\n\t}\n\n\t@Override\n\tpublic <T> void scanCtType(CtType<T> type) {\n\t\tif (child instanceof CtType && !(child instanceof CtTypeParameter)) {\n\t\t\tif (type.getTypeMembers().contains(child)) {\n\t\t\t\ttype.removeTypeMember((CtType) child);\n\t\t\t}\n\t\t\ttype.addNestedType((CtType<?>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtEnumValue && type instanceof CtEnum) {\n\t\t\t((CtEnum) type).addEnumValue((CtEnumValue) child);\n\t\t} else if (child instanceof CtField) {\n\t\t\ttype.addField((CtField<?>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtConstructor) {\n\t\t\treturn;\n\t\t}\n\t\tif (child instanceof CtMethod) {\n\t\t\ttype.addMethod((CtMethod<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.scanCtType(type);\n\t}\n\n\t@Override\n\tpublic <T> void scanCtVariable(CtVariable<T> v) {\n\t\tif (childJDT instanceof TypeReference && child instanceof CtTypeAccess) {\n\t\t\tv.setType(((CtTypeAccess) child).getAccessedType());\n\t\t\tsubstituteAnnotation((CtTypedElement) v);\n\t\t\treturn;\n\t\t} else if (child instanceof CtExpression && hasChildEqualsToDefaultValue(v)) {\n\t\t\tv.setDefaultExpression((CtExpression<T>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.scanCtVariable(v);\n\t}\n\n\tprivate <T> boolean hasChildEqualsToDefaultValue(CtVariable<T> ctVariable) {\n\t\tif (jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof AnnotationMethodDeclaration) {\n\t\t\tfinal AnnotationMethodDeclaration parent = (AnnotationMethodDeclaration) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t\t// Default value is equals to the jdt child.\n\t\t\treturn parent.defaultValue != null && getFinalExpressionFromCast(parent.defaultValue).equals(childJDT)\n\t\t\t\t\t// Return type not yet initialized.\n\t\t\t\t\t&& !child.equals(ctVariable.getDefaultExpression());\n\t\t}\n\t\tfinal AbstractVariableDeclaration parent = (AbstractVariableDeclaration) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Default value is equals to the jdt child.\n\t\treturn parent.initialization != null && getFinalExpressionFromCast(parent.initialization).equals(childJDT)\n\t\t\t\t// Return type not yet initialized.\n\t\t\t\t&& !child.equals(ctVariable.getDefaultExpression());\n\t}\n\n\t@Override\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotation(CtAnnotation<A> annotation) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tannotation.addValue(this.jdtTreeBuilder.getContextBuilder().annotationValueName.peek(), child);\n\t\t}\n\t\tsuper.visitCtAnnotation(annotation);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructor(CtConstructor<T> e) {\n\t\tif (e.getBody() == null && child instanceof CtBlock) {\n\t\t\te.setBody((CtBlock) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtStatement) {\n\t\t\tvisitCtBlock(e.getBody());\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtConstructor(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtMethod(CtMethod<T> e) {\n\t\tif (e.getBody() == null && child instanceof CtBlock) {\n\t\t\te.setBody((CtBlock) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtStatement) {\n\t\t\tvisitCtBlock(e.getBody());\n\t\t\treturn;\n\t\t} else if (child instanceof CtTypeAccess && hasChildEqualsToType(e)) {\n\t\t\te.setType(((CtTypeAccess) child).getAccessedType());\n\t\t\tsubstituteAnnotation(e);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtMethod(e);\n\t}\n\n\tprivate <T> boolean hasChildEqualsToType(CtMethod<T> ctMethod) {\n\t\tfinal MethodDeclaration parent = (MethodDeclaration) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Return type is equals to the jdt child.\n\t\treturn parent.returnType != null && parent.returnType.equals(childJDT)\n\t\t\t\t// Return type not yet initialized.\n\t\t\t\t&& !child.equals(ctMethod.getType());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\t\tif (child instanceof CtExpression && hasChildEqualsToDefaultValue(annotationMethod)) {\n\t\t\tannotationMethod.setDefaultExpression((CtExpression) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtAnnotationMethod(annotationMethod);\n\t}\n\n\tprivate <T> boolean hasChildEqualsToDefaultValue(CtAnnotationMethod<T> ctAnnotationMethod) {\n\t\tfinal AnnotationMethodDeclaration parent = (AnnotationMethodDeclaration) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Default value is equals to the jdt child.\n\t\treturn parent.defaultValue != null && parent.defaultValue.equals(childJDT)\n\t\t\t\t// Default value not yet initialized.\n\t\t\t\t&& !child.equals(ctAnnotationMethod.getDefaultExpression());\n\t}\n\n\t@Override\n\tpublic void visitCtAnonymousExecutable(CtAnonymousExecutable e) {\n\t\tif (child instanceof CtBlock) {\n\t\t\te.setBody((CtBlock) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtAnonymousExecutable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayRead(CtArrayRead<T> arrayRead) {\n\t\tif (visitArrayAccess(arrayRead)) {\n\t\t\tsuper.visitCtArrayRead(arrayRead);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayWrite(CtArrayWrite<T> arrayWrite) {\n\t\tif (visitArrayAccess(arrayWrite)) {\n\t\t\tsuper.visitCtArrayWrite(arrayWrite);\n\t\t}\n\t}\n\n\tprivate <T, E extends CtExpression<?>> boolean visitArrayAccess(CtArrayAccess<T, E> arrayAccess) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tif (arrayAccess.getTarget() == null) {\n\t\t\t\tarrayAccess.setTarget((E) child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tarrayAccess.setIndexExpression((CtExpression<Integer>) child);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAssert(CtAssert<T> asserted) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tif (asserted.getAssertExpression() == null) {\n\t\t\t\tasserted.setAssertExpression((CtExpression<Boolean>) child);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tasserted.setExpression((CtExpression<T>) child);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtAssert(asserted);\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtAssignment(CtAssignment<T, A> assignement) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tif (assignement.getAssigned() == null) {\n\t\t\t\tassignement.setAssigned((CtExpression<T>) child);\n\t\t\t\treturn;\n\t\t\t} else if (assignement.getAssignment() == null) {\n\t\t\t\tassignement.setAssignment((CtExpression<A>) child);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtAssignment(assignement);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> operator) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tif (operator.getLeftHandOperand() == null) {\n\t\t\t\toperator.setLeftHandOperand((CtExpression<?>) child);\n\t\t\t\treturn;\n\t\t\t} else if (operator.getRightHandOperand() == null) {\n\t\t\t\tif (child.getPosition().isValidPosition()) {\n\t\t\t\t\tint childEnd = child.getPosition().getSourceEnd();\n\t\t\t\t\tSourcePosition oldPos = operator.getPosition();\n\t\t\t\t\tif (oldPos.isValidPosition() && oldPos.getSourceEnd() < childEnd) {\n\t\t\t\t\t\t//fix parent position if right hand expression is `x instanceof List<?>` which has bad sourceEnd ending before `<?>\n\t\t\t\t\t\tint[] lineSeparatorPositions = jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\t\t\t\t\t\toperator.setPosition(operator.getFactory().Core().createSourcePosition(\n\t\t\t\t\t\t\t\toldPos.getCompilationUnit(),\n\t\t\t\t\t\t\t\toldPos.getSourceStart(), childEnd,\n\t\t\t\t\t\t\t\tlineSeparatorPositions));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toperator.setRightHandOperand((CtExpression<?>) child);\n\t\t\t\treturn;\n\t\t\t} else if (jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof StringLiteralConcatenation) {\n\t\t\t\tCtBinaryOperator<?> op = operator.getFactory().Core().createBinaryOperator();\n\t\t\t\top.setKind(BinaryOperatorKind.PLUS);\n\t\t\t\top.setLeftHandOperand(operator.getRightHandOperand());\n\t\t\t\top.setRightHandOperand((CtExpression<?>) child);\n\t\t\t\toperator.setRightHandOperand(op);\n\t\t\t\tint[] lineSeparatorPositions = jdtTreeBuilder.getContextBuilder().getCompilationUnitLineSeparatorPositions();\n\t\t\t\tSourcePosition leftPosition = op.getLeftHandOperand().getPosition();\n\t\t\t\tSourcePosition rightPosition = op.getRightHandOperand().getPosition();\n\t\t\t\top.setPosition(op.getFactory().createSourcePosition(leftPosition.getCompilationUnit(), leftPosition.getSourceStart(), rightPosition.getSourceEnd(), lineSeparatorPositions));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtBinaryOperator(operator);\n\t}\n\n\t@Override\n\tpublic <R> void visitCtBlock(CtBlock<R> block) {\n\t\tif (child instanceof CtStatement) {\n\t\t\tblock.addStatement((CtStatement) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtBlock(block);\n\t}\n\n\t@Override\n\tpublic <E> void visitCtCase(CtCase<E> caseStatement) {\n\t\tfinal ASTNode node = jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\tif (node instanceof CaseStatement && ((CaseStatement) node).constantExpression != null && caseStatement.getCaseExpression() == null && child instanceof CtExpression) {\n\t\t\tcaseStatement.setCaseExpression((CtExpression<E>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtStatement) {\n\t\t\tcaseStatement.addStatement((CtStatement) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtCase(caseStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtCatch(CtCatch catchBlock) {\n\t\tif (child instanceof CtBlock) {\n\t\t\tcatchBlock.setBody((CtBlock<?>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtCatchVariable) {\n\t\t\tcatchBlock.setParameter((CtCatchVariable<? extends Throwable>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtCatch(catchBlock);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> e) {\n\t\tif (jdtTreeBuilder.getContextBuilder().stack.peekFirst().node instanceof UnionTypeReference) {\n\t\t\te.addMultiType((CtTypeReference<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtCatchVariable(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\tif (child instanceof CtConstructor) {\n\t\t\tctClass.addConstructor((CtConstructor<T>) child);\n\t\t}\n\t\tif (child instanceof CtAnonymousExecutable) {\n\t\t\tctClass.addAnonymousExecutable((CtAnonymousExecutable) child);\n\t\t}\n\t\tsuper.visitCtClass(ctClass);\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameter(CtTypeParameter typeParameter) {\n\t\tif (childJDT instanceof TypeReference && child instanceof CtTypeAccess) {\n\t\t\tif (typeParameter.getSuperclass() == null) {\n\t\t\t\ttypeParameter.setSuperclass(((CtTypeAccess) child).getAccessedType());\n\t\t\t} else if (typeParameter.getSuperclass() instanceof CtIntersectionTypeReference) {\n\t\t\t\ttypeParameter.getSuperclass().asCtIntersectionTypeReference().addBound(((CtTypeAccess) child).getAccessedType());\n\t\t\t} else {\n\t\t\t\tfinal List<CtTypeReference<?>> refs = new ArrayList<>();\n\t\t\t\trefs.add(typeParameter.getSuperclass());\n\t\t\t\trefs.add(((CtTypeAccess) child).getAccessedType());\n\t\t\t\ttypeParameter.setSuperclass(jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(refs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtTypeParameter(typeParameter);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConditional(CtConditional<T> conditional) {\n\t\tif (child instanceof CtExpression) {\n\t\t\tif (conditional.getCondition() == null) {\n\t\t\t\tconditional.setCondition((CtExpression<Boolean>) child);\n\t\t\t} else if (conditional.getThenExpression() == null) {\n\t\t\t\tconditional.setThenExpression((CtExpression<T>) child);\n\t\t\t} else if (conditional.getElseExpression() == null) {\n\t\t\t\tconditional.setElseExpression((CtExpression<T>) child);\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtConditional(conditional);\n\t}\n\n\t@Override\n\tpublic void visitCtDo(CtDo doLoop) {\n\t\tif (doLoop.getBody() != null && child instanceof CtExpression && doLoop.getLoopingExpression() == null) {\n\t\t\tdoLoop.setLoopingExpression((CtExpression<Boolean>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtDo(doLoop);\n\t}\n\n\t@Override\n\tpublic void visitCtFor(CtFor forLoop) {\n\t\tif (isContainedInForInit() && child instanceof CtStatement) {\n\t\t\tforLoop.addForInit((CtStatement) child);\n\t\t\treturn;\n\t\t} else if (isContainedInForUpdate() && child instanceof CtStatement) {\n\t\t\tforLoop.addForUpdate((CtStatement) child);\n\t\t\treturn;\n\t\t} else if (forLoop.getExpression() == null && child instanceof CtExpression) {\n\t\t\tforLoop.setExpression((CtExpression<Boolean>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtFor(forLoop);\n\t}\n\n\tprivate boolean isContainedInForInit() {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof ForStatement)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ForStatement parent = (ForStatement) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\tif (parent.initializations == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Statement initialization : parent.initializations) {\n\t\t\tif (initialization != null && initialization.equals(childJDT)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isContainedInForUpdate() {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof ForStatement)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ForStatement parent = (ForStatement) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\tif (parent.increments == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Statement increment : parent.increments) {\n\t\t\tif (increment != null && increment.equals(childJDT)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void visitCtForEach(CtForEach foreach) {\n\t\tif (foreach.getVariable() == null && child instanceof CtVariable) {\n\t\t\tforeach.setVariable((CtLocalVariable<?>) child);\n\t\t\treturn;\n\t\t} else if (foreach.getExpression() == null && child instanceof CtExpression) {\n\t\t\tforeach.setExpression((CtExpression<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtForEach(foreach);\n\t}\n\n\t@Override\n\tpublic void visitCtWhile(CtWhile whileLoop) {\n\t\tif (whileLoop.getLoopingExpression() == null && child instanceof CtExpression) {\n\t\t\twhileLoop.setLoopingExpression((CtExpression<Boolean>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtWhile(whileLoop);\n\t}\n\n\t@Override\n\tpublic void visitCtIf(CtIf ifElement) {\n\t\tif (ifElement.getCondition() == null && child instanceof CtExpression) {\n\t\t\tifElement.setCondition((CtExpression<Boolean>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtStatement) {\n\t\t\tCtStatement child = (CtStatement) this.child;\n\t\t\t// we create implicit blocks everywhere for facilitating transformation\n\t\t\tif (!(this.child instanceof CtBlock)) {\n\t\t\t\tchild = jdtTreeBuilder.getFactory().Code().createCtBlock(child);\n\t\t\t\tchild.setImplicit(true);\n\t\t\t\tchild.setPosition(this.child.getPosition());\n\t\t\t}\n\n\t\t\tIfStatement ifJDT = (IfStatement) this.parentJDT;\n\t\t\tif (ifJDT.thenStatement == this.childJDT) {\n\t\t\t\t//we are visiting `then` of `if`\n\t\t\t\tifElement.setThenStatement(child);\n\t\t\t\treturn;\n\t\t\t} else if (ifJDT.elseStatement == this.childJDT) {\n\t\t\t\t//we are visiting `else` of `if`\n\t\t\t\tifElement.setElseStatement(child);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"Unexpected call of ParentExiter on CtIf\");\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtIf(ifElement);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtSuperAccess(CtSuperAccess<T> superAccess) {\n\t\tif (child instanceof CtTypeAccess<?>) {\n\t\t\tsuperAccess.setTarget((CtTypeAccess<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtSuperAccess(superAccess);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInvocation(CtInvocation<T> invocation) {\n\t\tif (childJDT instanceof TypeReference && child instanceof CtTypeAccess) {\n\t\t\tinvocation.getExecutable().addActualTypeArgument(((CtTypeAccess) child).getAccessedType());\n\t\t\treturn;\n\t\t} else if (child instanceof CtExpression) {\n\t\t\tif (hasChildEqualsToReceiver(invocation) || hasChildEqualsToQualification(invocation)) {\n\t\t\t\tif (child instanceof CtThisAccess) {\n\t\t\t\t\tfinal CtTypeReference<?> declaringType = invocation.getExecutable().getDeclaringType();\n\t\t\t\t\tif (declaringType != null && invocation.getExecutable().isStatic() && child.isImplicit()) {\n\t\t\t\t\t\tinvocation.setTarget(jdtTreeBuilder.getFactory().Code().createTypeAccess(declaringType, declaringType.isAnonymous()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinvocation.setTarget((CtThisAccess<?>) child);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinvocation.setTarget((CtExpression<?>) child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinvocation.addArgument((CtExpression<?>) child);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtInvocation(invocation);\n\t}\n\n\tprivate <T> boolean hasChildEqualsToQualification(CtInvocation<T> ctInvocation) {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof ExplicitConstructorCall)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ExplicitConstructorCall parent = (ExplicitConstructorCall) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// qualification is equals to the jdt child.\n\t\treturn parent.qualification != null && getFinalExpressionFromCast(parent.qualification).equals(childJDT)\n\t\t\t\t// qualification not yet initialized.\n\t\t\t\t&& !child.equals(ctInvocation.getTarget());\n\t}\n\n\tprivate <T> boolean hasChildEqualsToReceiver(CtInvocation<T> ctInvocation) {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof MessageSend)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal MessageSend parent = (MessageSend) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Receiver is equals to the jdt child.\n\t\treturn parent.receiver != null && getFinalExpressionFromCast(parent.receiver).equals(childJDT)\n\t\t\t\t// Receiver not yet initialized.\n\t\t\t\t&& !child.equals(ctInvocation.getTarget());\n\t}\n\n\tprivate Expression getFinalExpressionFromCast(Expression potentialCase) {\n\t\tif (!(potentialCase instanceof CastExpression)) {\n\t\t\treturn potentialCase;\n\t\t}\n\t\treturn getFinalExpressionFromCast(((CastExpression) potentialCase).expression);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtNewArray(CtNewArray<T> newArray) {\n\t\tif (childJDT instanceof TypeReference && child instanceof CtTypeAccess) {\n\t\t\tfinal ArrayAllocationExpression arrayAlloc = (ArrayAllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t\tnewArray.setType((CtArrayTypeReference) jdtTreeBuilder.getFactory().Type().createArrayReference(((CtTypeAccess) child).getAccessedType(), arrayAlloc.dimensions.length));\n\t\t} else if (child instanceof CtExpression) {\n\t\t\tif (isContainedInDimensionExpression()) {\n\t\t\t\tnewArray.addDimensionExpression((CtExpression<Integer>) child);\n\t\t\t} else if (child instanceof CtNewArray && childJDT instanceof ArrayInitializer && jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof ArrayAllocationExpression) {\n\t\t\t\tnewArray.setElements(((CtNewArray) child).getElements());\n\t\t\t} else {\n\t\t\t\tnewArray.addElement((CtExpression) child);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isContainedInDimensionExpression() {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof ArrayAllocationExpression)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal ArrayAllocationExpression parent = (ArrayAllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\tif (parent.dimensions == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (Expression dimension : parent.dimensions) {\n\t\t\tif (dimension != null && getFinalExpressionFromCast(dimension).equals(childJDT)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructorCall(CtConstructorCall<T> ctConstructorCall) {\n\t\tif (child instanceof CtTypeAccess) {\n\t\t\tif (hasChildEqualsToType(ctConstructorCall)) {\n\t\t\t\tctConstructorCall.getExecutable().setType(((CtTypeAccess) child).getAccessedType());\n\t\t\t} else {\n\t\t\t\tctConstructorCall.addActualTypeArgument(((CtTypeAccess) child).getAccessedType());\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (child instanceof CtExpression) {\n\t\t\tif (hasChildEqualsToEnclosingInstance(ctConstructorCall)) {\n\t\t\t\tctConstructorCall.setTarget((CtExpression<?>) child);\n\t\t\t} else {\n\t\t\t\tctConstructorCall.addArgument((CtExpression<?>) child);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtConstructorCall(ctConstructorCall);\n\t}\n\n\tprivate <T> boolean hasChildEqualsToEnclosingInstance(CtConstructorCall<T> ctConstructorCall) {\n\t\tif (!(jdtTreeBuilder.getContextBuilder().stack.peek().node instanceof QualifiedAllocationExpression)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal QualifiedAllocationExpression parent = (QualifiedAllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Enclosing instance is equals to the jdt child.\n\t\treturn parent.enclosingInstance != null && getFinalExpressionFromCast(parent.enclosingInstance).equals(childJDT)\n\t\t\t\t// Enclosing instance not yet initialized.\n\t\t\t\t&& !child.equals(ctConstructorCall.getTarget());\n\t}\n\n\tprivate <T> boolean hasChildEqualsToType(CtConstructorCall<T> ctConstructorCall) {\n\t\tfinal AllocationExpression parent = (AllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t// Type is equals to the jdt child.\n\t\treturn parent.type != null && parent.type.equals(childJDT);\n\t}\n\n\tprivate static final String KEYWORD_NEW = \"new\";\n\n\t@Override\n\tpublic <T> void visitCtNewClass(CtNewClass<T> newClass) {\n\t\tif (child instanceof CtClass) {\n\t\t\tnewClass.setAnonymousClass((CtClass<?>) child);\n\t\t\tfinal QualifiedAllocationExpression node = (QualifiedAllocationExpression) jdtTreeBuilder.getContextBuilder().stack.peek().node;\n\t\t\tfinal ReferenceBinding[] referenceBindings = node.resolvedType == null ? null : node.resolvedType.superInterfaces();\n\t\t\tif (referenceBindings != null && referenceBindings.length > 0) {\n\t\t\t\t//the interface of anonymous class is not printed so it must have no position\n\t\t\t\t//note: the interface is sometimes already assigned so call setSuperInterfaces to replace it\n\t\t\t\t((CtClass<?>) child).setSuperInterfaces(Collections.singleton(cloneAsImplicit(newClass.getType())));\n\t\t\t} else if (newClass.getType() != null) {\n\t\t\t\t//the super class of anonymous class is not printed so it must have no position\n\t\t\t\t((CtClass<?>) child).setSuperclass(cloneAsImplicit(newClass.getType()));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtNewClass(newClass);\n\t}\n\n\tprivate <T extends CtElement> T cloneAsImplicit(T ele) {\n\t\tele = (T) ele.clone();\n\t\tele.accept(new CtScanner() {\n\t\t\t@Override\n\t\t\tprotected void enter(CtElement e) {\n\t\t\t\te.setPosition(SourcePosition.NOPOSITION);\n\t\t\t}\n\t\t});\n\t\tele.setImplicit(true);\n\t\treturn ele;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLambda(CtLambda<T> lambda) {\n\t\tif (child instanceof CtParameter) {\n\t\t\tlambda.addParameter((CtParameter<?>) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtBlock) {\n\t\t\tlambda.setBody((CtBlock) child);\n\t\t\treturn;\n\t\t} else if (child instanceof CtExpression) {\n\t\t\tlambda.setExpression((CtExpression<T>) child);\n\t\t}\n\t\tsuper.visitCtLambda(lambda);\n\t}\n\n\t@Override\n\tpublic <T, E extends CtExpression<?>> void visitCtExecutableReferenceExpression(CtExecutableReferenceExpression<T, E> expression) {\n\t\tif (child instanceof CtExpression) {\n\t\t\texpression.setTarget((E) child);\n\t\t}\n\t\tsuper.visitCtExecutableReferenceExpression(expression);\n\t}\n\n\t@Override\n\tpublic void visitCtPackage(CtPackage ctPackage) {\n\t\tif (child instanceof CtType) {\n\t\t\tCtType<?> type = (CtType<?>) child;\n\t\t\tif (ctPackage.getTypes().contains(type)) {\n\t\t\t\tctPackage.removeType(type);\n\t\t\t}\n\t\t\tctPackage.addType(type);\n\t\t\tCompilationUnit cu = type.getPosition().getCompilationUnit();\n\t\t\tif (cu != null) {\n\t\t\t\tcu.addDeclaredType(type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtPackage(ctPackage);\n\t}\n\n\t@Override\n\tpublic <R> void visitCtReturn(CtReturn<R> returnStatement) {\n\t\tif (child instanceof CtExpression) {\n\t\t\treturnStatement.setReturnedExpression((CtExpression<R>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtReturn(returnStatement);\n\t}\n\n\t@Override\n\tpublic <E> void visitCtSwitch(CtSwitch<E> switchStatement) {\n\t\tif (switchStatement.getSelector() == null && child instanceof CtExpression) {\n\t\t\tswitchStatement.setSelector((CtExpression<E>) child);\n\t\t\treturn;\n\t\t}\n\t\tif (child instanceof CtCase) {\n\t\t\tswitchStatement.addCase((CtCase<E>) child);\n\t\t\t//we have all statements of the case. Update source position now\n\t\t\tchild.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition((CtCase<E>) child));\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtSwitch(switchStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtSynchronized(CtSynchronized synchro) {\n\t\tif (synchro.getExpression() == null && child instanceof CtExpression) {\n\t\t\tsynchro.setExpression((CtExpression<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tif (synchro.getBlock() == null && child instanceof CtBlock) {\n\t\t\tsynchro.setBlock((CtBlock<?>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtSynchronized(synchro);\n\t}\n\n\t@Override\n\tpublic void visitCtThrow(CtThrow throwStatement) {\n\t\tif (throwStatement.getThrownExpression() == null && child instanceof CtExpression) {\n\t\t\tthrowStatement.setThrownExpression((CtExpression<? extends Throwable>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtThrow(throwStatement);\n\t}\n\n\t@Override\n\tpublic void visitCtTry(CtTry tryBlock) {\n\t\tif (child instanceof CtBlock) {\n\t\t\tfinal CtBlock<?> childBlock = (CtBlock<?>) this.child;\n\t\t\tCtCatch lastCatcher = getLastCatcher(tryBlock);\n\t\t\tif (lastCatcher != null && lastCatcher.getBody() == null) {\n\t\t\t\tlastCatcher.setBody(childBlock);\n\t\t\t\t//we have finally all the information needed to build full position of CtCatch element\n\t\t\t\tlastCatcher.setPosition(jdtTreeBuilder.getPositionBuilder().buildPosition(lastCatcher));\n\t\t\t} else if (tryBlock.getBody() != null && tryBlock.getFinalizer() == null) {\n\t\t\t\ttryBlock.setFinalizer(childBlock);\n\t\t\t} else {\n\t\t\t\ttryBlock.setBody(childBlock);\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (child instanceof CtCatch) {\n\t\t\ttryBlock.addCatcher((CtCatch) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtTry(tryBlock);\n\t}\n\n\t/**\n\t * @param tryBlock\n\t * @return last CtCatch of `tryBlock` or null\n\t */\n\tprivate CtCatch getLastCatcher(CtTry tryBlock) {\n\t\tList<CtCatch> catchers = tryBlock.getCatchers();\n\t\tint nrCatchers = catchers.size();\n\t\tif (nrCatchers > 0) {\n\t\t\treturn catchers.get(nrCatchers - 1);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void visitCtTryWithResource(CtTryWithResource tryWithResource) {\n\t\tif (child instanceof CtLocalVariable) {\n\t\t\ttryWithResource.addResource((CtLocalVariable<?>) child);\n\t\t}\n\t\tsuper.visitCtTryWithResource(tryWithResource);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {\n\t\tif (operator.getOperand() == null && child instanceof CtExpression) {\n\t\t\toperator.setOperand((CtExpression<T>) child);\n\t\t\treturn;\n\t\t}\n\t\tsuper.visitCtUnaryOperator(operator);\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference e) {\n\t\tif (childJDT instanceof TypeReference && child instanceof CtTypeAccess) {\n\t\t\te.setBoundingType(((CtTypeAccess) child).getAccessedType());\n\t\t}\n\t\tsuper.visitCtWildcardReference(e);\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/FactoryCompilerConfig.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n\nimport spoon.SpoonModelBuilder;\nimport spoon.reflect.declaration.CtType;\n\npublic class FactoryCompilerConfig implements SpoonModelBuilder.InputType {\n\n\tpublic static final SpoonModelBuilder.InputType INSTANCE = new FactoryCompilerConfig();\n\n\t//avoid direct instantiation. But somebody can inherit\n\tprotected FactoryCompilerConfig() {\n\t}\n\n\t/**\n\t * returns the compilation units corresponding to the types in the factory.\n\t */\n\t@Override\n\tpublic void initializeCompiler(JDTBatchCompiler compiler) {\n\t\tJDTBasedSpoonCompiler jdtCompiler = compiler.getJdtCompiler();\n\t\tList<CompilationUnit> unitList = new ArrayList<>();\n\t\tfor (CtType<?> ctType : jdtCompiler.getFactory().Type().getAll()) {\n\t\t\tif (ctType.isTopLevel()) {\n\t\t\t\tunitList.add(new CompilationUnitWrapper(ctType));\n\t\t\t}\n\t\t}\n\t\tcompiler.setCompilationUnits(unitList.toArray(new CompilationUnit[0]));\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTTreeBuilderQuery.java",
      "weight" : 234.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.UnaryOperatorKind;\nimport spoon.reflect.declaration.CtAnnotatedElementType;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/** Helper class for JDTTreeBuilder. Package visible to reduce API surface. */\nclass JDTTreeBuilderQuery {\n\tprivate JDTTreeBuilderQuery() { }\n\t/**\n\t * Searches a type from an entry-point according to a simple name.\n\t *\n\t * @param type\n\t * \t\tEntry-point to search.\n\t * @param simpleName\n\t * \t\tExpected type name.\n\t * @return type binding.\n\t */\n\tstatic TypeBinding searchTypeBinding(ReferenceBinding type, String simpleName) {\n\t\tif (simpleName == null || type == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (type.memberTypes() != null) {\n\t\t\tfor (ReferenceBinding memberType : type.memberTypes()) {\n\t\t\t\tif (simpleName.equals(CharOperation.charToString(memberType.sourceName()))) {\n\t\t\t\t\treturn memberType;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn searchTypeBinding(type.superclass(), simpleName);\n\t}\n\n\t/**\n\t * Searches a type used in units declared in a compilation unit.\n\t *\n\t * @param qualifiedName\n\t * \t\tQualified name of the expected type.\n\t * @param unitsToProcess\n\t * \t\tSearch the type expected in units.\n\t * @return type binding.\n\t */\n\tstatic TypeBinding searchTypeBinding(String qualifiedName, CompilationUnitDeclaration[] unitsToProcess) {\n\t\tif (qualifiedName == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (CompilationUnitDeclaration unitToProcess : unitsToProcess) {\n\t\t\tif (unitToProcess.types != null) {\n\t\t\t\tfor (TypeDeclaration type : unitToProcess.types) {\n\t\t\t\t\tif (qualifiedName.equals(CharOperation.toString(type.binding.compoundName))) {\n\t\t\t\t\t\treturn type.binding;\n\t\t\t\t\t}\n\t\t\t\t\tif (type.memberTypes != null) {\n\t\t\t\t\t\tfor (TypeDeclaration memberType : type.memberTypes) {\n\t\t\t\t\t\t\tif (qualifiedName.equals(CharOperation.toString(memberType.binding.compoundName))) {\n\t\t\t\t\t\t\t\treturn type.binding;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches a type declared in imports.\n\t *\n\t * @param typeName\n\t * \t\tExpected type name.\n\t * @param imports\n\t * \t\tSearch the type in imports.\n\t * @return qualified name of the expected type.\n\t */\n\tstatic String searchType(String typeName, ImportReference[] imports) {\n\t\tif (typeName == null || imports == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (ImportReference anImport : imports) {\n\t\t\tfinal String importType = CharOperation.charToString(anImport.getImportName()[anImport.getImportName().length - 1]);\n\t\t\tif (typeName.equals(importType)) {\n\t\t\t\treturn CharOperation.toString(anImport.getImportName());\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Searches a package used in units declared in a compilation unit.\n\t *\n\t * @param packageName\n\t * \t\tPackage name.\n\t * @param unitsToProcess\n\t * \t\tSearch the package expected in units.\n\t * @return import reference which correspond to the package expected.\n\t */\n\tstatic ImportReference searchPackage(char[][] packageName, CompilationUnitDeclaration[] unitsToProcess) {\n\t\tfor (CompilationUnitDeclaration unit : unitsToProcess) {\n\t\t\tfinal ImportReference currentPackage = unit.currentPackage;\n\t\t\tif (currentPackage == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal char[][] tokens = currentPackage.tokens;\n\t\t\tif (packageName.length > tokens.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean isFound = true;\n\t\t\tfor (int i = 0; i < packageName.length; i++) {\n\t\t\t\tchar[] chars = packageName[i];\n\t\t\t\tif (!CharOperation.equals(chars, tokens[i])) {\n\t\t\t\t\tisFound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isFound) {\n\t\t\t\treturn currentPackage;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks in an annotation if a given type is present.\n\t *\n\t * @param a\n\t * \t\tAn annotation.\n\t * @param elementType\n\t * \t\tExpected element type of the annotation.\n\t * @return true if the annotation is compatible with the given element type.\n\t */\n\tstatic boolean hasAnnotationWithType(Annotation a, CtAnnotatedElementType elementType) {\n\t\tif (a.resolvedType == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// JLS says:\n\t\t//  \"If an annotation of type java.lang.annotation.Target is not present on the declaration of an annotation type T,\n\t\t// then T is applicable in all declaration contexts except type parameter declarations, and in no type contexts.\"\n\t\tboolean shouldTargetAnnotationExists = (elementType == CtAnnotatedElementType.TYPE_USE || elementType == CtAnnotatedElementType.TYPE_PARAMETER);\n\t\tboolean targetAnnotationExists = false;\n\n\t\tfor (AnnotationBinding annotation : a.resolvedType.getAnnotations()) {\n\t\t\tif (!\"Target\".equals(CharOperation.charToString(annotation.getAnnotationType().sourceName()))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttargetAnnotationExists = true;\n\t\t\tObject value = annotation.getElementValuePairs()[0].value;\n\t\t\tif (value == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (value instanceof FieldBinding && elementType.name().equals(CharOperation.charToString(((FieldBinding) value).name))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (value.getClass().isArray()) {\n\t\t\t\tObject[] fields = (Object[]) value;\n\t\t\t\tfor (Object field : fields) {\n\t\t\t\t\tif (field instanceof FieldBinding && elementType.name().equals(CharOperation.charToString(((FieldBinding) field).name))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// true here means that the target annotation is not mandatory and we have not found it\n\t\treturn !shouldTargetAnnotationExists && !targetAnnotationExists;\n\t}\n\n\t/**\n\t * Checks if the qualified name reference is a problem field binding and have a valid field.\n\t *\n\t * @param qualifiedNameReference\n\t * \t\tReference which should contains a problem field binding.\n\t * @return true if the qualified name reference is a valid problem field binding.\n\t */\n\tstatic boolean isValidProblemBindingField(QualifiedNameReference qualifiedNameReference) {\n\t\treturn qualifiedNameReference.binding instanceof ProblemFieldBinding && !((FieldBinding) qualifiedNameReference.binding).declaringClass.isAnonymousType()\n\t\t\t\t&& qualifiedNameReference.tokens.length - 1 == ((FieldBinding) qualifiedNameReference.binding).declaringClass.compoundName.length && CharOperation\n\t\t\t\t.equals(CharOperation.subarray(qualifiedNameReference.tokens, 0, qualifiedNameReference.tokens.length - 1),\n\t\t\t\t\t\t((FieldBinding) qualifiedNameReference.binding).declaringClass.compoundName);\n\t}\n\n\t/**\n\t * Checks if the last node in the stack in the context is an assignment and have a lhs equals to the given expression.\n\t *\n\t * @param context\n\t * \t\tContext of the {@link JDTTreeBuilder}.\n\t * @param lhs\n\t * \t\tPotential lhs of the assignment.\n\t * @return true if the lhs is equals to the given expression.\n\t */\n\tstatic boolean isLhsAssignment(ContextBuilder context, Expression lhs) {\n\t\treturn context.stack.peek().node instanceof Assignment && ((Assignment) context.stack.peek().node).lhs.equals(lhs);\n\t}\n\n\t/**\n\t * Converts the unary operator from JDT to Spoon.\n\t *\n\t * @param operator\n\t * \t\tIdentifier of the unary operator.\n\t * @return enum value of {@link UnaryOperatorKind}.\n\t */\n\tstatic UnaryOperatorKind getUnaryOperator(int operator) {\n\t\tswitch (operator) {\n\t\tcase OperatorIds.PLUS:\n\t\t\treturn UnaryOperatorKind.POS;\n\t\tcase OperatorIds.MINUS:\n\t\t\treturn UnaryOperatorKind.NEG;\n\t\tcase OperatorIds.NOT:\n\t\t\treturn UnaryOperatorKind.NOT;\n\t\tcase OperatorIds.TWIDDLE:\n\t\t\treturn UnaryOperatorKind.COMPL;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts the binary operator from JDT to Spoon.\n\t *\n\t * @param operator\n\t * \t\tIdentifier of the binary operator.\n\t * @return enum value of {@link BinaryOperatorKind}.\n\t */\n\tstatic BinaryOperatorKind getBinaryOperatorKind(int operator) {\n\t\tswitch (operator) {\n\t\tcase OperatorIds.EQUAL_EQUAL:\n\t\t\treturn BinaryOperatorKind.EQ;\n\t\tcase OperatorIds.LESS_EQUAL:\n\t\t\treturn BinaryOperatorKind.LE;\n\t\tcase OperatorIds.GREATER_EQUAL:\n\t\t\treturn BinaryOperatorKind.GE;\n\t\tcase OperatorIds.NOT_EQUAL:\n\t\t\treturn BinaryOperatorKind.NE;\n\t\tcase OperatorIds.LEFT_SHIFT:\n\t\t\treturn BinaryOperatorKind.SL;\n\t\tcase OperatorIds.RIGHT_SHIFT:\n\t\t\treturn BinaryOperatorKind.SR;\n\t\tcase OperatorIds.UNSIGNED_RIGHT_SHIFT:\n\t\t\treturn BinaryOperatorKind.USR;\n\t\tcase OperatorIds.OR_OR:\n\t\t\treturn BinaryOperatorKind.OR;\n\t\tcase OperatorIds.AND_AND:\n\t\t\treturn BinaryOperatorKind.AND;\n\t\tcase OperatorIds.PLUS:\n\t\t\treturn BinaryOperatorKind.PLUS;\n\t\tcase OperatorIds.MINUS:\n\t\t\treturn BinaryOperatorKind.MINUS;\n\t\tcase OperatorIds.NOT:\n\t\t\treturn BinaryOperatorKind.NE;\n\t\tcase OperatorIds.REMAINDER:\n\t\t\treturn BinaryOperatorKind.MOD;\n\t\tcase OperatorIds.XOR:\n\t\t\treturn BinaryOperatorKind.BITXOR;\n\t\tcase OperatorIds.AND:\n\t\t\treturn BinaryOperatorKind.BITAND;\n\t\tcase OperatorIds.MULTIPLY:\n\t\t\treturn BinaryOperatorKind.MUL;\n\t\tcase OperatorIds.OR:\n\t\t\treturn BinaryOperatorKind.BITOR;\n\t\tcase OperatorIds.DIVIDE:\n\t\t\treturn BinaryOperatorKind.DIV;\n\t\tcase OperatorIds.GREATER:\n\t\t\treturn BinaryOperatorKind.GT;\n\t\tcase OperatorIds.LESS:\n\t\t\treturn BinaryOperatorKind.LT;\n\t\tcase OperatorIds.QUESTIONCOLON:\n\t\t\tthrow new RuntimeException(\"Unknown operator\");\n\t\tcase OperatorIds.EQUAL:\n\t\t\treturn BinaryOperatorKind.EQ;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts the modifier from JDT to Spoon.\n\t *\n\t * @param modifier\n\t * \t\tIdentifier of the modifier.\n\t * @param implicit True if the modifier is not explicit in the source code (e.g. a missing 'public' in an interface)\n\t * @return Set of enum value of {@link CtExtendedModifier}.\n\t */\n\tstatic Set<CtExtendedModifier> getModifiers(int modifier, boolean implicit, boolean isMethod) {\n\t\tSet<CtExtendedModifier> modifiers = new HashSet<>();\n\t\tif ((modifier & ClassFileConstants.AccPublic) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.PUBLIC, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccPrivate) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.PRIVATE, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccProtected) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.PROTECTED, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccStatic) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.STATIC, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccFinal) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.FINAL, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccSynchronized) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.SYNCHRONIZED, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccVolatile) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.VOLATILE, implicit));\n\t\t}\n\t\t// a method can never be transient, but it can have the flag because of varArgs.\n\t\t// source: https://stackoverflow.com/questions/16233910/can-transient-keywords-mark-a-method\n\t\tif (!isMethod && (modifier & ClassFileConstants.AccTransient) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.TRANSIENT, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccAbstract) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.ABSTRACT, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccStrictfp) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.STRICTFP, implicit));\n\t\t}\n\t\tif ((modifier & ClassFileConstants.AccNative) != 0) {\n\t\t\tmodifiers.add(new CtExtendedModifier(ModifierKind.NATIVE, implicit));\n\t\t}\n\t\treturn modifiers;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTBatchCompiler.java",
      "weight" : 224.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.core.compiler.CompilationProgress;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\nimport org.eclipse.jdt.internal.compiler.IProblemFactory;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\nimport org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\nimport org.eclipse.jdt.internal.core.util.CommentRecorderParser;\nimport spoon.SpoonException;\nimport spoon.support.compiler.SpoonProgress;\n\nimport java.io.File;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\n/*\n * Overrides the getCompilationUnits() from JDT's class to pass the ones we want.\n *\n * (we use a fully qualified name in inheritance to make it clear we are extending jdt)\n */\npublic class JDTBatchCompiler extends org.eclipse.jdt.internal.compiler.batch.Main {\n\n\tprotected final JDTBasedSpoonCompiler jdtCompiler;\n\tprotected CompilationUnit[] compilationUnits;\n\n\tpublic JDTBatchCompiler(JDTBasedSpoonCompiler jdtCompiler) {\n\t\t// by default we don't want anything from JDT\n\t\t// the reports are sent with callbakcs to the reporter\n\t\t// for debuggging, you may use System.out/err instead\n\t\tthis(jdtCompiler, new NullOutputStream(), new NullOutputStream());\n\t}\n\n\tJDTBatchCompiler(JDTBasedSpoonCompiler jdtCompiler, OutputStream outWriter, OutputStream errWriter) {\n\t\tsuper(new PrintWriter(outWriter), new PrintWriter(errWriter), false, null, null);\n\t\tthis.jdtCompiler = jdtCompiler;\n\t\tif (jdtCompiler != null) {\n\t\t\tthis.jdtCompiler.probs.clear();\n\t\t}\n\t}\n\n\t/**\n\t * This method returns the compilation units that will be processed and/or compiled by JDT.\n\t * Note that this method also process the CUs to associate the right module information.\n\t * Warning: this method cannot be replaced by a call to its supermethod as we manage the CUs differently\n\t * in Spoon. We might indeed have CUs coming from virtual files or ignored CU due to the configuration.\n\t * The the CUs are created from the {@link FileCompilerConfig}.\n\t */\n\t@Override\n\tpublic CompilationUnit[] getCompilationUnits() {\n\n\t\tMap<String, char[]> pathToModName = new HashMap<>();\n\n\t\tfor (int round = 0; round < 2; round++) {\n\t\t\tfor (CompilationUnit compilationUnit : this.compilationUnits) {\n\t\t\t\tchar[] charName = compilationUnit.getFileName();\n\t\t\t\tboolean isModuleInfo = CharOperation.endsWith(charName, TypeConstants.MODULE_INFO_FILE_NAME);\n\t\t\t\tif (isModuleInfo == (round == 0)) { // 1st round: modules, 2nd round others (to ensure populating pathToModCU well in time)\n\n\t\t\t\t\tString fileName = new String(charName);\n\t\t\t\t\tif (isModuleInfo) {\n\t\t\t\t\t\tint lastSlash = CharOperation.lastIndexOf(File.separatorChar, charName);\n\t\t\t\t\t\tif (lastSlash != -1) {\n\t\t\t\t\t\t\tchar[] modulePath = CharOperation.subarray(charName, 0, lastSlash);\n\n\t\t\t\t\t\t\tlastSlash = CharOperation.lastIndexOf(File.separatorChar, modulePath);\n\t\t\t\t\t\t\tif (lastSlash == -1) {\n\t\t\t\t\t\t\t\tlastSlash = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastSlash += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//TODO the module name parsed by JDK compiler is in `this.modNames`\n\t\t\t\t\t\t\tcompilationUnit.module = CharOperation.subarray(modulePath, lastSlash, modulePath.length);\n\t\t\t\t\t\t\tpathToModName.put(String.valueOf(modulePath), compilationUnit.module);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (Map.Entry<String, char[]> entry : pathToModName.entrySet()) {\n\t\t\t\t\t\t\tif (fileName.startsWith(entry.getKey())) { // associate CUs to module by common prefix\n\t\t\t\t\t\t\t\tcompilationUnit.module = entry.getValue();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn compilationUnits;\n\t}\n\n\tpublic void setCompilationUnits(CompilationUnit[] compilationUnits) {\n\t\tthis.compilationUnits = compilationUnits;\n\t}\n\n\t@Override\n\tpublic ICompilerRequestor getBatchRequestor() {\n\t\tfinal ICompilerRequestor r = super.getBatchRequestor();\n\t\treturn new ICompilerRequestor() {\n\t\t\t@Override\n\t\t\tpublic void acceptResult(CompilationResult compilationResult) {\n\t\t\t\tif (compilationResult.hasErrors()) {\n\t\t\t\t\tfor (CategorizedProblem problem:compilationResult.problems) {\n\t\t\t\t\t\tif (JDTBatchCompiler.this.jdtCompiler != null) {\n\t\t\t\t\t\t\tJDTBatchCompiler.this.jdtCompiler.reportProblem(problem);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new SpoonException(problem.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr.acceptResult(compilationResult); // this is required to complete the compilation and produce the class files\n\t\t\t}\n\t\t};\n\t}\n\n\tprotected Set<String> filesToBeIgnored = new HashSet<>();\n\n\tpublic void ignoreFile(String filePath) {\n\t\tfilesToBeIgnored.add(filePath);\n\t}\n\n\n\t/** Calls JDT to retrieve the list of compilation unit declarations.\n\t * Depends on the actual implementation of {@link #getCompilationUnits()}\n\t */\n\tpublic CompilationUnitDeclaration[] getUnits() {\n\t\tstartTime = System.currentTimeMillis();\n\t\tINameEnvironment environment = this.jdtCompiler.environment;\n\t\tif (environment == null) {\n\t\t\tenvironment = getLibraryAccess();\n\t\t}\n\t\tCompilerOptions compilerOptions = new CompilerOptions(this.options);\n\t\tcompilerOptions.parseLiteralExpressionsAsConstants = false;\n\n\t\tIErrorHandlingPolicy errorHandlingPolicy;\n\n\t\tif (jdtCompiler.getEnvironment().getNoClasspath()) {\n\n\t\t\t// in no classpath, we should proceed on error,\n\t\t\t// as we will encounter some\n\t\t\terrorHandlingPolicy = new IErrorHandlingPolicy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean proceedOnErrors() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean stopOnFirstError() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// we cannot ignore them, because JDT will continue its process\n\t\t\t\t// and it led to NPE in several places\n\t\t\t\t@Override\n\t\t\t\tpublic boolean ignoreAllErrors() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\n\t\t\t// when there is a classpath, we should not have any error\n\t\t\terrorHandlingPolicy = new IErrorHandlingPolicy() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean proceedOnErrors() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// we wait for all errors to be gathered before stopping\n\t\t\t\t@Override\n\t\t\t\tpublic boolean stopOnFirstError() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean ignoreAllErrors() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tIProblemFactory problemFactory = getProblemFactory();\n\t\tTreeBuilderCompiler treeBuilderCompiler = new TreeBuilderCompiler(\n\t\t\t\tenvironment, errorHandlingPolicy, compilerOptions,\n\t\t\t\tthis.jdtCompiler.requestor, problemFactory, this.out, new CompilationProgress() {\n\n\t\t\tprivate String currentElement = null;\n\t\t\tprivate int totalTask = -1;\n\n\t\t\t@Override\n\t\t\tpublic void begin(int i) { }\n\n\t\t\t@Override\n\t\t\tpublic void done() { }\n\n\t\t\t@Override\n\t\t\tpublic boolean isCanceled() {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void setTaskName(String s) {\n\t\t\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\t\tString strToFind = \"Processing \";\n\t\t\t\t\tint processingPosition = s.indexOf(strToFind);\n\t\t\t\t\tif (processingPosition != -1) {\n\t\t\t\t\t\tcurrentElement = s.substring(processingPosition + strToFind.length());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void worked(int increment, int remaining) {\n\t\t\t\tif (totalTask == -1) {\n\t\t\t\t\ttotalTask = remaining + 1;\n\t\t\t\t}\n\t\t\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().step(SpoonProgress.Process.COMPILE, currentElement, totalTask - remaining, totalTask);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (jdtCompiler.getEnvironment().getNoClasspath()) {\n\t\t\ttreeBuilderCompiler.lookupEnvironment.problemReporter = new ProblemReporter(errorHandlingPolicy, compilerOptions, problemFactory) {\n\t\t\t\t@Override\n\t\t\t\tpublic int computeSeverity(int problemID) {\n\t\t\t\t\t// ignore all the problem and continue the build creation\n\t\t\t\t\treturn 256;\n\t\t\t\t}\n\t\t\t};\n\t\t\ttreeBuilderCompiler.lookupEnvironment.mayTolerateMissingType = true;\n\t\t}\n\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().start(SpoonProgress.Process.COMPILE);\n\t\t}\n\t\t// they have to be done all at once\n\t\tfinal CompilationUnitDeclaration[] result = treeBuilderCompiler.buildUnits(getCompilationUnits());\n\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().end(SpoonProgress.Process.COMPILE);\n\t\t}\n\t\t// now adding the doc\n\t\tif (jdtCompiler.getEnvironment().isCommentsEnabled()) {\n\t\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().start(SpoonProgress.Process.COMMENT);\n\t\t\t}\n\t\t\t//compile comments only if they are needed\n\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\tCompilationUnitDeclaration unit = result[i];\n\t\t\t\tCommentRecorderParser parser =\n\t\t\t\t\t\tnew CommentRecorderParser(\n\t\t\t\t\t\t\t\tnew ProblemReporter(\n\t\t\t\t\t\t\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(),\n\t\t\t\t\t\t\t\t\t\tcompilerOptions,\n\t\t\t\t\t\t\t\t\t\tnew DefaultProblemFactory(Locale.getDefault())),\n\t\t\t\t\t\t\t\tfalse);\n\n\t\t\t\t//reuse the source compilation unit\n\t\t\t\tICompilationUnit sourceUnit = unit.compilationResult.compilationUnit;\n\n\t\t\t\tfinal CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0, compilerOptions.maxProblemsPerUnit);\n\t\t\t\tCompilationUnitDeclaration tmpDeclForComment = parser.dietParse(sourceUnit, compilationResult);\n\t\t\t\tunit.comments = tmpDeclForComment.comments;\n\n\t\t\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().step(SpoonProgress.Process.COMMENT, new String(unit.getFileName()), i + 1, result.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jdtCompiler.getEnvironment().getSpoonProgress() != null) {\n\t\t\t\tjdtCompiler.getEnvironment().getSpoonProgress().end(SpoonProgress.Process.COMMENT);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic JDTBasedSpoonCompiler getJdtCompiler() {\n\t\treturn jdtCompiler;\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTSnippetCompiler.java",
      "weight" : 61.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.builder.JDTBuilder;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.compiler.SnippetCompilationError;\nimport spoon.support.compiler.VirtualFile;\n\npublic class JDTSnippetCompiler extends JDTBasedSpoonCompiler {\n\n\tprivate final AtomicLong snippetNumber = new AtomicLong(0);\n\tpublic static final String SNIPPET_FILENAME_PREFIX = JDTSnippetCompiler.class.getName() + \"_spoonSnippet_\";\n\n\tprivate CompilationUnit snippetCompilationUnit;\n\n\tpublic JDTSnippetCompiler(Factory factory, String contents) {\n\t\tsuper(factory);\n\t\t//give the Virtual file the unique name so JDTCommentBuilder.spoonUnit can be correctly initialized\n\t\taddInputSource(new VirtualFile(contents, SNIPPET_FILENAME_PREFIX + (snippetNumber.incrementAndGet())));\n\t}\n\n\t@Override\n\tpublic boolean build() {\n\t\treturn build(null);\n\t}\n\n\t@Override\n\tpublic boolean build(JDTBuilder builder) {\n\t\tif (factory == null) {\n\t\t\tthrow new SpoonException(\"Factory not initialized\");\n\t\t}\n\n\t\tboolean srcSuccess;\n\t\tList<SpoonFile> allFiles = sources.getAllJavaFiles();\n\t\tfactory.getEnvironment().debugMessage(\"compiling sources: \" + allFiles);\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\t\ttry {\n\t\t\tsrcSuccess = buildSources(builder);\n\t\t} finally {\n\t\t\t//remove snippet compilation unit from the cache (to clear memory) and remember it so client can use it\n\t\t\tfor (SpoonFile spoonFile : allFiles) {\n\t\t\t\tif (spoonFile.getName().startsWith(SNIPPET_FILENAME_PREFIX)) {\n\t\t\t\t\tsnippetCompilationUnit = factory.CompilationUnit().removeFromCache(spoonFile.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treportProblems(factory.getEnvironment());\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn srcSuccess;\n\t}\n\n\t@Override\n\tprotected boolean buildSources(JDTBuilder jdtBuilder) {\n\t\treturn buildUnitsAndModel(jdtBuilder, sources, getSourceClasspath(), \"snippet \");\n\t}\n\n\t@Override\n\tprotected void report(Environment environment, CategorizedProblem problem) {\n\t\tif (problem.isError()) {\n\t\t\tthrow new SnippetCompilationError(problem.getMessage() + \"at line \" + problem.getSourceLineNumber());\n\t\t}\n\t}\n\n\t/**\n\t * @return CompilationUnit which was produced by compiling of this snippet\n\t */\n\tpublic CompilationUnit getSnippetCompilationUnit() {\n\t\treturn snippetCompilationUnit;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/FileCompilerConfig.java",
      "weight" : 40.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport spoon.SpoonModelBuilder;\nimport spoon.compiler.Environment;\nimport spoon.compiler.SpoonFile;\n\nimport org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n\npublic class FileCompilerConfig implements SpoonModelBuilder.InputType {\n\n\t/**\n\t * Default implementation of which initializes {@link JDTBatchCompiler} by all sources and templates registered in {@link SpoonModelBuilder}\n\t */\n\tpublic static final SpoonModelBuilder.InputType INSTANCE = new FileCompilerConfig((List<SpoonFile>) null) {\n\t\t@Override\n\t\tpublic List<SpoonFile> getFiles(JDTBatchCompiler compiler) {\n\t\t\tJDTBasedSpoonCompiler jdtCompiler = compiler.getJdtCompiler();\n\t\t\tList<SpoonFile> files = new ArrayList<>();\n\t\t\tfiles.addAll(jdtCompiler.sources.getAllJavaFiles());\n\t\t\tfiles.addAll(jdtCompiler.templates.getAllJavaFiles());\n\t\t\treturn files;\n\t\t}\n\t};\n\n\tprivate final List<SpoonFile> files;\n\n\tpublic FileCompilerConfig(List<SpoonFile> files) {\n\t\tthis.files = files;\n\t}\n\n\t@Override\n\tpublic void initializeCompiler(JDTBatchCompiler compiler) {\n\t\tJDTBasedSpoonCompiler jdtCompiler = compiler.getJdtCompiler();\n\t\tList<CompilationUnit> cuList = new ArrayList<>();\n\n\t\tfor (SpoonFile f : getFiles(compiler)) {\n\n\t\t\tif (compiler.filesToBeIgnored.contains(f.getPath())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString fName = f.isActualFile() ? f.getPath() : f.getName();\n\t\t\tEnvironment env = jdtCompiler.getEnvironment();\n\t\t\tcuList.add(new CompilationUnit(f.getContentChars(env), fName, env.getEncoding().displayName()));\n\t\t}\n\n\t\tcompiler.setCompilationUnits(cuList.toArray(new CompilationUnit[0]));\n\t}\n\n\tprotected List<SpoonFile> getFiles(JDTBatchCompiler compiler) {\n\t\treturn files;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/TreeBuilderCompiler.java",
      "weight" : 65.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.core.compiler.CompilationProgress;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\nimport org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;\nimport org.eclipse.jdt.internal.compiler.IProblemFactory;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\nimport org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeConstants;\nimport org.eclipse.jdt.internal.compiler.util.Messages;\n\n\nclass TreeBuilderCompiler extends org.eclipse.jdt.internal.compiler.Compiler {\n\n\tTreeBuilderCompiler(INameEnvironment environment, IErrorHandlingPolicy policy, CompilerOptions options,\n\t\t\tICompilerRequestor requestor, IProblemFactory problemFactory, PrintWriter out,\n\t\t\tCompilationProgress progress) {\n\t\tsuper(environment, policy, options, requestor, problemFactory, out, progress);\n\t}\n\n\t// This code is directly inspired from Compiler class.\n\tprivate void sortModuleDeclarationsFirst(ICompilationUnit[] sourceUnits) {\n\t\tArrays.sort(sourceUnits, (u1, u2) -> {\n\t\t\tchar[] fn1 = u1.getFileName();\n\t\t\tchar[] fn2 = u2.getFileName();\n\t\t\tboolean isMod1 = CharOperation.endsWith(fn1, TypeConstants.MODULE_INFO_FILE_NAME) || CharOperation.endsWith(fn1, TypeConstants.MODULE_INFO_CLASS_NAME);\n\t\t\tboolean isMod2 = CharOperation.endsWith(fn2, TypeConstants.MODULE_INFO_FILE_NAME) || CharOperation.endsWith(fn2, TypeConstants.MODULE_INFO_CLASS_NAME);\n\t\t\tif (isMod1 == isMod2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn isMod1 ? -1 : 1;\n\t\t});\n\t}\n\n\t// this method is not meant to be in the public API\n\tprotected CompilationUnitDeclaration[] buildUnits(CompilationUnit[] sourceUnits) {\n\n\t\t// //////////////////////////////////////////////////////////////////////////\n\t\t// This code is largely inspired from JDT's\n\t\t// CompilationUnitResolver.resolve\n\n\t\tthis.reportProgress(Messages.compilation_beginningToCompile);\n\n\t\tthis.sortModuleDeclarationsFirst(sourceUnits);\n\t\t// build and record parsed units\n\t\tbeginToCompile(sourceUnits);\n\n\t\tCompilationUnitDeclaration unit;\n\t\tint i = 0;\n\n\t\t// process all units (some more could be injected in the loop by the lookup environment)\n\t\tfor (; i < this.totalUnits; i++) {\n\t\t\tunit = unitsToProcess[i];\n\t\t\tthis.reportProgress(Messages.bind(Messages.compilation_processing, new String(unit.getFileName())));\n\t\t\tthis.parser.getMethodBodies(unit);\n\n\t\t\t// fault in fields & methods\n\t\t\tif (unit.scope != null) {\n\t\t\t\tunit.scope.faultInTypes();\n\t\t\t}\n\n\t\t\t// verify inherited methods\n\t\t\tif (unit.scope != null) {\n\t\t\t\tunit.scope.verifyMethods(lookupEnvironment.methodVerifier());\n\t\t\t}\n\n\t\t\t// type checking\n\t\t\tunit.resolve();\n\t\t\t// flow analysis\n\t\t\tunit.analyseCode();\n\n\t\t\tunit.ignoreFurtherInvestigation = false;\n\t\t\trequestor.acceptResult(unit.compilationResult);\n\t\t\tthis.reportWorked(1, i);\n\t\t}\n\n\t\tArrayList<CompilationUnitDeclaration> unitsToReturn = new ArrayList<>();\n\t\tfor (CompilationUnitDeclaration cud : this.unitsToProcess) {\n\t\t\tif (cud != null) {\n\t\t\t\tunitsToReturn.add(cud);\n\t\t\t}\n\t\t}\n\t\treturn unitsToReturn.toArray(new CompilationUnitDeclaration[0]);\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/TreeBuilderRequestor.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.internal.compiler.CompilationResult;\nimport org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n\npublic class TreeBuilderRequestor implements ICompilerRequestor {\n\n\tprivate final JDTBasedSpoonCompiler jdtCompiler;\n\n\t/**\n\t * @param jdtCompiler\n\t */\n\tTreeBuilderRequestor(JDTBasedSpoonCompiler jdtCompiler) {\n\t\tthis.jdtCompiler = jdtCompiler;\n\t}\n\n\t@Override\n\tpublic void acceptResult(CompilationResult result) {\n\t\tif (result.hasErrors()) {\n\t\t\tfor (CategorizedProblem problem : result.problems) {\n\t\t\t\tthis.jdtCompiler.reportProblem(problem);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTCommentBuilder.java",
      "weight" : 460.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.apache.log4j.Logger;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * The comment builder that will insert all element of a CompilationUnitDeclaration into the Spoon AST\n */\npublic class JDTCommentBuilder {\n\n\tprivate static final Logger LOGGER = Logger.getLogger(JDTCommentBuilder.class);\n\n\tprivate final CompilationUnitDeclaration declarationUnit;\n\tprivate String filePath;\n\tprivate CompilationUnit spoonUnit;\n\tprivate Factory factory;\n\tprivate ICompilationUnit sourceUnit;\n\tprivate char[] contents;\n\n\t/**\n\t * Creates a JDTCommentBuilder that will insert all comment of the declarationUnit into the Spoon AST\n\t * @param declarationUnit the declaration unit\n\t * @param factory the Spoon AST\n\t */\n\tJDTCommentBuilder(CompilationUnitDeclaration declarationUnit,  Factory factory) {\n\t\tthis.declarationUnit = declarationUnit;\n\t\tif (declarationUnit.comments == null) {\n\t\t\treturn;\n\t\t}\n\t\tthis.factory = factory;\n\t\tthis.sourceUnit = declarationUnit.compilationResult.compilationUnit;\n\t\tthis.contents = sourceUnit.getContents();\n\t\tthis.filePath = CharOperation.charToString(sourceUnit.getFileName());\n\t\tthis.spoonUnit = JDTTreeBuilder.getOrCreateCompilationUnit(declarationUnit, factory);\n\t}\n\n\t/**\n\t * Start the build process\n\t */\n\tpublic void build() {\n\t\tif (declarationUnit.comments == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int j = 0; j < declarationUnit.comments.length; j++) {\n\t\t\tint[] positions = declarationUnit.comments[j];\n\t\t\tbuildComment(positions);\n\t\t}\n\t}\n\n\t/**\n\t * Inserts the comment at the position positions in the AST\n\t * @param positions the position of the comment\n\t */\n\tprivate void buildComment(int[] positions) {\n\t\tint start = positions[0];\n\t\tint end = -positions[1];\n\n\t\tCtComment comment;\n\n\t\t// Javadoc comments have negative end position\n\t\tif (end <= 0) {\n\t\t\tcomment = factory.Core().createJavaDoc();\n\t\t\tend = -end;\n\t\t} else {\n\t\t\tcomment = factory.Core().createComment();\n\t\t\tcomment.setCommentType(CtComment.CommentType.BLOCK);\n\n\t\t\t// the inline comments have negative start\n\t\t\tif (start < 0) {\n\t\t\t\tcomment.setCommentType(CtComment.CommentType.INLINE);\n\t\t\t\tstart = -start;\n\t\t\t}\n\t\t}\n\n\t\tcomment.setContent(getCommentContent(start, end));\n\n\t\t// set the position\n\t\tint[] lineSeparatorPositions = declarationUnit.compilationResult.lineSeparatorPositions;\n\t\tSourcePosition sourcePosition = factory.Core().createSourcePosition(spoonUnit, start, end - 1, lineSeparatorPositions);\n\t\tcomment.setPosition(sourcePosition);\n\n\t\tinsertCommentInAST(comment);\n\t}\n\n\t/**\n\t * Insert the element to nearer element in the elements collections\n\t * @param comment the comment to insert\n\t * @param elements the collection that content the ast elements\n\t * @return\n\t */\n\tprivate CtElement addCommentToNear(final CtComment comment, final Collection<CtElement> elements) {\n\t\tCtElement best = null;\n\t\tint smallDistance = Integer.MAX_VALUE;\n\n\t\tfor (CtElement element : elements) {\n\t\t\tif (element.getPosition().isValidPosition() == false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (element.isImplicit()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (element instanceof CtComment) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfinal boolean isAfter = element.getPosition().getSourceEnd() < comment.getPosition().getSourceStart();\n\t\t\tint distance = Math.abs(element.getPosition().getSourceStart() - comment.getPosition().getSourceEnd());\n\t\t\tif (isAfter) {\n\t\t\t\tdistance = Math.abs(element.getPosition().getSourceEnd() - comment.getPosition().getSourceStart());\n\t\t\t}\n\n\t\t\tint elementEndLine = element.getPosition().getEndLine();\n\t\t\tint commentLine = comment.getPosition().getLine();\n\n\t\t\tif (distance < smallDistance && (!isAfter || elementEndLine == commentLine || element instanceof CtType)) {\n\t\t\t\tbest = element;\n\t\t\t\tsmallDistance = distance;\n\t\t\t}\n\t\t}\n\t\t// adds the comment to the nearest element\n\t\tif (best != null) {\n\t\t\tbest.addComment(comment);\n\t\t}\n\t\treturn best;\n\t}\n\n\t/**\n\t * Inserts the comment into the AST.\n\t * @param comment the comment to insert\n\t */\n\tprivate void insertCommentInAST(final CtComment comment) {\n\t\tCtElement commentParent = findCommentParent(comment);\n\t\tif (commentParent == null) {\n\t\t\tFile file = spoonUnit.getFile();\n\t\t\tif (file != null && file.getName().equals(DefaultJavaPrettyPrinter.JAVA_PACKAGE_DECLARATION)) {\n\t\t\t\tspoonUnit.getDeclaredPackage().addComment(comment);\n\t\t\t} else if (file != null && file.getName().equals(DefaultJavaPrettyPrinter.JAVA_MODULE_DECLARATION)) {\n\t\t\t\tspoonUnit.getDeclaredModule().addComment(comment);\n\t\t\t} else {\n\t\t\t\tcomment.setCommentType(CtComment.CommentType.FILE);\n\t\t\t\taddCommentToNear(comment, new ArrayList<>(spoonUnit.getDeclaredTypes()));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t// visitor that inserts the comment in the element\n\t\tCtInheritanceScanner insertionVisitor = new CtInheritanceScanner() {\n\t\t\tprivate boolean isScanned = false;\n\n\t\t\t@Override\n\t\t\tpublic void scan(CtElement e) {\n\t\t\t\tif (e == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Do not visit the AST, only the first element\n\t\t\t\tif (!isScanned) {\n\t\t\t\t\tisScanned = true;\n\t\t\t\t\tSourcePosition sp = e.getPosition();\n\t\t\t\t\tif (sp.getSourceStart() == comment.getPosition().getSourceStart()) {\n\t\t\t\t\t\te.addComment(comment);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (sp instanceof DeclarationSourcePosition) {\n\t\t\t\t\t\tDeclarationSourcePosition dsp = (DeclarationSourcePosition) sp;\n\t\t\t\t\t\tif (comment.getPosition().getSourceEnd() < dsp.getModifierSourceEnd()) {\n\t\t\t\t\t\t\te.addComment(comment);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsuper.scan(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void scanCtReference(CtReference reference) {\n\t\t\t\treference.addComment(comment);\n\t\t\t\tsuper.scanCtReference(reference);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <R> void visitCtStatementList(CtStatementList e) {\n\t\t\t\taddCommentToNear(comment, new ArrayList<>(e.getStatements()));\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addStatement(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtMethod(CtMethod<T> e) {\n\t\t\t\te.addComment(comment);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtConstructor(CtConstructor<T> e) {\n\t\t\t\te.addComment(comment);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtConditional(CtConditional<T> e) {\n\t\t\t\tList<CtElement> elements = new ArrayList<>();\n\t\t\t\telements.add(e.getElseExpression());\n\t\t\t\telements.add(e.getThenExpression());\n\t\t\t\telements.add(e.getCondition());\n\t\t\t\taddCommentToNear(comment, elements);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> e) {\n\t\t\t\tList<CtElement> elements = new ArrayList<>();\n\t\t\t\telements.add(e.getLeftHandOperand());\n\t\t\t\telements.add(e.getRightHandOperand());\n\t\t\t\taddCommentToNear(comment, elements);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtClass(CtClass<T> e) {\n\t\t\t\t//all the comments located before the body brackets belongs to class\n\t\t\t\tif (comment.getPosition().getSourceEnd() < ((BodyHolderSourcePosition) e.getPosition()).getBodyStart()) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal List<CtElement> elements = new ArrayList<>();\n\t\t\t\tfor (CtTypeMember typeMember : e.getTypeMembers()) {\n\t\t\t\t\tif (typeMember instanceof CtField || typeMember instanceof CtMethod || typeMember instanceof CtConstructor) {\n\t\t\t\t\t\telements.add(typeMember);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddCommentToNear(comment, elements);\n\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtInterface(CtInterface<T> e) {\n\t\t\t\tfinal List<CtElement> elements = new ArrayList<>();\n\t\t\t\tfor (CtTypeMember typeMember : e.getTypeMembers()) {\n\t\t\t\t\tif (typeMember instanceof CtField || typeMember instanceof CtMethod) {\n\t\t\t\t\t\telements.add(typeMember);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddCommentToNear(comment, elements);\n\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void scanCtVariable(CtVariable<T> e) {\n\t\t\t\te.addComment(comment);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <E> void visitCtSwitch(CtSwitch<E> e) {\n\t\t\t\tList<CtCase<? super E>> cases = e.getCases();\n\t\t\t\tCtCase previous = null;\n\t\t\t\tfor (CtCase<? super E> ctCase : cases) {\n\t\t\t\t\tif (previous == null) {\n\t\t\t\t\t\tif (comment.getPosition().getSourceStart() < ctCase.getPosition().getSourceStart()\n\t\t\t\t\t\t\t\t&& e.getPosition().getSourceStart() < comment.getPosition().getSourceStart()) {\n\t\t\t\t\t\t\tctCase.addComment(comment);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (previous.getPosition().getSourceEnd() < comment.getPosition().getSourceStart()\n\t\t\t\t\t\t\t\t&& ctCase.getPosition().getSourceStart() > comment.getPosition().getSourceStart()) {\n\t\t\t\t\t\t\taddCommentToNear(comment, new ArrayList<>(previous.getStatements()));\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcomment.getParent();\n\t\t\t\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\t\t\t\tprevious.addStatement(comment);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprevious = ctCase;\n\t\t\t\t}\n\t\t\t\tif (previous.getPosition().getSourceEnd() < comment.getPosition().getSourceStart()) {\n\t\t\t\t\taddCommentToNear(comment, new ArrayList<>(previous.getStatements()));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcomment.getParent();\n\t\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\t\tprevious.addStatement(comment);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtIf(CtIf e) {\n\t\t\t\tCtStatement thenStatement = e.getThenStatement();\n\t\t\t\tif (thenStatement != null) {\n\t\t\t\t\tif (!(thenStatement instanceof CtBlock)) {\n\t\t\t\t\t\tif (comment.getPosition().getSourceEnd() <= thenStatement.getPosition().getSourceStart()) {\n\t\t\t\t\t\t\tthenStatement.addComment(comment);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCtStatement elseStatement = e.getElseStatement();\n\t\t\t\tif (elseStatement != null && thenStatement != null) {\n\t\t\t\t\tSourcePosition thenPosition = thenStatement.getPosition();\n\t\t\t\t\tif (!thenPosition.isValidPosition() && thenStatement instanceof CtBlock) {\n\t\t\t\t\t\tCtStatement thenExpression = ((CtBlock) thenStatement).getStatement(0);\n\t\t\t\t\t\tthenPosition = thenExpression.getPosition();\n\t\t\t\t\t}\n\t\t\t\t\tSourcePosition elsePosition = elseStatement.getPosition();\n\t\t\t\t\tif (!elsePosition.isValidPosition() && elseStatement instanceof CtBlock) {\n\t\t\t\t\t\tCtStatement elseExpression = ((CtBlock) elseStatement).getStatement(0);\n\t\t\t\t\t\telsePosition = elseExpression.getPosition();\n\t\t\t\t\t}\n\t\t\t\t\tif (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd() && comment.getPosition().getSourceEnd() < elsePosition.getSourceStart()) {\n\t\t\t\t\t\telseStatement.addComment(comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void scanCtStatement(CtStatement s) {\n\t\t\t\tif (!(s instanceof CtStatementList || s instanceof CtSwitch || s instanceof CtVariable)) {\n\t\t\t\t\ts.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtAnonymousExecutable(CtAnonymousExecutable e) {\n\t\t\t\te.addComment(comment);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtNewArray(CtNewArray<T> e) {\n\t\t\t\taddCommentToNear(comment, new ArrayList<>(e.getElements()));\n\t\t\t\ttry {\n\t\t\t\t\tcomment.getParent();\n\t\t\t\t} catch (ParentNotInitializedException ex) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtParameter(CtParameter<T> e) {\n\t\t\t\te.addComment(comment);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtCatch(CtCatch e) {\n\t\t\t\tif (comment.getPosition().getLine() <= e.getPosition().getLine()) {\n\t\t\t\t\te.addComment(comment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCtModule(CtModule module) {\n\t\t\t\taddCommentToNear(comment, new ArrayList<>(module.getModuleDirectives()));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <A extends Annotation> void visitCtAnnotation(CtAnnotation<A> e) {\n\t\t\t\taddCommentToNear(comment, new ArrayList<>(e.getValues().values()));\n\t\t\t}\n\t\t};\n\t\tinsertionVisitor.scan(commentParent);\n\n\t\t// postcondition\n\t\t// now we make sure that there is a parent\n\t\t// if there is no parent\n\t\tif (!comment.isParentInitialized()) {\n\t\t\t// that's a serious error, there is something to debug\n\t\t\tLOGGER.error(\"\\\"\" + comment + \"\\\" cannot be added into the AST, with parent \" + commentParent.getClass()\n\t\t\t\t\t+ \" at \" + commentParent.getPosition().toString()\n\t\t\t\t\t+ \", please report the bug by posting on https://github.com/INRIA/spoon/issues/2482\");\n\t\t}\n\t}\n\n\t/**\n\t * Find the parent of a comment based on the position\n\t * @param comment the comment\n\t * @return the parent of the comment\n\t */\n\tprivate CtElement findCommentParent(CtComment comment) {\n\t\tclass FindCommentParentScanner extends CtScanner {\n\t\t\tpublic CtElement commentParent;\n\n\t\t\tprivate int start;\n\t\t\tprivate int end;\n\n\t\t\tFindCommentParentScanner(int start, int end) {\n\t\t\t\tthis.start = start;\n\t\t\t\tthis.end = end;\n\t\t\t}\n\n\t\t\tprivate boolean isCommentBetweenElementPosition(CtElement element) {\n\t\t\t\treturn (element.getPosition().isValidPosition()\n\t\t\t\t\t\t&& element.getPosition().getSourceStart() <= this.start\n\t\t\t\t\t\t&& element.getPosition().getSourceEnd() >= this.end);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void scan(CtElement element) {\n\t\t\t\tif (element == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (element.isImplicit() && !(element instanceof CtBlock)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tCtElement body = getBody(element);\n\t\t\t\tif (body != null && body.getPosition().isValidPosition() == false) {\n\t\t\t\t\tbody = null;\n\t\t\t\t}\n\n\t\t\t\tboolean betweenElementPosition = this.isCommentBetweenElementPosition(element);\n\t\t\t\tboolean bodyBetweenElementPosition = (body != null) && this.isCommentBetweenElementPosition(body);\n\n\t\t\t\tif (betweenElementPosition || bodyBetweenElementPosition) {\n\t\t\t\t\tcommentParent = element;\n\t\t\t\t\telement.accept(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFindCommentParentScanner findCommentParentScanner = new FindCommentParentScanner(\n\t\t\t\tcomment.getPosition().getSourceStart(),\n\t\t\t\tcomment.getPosition().getSourceEnd());\n\n\t\tif (!spoonUnit.getDeclaredTypes().isEmpty()) {\n\t\t\tfindCommentParentScanner.scan(spoonUnit.getDeclaredTypes());\n\t\t} else if (spoonUnit.getDeclaredModuleReference() != null) {\n\t\t\tfindCommentParentScanner.scan(spoonUnit.getDeclaredModuleReference().getDeclaration());\n\t\t}\n\n\t\treturn findCommentParentScanner.commentParent;\n\t}\n\n\t/**\n\t * @param e\n\t * @return body of element or null if this element has no body\n\t */\n\tstatic CtElement getBody(CtElement e) {\n\t\tif (e instanceof CtBodyHolder) {\n\t\t\treturn ((CtBodyHolder) e).getBody();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Extract the comment from the content of the class\n\t * @param start the start position of the comment\n\t * @param end the end position of the comment\n\t * @return the content of the comment\n\t */\n\tprivate String getCommentContent(int start, int end) {\n\t\treturn new String(contents, start, end - start);\n\t}\n\n\tpublic static String cleanComment(String comment) {\n\t\tif (comment == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn cleanComment(new StringReader(comment));\n\t}\n\n\tprivate static final Pattern startCommentRE = Pattern.compile(\"^/\\\\*{1,2} ?\");\n\tprivate static final Pattern middleCommentRE = Pattern.compile(\"^[ \\t]*\\\\*? ?\");\n\tprivate static final Pattern endCommentRE = Pattern.compile(\"\\\\*/$\");\n\n\tprivate static String cleanComment(Reader comment) {\n\t\tStringBuilder ret = new StringBuilder();\n\t\ttry (BufferedReader br = new BufferedReader(comment)) {\n\t\t\tString line = br.readLine();\n\t\t\t// nothing in the first line\n\t\t\tif (line == null) {\n\t\t\t\treturn ret.toString();\n\t\t\t}\n\t\t\tboolean isLastLine = false;\n\t\t\tif (line.length() >= 2 && line.charAt(1) == '/') {\n\t\t\t\t//it is single line comment, which starts with \"//\"\n\t\t\t\tisLastLine = true;\n\t\t\t\tline = line.substring(2);\n\t\t\t} else {\n\t\t\t\t//it is potentially multiline comment, which starts with \"/*\" or \"/**\"\n\t\t\t\t//check end first\n\t\t\t\tif (line.endsWith(\"*/\") && line.length() > 3) {\n\t\t\t\t\t//it is last line\n\t\t\t\t\tline = endCommentRE.matcher(line).replaceFirst(\"\");\n\t\t\t\t\tisLastLine = true;\n\t\t\t\t}\n\t\t\t\t//skip beginning\n\t\t\t\tline = startCommentRE.matcher(line).replaceFirst(\"\");\n\t\t\t}\n\t\t\t//append first line\n\t\t\tret.append(line);\n\t\t\twhile ((line = br.readLine()) != null) {\n\t\t\t\tif (isLastLine) {\n\t\t\t\t\tthrow new SpoonException(\"Unexpected next line after last line\");\n\t\t\t\t}\n\t\t\t\tif (line.endsWith(\"*/\")) {\n\t\t\t\t\t//it is last line\n\t\t\t\t\tline = endCommentRE.matcher(line).replaceFirst(\"\");\n\t\t\t\t\tisLastLine = true;\n\t\t\t\t}\n\t\t\t\t//always clean middle comment, but after end comment is detected\n\t\t\t\tline = middleCommentRE.matcher(line).replaceFirst(\"\");\n\t\t\t\t//write next line - Note that Spoon model comment's lines are always separated by \"\\n\"\n\t\t\t\tret.append(CtComment.LINE_SEPARATOR);\n\t\t\t\tret.append(line);\n\t\t\t}\n\t\t\treturn ret.toString().trim();\n\t\t} catch (IOException e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/ASTPair.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport spoon.reflect.declaration.CtElement;\n\npublic class ASTPair {\n\tpublic CtElement element;\n\n\tpublic ASTNode node;\n\n\tpublic ASTPair(CtElement element, ASTNode node) {\n\t\tthis.element = element;\n\t\tthis.node = node;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn element.getClass().getSimpleName() + \"-\" + node.getClass().getSimpleName();\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTTreeBuilder.java",
      "weight" : 1436.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.apache.log4j.Logger;\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ASTVisitor;\nimport org.eclipse.jdt.internal.compiler.ast.AND_AND_Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayInitializer;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayReference;\nimport org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.AssertStatement;\nimport org.eclipse.jdt.internal.compiler.ast.Assignment;\nimport org.eclipse.jdt.internal.compiler.ast.BinaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Block;\nimport org.eclipse.jdt.internal.compiler.ast.BreakStatement;\nimport org.eclipse.jdt.internal.compiler.ast.CaseStatement;\nimport org.eclipse.jdt.internal.compiler.ast.CastExpression;\nimport org.eclipse.jdt.internal.compiler.ast.CharLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.CompoundAssignment;\nimport org.eclipse.jdt.internal.compiler.ast.ConditionalExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ContinueStatement;\nimport org.eclipse.jdt.internal.compiler.ast.DoStatement;\nimport org.eclipse.jdt.internal.compiler.ast.DoubleLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.EqualExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;\nimport org.eclipse.jdt.internal.compiler.ast.ExtendedStringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FalseLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.FieldReference;\nimport org.eclipse.jdt.internal.compiler.ast.FloatLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.ForStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ForeachStatement;\nimport org.eclipse.jdt.internal.compiler.ast.IfStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.Initializer;\nimport org.eclipse.jdt.internal.compiler.ast.InstanceOfExpression;\nimport org.eclipse.jdt.internal.compiler.ast.IntLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.Javadoc;\nimport org.eclipse.jdt.internal.compiler.ast.LabeledStatement;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.LongLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.MemberValuePair;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.MethodDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.NormalAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.NullLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.OR_OR_Expression;\nimport org.eclipse.jdt.internal.compiler.ast.OperatorIds;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.PostfixExpression;\nimport org.eclipse.jdt.internal.compiler.ast.PrefixExpression;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedSuperReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Receiver;\nimport org.eclipse.jdt.internal.compiler.ast.ReferenceExpression;\nimport org.eclipse.jdt.internal.compiler.ast.ReturnStatement;\nimport org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation;\nimport org.eclipse.jdt.internal.compiler.ast.SuperReference;\nimport org.eclipse.jdt.internal.compiler.ast.SwitchStatement;\nimport org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement;\nimport org.eclipse.jdt.internal.compiler.ast.ThisReference;\nimport org.eclipse.jdt.internal.compiler.ast.ThrowStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TrueLiteral;\nimport org.eclipse.jdt.internal.compiler.ast.TryStatement;\nimport org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.TypeParameter;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.UnaryExpression;\nimport org.eclipse.jdt.internal.compiler.ast.UnionTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.WhileStatement;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\nimport org.eclipse.jdt.internal.compiler.lookup.ModuleBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport spoon.SpoonException;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.UnaryOperatorKind;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.support.compiler.jdt.ContextBuilder.CastInfo;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getBinaryOperatorKind;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getModifiers;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.getUnaryOperator;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.isLhsAssignment;\n\n/**\n * A visitor for iterating through the parse tree.\n */\npublic class JDTTreeBuilder extends ASTVisitor {\n\n\tprivate final PositionBuilder position;\n\n\tprivate final ContextBuilder context;\n\n\tprivate final ParentExiter exiter;\n\n\tfinal ReferenceBuilder references;\n\n\tprivate final JDTTreeBuilderHelper helper;\n\n\tprivate final Factory factory;\n\n\tboolean skipTypeInAnnotation = false;\n\n\tpublic static Logger getLogger() {\n\t\treturn LOGGER;\n\t}\n\n\tprivate static final Logger LOGGER = Logger.getLogger(JDTTreeBuilder.class);\n\n\tpublic PositionBuilder getPositionBuilder() {\n\t\treturn position;\n\t}\n\n\tpublic ContextBuilder getContextBuilder() {\n\t\treturn context;\n\t}\n\n\tpublic ReferenceBuilder getReferencesBuilder() {\n\t\treturn references;\n\t}\n\n\tpublic JDTTreeBuilderHelper getHelper() {\n\t\treturn helper;\n\t}\n\n\tpublic ParentExiter getExiter() {\n\t\treturn exiter;\n\t}\n\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\tpublic JDTTreeBuilder(Factory factory) {\n\t\tthis.factory = factory;\n\t\tthis.position = new PositionBuilder(this);\n\t\tthis.context = new ContextBuilder(this);\n\t\tthis.exiter = new ParentExiter(this);\n\t\tthis.references = new ReferenceBuilder(this);\n\t\tthis.helper = new JDTTreeBuilderHelper(this);\n\t\tLOGGER.setLevel(factory.getEnvironment().getLevel());\n\t}\n\n\t// an abstract class here is better because the method is actually package-protected, as the type, (and not public as in the case of interface methods in Java)\n\tabstract static class OnAccessListener {\n\t\tabstract boolean onAccess(char[][] tokens, int index);\n\t}\n\n\tclass SpoonReferenceBinding extends ReferenceBinding {\n\t\tprivate ReferenceBinding enclosingType;\n\n\t\tSpoonReferenceBinding(char[] sourceName, ReferenceBinding enclosingType) {\n\t\t\tthis.sourceName = sourceName;\n\t\t\tthis.enclosingType = enclosingType;\n\t\t}\n\n\t\t@Override\n\t\tpublic ReferenceBinding enclosingType() {\n\t\t\treturn enclosingType;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(AllocationExpression allocationExpression, BlockScope scope) {\n\t\tcontext.exit(allocationExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(AND_AND_Expression and_and_Expression, BlockScope scope) {\n\t\tcontext.exit(and_and_Expression);\n\t}\n\n\t@Override\n\tpublic void endVisit(AnnotationMethodDeclaration annotationTypeDeclaration, ClassScope classScope) {\n\t\tcontext.exit(annotationTypeDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(Argument argument, BlockScope scope) {\n\t\tcontext.exit(argument);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayAllocationExpression arrayAllocationExpression, BlockScope scope) {\n\t\tcontext.exit(arrayAllocationExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayInitializer arrayInitializer, BlockScope scope) {\n\t\tcontext.exit(arrayInitializer);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayReference arrayReference, BlockScope scope) {\n\t\tcontext.exit(arrayReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayTypeReference arrayTypeReference, BlockScope scope) {\n\t\tcontext.exit(arrayTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayTypeReference arrayTypeReference, ClassScope scope) {\n\t\tcontext.exit(arrayTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, BlockScope scope) {\n\t\tcontext.exit(arrayQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, ClassScope scope) {\n\t\tcontext.exit(arrayQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(AssertStatement assertStatement, BlockScope scope) {\n\t\tcontext.exit(assertStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(Assignment assignment, BlockScope scope) {\n\t\tcontext.exit(assignment);\n\t}\n\n\t@Override\n\tpublic void endVisit(BinaryExpression binaryExpression, BlockScope scope) {\n\t\tcontext.exit(binaryExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(Block block, BlockScope scope) {\n\t\tcontext.exit(block);\n\t}\n\n\t@Override\n\tpublic void endVisit(BreakStatement breakStatement, BlockScope scope) {\n\t\tcontext.exit(breakStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(CaseStatement caseStatement, BlockScope scope) {\n\t}\n\n\t@Override\n\tpublic void endVisit(CharLiteral charLiteral, BlockScope scope) {\n\t\tcontext.exit(charLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) {\n\t\tcontext.exit(classLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(CompoundAssignment compoundAssignment, BlockScope scope) {\n\t\tcontext.exit(compoundAssignment);\n\t}\n\n\t@Override\n\tpublic void endVisit(ConditionalExpression conditionalExpression, BlockScope scope) {\n\t\tcontext.exit(conditionalExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {\n\t\tcontext.exit(constructorDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(ContinueStatement continueStatement, BlockScope scope) {\n\t\tcontext.exit(continueStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(DoStatement doStatement, BlockScope scope) {\n\t\tcontext.exit(doStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(DoubleLiteral doubleLiteral, BlockScope scope) {\n\t\tcontext.exit(doubleLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(EqualExpression equalExpression, BlockScope scope) {\n\t\tcontext.exit(equalExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(ExplicitConstructorCall explicitConstructor, BlockScope scope) {\n\t\tcontext.exit(explicitConstructor);\n\t}\n\n\t@Override\n\tpublic void endVisit(ExtendedStringLiteral extendedStringLiteral, BlockScope scope) {\n\t\tcontext.exit(extendedStringLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(FalseLiteral falseLiteral, BlockScope scope) {\n\t\tcontext.exit(falseLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(FieldDeclaration fieldDeclaration, MethodScope scope) {\n\t\tcontext.exit(fieldDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(FieldReference fieldReference, BlockScope scope) {\n\t\tcontext.exit(fieldReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(FloatLiteral floatLiteral, BlockScope scope) {\n\t\tcontext.exit(floatLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(ForeachStatement forStatement, BlockScope scope) {\n\t\tcontext.exit(forStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(ForStatement forStatement, BlockScope scope) {\n\t\tcontext.exit(forStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(IfStatement ifStatement, BlockScope scope) {\n\t\tcontext.exit(ifStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(Initializer initializer, MethodScope scope) {\n\t\tcontext.exit(initializer);\n\t}\n\n\t@Override\n\tpublic void endVisit(InstanceOfExpression instanceOfExpression, BlockScope scope) {\n\t\tcontext.exit(instanceOfExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(IntLiteral intLiteral, BlockScope scope) {\n\t\tcontext.exit(intLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(LabeledStatement labeledStatement, BlockScope scope) {\n\t\tASTPair pair = context.stack.peek();\n\t\tCtBlock<?> block = (CtBlock<?>) pair.element;\n\t\tif (block.getStatements().size() == 1) {\n\t\t\tCtStatement childStmt = block.getStatement(0);\n\t\t\tif (childStmt.getLabel() == null) {\n\t\t\t\t//the child statement has no label, so we can move label from `block` to child statement and to remove this `block`\n\t\t\t\t//example code:\n\t\t\t\t//label: while(true);\n\t\t\t\tchildStmt.setLabel(block.getLabel());\n\t\t\t\tSourcePosition oldPos = childStmt.getPosition();\n\t\t\t\tint newSourceStart = Math.min(oldPos.getSourceStart(), block.getPosition().getSourceStart());\n\t\t\t\tif (newSourceStart != oldPos.getSourceStart()) {\n\t\t\t\t\tchildStmt.setPosition(block.getFactory().Core().createSourcePosition(\n\t\t\t\t\t\t\toldPos.getCompilationUnit(),\n\t\t\t\t\t\t\tnewSourceStart, oldPos.getSourceEnd(),\n\t\t\t\t\t\t\toldPos.getCompilationUnit().getLineSeparatorPositions()));\n\t\t\t\t}\n\t\t\t\t//call exit with origin labeled statement\n\t\t\t\t//because some listeners needs origin one\n\t\t\t\t//we cannot call exit on unexpected child\n\t\t\t\tcontext.exit(labeledStatement);\n\t\t\t\t//use childStmt instead of helper block\n\t\t\t\tCtElement parent = block.getParent();\n\t\t\t\t//remember whether parent was implicit\n\t\t\t\tboolean parentIsImplicit = parent.isImplicit();\n\t\t\t\t//because replace resets CtBlock#isImplicit to false\n\t\t\t\tblock.replace(childStmt);\n\t\t\t\t//but we need to keep it as it was before\n\t\t\t\tparent.setImplicit(parentIsImplicit);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//else example code:\n\t\t//label:;\n\t\t//label1: label2: while(true);\n\t\t//needs to keep an implicit helper CtBlock as holder of `label1`\n\t\tcontext.exit(labeledStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(LocalDeclaration localDeclaration, BlockScope scope) {\n\t\tcontext.exit(localDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(LongLiteral longLiteral, BlockScope scope) {\n\t\tcontext.exit(longLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(NormalAnnotation annotation, ClassScope scope) {\n\t\tcontext.exit(annotation);\n\t\tskipTypeInAnnotation = false;\n\t}\n\n\t@Override\n\tpublic void endVisit(MarkerAnnotation annotation, ClassScope scope) {\n\t\tcontext.exit(annotation);\n\t\tskipTypeInAnnotation = false;\n\t}\n\n\t@Override\n\tpublic void endVisit(MarkerAnnotation annotation, BlockScope scope) {\n\t\tcontext.exit(annotation);\n\t\tskipTypeInAnnotation = false;\n\t}\n\n\t@Override\n\tpublic void endVisit(MemberValuePair pair, ClassScope scope) {\n\t\tif (!context.annotationValueName.pop().equals(new String(pair.name))) {\n\t\t\tthrow new RuntimeException(\"Inconsistent Stack\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(MemberValuePair pair, BlockScope scope) {\n\t\tif (!context.annotationValueName.pop().equals(new String(pair.name))) {\n\t\t\tthrow new RuntimeException(\"Inconsistent Stack\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(MessageSend messageSend, BlockScope scope) {\n\t\tcontext.exit(messageSend);\n\t}\n\n\t@Override\n\tpublic void endVisit(MethodDeclaration methodDeclaration, ClassScope scope) {\n\t\t// Exit from method and Block\n\t\tcontext.exit(methodDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(NormalAnnotation annotation, BlockScope scope) {\n\t\tcontext.exit(annotation);\n\t\tskipTypeInAnnotation = false;\n\t}\n\n\t@Override\n\tpublic void endVisit(NullLiteral nullLiteral, BlockScope scope) {\n\t\tcontext.exit(nullLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(OR_OR_Expression or_or_Expression, BlockScope scope) {\n\t\tcontext.exit(or_or_Expression);\n\t}\n\n\t@Override\n\tpublic void endVisit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, ClassScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(parameterizedQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(parameterizedQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(parameterizedSingleTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, ClassScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(parameterizedSingleTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(PostfixExpression postfixExpression, BlockScope scope) {\n\t\tcontext.exit(postfixExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(PrefixExpression prefixExpression, BlockScope scope) {\n\t\tcontext.exit(prefixExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedAllocationExpression qualifiedAllocationExpression, BlockScope scope) {\n\t\tendVisit((AllocationExpression) qualifiedAllocationExpression, scope);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedNameReference qualifiedNameReference, BlockScope scope) {\n\t\tif (context.stack.peek().node == qualifiedNameReference) {\n\t\t\tcontext.exit(qualifiedNameReference);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedThisReference qualifiedThisReference, BlockScope scope) {\n\t\tendVisit((ThisReference) qualifiedThisReference, scope);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedTypeReference qualifiedTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(qualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedTypeReference qualifiedTypeReference, ClassScope scope) {\n\t\tendVisit(qualifiedTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic void endVisit(ReturnStatement returnStatement, BlockScope scope) {\n\t\tcontext.exit(returnStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(SingleMemberAnnotation annotation, BlockScope scope) {\n\t\tif (!\"value\".equals(context.annotationValueName.pop())) {\n\t\t\tthrow new RuntimeException(\"Inconsistent Stack\");\n\t\t}\n\t\tcontext.exit(annotation);\n\t\tskipTypeInAnnotation = false;\n\t}\n\n\t@Override\n\tpublic void endVisit(SingleNameReference singleNameReference, BlockScope scope) {\n\t\tif (context.stack.peek().node == singleNameReference) {\n\t\t\tcontext.exit(singleNameReference);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(SingleTypeReference singleTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(singleTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(SingleTypeReference singleTypeReference, ClassScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\tskipTypeInAnnotation = false;\n\t\t\treturn;\n\t\t}\n\t\tcontext.exit(singleTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(StringLiteral stringLiteral, BlockScope scope) {\n\t\tcontext.exit(stringLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(StringLiteralConcatenation literal, BlockScope scope) {\n\t\tcontext.exit(literal);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedSuperReference qualifiedsuperReference, BlockScope scope) {\n\t\tcontext.exit(qualifiedsuperReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(SuperReference superReference, BlockScope scope) {\n\t\tcontext.exit(superReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(QualifiedThisReference qualifiedThisReference, ClassScope scope) {\n\t\tsuper.endVisit(qualifiedThisReference, scope);\n\t\tcontext.exit(qualifiedThisReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(ThisReference thisReference, BlockScope scope) {\n\t\tcontext.exit(thisReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(SwitchStatement switchStatement, BlockScope scope) {\n\t\tif (context.stack.peek().node instanceof CaseStatement) {\n\t\t\tcontext.exit(context.stack.peek().node);\n\t\t}\n\t\tcontext.exit(switchStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(SynchronizedStatement synchronizedStatement, BlockScope scope) {\n\t\tcontext.exit(synchronizedStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(ThrowStatement throwStatement, BlockScope scope) {\n\t\tcontext.exit(throwStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(TrueLiteral trueLiteral, BlockScope scope) {\n\t\tcontext.exit(trueLiteral);\n\t}\n\n\t@Override\n\tpublic void endVisit(TryStatement tryStatement, BlockScope scope) {\n\t\tcontext.exit(tryStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(TypeParameter typeParameter, BlockScope scope) {\n\t\tcontext.exit(typeParameter);\n\t}\n\n\t@Override\n\tpublic void endVisit(TypeParameter typeParameter, ClassScope scope) {\n\t\tcontext.exit(typeParameter);\n\t}\n\n\t@Override\n\tpublic void endVisit(TypeDeclaration localTypeDeclaration, BlockScope scope) {\n\t\tcontext.exit(localTypeDeclaration);\n\t}\n\n\t@Override\n\tpublic void endVisit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {\n\t\twhile (!context.stack.isEmpty() && context.stack.peek().node == memberTypeDeclaration) {\n\t\t\tcontext.exit(memberTypeDeclaration);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {\n\t\twhile (!context.stack.isEmpty() && context.stack.peek().node == typeDeclaration) {\n\t\t\tcontext.exit(typeDeclaration);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void endVisit(UnaryExpression unaryExpression, BlockScope scope) {\n\t\tcontext.exit(unaryExpression);\n\t}\n\n\t@Override\n\tpublic void endVisit(WhileStatement whileStatement, BlockScope scope) {\n\t\tcontext.exit(whileStatement);\n\t}\n\n\t@Override\n\tpublic void endVisit(CompilationUnitDeclaration compilationUnitDeclaration, CompilationUnitScope scope) {\n\t\tcontext.compilationunitdeclaration = null;\n\t\tcontext.compilationUnitSpoon = null;\n\t}\n\n\t@Override\n\tpublic boolean visit(Javadoc javadoc, BlockScope scope) {\n\t\t// Use a custom compiler.\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean visit(Javadoc javadoc, ClassScope scope) {\n\t\t// Use a custom compiler.\n\t\treturn false;\n\t}\n\n\tstatic CompilationUnit getOrCreateCompilationUnit(CompilationUnitDeclaration compilationUnitDeclaration, Factory factory) {\n\t\tCompilationUnit compilationUnitSpoon = factory.CompilationUnit().getOrCreate(new String(compilationUnitDeclaration.getFileName()));\n\t\tif (compilationUnitSpoon.getLineSeparatorPositions() == null) {\n\t\t\tcompilationUnitSpoon.setLineSeparatorPositions(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);\n\t\t} else if (compilationUnitSpoon.getLineSeparatorPositions() != compilationUnitDeclaration.compilationResult.lineSeparatorPositions) {\n\t\t\tthrow new SpoonException(\"Unexpected CompilationUnit lineSeparatorPositions\");\n\t\t}\n\t\treturn compilationUnitSpoon;\n\t}\n\n\t@Override\n\tpublic boolean visit(CompilationUnitDeclaration compilationUnitDeclaration, CompilationUnitScope scope) {\n\t\tcontext.compilationunitdeclaration = scope.referenceContext;\n\t\tcontext.compilationUnitSpoon = getOrCreateCompilationUnit(context.compilationunitdeclaration, getFactory());\n\t\tModuleBinding enclosingModule = scope.fPackage.enclosingModule;\n\n\t\tCtModule module;\n\t\tif (!enclosingModule.isUnnamed() && enclosingModule.shortReadableName() != null && enclosingModule.shortReadableName().length > 0) {\n\t\t\tmodule = getFactory().Module().getOrCreate(String.valueOf(enclosingModule.shortReadableName()));\n\t\t} else {\n\t\t\tmodule = getFactory().Module().getUnnamedModule();\n\t\t}\n\n\t\tcontext.compilationUnitSpoon.setDeclaredPackage(getFactory().Package().getOrCreate(CharOperation.toString(scope.currentPackageName), module));\n\t\tCtPackageDeclaration packageDeclaration = context.compilationUnitSpoon.getPackageDeclaration();\n\t\tif (packageDeclaration != null) {\n\t\t\tImportReference packageRef = compilationUnitDeclaration.currentPackage;\n\t\t\tif (packageRef != null) {\n\t\t\t\tchar[] content = context.getCompilationUnitContents();\n\t\t\t\tint declStart = packageRef.declarationSourceStart;\n\t\t\t\t//look for first comment\n\t\t\t\tint firstComment = PositionBuilder.findNextNonWhitespace(false, content, packageRef.sourceStart(), 0);\n\t\t\t\tif (firstComment < packageRef.sourceStart() && content[firstComment] == '/' && content[firstComment + 1] == '*') {\n\t\t\t\t\t//there is a `/*` or `/**`comment before package reference;\n\t\t\t\t\t//such comment is understood as compilation unit comment\n\t\t\t\t\t//all next comments belong to package declaration\n\t\t\t\t\tint commentEnd = PositionBuilder.getEndOfComment(content, packageRef.sourceStart(), firstComment);\n\t\t\t\t\tdeclStart = PositionBuilder.findNextNonWhitespace(false, content, packageRef.sourceStart(), commentEnd + 1);\n\t\t\t\t} else {\n\t\t\t\t\tdeclStart = firstComment;\n\t\t\t\t}\n\t\t\t\tpackageDeclaration.setPosition(factory.Core().createCompoundSourcePosition(\n\t\t\t\t\t\tcontext.compilationUnitSpoon, packageRef.sourceStart(), packageRef.sourceEnd(), declStart, packageRef.declarationEnd, context.compilationUnitSpoon.getLineSeparatorPositions()));\n\t\t\t\tpackageDeclaration.getReference().setPosition(factory.Core().createSourcePosition(context.compilationUnitSpoon, packageRef.sourceStart(), packageRef.sourceEnd(), context.compilationUnitSpoon.getLineSeparatorPositions()));\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@Override\n\tpublic boolean visit(ReferenceExpression referenceExpression, BlockScope blockScope) {\n\t\tcontext.enter(helper.createExecutableReferenceExpression(referenceExpression), referenceExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void endVisit(ReferenceExpression referenceExpression, BlockScope blockScope) {\n\t\tcontext.exit(referenceExpression);\n\t}\n\n\t@Override\n\tpublic boolean visit(LambdaExpression lambdaExpression, BlockScope blockScope) {\n\t\tCtLambda<?> lambda = factory.Core().createLambda();\n\t\tfinal MethodBinding methodBinding = lambdaExpression.getMethodBinding();\n\t\tif (methodBinding != null) {\n\t\t\tlambda.setSimpleName(CharOperation.charToString(methodBinding.constantPoolName()));\n\t\t}\n\t\tcontext.isBuildLambda = true;\n\t\tcontext.enter(lambda, lambdaExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void endVisit(LambdaExpression lambdaExpression, BlockScope blockScope) {\n\t\tcontext.isBuildLambda = false;\n\t\tcontext.exit(lambdaExpression);\n\t}\n\n\t@Override\n\tpublic boolean visit(AllocationExpression allocationExpression, BlockScope scope) {\n\t\tCtConstructorCall constructorCall = factory.Core().createConstructorCall();\n\t\tconstructorCall.setExecutable(references.getExecutableReference(allocationExpression));\n\t\tASTPair first = this.context.stack.getFirst();\n\n\t\t// in case of enum values the constructor call is often implicit\n\t\tif (first.element instanceof CtEnumValue) {\n\t\t\tif (allocationExpression.sourceEnd == first.node.sourceEnd) {\n\t\t\t\tconstructorCall.setImplicit(true);\n\t\t\t}\n\t\t}\n\t\tcontext.enter(constructorCall, allocationExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedAllocationExpression qualifiedAllocationExpression, BlockScope scope) {\n\t\tCtConstructorCall constructorCall;\n\t\tif (qualifiedAllocationExpression.anonymousType != null) {\n\t\t\tconstructorCall = factory.Core().createNewClass();\n\t\t} else {\n\t\t\tconstructorCall = factory.Core().createConstructorCall();\n\t\t}\n\t\tconstructorCall.setExecutable(references.getExecutableReference(qualifiedAllocationExpression));\n\t\tcontext.enter(constructorCall, qualifiedAllocationExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(AND_AND_Expression and_and_Expression, BlockScope scope) {\n\t\tCtBinaryOperator<?> op = factory.Core().createBinaryOperator();\n\t\top.setKind(getBinaryOperatorKind((and_and_Expression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT));\n\t\tcontext.enter(op, and_and_Expression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(AnnotationMethodDeclaration annotationTypeDeclaration, ClassScope classScope) {\n\t\tCtAnnotationMethod<Object> ctAnnotationMethod = factory.Core().createAnnotationMethod();\n\t\tctAnnotationMethod.setSimpleName(CharOperation.charToString(annotationTypeDeclaration.selector));\n\t\tcontext.enter(ctAnnotationMethod, annotationTypeDeclaration);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(Argument argument, BlockScope scope) {\n\t\tif (this.getContextBuilder().stack.peekFirst().element instanceof CtTry) {\n\t\t\tcontext.enter(factory.Core().createCatch(), argument);\n\t\t\treturn true;\n\t\t}\n\t\tcontext.enter(helper.createParameter(argument), argument);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayAllocationExpression arrayAllocationExpression, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createNewArray(), arrayAllocationExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayInitializer arrayInitializer, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createNewArray(), arrayInitializer);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayReference arrayReference, BlockScope scope) {\n\t\tCtArrayAccess<?, ?> a;\n\t\tif (isLhsAssignment(context, arrayReference)) {\n\t\t\ta = factory.Core().createArrayWrite();\n\t\t} else {\n\t\t\ta = factory.Core().createArrayRead();\n\t\t}\n\t\tcontext.enter(a, arrayReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayTypeReference arrayTypeReference, BlockScope scope) {\n\t\tCtTypeReference<Object> objectCtTypeReference = references.buildTypeReference(arrayTypeReference, scope);\n\t\tfinal CtTypeAccess<Object> typeAccess = factory.Code().createTypeAccess(objectCtTypeReference);\n\t\tif (typeAccess.getAccessedType() instanceof CtArrayTypeReference) {\n\t\t\t((CtArrayTypeReference) typeAccess.getAccessedType()).getArrayType().setAnnotations(this.references.buildTypeReference(arrayTypeReference, scope).getAnnotations());\n\t\t}\n\t\tcontext.enter(typeAccess, arrayTypeReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayTypeReference arrayTypeReference, ClassScope scope) {\n\t\treturn visit(arrayTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, BlockScope scope) {\n\t\tfinal CtTypeAccess<Object> typeAccess = factory.Core().createTypeAccess();\n\n\t\tcontext.enter(typeAccess, arrayQualifiedTypeReference);\n\n\t\tfinal CtArrayTypeReference<Object> arrayType = (CtArrayTypeReference<Object>) references.getTypeReference(arrayQualifiedTypeReference.resolvedType);\n\t\tarrayType.getArrayType().setAnnotations(this.references.buildTypeReference(arrayQualifiedTypeReference, scope).getAnnotations());\n\t\ttypeAccess.setAccessedType(arrayType);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ArrayQualifiedTypeReference arrayQualifiedTypeReference, ClassScope scope) {\n\t\treturn visit(arrayQualifiedTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(AssertStatement assertStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createAssert(), assertStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(Assignment assignment, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createAssignment(), assignment);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(CompoundAssignment compoundAssignment, BlockScope scope) {\n\t\tCtOperatorAssignment<Object, Object> a = factory.Core().createOperatorAssignment();\n\t\ta.setKind(getBinaryOperatorKind(compoundAssignment.operator));\n\t\tcontext.enter(a, compoundAssignment);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(BinaryExpression binaryExpression, BlockScope scope) {\n\t\tCtBinaryOperator<?> op = factory.Core().createBinaryOperator();\n\t\top.setKind(getBinaryOperatorKind((binaryExpression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT));\n\t\tcontext.enter(op, binaryExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(Block block, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createBlock(), block);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(BreakStatement breakStatement, BlockScope scope) {\n\t\tCtBreak b = factory.Core().createBreak();\n\t\tif (breakStatement.label != null) {\n\t\t\tb.setTargetLabel(new String(breakStatement.label));\n\t\t}\n\t\tcontext.enter(b, breakStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(CastExpression castExpression, BlockScope scope) {\n\t\tCastInfo ci = new CastInfo();\n\t\t//the 8 bits from 21 to 28 represents number of enclosing brackets\n\t\tci.nrOfBrackets = ((castExpression.bits >>> 21) & 0xF);\n\t\tci.typeRef = this.references.buildTypeReference(castExpression.type, scope, true);\n\t\tcontext.casts.add(ci);\n\t\tcastExpression.expression.traverse(this, scope);\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean visit(CharLiteral charLiteral, BlockScope scope) {\n\t\tcharLiteral.computeConstant();\n\t\tcontext.enter(factory.Code().createLiteral(charLiteral.constant.charValue()), charLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ClassLiteralAccess classLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createClassAccess(references.getTypeReference(classLiteral.targetType)), classLiteral);\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean visit(ConditionalExpression conditionalExpression, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createConditional(), conditionalExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {\n\t\tCtMethod<Object> m = factory.Core().createMethod();\n\t\tm.setSimpleName(CharOperation.charToString(methodDeclaration.selector));\n\n\t\tif (methodDeclaration.binding != null) {\n\t\t\tm.setExtendedModifiers(getModifiers(methodDeclaration.binding.modifiers, true, true));\n\t\t}\n\n\t\tfor (CtExtendedModifier extendedModifier : getModifiers(methodDeclaration.modifiers, false, true)) {\n\t\t\tm.addModifier(extendedModifier.getKind()); // avoid to keep implicit AND explicit modifier of the same kind.\n\t\t}\n\t\tm.setDefaultMethod(methodDeclaration.isDefaultMethod());\n\n\t\tcontext.enter(m, methodDeclaration);\n\n\t\t// Create block\n\t\tif (!methodDeclaration.isAbstract() && (methodDeclaration.modifiers & ClassFileConstants.AccNative) == 0) {\n\t\t\tcontext.enter(getFactory().Core().createBlock(), methodDeclaration);\n\t\t\tcontext.exit(methodDeclaration);\n\t\t}\n\n\t\t// We consider the receiver as a standard argument (i.e. as a parameter)\n\t\tReceiver receiver = methodDeclaration.receiver;\n\t\tif (receiver != null) {\n\t\t\treceiver.traverse(this, methodDeclaration.scope);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {\n\t\tCtConstructor<Object> c = factory.Core().createConstructor();\n\t\t// if the source start of the class is equals to the source start of the constructor\n\t\t// it means that the constructor is implicit.\n\t\tc.setImplicit(scope.referenceContext.sourceStart() == constructorDeclaration.sourceStart());\n\t\tif (constructorDeclaration.binding != null) {\n\t\t\tc.setExtendedModifiers(getModifiers(constructorDeclaration.binding.modifiers, true, true));\n\t\t}\n\t\t// avoid to add explicit modifier to implicit constructor\n\t\tif (!c.isImplicit()) {\n\t\t\tfor (CtExtendedModifier extendedModifier : getModifiers(constructorDeclaration.modifiers, false, true)) {\n\t\t\t\tc.addModifier(extendedModifier.getKind()); // avoid to keep implicit AND explicit modifier of the same kind.\n\t\t\t}\n\t\t}\n\t\tcontext.enter(c, constructorDeclaration);\n\n\t\t// Create block\n\t\tcontext.enter(factory.Core().createBlock(), constructorDeclaration);\n\t\tcontext.exit(constructorDeclaration);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TypeParameter typeParameter, ClassScope scope) {\n\t\treturn visitTypeParameter(typeParameter, scope);\n\t}\n\n\t@Override\n\tpublic boolean visit(TypeParameter typeParameter, BlockScope scope) {\n\t\treturn visitTypeParameter(typeParameter, scope);\n\t}\n\n\tprivate boolean visitTypeParameter(TypeParameter typeParameter, Scope scope) {\n\t\tfinal CtTypeParameter typeParameterRef = factory.Core().createTypeParameter();\n\t\ttypeParameterRef.setSimpleName(CharOperation.charToString(typeParameter.name));\n\t\tcontext.enter(typeParameterRef, typeParameter);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ContinueStatement continueStatement, BlockScope scope) {\n\t\tCtContinue c = factory.Core().createContinue();\n\t\tcontext.enter(c, continueStatement);\n\t\tif (continueStatement.label != null) {\n\t\t\tc.setTargetLabel(new String(continueStatement.label));\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(DoStatement doStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createDo(), doStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(DoubleLiteral doubleLiteral, BlockScope scope) {\n\t\tdoubleLiteral.computeConstant();\n\t\tcontext.enter(factory.Code().createLiteral(doubleLiteral.constant.doubleValue()), doubleLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(EqualExpression equalExpression, BlockScope scope) {\n\t\tCtBinaryOperator<?> op = factory.Core().createBinaryOperator();\n\t\top.setKind(getBinaryOperatorKind((equalExpression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT));\n\t\tcontext.enter(op, equalExpression);\n\t\treturn true; // do nothing by default, keep traversing\n\t}\n\n\t@Override\n\tpublic boolean visit(ExplicitConstructorCall explicitConstructor, BlockScope scope) {\n\t\tCtInvocation<Object> inv = factory.Core().createInvocation();\n\t\tinv.setImplicit(explicitConstructor.isImplicitSuper());\n\t\tinv.setExecutable(references.getExecutableReference(explicitConstructor.binding));\n\t\tCtTypeReference<?> declaringType = inv.getExecutable().getDeclaringType();\n\t\tinv.getExecutable().setType(declaringType == null ? null : (CtTypeReference<Object>) declaringType.clone());\n\t\tcontext.enter(inv, explicitConstructor);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ExtendedStringLiteral extendedStringLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createLiteral(CharOperation.charToString(extendedStringLiteral.source())), extendedStringLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(FalseLiteral falseLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createLiteral(false), falseLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(FieldDeclaration fieldDeclaration, MethodScope scope) {\n\t\tCtField<Object> field;\n\t\tif (fieldDeclaration.type != null) {\n\t\t\tfield = factory.Core().createField();\n\t\t} else {\n\t\t\tfield = factory.Core().createEnumValue();\n\t\t\tif (fieldDeclaration.binding != null) {\n\t\t\t\tfield.setType(references.getTypeReference(fieldDeclaration.binding.type));\n\t\t\t}\n\t\t}\n\t\tfield.setSimpleName(CharOperation.charToString(fieldDeclaration.name));\n\t\tif (fieldDeclaration.binding != null) {\n\t\t\tif (fieldDeclaration.binding.declaringClass != null\n\t\t\t\t&& fieldDeclaration.binding.declaringClass.isEnum()\n\t\t\t\t&& field instanceof CtEnumValue) {\n\t\t\t\t//enum values take over visibility from enum type\n\t\t\t\t//JDT compiler has a bug that enum values are always public static final, even for private enum\n\t\t\t\tfield.setExtendedModifiers(getModifiers(fieldDeclaration.binding.declaringClass.modifiers, true, false));\n\t\t\t} else {\n\t\t\t\tfield.setExtendedModifiers(getModifiers(fieldDeclaration.binding.modifiers, true, false));\n\t\t\t}\n\t\t}\n\t\tfor (CtExtendedModifier extendedModifier : getModifiers(fieldDeclaration.modifiers, false, false)) {\n\t\t\tfield.addModifier(extendedModifier.getKind()); // avoid to keep implicit AND explicit modifier of the same kind.\n\t\t}\n\n\t\tcontext.enter(field, fieldDeclaration);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(FieldReference fieldReference, BlockScope scope) {\n\t\tcontext.enter(helper.createFieldAccess(fieldReference), fieldReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(FloatLiteral floatLiteral, BlockScope scope) {\n\t\tfloatLiteral.computeConstant();\n\t\tcontext.enter(factory.Code().createLiteral(floatLiteral.constant.floatValue()), floatLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ForeachStatement forStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createForEach(), forStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ForStatement forStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createFor(), forStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(IfStatement ifStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createIf(), ifStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(Initializer initializer, MethodScope scope) {\n\t\tCtAnonymousExecutable b = factory.Core().createAnonymousExecutable();\n\t\tif (initializer.isStatic()) {\n\t\t\tb.addModifier(ModifierKind.STATIC);\n\t\t}\n\t\tcontext.enter(b, initializer);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(InstanceOfExpression instanceOfExpression, BlockScope scope) {\n\t\tCtBinaryOperator<?> op = factory.Core().createBinaryOperator();\n\t\top.setKind(BinaryOperatorKind.INSTANCEOF);\n\t\tcontext.enter(op, instanceOfExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(IntLiteral intLiteral, BlockScope scope) {\n\t\tintLiteral.computeConstant();\n\t\tCtLiteral<Integer> l = factory.Code().createLiteral(intLiteral.constant.intValue());\n\t\tcontext.enter(l, intLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(LabeledStatement labeledStatement, BlockScope scope) {\n\t\t/*\n\t\t * Create helper implicit block which holds label until child statement node is available\n\t\t */\n\t\tCtBlock<?> block = factory.Core().createBlock();\n\t\tblock.setLabel(new String(labeledStatement.label));\n\t\tcontext.enter(block, labeledStatement);\n\t\t//set implicit after position is build, so we know the position of the label\n\t\tblock.setImplicit(true);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(LocalDeclaration localDeclaration, BlockScope scope) {\n\t\tCtLocalVariable<Object> v = factory.Core().createLocalVariable();\n\n\t\tboolean isVar = localDeclaration.type.isTypeNameVar(scope);\n\n\t\tif (isVar) {\n\t\t\tv.setInferred(true);\n\t\t}\n\t\tv.setSimpleName(CharOperation.charToString(localDeclaration.name));\n\t\tif (localDeclaration.binding != null) {\n\t\t\tv.setExtendedModifiers(getModifiers(localDeclaration.binding.modifiers, true, false));\n\t\t}\n\t\tfor (CtExtendedModifier extendedModifier : getModifiers(localDeclaration.modifiers, false, false)) {\n\t\t\tv.addModifier(extendedModifier.getKind()); // avoid to keep implicit AND explicit modifier of the same kind.\n\t\t}\n\n\t\tcontext.enter(v, localDeclaration);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(LongLiteral longLiteral, BlockScope scope) {\n\t\tlongLiteral.computeConstant();\n\t\tcontext.enter(factory.Code().createLiteral(longLiteral.constant.longValue()), longLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(NormalAnnotation annotation, ClassScope scope) {\n\t\treturn visitNormalAnnotation(annotation, scope);\n\t}\n\n\t@Override\n\tpublic boolean visit(NormalAnnotation annotation, BlockScope scope) {\n\t\treturn visitNormalAnnotation(annotation, scope);\n\t}\n\n\t@Override\n\tpublic boolean visit(MarkerAnnotation annotation, ClassScope scope) {\n\t\treturn visitMarkerAnnotation(annotation, scope);\n\t}\n\n\t@Override\n\tpublic boolean visit(MarkerAnnotation annotation, BlockScope scope) {\n\t\treturn visitMarkerAnnotation(annotation, scope);\n\t}\n\n\t@Override\n\tpublic boolean visit(SingleMemberAnnotation annotation, BlockScope scope) {\n\t\tvisitMarkerAnnotation(annotation, scope);\n\t\tcontext.annotationValueName.push(\"value\");\n\t\treturn true;\n\t}\n\n\tprivate <A extends java.lang.annotation.Annotation> boolean visitNormalAnnotation(NormalAnnotation annotation, Scope scope) {\n\t\tcontext.enter(factory.Code().createAnnotation(references.<A>getTypeReference(annotation.resolvedType)), annotation);\n\t\tskipTypeInAnnotation = true;\n\t\treturn true;\n\t}\n\n\tprivate <A extends java.lang.annotation.Annotation> boolean visitMarkerAnnotation(Annotation annotation, Scope scope) {\n\t\tcontext.enter(factory.Code().createAnnotation(references.<A>getTypeReference(annotation.resolvedType, annotation.type)), annotation);\n\t\tskipTypeInAnnotation = true;\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(MemberValuePair pair, ClassScope scope) {\n\t\tcontext.annotationValueName.push(new String(pair.name));\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(MemberValuePair pair, BlockScope scope) {\n\t\tcontext.annotationValueName.push(new String(pair.name));\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(MessageSend messageSend, BlockScope scope) {\n\t\tCtInvocation<Object> inv = factory.Core().createInvocation();\n\t\tinv.setExecutable(references.getExecutableReference(messageSend));\n\t\tif (messageSend.binding instanceof ProblemMethodBinding) {\n\t\t\t// We are in a static complex in noclasspath mode.\n\t\t\tif (inv.getExecutable() != null && inv.getExecutable().getDeclaringType() != null) {\n\t\t\t\tinv.setTarget(factory.Code().createTypeAccess(inv.getExecutable().getDeclaringType(), inv.getExecutable().getDeclaringType().isAnonymous()));\n\t\t\t}\n\t\t\tif (messageSend.expectedType() != null) {\n\t\t\t\tinv.getExecutable().setType(references.getTypeReference(messageSend.expectedType()));\n\t\t\t}\n\t\t}\n\t\tcontext.enter(inv, messageSend);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(NullLiteral nullLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createLiteral(null), nullLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(OR_OR_Expression or_or_Expression, BlockScope scope) {\n\t\tCtBinaryOperator<?> op = factory.Core().createBinaryOperator();\n\t\top.setKind(getBinaryOperatorKind((or_or_Expression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT));\n\t\tcontext.enter(op, or_or_Expression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, BlockScope scope) {\n\t\treturn createParameterizedType(parameterizedQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic boolean visit(ParameterizedQualifiedTypeReference parameterizedQualifiedTypeReference, ClassScope scope) {\n\t\treturn createParameterizedType(parameterizedQualifiedTypeReference);\n\t}\n\n\t@Override\n\tpublic boolean visit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, BlockScope scope) {\n\t\treturn createParameterizedType(parameterizedSingleTypeReference);\n\t}\n\n\t@Override\n\tpublic boolean visit(ParameterizedSingleTypeReference parameterizedSingleTypeReference, ClassScope scope) {\n\t\treturn createParameterizedType(parameterizedSingleTypeReference);\n\t}\n\n\tprivate boolean createParameterizedType(TypeReference parameterizedTypeReference) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\treturn true;\n\t\t}\n\t\tCtTypeReference typeReference = references.buildTypeReference(parameterizedTypeReference, null);\n\t\tCtTypeAccess typeAccess = factory.Code().createTypeAccessWithoutCloningReference(typeReference);\n\t\tcontext.enter(typeAccess, parameterizedTypeReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(PostfixExpression postfixExpression, BlockScope scope) {\n\t\tCtUnaryOperator<?> op = factory.Core().createUnaryOperator();\n\t\tif (postfixExpression.operator == OperatorIds.PLUS) {\n\t\t\top.setKind(UnaryOperatorKind.POSTINC);\n\t\t}\n\t\tif (postfixExpression.operator == OperatorIds.MINUS) {\n\t\t\top.setKind(UnaryOperatorKind.POSTDEC);\n\t\t}\n\t\tcontext.enter(op, postfixExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(PrefixExpression prefixExpression, BlockScope scope) {\n\t\tCtUnaryOperator<?> op = factory.Core().createUnaryOperator();\n\t\tif (prefixExpression.operator == OperatorIds.PLUS) {\n\t\t\top.setKind(UnaryOperatorKind.PREINC);\n\t\t}\n\t\tif (prefixExpression.operator == OperatorIds.MINUS) {\n\t\t\top.setKind(UnaryOperatorKind.PREDEC);\n\t\t}\n\t\tcontext.enter(op, prefixExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedNameReference qualifiedNameRef, BlockScope scope) {\n\t\tif (qualifiedNameRef.binding instanceof FieldBinding || qualifiedNameRef.binding instanceof VariableBinding) {\n\t\t\tcontext.enter(helper.createVariableAccess(qualifiedNameRef), qualifiedNameRef);\n\t\t\treturn true;\n\t\t} else if (qualifiedNameRef.binding instanceof TypeBinding) {\n\t\t\tcontext.enter(factory.Code().createTypeAccessWithoutCloningReference(references.getTypeReference((TypeBinding) qualifiedNameRef.binding)), qualifiedNameRef);\n\t\t\treturn true;\n\t\t} else if (qualifiedNameRef.binding instanceof ProblemBinding) {\n\t\t\tif (context.stack.peek().element instanceof CtInvocation) {\n\t\t\t\tcontext.enter(helper.createTypeAccessNoClasspath(qualifiedNameRef), qualifiedNameRef);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcontext.enter(helper.createFieldAccessNoClasspath(qualifiedNameRef), qualifiedNameRef);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tcontext.enter(\n\t\t\t\t\thelper.createVariableAccess(\n\t\t\t\t\t\t\tfactory.Core().createUnboundVariableReference().<CtUnboundVariableReference>setSimpleName(qualifiedNameRef.toString()),\n\t\t\t\t\t\t\tisLhsAssignment(context, qualifiedNameRef)),\n\t\t\t\t\tqualifiedNameRef\n\t\t\t);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedTypeReference qualifiedTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\treturn true;\n\t\t}\n\t\tif (context.stack.peekFirst().node instanceof UnionTypeReference) {\n\t\t\tCtTypeReference<Throwable> reference = references.<Throwable>getTypeReference(qualifiedTypeReference.resolvedType);\n\t\t\tif (reference == null) {\n\t\t\t\treference = getFactory().createReference(qualifiedTypeReference.toString());\n\t\t\t}\n\t\t\tcontext.enter(reference, qualifiedTypeReference);\n\t\t\treturn true;\n\t\t} else if (context.stack.peekFirst().element instanceof CtCatch) {\n\t\t\tcontext.enter(helper.createCatchVariable(qualifiedTypeReference), qualifiedTypeReference);\n\t\t\treturn true;\n\t\t}\n\t\tcontext.enter(factory.Code().createTypeAccessWithoutCloningReference(references.buildTypeReference(qualifiedTypeReference, scope)), qualifiedTypeReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedTypeReference qualifiedTypeReference, ClassScope scope) {\n\t\treturn visit(qualifiedTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(ReturnStatement returnStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createReturn(), returnStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(SingleNameReference singleNameReference, BlockScope scope) {\n\t\tif (singleNameReference.binding instanceof FieldBinding) {\n\t\t\tcontext.enter(helper.createFieldAccess(singleNameReference), singleNameReference);\n\t\t} else if (singleNameReference.binding instanceof VariableBinding) {\n\t\t\tcontext.enter(helper.createVariableAccess(singleNameReference), singleNameReference);\n\t\t} else if (singleNameReference.binding instanceof TypeBinding) {\n\t\t\tcontext.enter(factory.Code().createTypeAccessWithoutCloningReference(references.getTypeReference((TypeBinding) singleNameReference.binding)), singleNameReference);\n\t\t} else if (singleNameReference.binding instanceof ProblemBinding) {\n\t\t\tif (context.stack.peek().element instanceof CtInvocation && Character.isUpperCase(CharOperation.charToString(singleNameReference.token).charAt(0))) {\n\t\t\t\tcontext.enter(helper.createTypeAccessNoClasspath(singleNameReference), singleNameReference);\n\t\t\t} else {\n\t\t\t\tcontext.enter(helper.createFieldAccessNoClasspath(singleNameReference), singleNameReference);\n\t\t\t}\n\t\t} else if (singleNameReference.binding == null) {\n\t\t\tCtExpression access = helper.createVariableAccessNoClasspath(singleNameReference);\n\t\t\tif (access == null) {\n\t\t\t\taccess = helper.createTypeAccessNoClasspath(singleNameReference);\n\t\t\t}\n\t\t\tcontext.enter(access, singleNameReference);\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedSuperReference qualifiedSuperReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\treturn true;\n\t\t}\n\t\tcontext.enter(factory.Core().createSuperAccess(), qualifiedSuperReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(SuperReference superReference, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createSuperAccess(), superReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(QualifiedThisReference qualifiedThisRef, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createThisAccess(references.getTypeReference(qualifiedThisRef.qualification.resolvedType), qualifiedThisRef.isImplicitThis()), qualifiedThisRef);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ThisReference thisReference, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createThisAccess(references.getTypeReference(thisReference.resolvedType), thisReference.isImplicitThis()), thisReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void endVisit(UnionTypeReference unionTypeReference, BlockScope scope) {\n\t\tcontext.exit(unionTypeReference);\n\t}\n\n\t@Override\n\tpublic void endVisit(UnionTypeReference unionTypeReference, ClassScope scope) {\n\t\tendVisit(unionTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(UnionTypeReference unionTypeReference, BlockScope scope) {\n\t\tif (!(context.stack.peekFirst().node instanceof Argument)) {\n\t\t\tthrow new SpoonException(\"UnionType is only supported for CtCatch.\");\n\t\t}\n\t\tcontext.enter(helper.createCatchVariable(unionTypeReference), unionTypeReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(UnionTypeReference unionTypeReference, ClassScope scope) {\n\t\treturn visit(unionTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(SingleTypeReference singleTypeReference, BlockScope scope) {\n\t\tif (skipTypeInAnnotation) {\n\t\t\treturn true;\n\t\t}\n\t\tif (context.stack.peekFirst().node instanceof UnionTypeReference) {\n\t\t\tif (singleTypeReference.resolvedType == null) {\n\t\t\t\tCtTypeReference typeReference = factory.Type().createReference(singleTypeReference.toString());\n\t\t\t\tCtReference ref = references.getDeclaringReferenceFromImports(singleTypeReference.getLastToken());\n\t\t\t\treferences.setPackageOrDeclaringType(typeReference, ref);\n\t\t\t\tcontext.enter(typeReference, singleTypeReference);\n\t\t\t} else {\n\t\t\t\tcontext.enter(references.<Throwable>getTypeReference(singleTypeReference.resolvedType), singleTypeReference);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} else if (context.stack.peekFirst().element instanceof CtCatch) {\n\t\t\tcontext.enter(helper.createCatchVariable(singleTypeReference), singleTypeReference);\n\t\t\treturn true;\n\t\t}\n\t\tcontext.enter(factory.Code().createTypeAccessWithoutCloningReference(references.buildTypeReference(singleTypeReference, scope)), singleTypeReference);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(SingleTypeReference singleTypeReference, ClassScope scope) {\n\t\treturn visit(singleTypeReference, (BlockScope) null);\n\t}\n\n\t@Override\n\tpublic boolean visit(StringLiteral stringLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createLiteral(CharOperation.charToString(stringLiteral.source())), stringLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(StringLiteralConcatenation literal, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createBinaryOperator().<CtBinaryOperator>setKind(BinaryOperatorKind.PLUS), literal);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(CaseStatement caseStatement, BlockScope scope) {\n\t\tif (context.stack.peek().node instanceof CaseStatement) {\n\t\t\tcontext.exit(context.stack.peek().node);\n\t\t}\n\n\t\tcontext.enter(factory.Core().createCase(), caseStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(SwitchStatement switchStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createSwitch(), switchStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(SynchronizedStatement synchronizedStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createSynchronized(), synchronizedStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ThrowStatement throwStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createThrow(), throwStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TrueLiteral trueLiteral, BlockScope scope) {\n\t\tcontext.enter(factory.Code().createLiteral(true), trueLiteral);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TryStatement tryStatement, BlockScope scope) {\n\t\tCtTry t;\n\t\tif (tryStatement.resources.length > 0) {\n\t\t\tt = factory.Core().createTryWithResource();\n\t\t} else {\n\t\t\tt = factory.Core().createTry();\n\t\t}\n\t\tcontext.enter(t, tryStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {\n\t\tCtType<?> t;\n\t\tif (localTypeDeclaration.binding == null) {\n\t\t\t// no classpath mode but JDT returns nothing. We create an empty class.\n\t\t\tt = factory.Core().createClass();\n\t\t\tt.setSimpleName(CtType.NAME_UNKNOWN);\n\t\t\t((CtClass) t).setSuperclass(references.getTypeReference(null, localTypeDeclaration.allocation.type));\n\t\t\tcontext.enter(t, localTypeDeclaration);\n\t\t} else {\n\t\t\thelper.createType(localTypeDeclaration);\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TypeDeclaration memberTypeDeclaration, ClassScope scope) {\n\t\thelper.createType(memberTypeDeclaration);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {\n\t\tif (\"package-info\".equals(new String(typeDeclaration.name))) {\n\t\t\tcontext.enter(factory.Package().getOrCreate(new String(typeDeclaration.binding.fPackage.readableName())), typeDeclaration);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tCtModule module;\n\t\t\t// skip the type declaration that are already declared\n\t\t\tif (typeDeclaration.binding == null && getFactory().getEnvironment().isIgnoreDuplicateDeclarations()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (typeDeclaration.binding.module != null && !typeDeclaration.binding.module.isUnnamed() && typeDeclaration.binding.module.shortReadableName() != null && typeDeclaration.binding.module.shortReadableName().length > 0) {\n\t\t\t\tmodule = factory.Module().getOrCreate(String.valueOf(typeDeclaration.binding.module.shortReadableName()));\n\t\t\t} else {\n\t\t\t\tmodule = factory.Module().getUnnamedModule();\n\t\t\t}\n\n\t\t\tCtPackage pack;\n\t\t\tif (typeDeclaration.binding.fPackage.shortReadableName() != null && typeDeclaration.binding.fPackage.shortReadableName().length > 0) {\n\t\t\t\tpack = factory.Package().getOrCreate(new String(typeDeclaration.binding.fPackage.shortReadableName()), module);\n\t\t\t} else {\n\t\t\t\tpack = module.getRootPackage();\n\t\t\t}\n\t\t\tcontext.enter(pack, typeDeclaration);\n\t\t\tpack.addType(helper.createType(typeDeclaration));\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean visit(UnaryExpression unaryExpression, BlockScope scope) {\n\t\tCtUnaryOperator<?> op = factory.Core().createUnaryOperator();\n\t\top.setKind(getUnaryOperator((unaryExpression.bits & ASTNode.OperatorMASK) >> ASTNode.OperatorSHIFT));\n\t\tcontext.enter(op, unaryExpression);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(WhileStatement whileStatement, BlockScope scope) {\n\t\tcontext.enter(factory.Core().createWhile(), whileStatement);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean visit(ModuleDeclaration moduleDeclaration, CompilationUnitScope scope) {\n\t\tCtModule module = getHelper().createModule(moduleDeclaration);\n\t\tcontext.compilationUnitSpoon.setDeclaredModule(module);\n\t\treturn true;\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/JDTBasedSpoonCompiler.java",
      "weight" : 508.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.log4j.Level;\nimport org.eclipse.jdt.core.compiler.CategorizedProblem;\nimport org.eclipse.jdt.core.compiler.IProblem;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.env.INameEnvironment;\nimport spoon.Launcher;\nimport spoon.OutputType;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.compiler.ModelBuildingException;\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\nimport spoon.compiler.SpoonResource;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.compiler.builder.AdvancedOptions;\nimport spoon.compiler.builder.AnnotationProcessingOptions;\nimport spoon.compiler.builder.ClasspathOptions;\nimport spoon.compiler.builder.ComplianceOptions;\nimport spoon.compiler.builder.JDTBuilder;\nimport spoon.compiler.builder.JDTBuilderImpl;\nimport spoon.compiler.builder.SourceOptions;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.AstParentConsistencyChecker;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.reflect.visitor.Query;\nimport spoon.support.sniper.SniperJavaPrettyPrinter;\nimport spoon.support.QueueProcessingManager;\nimport spoon.support.comparator.FixedOrderBasedOnFileNameCompilationUnitComparator;\nimport spoon.support.compiler.SpoonProgress;\nimport spoon.support.compiler.VirtualFolder;\nimport spoon.support.modelobs.SourceFragmentCreator;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\n\n/**\n * Main class of Spoon to build the model.\n * Highly depends on {@link JDTBatchCompiler} for performing the job.\n */\npublic class JDTBasedSpoonCompiler implements spoon.SpoonModelBuilder {\n\tprotected INameEnvironment environment = null;\n\tprotected final List<CategorizedProblem> probs = new ArrayList<>();\n\tprotected final TreeBuilderRequestor requestor = new TreeBuilderRequestor(this);\n\tprotected Factory factory;\n\tprotected int javaCompliance = 7;\n\t//list of java files or folders with java files which represents source of the CtModel\n\tprotected SpoonFolder sources = new VirtualFolder();\n\t//list of java files or folders with java files which represents templates. Templates are added to CtModel too.\n\tprotected SpoonFolder templates = new VirtualFolder();\n\t//The classpath used to build templates\n\tprotected String[] templateClasspath = new String[0];\n\tprotected List<CompilationUnitFilter> compilationUnitFilters = new ArrayList<>();\n\tprivate boolean sortList;\n\n\t/**\n\t * Default constructor\n\t */\n\tpublic JDTBasedSpoonCompiler(Factory factory) {\n\t\tthis.factory = factory;\n\t\tthis.initializeCUCOmparator();\n\t}\n\n\tprivate void initializeCUCOmparator() {\n\t\tthis.sortList = System.getenv(\"SPOON_SEED_CU_COMPARATOR\") == null;\n\t}\n\n\t@Override\n\tpublic boolean build() {\n\t\treturn build(null);\n\t}\n\n\t@Override\n\tpublic boolean build(JDTBuilder builder) {\n\t\tif (factory == null) {\n\t\t\tthrow new SpoonException(\"Factory not initialized\");\n\t\t}\n\t\tif (factory.getModel() != null && factory.getModel().isBuildModelFinished()) {\n\t\t\tthrow new SpoonException(\"Model already built\");\n\t\t}\n\n\t\tboolean srcSuccess;\n\t\tboolean templateSuccess;\n\t\tfactory.getEnvironment().debugMessage(\"building sources: \" + sources.getAllJavaFiles());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\t\tsrcSuccess = buildSources(builder);\n\n\t\treportProblems(factory.getEnvironment());\n\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\tfactory.getEnvironment().debugMessage(\"building templates: \" + templates.getAllJavaFiles());\n\t\tt = System.currentTimeMillis();\n\t\ttemplateSuccess = buildTemplates(builder);\n\t\tfactory.getEnvironment().debugMessage(\"built in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\tcheckModel();\n\t\tfactory.getModel().setBuildModelIsFinished(true);\n\n\t\tif (factory.getEnvironment().createPrettyPrinter() instanceof SniperJavaPrettyPrinter) {\n\t\t\t//setup a model change collector\n\t\t\tnew SourceFragmentCreator().attachTo(factory.getEnvironment());\n\t\t}\n\n\t\treturn srcSuccess && templateSuccess;\n\t}\n\n\tprivate void checkModel() {\n\t\tif (!factory.getEnvironment().checksAreSkipped()) {\n\t\t\tfactory.getModel().getUnnamedModule().accept(new AstParentConsistencyChecker());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean compile(InputType... types) {\n\t\tfactory.getEnvironment().debugMessage(\"compiling sources: \" + factory.CompilationUnit().getMap().keySet());\n\t\tlong t = System.currentTimeMillis();\n\t\tjavaCompliance = factory.getEnvironment().getComplianceLevel();\n\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler(types);\n\n\n\t\tfinal String[] args = new JDTBuilderImpl() //\n\t\t\t\t.classpathOptions(new ClasspathOptions().encoding(this.getEnvironment().getEncoding().displayName()).classpath(getSourceClasspath()).binaries(getBinaryOutputDirectory())) //\n\t\t\t\t.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //\n\t\t\t\t.annotationProcessingOptions(new AnnotationProcessingOptions().compileProcessors()) //\n\t\t\t\t.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //\n\t\t\t\t.sources(new SourceOptions().sources(sources.getAllJavaFiles())) // no sources, handled by the JDTBatchCompiler\n\t\t\t\t.build();\n\n\t\tgetFactory().getEnvironment().debugMessage(\"compile args: \" + Arrays.toString(args));\n\t\tSystem.setProperty(\"jdt.compiler.useSingleThread\", \"true\");\n\t\tbatchCompiler.compile(args);\n\n\t\treportProblems(factory.getEnvironment());\n\t\tfactory.getEnvironment().debugMessage(\"compiled in \" + (System.currentTimeMillis() - t) + \" ms\");\n\t\treturn probs.isEmpty();\n\t}\n\n\t@Override\n\tpublic void instantiateAndProcess(List<String> processors) {\n\t\t// processing (consume all the processors)\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\tfor (String processorName : processors) {\n\t\t\tprocessing.addProcessor(processorName);\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\n\t\t}\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\t@Override\n\tpublic void process(Collection<Processor<? extends CtElement>> processors) {\n\t\t// processing (consume all the processors)\n\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\tfor (Processor<? extends CtElement> processorName : processors) {\n\t\t\tprocessing.addProcessor(processorName);\n\t\t\tfactory.getEnvironment().debugMessage(\"Loaded processor \" + processorName + \".\");\n\t\t}\n\n\t\tprocessing.process(factory.Package().getRootPackage());\n\t}\n\n\t@Override\n\tpublic void generateProcessedSourceFiles(OutputType outputType) {\n\t\tgenerateProcessedSourceFiles(outputType, null);\n\t}\n\n\t@Override\n\tpublic void generateProcessedSourceFiles(OutputType outputType, Filter<CtType<?>> typeFilter) {\n\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\tgetEnvironment().getSpoonProgress().start(SpoonProgress.Process.PRINT);\n\t\t}\n\t\tswitch (outputType) {\n\t\tcase CLASSES:\n\t\t\tgenerateProcessedSourceFilesUsingTypes(typeFilter);\n\t\t\tbreak;\n\t\tcase COMPILATION_UNITS:\n\t\t\tgenerateProcessedSourceFilesUsingCUs();\n\t\t\tbreak;\n\t\tcase NO_OUTPUT:\n\t\t}\n\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\tgetEnvironment().getSpoonProgress().end(SpoonProgress.Process.PRINT);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addInputSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.sources.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.sources.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addInputSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.sources.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.sources.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addInputSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddInputSource(r);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Set<File> getInputSources() {\n\t\tSet<File> files = new HashSet<>();\n\t\tfor (SpoonFolder file : getSource().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic void addTemplateSource(SpoonResource source) {\n\t\tif (source.isFile()) {\n\t\t\tthis.templates.addFile((SpoonFile) source);\n\t\t} else {\n\t\t\tthis.templates.addFolder((SpoonFolder) source);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addTemplateSource(File source) {\n\t\ttry {\n\t\t\tif (SpoonResourceHelper.isFile(source)) {\n\t\t\t\tthis.templates.addFile(SpoonResourceHelper.createFile(source));\n\t\t\t} else {\n\t\t\t\tthis.templates.addFolder(SpoonResourceHelper.createFolder(source));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addTemplateSources(List<SpoonResource> resources) {\n\t\tfor (SpoonResource r : resources) {\n\t\t\taddTemplateSource(r);\n\t\t}\n\t}\n\n\t@Override\n\tpublic Set<File> getTemplateSources() {\n\t\tSet<File> files = new HashSet<>();\n\t\tfor (SpoonFolder file : getTemplates().getSubFolders()) {\n\t\t\tfiles.add(new File(file.getPath()));\n\t\t}\n\t\treturn files;\n\t}\n\n\t@Override\n\tpublic File getSourceOutputDirectory() {\n\t\treturn this.factory.getEnvironment().getSourceOutputDirectory();\n\t}\n\n\t@Override\n\tpublic void setBinaryOutputDirectory(File binaryOutputDirectory) {\n\t\tthis.getEnvironment().setBinaryOutputDirectory(binaryOutputDirectory.getAbsolutePath());\n\t}\n\n\t@Override\n\tpublic File getBinaryOutputDirectory() {\n\t\treturn new File(getEnvironment().getBinaryOutputDirectory());\n\t}\n\n\t@Override\n\tpublic String[] getSourceClasspath() {\n\t\treturn getEnvironment().getSourceClasspath();\n\t}\n\n\t@Override\n\tpublic void setSourceClasspath(String... classpath) {\n\t\tgetEnvironment().setSourceClasspath(classpath);\n\t}\n\n\t@Override\n\tpublic String[] getTemplateClasspath() {\n\t\treturn templateClasspath;\n\t}\n\n\t@Override\n\tpublic void setTemplateClasspath(String... classpath) {\n\t\tthis.templateClasspath = classpath;\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\tprotected boolean buildSources(JDTBuilder jdtBuilder) {\n\t\treturn buildUnitsAndModel(jdtBuilder, sources, getSourceClasspath(), \"\");\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler() {\n\t\treturn new JDTBatchCompiler(this);\n\t}\n\n\tprotected JDTBatchCompiler createBatchCompiler(InputType... types) {\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler();\n\t\t// backward compatible\n\t\tif (types.length == 0) {\n\t\t\ttypes = new InputType[]{InputType.CTTYPES};\n\t\t}\n\t\tfor (InputType inputType : types) {\n\t\t\tinputType.initializeCompiler(batchCompiler);\n\t\t}\n\t\treturn batchCompiler;\n\t}\n\n\tprotected boolean buildTemplates(JDTBuilder jdtBuilder) {\n\t\treturn buildUnitsAndModel(jdtBuilder, templates, getTemplateClasspath(), \"template \");\n\t}\n\n\t/**\n\t * Get the units from the given source folder and build the Spoon Model.\n\t * @param jdtBuilder The instance of JDTBuilder to prepare the right JDT arguments\n\t * @param sourcesFolder The source folder\n\t * @param classpath The complete classpath\n\t * @param debugMessagePrefix Useful to help debugging\n\t * @return true if the model has been built without errors\n\t */\n\tprotected boolean buildUnitsAndModel(JDTBuilder jdtBuilder, SpoonFolder sourcesFolder, String[] classpath, String debugMessagePrefix) {\n\t\tCompilationUnitDeclaration[] units = buildUnits(jdtBuilder, sourcesFolder, classpath, debugMessagePrefix);\n\n\t\t// here we build the model in the template factory\n\t\tbuildModel(units);\n\n\t\treturn probs.isEmpty();\n\t}\n\n\tprivate static final CompilationUnitDeclaration[] EMPTY_RESULT = new CompilationUnitDeclaration[0];\n\n\t/**\n\t * Build the CompilationUnit found in the source folder\n\t * @param jdtBuilder The instance of JDTBuilder to prepare the right JDT arguments\n\t * @param sourcesFolder The source folder\n\t * @param classpath The complete classpath\n\t * @param debugMessagePrefix Useful to help debugging\n\t * @return All compilationUnitDeclaration from JDT found in source folder\n\t */\n\tprotected CompilationUnitDeclaration[] buildUnits(JDTBuilder jdtBuilder, SpoonFolder sourcesFolder, String[] classpath, String debugMessagePrefix) {\n\t\tList<SpoonFile> sourceFiles = Collections.unmodifiableList(sourcesFolder.getAllJavaFiles());\n\t\tif (sourceFiles.isEmpty()) {\n\t\t\treturn EMPTY_RESULT;\n\t\t}\n\n\t\tJDTBatchCompiler batchCompiler = createBatchCompiler(new FileCompilerConfig(sourceFiles));\n\n\t\tString[] args;\n\t\tif (jdtBuilder == null) {\n\t\t\targs = new JDTBuilderImpl() //\n\t\t\t\t\t.classpathOptions(new ClasspathOptions().encoding(this.getEnvironment().getEncoding().displayName()).classpath(classpath)) //\n\t\t\t\t\t.complianceOptions(new ComplianceOptions().compliance(javaCompliance)) //\n\t\t\t\t\t.advancedOptions(new AdvancedOptions().preserveUnusedVars().continueExecution().enableJavadoc()) //\n\t\t\t\t\t.sources(new SourceOptions().sources(sourceFiles)) // no sources, handled by the JDTBatchCompiler\n\t\t\t\t\t.build();\n\t\t} else {\n\t\t\targs = jdtBuilder.build();\n\t\t}\n\n\t\tgetFactory().getEnvironment().debugMessage(debugMessagePrefix + \"build args: \" + Arrays.toString(args));\n\t\tbatchCompiler.configure(args);\n\n\t\treturn batchCompiler.getUnits();\n\t}\n\n\tprotected List<CompilationUnitDeclaration> sortCompilationUnits(CompilationUnitDeclaration[] units) {\n\t\tList<CompilationUnitDeclaration> unitList = new ArrayList<>(Arrays.asList(units));\n\t\tif (this.sortList) {\n\t\t\tunitList.sort(new FixedOrderBasedOnFileNameCompilationUnitComparator());\n\t\t} else {\n\t\t\tCollections.shuffle(unitList);\n\t\t}\n\n\t\treturn unitList;\n\t}\n\n\tprotected void buildModel(CompilationUnitDeclaration[] units) {\n\t\tJDTTreeBuilder builder = new JDTTreeBuilder(factory);\n\t\tList<CompilationUnitDeclaration> unitList = this.sortCompilationUnits(units);\n\n\t\tforEachCompilationUnit(unitList, SpoonProgress.Process.MODEL, unit -> {\n\t\t\t// we need first to go through the whole model before getting the right reference for imports\n\t\t\tunit.traverse(builder, unit.scope);\n\t\t});\n\t\tif (getFactory().getEnvironment().isAutoImports()) {\n\t\t\t//we need first imports before we can place comments. Mainly comments on imports need that\n\t\t\tforEachCompilationUnit(unitList, SpoonProgress.Process.IMPORT, unit -> {\n\t\t\t\tnew JDTImportBuilder(unit, factory).build();\n\t\t\t});\n\t\t}\n\t\tif (getFactory().getEnvironment().isCommentsEnabled()) {\n\t\t\tforEachCompilationUnit(unitList, SpoonProgress.Process.COMMENT_LINKING, unit -> {\n\t\t\t\tnew JDTCommentBuilder(unit, factory).build();\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate void forEachCompilationUnit(List<CompilationUnitDeclaration> unitList, SpoonProgress.Process process, Consumer<CompilationUnitDeclaration> consumer) {\n\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\tgetEnvironment().getSpoonProgress().start(process);\n\t\t}\n\t\tint i = 0;\n\t\tfor (CompilationUnitDeclaration unit : unitList) {\n\t\t\tif (unit.isModuleInfo() || !unit.isEmpty()) {\n\t\t\t\tfinal String unitPath = new String(unit.getFileName());\n\t\t\t\tif (canProcessCompilationUnit(unitPath)) {\n\t\t\t\t\tconsumer.accept(unit);\n\t\t\t\t}\n\t\t\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\t\t\tgetEnvironment().getSpoonProgress().step(process, unitPath, ++i, unitList.size());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\tgetEnvironment().getSpoonProgress().end(process);\n\t\t}\n\t}\n\n\tprivate boolean canProcessCompilationUnit(String unitPath) {\n\t\tfor (final CompilationUnitFilter cuf : compilationUnitFilters) {\n\t\t\tif (cuf.exclude(unitPath)) {\n\t\t\t\t// do not traverse this unit\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingTypes(Filter<CtType<?>> typeFilter) {\n\t\tif (factory.getEnvironment().getDefaultFileGenerator() != null) {\n\t\t\tfactory.getEnvironment().debugMessage(\"Generating source using types...\");\n\t\t\tProcessingManager processing = new QueueProcessingManager(factory);\n\t\t\tprocessing.addProcessor(factory.getEnvironment().getDefaultFileGenerator());\n\t\t\tif (typeFilter != null) {\n\t\t\t\tprocessing.process(Query.getElements(factory.getModel().getUnnamedModule(), typeFilter));\n\t\t\t} else {\n\t\t\t\tprocessing.process(factory.getModel().getAllModules());\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void generateProcessedSourceFilesUsingCUs() {\n\n\t\tFile outputDirectory = getSourceOutputDirectory();\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source using compilation units...\");\n\t\t// Check output directory\n\t\tif (outputDirectory == null) {\n\t\t\tthrow new RuntimeException(\"You should set output directory before generating source files\");\n\t\t}\n\t\t// Create spooned directory\n\t\tif (outputDirectory.isFile()) {\n\t\t\tthrow new RuntimeException(\"Output must be a directory\");\n\t\t}\n\t\tif (!outputDirectory.exists()) {\n\t\t\tif (!outputDirectory.mkdirs()) {\n\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\toutputDirectory = outputDirectory.getCanonicalFile();\n\t\t} catch (IOException e1) {\n\t\t\tthrow new SpoonException(e1);\n\t\t}\n\n\t\tfactory.getEnvironment().debugMessage(\"Generating source files to: \" + outputDirectory);\n\n\t\tList<File> printedFiles = new ArrayList<>();\n\t\tfor (spoon.reflect.cu.CompilationUnit cu : factory.CompilationUnit().getMap().values()) {\n\n\t\t\tif (cu.getDeclaredTypes().isEmpty()) { // case of package-info\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCtType<?> element = cu.getMainType();\n\n\t\t\tCtPackage pack = element.getPackage();\n\n\t\t\t// create package directory\n\t\t\tFile packageDir;\n\t\t\tif (pack.isUnnamedPackage()) {\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath());\n\t\t\t} else {\n\t\t\t\t// Create current package directory\n\t\t\t\tpackageDir = new File(outputDirectory.getAbsolutePath() + File.separatorChar + pack.getQualifiedName().replace('.', File.separatorChar));\n\t\t\t}\n\t\t\tif (!packageDir.exists()) {\n\t\t\t\tif (!packageDir.mkdirs()) {\n\t\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// print type\n\t\t\ttry {\n\t\t\t\tFile file = new File(packageDir.getAbsolutePath() + File.separatorChar + element.getSimpleName() + DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION);\n\t\t\t\tfile.createNewFile();\n\n\t\t\t\t// the path must be given relatively to to the working directory\n\t\t\t\ttry (InputStream is = getCompilationUnitInputStream(cu.getFile().getPath());\n\t\t\t\t\tFileOutputStream outFile = new FileOutputStream(file)) {\n\n\t\t\t\t\tIOUtils.copy(is, outFile);\n\t\t\t\t}\n\n\t\t\t\tif (!printedFiles.contains(file)) {\n\t\t\t\t\tprintedFiles.add(file);\n\t\t\t\t}\n\n\t\t\t} catch (Exception e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setEnvironment(INameEnvironment environment) {\n\t\tthis.environment = environment;\n\t}\n\n\t/**\n\t * report a compilation problem (callback for JDT)\n\t */\n\tpublic void reportProblem(CategorizedProblem pb) {\n\t\tif (pb == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// we can not accept this problem, even in noclasspath mode\n\t\t// otherwise a nasty null pointer exception occurs later\n\t\tif (pb.getID() == IProblem.DuplicateTypes) {\n\t\t\tif (getFactory().getEnvironment().isIgnoreDuplicateDeclarations() == false) {\n\t\t\t\tthrow new ModelBuildingException(pb.getMessage());\n\t\t\t}\n\t\t} else {\n\t\t\tprobs.add(pb);\n\t\t}\n\t}\n\n\tpublic void reportProblems(Environment environment) {\n\t\tif (!getProblems().isEmpty()) {\n\t\t\tfor (CategorizedProblem problem : getProblems()) {\n\t\t\t\tif (problem != null) {\n\t\t\t\t\treport(environment, problem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void report(Environment environment, CategorizedProblem problem) {\n\t\tif (problem == null) {\n\t\t\tthrow new IllegalArgumentException(\"problem cannot be null\");\n\t\t}\n\n\t\tFile file = new File(new String(problem.getOriginatingFileName()));\n\t\tString filename = file.getAbsolutePath();\n\n\t\tString message = problem.getMessage() + \" at \" + filename + \":\" + problem.getSourceLineNumber();\n\n\t\tif (problem.isError()) {\n\t\t\tif (!environment.getNoClasspath()) {\n\t\t\t\t// by default, compilation errors are notified as exception\n\t\t\t\tthrow new ModelBuildingException(message);\n\t\t\t} else {\n\t\t\t\t// in noclasspath mode, errors are only reported\n\t\t\t\t// but undefined import, type, and name errors are irrelevant\n\t\t\t\tint problemId = problem.getID();\n\t\t\t\tif (problemId != IProblem.UndefinedType && problemId != IProblem.UndefinedName\n\t\t\t\t\t\t&& problemId != IProblem.ImportNotFound) {\n\t\t\t\t\tenvironment.report(null, Level.WARN, message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * returns the list of current problems\n\t */\n\tpublic List<CategorizedProblem> getProblems() {\n\t\treturn Collections.unmodifiableList(this.probs);\n\t}\n\n\tpublic SpoonFolder getSource() {\n\t\treturn sources;\n\t}\n\n\tpublic SpoonFolder getTemplates() {\n\t\treturn templates;\n\t}\n\n\tprotected InputStream getCompilationUnitInputStream(String path) {\n\t\tEnvironment env = factory.getEnvironment();\n\t\tspoon.reflect.cu.CompilationUnit cu = factory.CompilationUnit().getMap().get(path);\n\t\tList<CtType<?>> toBePrinted = cu.getDeclaredTypes();\n\n\t\tPrettyPrinter printer = env.createPrettyPrinter();\n\t\tprinter.calculate(cu, toBePrinted);\n\n\t\treturn new ByteArrayInputStream(printer.getResult().getBytes(env.getEncoding()));\n\t}\n\n\tprotected Environment getEnvironment() {\n\t\treturn getFactory().getEnvironment();\n\t}\n\n\t@Override\n\tpublic void addCompilationUnitFilter(final CompilationUnitFilter filter) {\n\t\tcompilationUnitFilters.add(filter);\n\t}\n\n\t@Override\n\tpublic void removeCompilationUnitFilter(CompilationUnitFilter filter) {\n\t\tcompilationUnitFilters.remove(filter);\n\t}\n\n\t@Override\n\tpublic List<CompilationUnitFilter> getCompilationUnitFilter() {\n\t\treturn new ArrayList<>(compilationUnitFilters);\n\t}\n}\n"
    }, {
      "name" : "support/compiler/jdt/CompilationUnitFilter.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\n/**\n * This interface is used by instances of {@link spoon.SpoonModelBuilder} to\n * exclude particular {@link spoon.reflect.cu.CompilationUnit}s while\n * generating a {@link spoon.reflect.CtModel} with\n * {@link spoon.SpoonModelBuilder#build(spoon.compiler.builder.JDTBuilder)}.\n *\n * This interface is useful for large sized software system where traversing\n * all files takes several minutes. Unlike the approach of adding a subset of\n * the files to examine, filtering unwanted files produces a more precise\n * {@link spoon.reflect.CtModel} since all files will be compiled (but not\n * transformed).\n */\npublic interface CompilationUnitFilter {\n\n\t/**\n\t * Tests if the file with path {@code path} should be excluded from the\n     * {@link spoon.reflect.CtModel} create by\n     * {@link spoon.SpoonModelBuilder#build(spoon.compiler.builder.JDTBuilder)}.\n\t *\n\t * @param path\n\t *      Path to the file that may or may not be excluded.\n\t * @return {@code true} if and only if {@code path} should be excluded,\n\t *         {@code false} otherwise.\n\t */\n\tboolean exclude(String path);\n}\n"
    }, {
      "name" : "support/compiler/jdt/ReferenceBuilder.java",
      "weight" : 905.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler.jdt;\n\nimport org.eclipse.jdt.core.compiler.CharOperation;\nimport org.eclipse.jdt.internal.compiler.ast.ASTNode;\nimport org.eclipse.jdt.internal.compiler.ast.AllocationExpression;\nimport org.eclipse.jdt.internal.compiler.ast.Annotation;\nimport org.eclipse.jdt.internal.compiler.ast.Argument;\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\nimport org.eclipse.jdt.internal.compiler.ast.Expression;\nimport org.eclipse.jdt.internal.compiler.ast.ImportReference;\nimport org.eclipse.jdt.internal.compiler.ast.LambdaExpression;\nimport org.eclipse.jdt.internal.compiler.ast.MessageSend;\nimport org.eclipse.jdt.internal.compiler.ast.ModuleReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.SingleNameReference;\nimport org.eclipse.jdt.internal.compiler.ast.TypeReference;\nimport org.eclipse.jdt.internal.compiler.ast.Wildcard;\nimport org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;\nimport org.eclipse.jdt.internal.compiler.lookup.ArrayBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Binding;\nimport org.eclipse.jdt.internal.compiler.lookup.BlockScope;\nimport org.eclipse.jdt.internal.compiler.lookup.CaptureBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ClassScope;\nimport org.eclipse.jdt.internal.compiler.lookup.FieldBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.MethodScope;\nimport org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemPackageBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.Scope;\nimport org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VariableBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.VoidTypeBinding;\nimport org.eclipse.jdt.internal.compiler.lookup.WildcardBinding;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.PackageFactory;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.support.reflect.CtExtendedModifier;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchPackage;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchType;\nimport static spoon.support.compiler.jdt.JDTTreeBuilderQuery.searchTypeBinding;\n\npublic class ReferenceBuilder {\n\n\t// Allow to detect circular references and to avoid endless recursivity\n\t// when resolving parameterizedTypes (e.g. Enum<E extends Enum<E>>)\n\tprivate Map<TypeBinding, CtTypeReference> exploringParameterizedBindings = new HashMap<>();\n\n\tprivate boolean bounds = false;\n\n\tprivate final JDTTreeBuilder jdtTreeBuilder;\n\n\tReferenceBuilder(JDTTreeBuilder jdtTreeBuilder) {\n\t\tthis.jdtTreeBuilder = jdtTreeBuilder;\n\t}\n\n\tprivate CtTypeReference<?> getBoundedTypeReference(TypeBinding binding) {\n\t\tbounds = true;\n\t\tCtTypeReference<?> ref = getTypeReference(binding);\n\t\tbounds = false;\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Builds a type reference from a {@link TypeReference}.\n\t *\n\t * @param type  Type from JDT.\n\t * @param scope Scope of the parent element.\n\t * @param <T>   Type of the type reference.\n\t * @return a type reference.\n\t */\n\t<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope) {\n\t\treturn buildTypeReference(type, scope, false);\n\t}\n\t<T> CtTypeReference<T> buildTypeReference(TypeReference type, Scope scope, boolean isTypeCast) {\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<T> typeReference = this.<T>getTypeReference(type.resolvedType, type);\n\t\treturn buildTypeReferenceInternal(typeReference, type, scope, isTypeCast);\n\t}\n\n\t/**\n\t * Builds a qualified type reference from a {@link TypeReference}.\n\t *\n\t * @param type Qualified type from JDT.\n\t * @param scope Scope of the parent element.\n\t * @return\n\t */\n\t<T> CtTypeReference<T> buildTypeReference(QualifiedTypeReference type, Scope scope) {\n\t\tCtTypeReference<T> accessedType = buildTypeReference((TypeReference) type, scope);\n\t\tfinal TypeBinding receiverType = type != null ? type.resolvedType : null;\n\t\tif (receiverType != null) {\n\t\t\tfinal CtTypeReference<T> ref = getQualifiedTypeReference(type.tokens, receiverType, receiverType.enclosingType(), new JDTTreeBuilder.OnAccessListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onAccess(char[][] tokens, int index) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ref != null) {\n\t\t\t\taccessedType = ref;\n\t\t\t}\n\t\t}\n\t\treturn accessedType;\n\t}\n\n\t/**\n\t * Builds a type parameter reference from a {@link TypeReference}\n\t *\n\t * @param type  Type from JDT.\n\t * @param scope Scope of the parent element.\n\t * @return a type parameter reference.\n\t */\n\tprivate CtTypeParameterReference buildTypeParameterReference(TypeReference type, Scope scope) {\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (CtTypeParameterReference) this.buildTypeReferenceInternal(this.getTypeParameterReference(type.resolvedType, type), type, scope, false);\n\t}\n\n\n\tprivate <T> CtTypeReference<T> buildTypeReferenceInternal(CtTypeReference<T> typeReference, TypeReference type, Scope scope, boolean isTypeCast) {\n\t\tif (type == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<?> currentReference = typeReference;\n\n\t\tfor (int position = type.getTypeName().length - 1; position >= 0; position--) {\n\t\t\tif (currentReference == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = isTypeCast;\n\t\t\tthis.jdtTreeBuilder.getContextBuilder().enter(currentReference, type);\n\t\t\tthis.jdtTreeBuilder.getContextBuilder().isBuildTypeCast = false;\n\t\t\tif (type.annotations != null && type.annotations.length - 1 <= position && type.annotations[position] != null && type.annotations[position].length > 0) {\n\t\t\t\tfor (Annotation annotation : type.annotations[position]) {\n\t\t\t\t\tif (scope instanceof ClassScope) {\n\t\t\t\t\t\tannotation.traverse(this.jdtTreeBuilder, (ClassScope) scope);\n\t\t\t\t\t} else if (scope instanceof BlockScope) {\n\t\t\t\t\t\tannotation.traverse(this.jdtTreeBuilder, (BlockScope) scope);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tannotation.traverse(this.jdtTreeBuilder, (BlockScope) null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type.getTypeArguments() != null && type.getTypeArguments().length - 1 <= position && type.getTypeArguments()[position] != null && type.getTypeArguments()[position].length > 0) {\n\t\t\t\tCtTypeReference<?> componentReference = getTypeReferenceOfArrayComponent(currentReference);\n\t\t\t\tcomponentReference.getActualTypeArguments().clear();\n\t\t\t\tfor (TypeReference typeArgument : type.getTypeArguments()[position]) {\n\t\t\t\t\tif (typeArgument instanceof Wildcard || typeArgument.resolvedType instanceof WildcardBinding || typeArgument.resolvedType instanceof TypeVariableBinding) {\n\t\t\t\t\t\tcomponentReference.addActualTypeArgument(buildTypeParameterReference(typeArgument, scope));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponentReference.addActualTypeArgument(buildTypeReference(typeArgument, scope));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ((type instanceof ParameterizedSingleTypeReference || type instanceof ParameterizedQualifiedTypeReference)\n\t\t\t\t\t&& !isTypeArgumentExplicit(type.getTypeArguments())) {\n\t\t\t\tfor (CtTypeReference<?> actualTypeArgument : currentReference.getActualTypeArguments()) {\n\t\t\t\t\tactualTypeArgument.setImplicit(true);\n\t\t\t\t\tif (actualTypeArgument instanceof CtArrayTypeReference) {\n\t\t\t\t\t\t((CtArrayTypeReference) actualTypeArgument).getComponentType().setImplicit(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type instanceof Wildcard && typeReference instanceof CtWildcardReference) {\n\t\t\t\t((CtWildcardReference) typeReference).setBoundingType(buildTypeReference(((Wildcard) type).bound, scope));\n\t\t\t}\n\t\t\tthis.jdtTreeBuilder.getContextBuilder().exit(type);\n\t\t\tcurrentReference = currentReference.getDeclaringType();\n\t\t}\n\t\treturn typeReference;\n\t}\n\n\tprivate CtTypeReference<?> getTypeReferenceOfArrayComponent(CtTypeReference<?> currentReference) {\n\t\twhile (currentReference instanceof CtArrayTypeReference) {\n\t\t\tcurrentReference = ((CtArrayTypeReference<?>) currentReference).getComponentType();\n\t\t}\n\t\treturn currentReference;\n\t}\n\n\tprivate boolean isTypeArgumentExplicit(TypeReference[][] typeArguments) {\n\t\tif (typeArguments == null) {\n\t\t\treturn true;\n\t\t}\n\t\tboolean isGenericTypeExplicit = true;\n\t\t// This loop is necessary because it is the only way to know if the generic type\n\t\t// is implicit or not.\n\t\tfor (TypeReference[] typeArgument : typeArguments) {\n\t\t\tisGenericTypeExplicit = typeArgument != null && typeArgument.length > 0;\n\t\t\tif (isGenericTypeExplicit) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn isGenericTypeExplicit;\n\t}\n\n\t/**\n\t * Builds a type reference from a qualified name when a type specified in the name isn't available.\n\t *\n\t * @param tokens        Qualified name.\n\t * @param receiverType  Last type in the qualified name.\n\t * @param enclosingType Enclosing type of the type name.\n\t * @param listener      Listener to know if we must build the type reference.\n\t * @return a type reference.\n\t */\n\t<T> CtTypeReference<T> getQualifiedTypeReference(char[][] tokens, TypeBinding receiverType, ReferenceBinding enclosingType, JDTTreeBuilder.OnAccessListener listener) {\n\t\tfinal List<CtExtendedModifier> listPublicProtected = Arrays.asList(new CtExtendedModifier(ModifierKind.PUBLIC), new CtExtendedModifier(ModifierKind.PROTECTED));\n\t\tif (enclosingType != null && Collections.disjoint(listPublicProtected, JDTTreeBuilderQuery.getModifiers(enclosingType.modifiers, false, false))) {\n\t\t\tString access = \"\";\n\t\t\tint i = 0;\n\t\t\tfinal CompilationUnitDeclaration[] units = ((TreeBuilderCompiler) this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.scope.environment.typeRequestor).unitsToProcess;\n\t\t\tfor (; i < tokens.length; i++) {\n\t\t\t\tfinal char[][] qualified = Arrays.copyOfRange(tokens, 0, i + 1);\n\t\t\t\tif (searchPackage(qualified, units) == null) {\n\t\t\t\t\taccess = CharOperation.toString(qualified);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!access.contains(CtPackage.PACKAGE_SEPARATOR)) {\n\t\t\t\taccess = searchType(access, this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration.imports);\n\t\t\t}\n\t\t\tfinal TypeBinding accessBinding = searchTypeBinding(access, units);\n\t\t\tif (accessBinding != null && listener.onAccess(tokens, i)) {\n\t\t\t\tfinal TypeBinding superClassBinding = searchTypeBinding(accessBinding.superclass(), CharOperation.charToString(tokens[i + 1]));\n\t\t\t\tif (superClassBinding != null) {\n\t\t\t\t\treturn this.getTypeReference(superClassBinding.clone(accessBinding));\n\t\t\t\t} else {\n\t\t\t\t\treturn this.getTypeReference(receiverType);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.getTypeReference(receiverType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Try to get the declaring reference (package or type) from imports of the current\n\t * compilation unit declaration (current class). This method returns a CtReference\n\t * which can be a CtTypeReference if it retrieves the information in an static import,\n\t * a CtPackageReference if it retrieves the information in an standard import, otherwise\n\t * it returns null.\n\t *\n\t * @param expectedName Name expected in imports.\n\t * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.\n\t */\n\tCtReference getDeclaringReferenceFromImports(char[] expectedName) {\n\t\tCompilationUnitDeclaration cuDeclaration = this.jdtTreeBuilder.getContextBuilder().compilationunitdeclaration;\n\t\tif (cuDeclaration == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLookupEnvironment environment = cuDeclaration.scope.environment;\n\n\t\tif (cuDeclaration.imports != null) {\n\t\t\tfor (ImportReference anImport : cuDeclaration.imports) {\n\t\t\t\tif (CharOperation.equals(anImport.getImportName()[anImport.getImportName().length - 1], expectedName)) {\n\t\t\t\t\tif (anImport.isStatic()) {\n\t\t\t\t\t\tint indexDeclaring = 2;\n\t\t\t\t\t\tif ((anImport.bits & ASTNode.OnDemand) != 0) {\n\t\t\t\t\t\t\t// With .*\n\t\t\t\t\t\t\tindexDeclaring = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchar[][] packageName = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - indexDeclaring);\n\t\t\t\t\t\tchar[][] className = CharOperation.subarray(anImport.getImportName(), anImport.getImportName().length - indexDeclaring, anImport.getImportName().length - (indexDeclaring - 1));\n\t\t\t\t\t\tPackageBinding aPackage;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (packageName.length != 0) {\n\t\t\t\t\t\t\t\taPackage = environment.createPackage(packageName);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\taPackage = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal MissingTypeBinding declaringType = environment.createMissingType(aPackage, className);\n\t\t\t\t\t\t\tthis.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = true;\n\t\t\t\t\t\t\tfinal CtTypeReference<Object> typeReference = getTypeReference(declaringType);\n\t\t\t\t\t\t\tthis.jdtTreeBuilder.getContextBuilder().ignoreComputeImports = false;\n\t\t\t\t\t\t\treturn typeReference;\n\t\t\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPackageBinding packageBinding = null;\n\t\t\t\t\t\tchar[][] chars = CharOperation.subarray(anImport.getImportName(), 0, anImport.getImportName().length - 1);\n\t\t\t\t\t\t// `findImport(chars, false, false);` and `createPackage(chars)` require\n\t\t\t\t\t\t// an array with a minimum length of 1 and throw an\n\t\t\t\t\t\t// ArrayIndexOutOfBoundsException if `chars.length == 0`. Fixes #759.\n\t\t\t\t\t\tif (chars.length > 0) {\n\t\t\t\t\t\t\tBinding someBinding = cuDeclaration.scope.findImport(chars, false, false);\n\t\t\t\t\t\t\tif (someBinding != null && someBinding.isValidBinding() && someBinding instanceof PackageBinding) {\n\t\t\t\t\t\t\t\tpackageBinding = (PackageBinding) someBinding;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tpackageBinding = environment.createPackage(chars);\n\t\t\t\t\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\t\t\t\t\tpackageBinding = null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (packageBinding == null || packageBinding instanceof ProblemPackageBinding) {\n\t\t\t\t\t\t\t// Big crisis here. We are already in noclasspath mode but JDT doesn't support always\n\t\t\t\t\t\t\t// creation of a package in this mode. So, if we are in this brace, we make the job of JDT...\n\t\t\t\t\t\t\tpackageBinding = new PackageBinding(chars, null, environment, environment.module);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn getPackageReference(packageBinding);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtExecutableReference<T> getExecutableReference(MethodBinding exec) {\n\t\tif (exec == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal CtExecutableReference ref = this.jdtTreeBuilder.getFactory().Core().createExecutableReference();\n\t\tif (exec.isConstructor()) {\n\t\t\tref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\n\t\t\t// in case of constructor of an array, it's the return type that we want\n\t\t\tif (exec.returnType instanceof VoidTypeBinding) {\n\t\t\t\tref.setType(getTypeReference(exec.declaringClass, true));\n\t\t\t} else {\n\t\t\t\tref.setType(getTypeReference(exec.returnType, true));\n\t\t\t}\n\t\t} else {\n\t\t\tref.setSimpleName(new String(exec.selector));\n\t\t\tref.setType(getTypeReference(exec.returnType, true));\n\t\t}\n\t\tif (exec instanceof ProblemMethodBinding) {\n\t\t\tif (exec.declaringClass != null && Arrays.asList(exec.declaringClass.methods()).contains(exec)) {\n\t\t\t\tref.setDeclaringType(getTypeReference(exec.declaringClass));\n\t\t\t} else {\n\t\t\t\tfinal CtReference declaringType = getDeclaringReferenceFromImports(exec.constantPoolName());\n\t\t\t\tif (declaringType instanceof CtTypeReference) {\n\t\t\t\t\tref.setDeclaringType((CtTypeReference<?>) declaringType);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exec.isConstructor()) {\n\t\t\t\t// super() invocation have a good declaring class.\n\t\t\t\tref.setDeclaringType(getTypeReference(exec.declaringClass));\n\t\t\t}\n\t\t\tref.setStatic(true);\n\t\t} else {\n\t\t\tif (exec.isConstructor() && !(exec.returnType instanceof VoidTypeBinding)) {\n\t\t\t\tref.setDeclaringType(getTypeReference(exec.returnType));\n\t\t\t} else {\n\t\t\t\tref.setDeclaringType(getTypeReference(exec.declaringClass));\n\t\t\t}\n\t\t\tref.setStatic(exec.isStatic());\n\t\t}\n\n\t\tif (exec.declaringClass instanceof ParameterizedTypeBinding) {\n\t\t\tref.setDeclaringType(getTypeReference(exec.declaringClass.actualType()));\n\t\t}\n\n\t\t// original() method returns a result not null when the current method is generic.\n\t\tif (exec.original() != null) {\n\t\t\tfinal List<CtTypeReference<?>> parameters = new ArrayList<>(exec.original().parameters.length);\n\t\t\tfor (TypeBinding b : exec.original().parameters) {\n\t\t\t\tparameters.add(getTypeReference(b, true));\n\t\t\t}\n\t\t\tref.setParameters(parameters);\n\t\t} else if (exec.parameters != null) {\n\t\t\t// This is a method without a generic argument.\n\t\t\tfinal List<CtTypeReference<?>> parameters = new ArrayList<>();\n\t\t\tfor (TypeBinding b : exec.parameters) {\n\t\t\t\tparameters.add(getTypeReference(b, true));\n\t\t\t}\n\t\t\tref.setParameters(parameters);\n\t\t}\n\n\t\treturn ref;\n\t}\n\n\t<T> CtExecutableReference<T> getExecutableReference(AllocationExpression allocationExpression) {\n\t\tCtExecutableReference<T> ref;\n\t\tif (allocationExpression.binding != null) {\n\t\t\tref = getExecutableReference(allocationExpression.binding);\n\t\t} else {\n\t\t\tref = jdtTreeBuilder.getFactory().Core().createExecutableReference();\n\t\t\tref.setSimpleName(CtExecutableReference.CONSTRUCTOR_NAME);\n\t\t\tref.setDeclaringType(getTypeReference(null, allocationExpression.type));\n\n\t\t\tfinal List<CtTypeReference<?>> parameters = new ArrayList<>(allocationExpression.argumentTypes.length);\n\t\t\tfor (TypeBinding b : allocationExpression.argumentTypes) {\n\t\t\t\tparameters.add(getTypeReference(b, true));\n\t\t\t}\n\t\t\tref.setParameters(parameters);\n\t\t}\n\t\tif (allocationExpression.type == null) {\n\t\t\tref.setType(this.<T>getTypeReference(allocationExpression.expectedType(), true));\n\t\t}\n\t\treturn ref;\n\t}\n\n\t<T> CtExecutableReference<T> getExecutableReference(MessageSend messageSend) {\n\t\tif (messageSend.binding != null) {\n\t\t\treturn getExecutableReference(messageSend.binding);\n\t\t}\n\t\tCtExecutableReference<T> ref = jdtTreeBuilder.getFactory().Core().createExecutableReference();\n\t\tref.setSimpleName(CharOperation.charToString(messageSend.selector));\n\t\tref.setType(this.<T>getTypeReference(messageSend.expectedType(), true));\n\t\tif (messageSend.receiver.resolvedType == null) {\n\t\t\t// It is crisis dude! static context, we don't have much more information.\n\t\t\tif (messageSend.receiver instanceof SingleNameReference) {\n\t\t\t\tref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((SingleNameReference) messageSend.receiver).getAccessedType());\n\t\t\t} else if (messageSend.receiver instanceof QualifiedNameReference) {\n\t\t\t\tref.setDeclaringType(jdtTreeBuilder.getHelper().createTypeAccessNoClasspath((QualifiedNameReference) messageSend.receiver).getAccessedType());\n\t\t\t}\n\t\t} else {\n\t\t\tref.setDeclaringType(getTypeReference(messageSend.receiver.resolvedType));\n\t\t}\n\t\tif (messageSend.arguments != null) {\n\t\t\tfinal List<CtTypeReference<?>> parameters = new ArrayList<>();\n\t\t\tfor (Expression expression : messageSend.arguments) {\n\t\t\t\tparameters.add(getTypeReference(expression.resolvedType, true));\n\t\t\t}\n\t\t\tref.setParameters(parameters);\n\t\t}\n\t\treturn ref;\n\t}\n\n\tprivate CtPackageReference getPackageReference(PackageBinding reference) {\n\t\treturn getPackageReference(new String(reference.shortReadableName()));\n\t}\n\n\tpublic CtPackageReference getPackageReference(String name) {\n\t\tif (name.isEmpty()) {\n\t\t\treturn this.jdtTreeBuilder.getFactory().Package().topLevel();\n\t\t}\n\t\tCtPackageReference ref = this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n\t\tref.setSimpleName(name);\n\t\treturn ref;\n\t}\n\n\tfinal Map<TypeBinding, CtTypeReference> bindingCache = new HashMap<>();\n\n\t<T> CtTypeReference<T> getTypeReference(TypeBinding binding, TypeReference ref) {\n\t\tCtTypeReference<T> ctRef = getTypeReference(binding);\n\t\tif (ctRef != null && isCorrectTypeReference(ref)) {\n\t\t\tinsertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n\t\t\treturn ctRef;\n\t\t}\n\t\treturn getTypeReference(ref);\n\t}\n\n\tCtTypeReference<Object> getTypeParameterReference(TypeBinding binding, TypeReference ref) {\n\t\tCtTypeReference<Object> ctRef = getTypeReference(binding);\n\t\tif (ctRef != null && isCorrectTypeReference(ref)) {\n\t\t\tif (!(ctRef instanceof CtTypeParameterReference)) {\n\t\t\t\tCtTypeParameterReference typeParameterRef = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n\t\t\t\ttypeParameterRef.setSimpleName(ctRef.getSimpleName());\n\t\t\t\ttypeParameterRef.setDeclaringType(ctRef.getDeclaringType());\n\t\t\t\ttypeParameterRef.setPackage(ctRef.getPackage());\n\t\t\t\tctRef = typeParameterRef;\n\t\t\t}\n\t\t\tinsertGenericTypesInNoClasspathFromJDTInSpoon(ref, ctRef);\n\t\t\treturn ctRef;\n\t\t}\n\t\treturn getTypeParameterReference(CharOperation.toString(ref.getParameterizedTypeName()));\n\t}\n\n\t/**\n\t * In no classpath, the model of the super interface isn't always correct.\n\t */\n\tprivate boolean isCorrectTypeReference(TypeReference ref) {\n\t\tif (ref.resolvedType == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(ref.resolvedType instanceof ProblemReferenceBinding)) {\n\t\t\treturn true;\n\t\t}\n\t\tfinal String[] compoundName = CharOperation.charArrayToStringArray(((ProblemReferenceBinding) ref.resolvedType).compoundName);\n\t\tfinal String[] typeName = CharOperation.charArrayToStringArray(ref.getTypeName());\n\t\tif (compoundName.length == 0 || typeName.length == 0) {\n\t\t\treturn false;\n\t\t}\n\t\treturn compoundName[compoundName.length - 1].equals(typeName[typeName.length - 1]);\n\t}\n\n\tprivate <T> void insertGenericTypesInNoClasspathFromJDTInSpoon(TypeReference original, CtTypeReference<T> type) {\n\t\tif (original.resolvedType instanceof ProblemReferenceBinding && original.getTypeArguments() != null) {\n\t\t\tfor (TypeReference[] typeReferences : original.getTypeArguments()) {\n\t\t\t\tif (typeReferences != null) {\n\t\t\t\t\tfor (TypeReference typeReference : typeReferences) {\n\t\t\t\t\t\ttype.addActualTypeArgument(this.getTypeReference(typeReference.resolvedType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * JDT doesn't return a correct AST with the resolved type of the reference.\n\t * This method try to build a correct Spoon AST from the name of the JDT\n\t * reference, thanks to the parsing of the string, the name parameterized from\n\t * the JDT reference and java convention.\n\t * Returns a complete Spoon AST when the name is correct, otherwise a spoon type\n\t * reference with a name that correspond to the name of the JDT type reference.\n\t */\n\t<T> CtTypeReference<T> getTypeReference(TypeReference ref) {\n\t\tif (ref == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<T> res = null;\n\t\tCtTypeReference inner = null;\n\t\tfinal String[] namesParameterized = CharOperation.charArrayToStringArray(ref.getParameterizedTypeName());\n\t\tString nameParameterized = CharOperation.toString(ref.getParameterizedTypeName());\n\t\tString typeName = CharOperation.toString(ref.getTypeName());\n\n\t\tint index = namesParameterized.length - 1;\n\t\tfor (; index >= 0; index--) {\n\t\t\t// Start at the end to get the class name first.\n\t\t\tCtTypeReference main = getTypeReference(namesParameterized[index]);\n\t\t\tif (main == null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (res == null) {\n\t\t\t\tres = (CtTypeReference<T>) main;\n\t\t\t} else {\n\t\t\t\tinner.setDeclaringType((CtTypeReference<?>) main);\n\t\t\t}\n\t\t\tinner = main;\n\t\t}\n\t\tif (res == null) {\n\t\t\treturn this.jdtTreeBuilder.getFactory().Type().createReference(nameParameterized);\n\t\t}\n\n\t\tif (inner.getPackage() == null) {\n\t\t\tPackageFactory packageFactory = this.jdtTreeBuilder.getFactory().Package();\n\t\t\tCtPackageReference packageReference = index >= 0 ? packageFactory.getOrCreate(concatSubArray(namesParameterized, index)).getReference() : packageFactory.topLevel();\n\t\t\tinner.setPackage(packageReference);\n\t\t}\n\t\tif (!res.toString().replace(\", ?\", \",?\").endsWith(nameParameterized)) {\n\t\t\t// verify that we did not match a class that have the same name in a different package\n\t\t\treturn this.jdtTreeBuilder.getFactory().Type().createReference(typeName);\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate String concatSubArray(String[] a, int endIndex) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < endIndex; i++) {\n\t\t\tsb.append(a[i]).append('.');\n\t\t}\n\t\tsb.append(a[endIndex]);\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Try to build a CtTypeReference from a simple name with specified generic types but\n\t * returns null if the name doesn't correspond to a type (not start by an upper case).\n\t */\n\tpublic <T> CtTypeReference<T> getTypeReference(String name) {\n\t\tCtTypeReference<T> main = null;\n\t\tif (name.matches(\".*(<.+>)\")) {\n\t\t\tPattern pattern = Pattern.compile(\"([^<]+)<(.+)>\");\n\t\t\tMatcher m = pattern.matcher(name);\n\t\t\tif (name.startsWith(\"?\")) {\n\t\t\t\tmain = (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\t\t\t} else {\n\t\t\t\tmain = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\t}\n\t\t\tif (m.find()) {\n\t\t\t\tmain.setSimpleName(m.group(1));\n\t\t\t\tfinal String[] split = m.group(2).split(\",\");\n\t\t\t\tfor (String parameter : split) {\n\t\t\t\t\tmain.addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Character.isUpperCase(name.charAt(0))) {\n\t\t\tif (name.endsWith(\"[]\")) {\n\t\t\t\tmain = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n\t\t\t\tname = name.substring(0, name.length() - 2);\n\t\t\t\t((CtArrayTypeReference<T>) main).setComponentType(this.getTypeReference(name));\n\t\t\t} else {\n\t\t\t\tmain = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\t}\n\t\t\tmain.setSimpleName(name);\n\t\t\tfinal CtReference declaring = this.getDeclaringReferenceFromImports(name.toCharArray());\n\t\t\tsetPackageOrDeclaringType(main, declaring);\n\t\t} else if (name.startsWith(\"?\")) {\n\t\t\treturn (CtTypeReference) this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\t\t}\n\t\treturn main;\n\t}\n\n\t/**\n\t * Try to build a CtTypeParameterReference from a single name with specified generic types but\n\t * keep in mind that if you give wrong data in the strong, reference will be wrong.\n\t */\n\tprivate CtTypeReference<Object> getTypeParameterReference(String name) {\n\t\tCtTypeReference<Object> param = null;\n\t\tif (name.contains(\"extends\") || name.contains(\"super\")) {\n\t\t\tString[] split = name.contains(\"extends\") ? name.split(\"extends\") : name.split(\"super\");\n\t\t\tparam = getTypeParameterReference(split[0].trim());\n\t\t\tif (param instanceof CtWildcardReference) {\n\t\t\t\t((CtWildcardReference) param).setBoundingType(getTypeReference(split[split.length - 1].trim()));\n\t\t\t}\n\t\t} else if (name.matches(\".*(<.+>)\")) {\n\t\t\tPattern pattern = Pattern.compile(\"([^<]+)<(.+)>\");\n\t\t\tMatcher m = pattern.matcher(name);\n\t\t\tif (m.find()) {\n\t\t\t\tparam = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\t\tparam.setSimpleName(m.group(1));\n\t\t\t\tfinal String[] split = m.group(2).split(\",\");\n\t\t\t\tfor (String parameter : split) {\n\t\t\t\t\tparam.addActualTypeArgument(getTypeParameterReference(parameter.trim()));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (name.contains(\"?\")) {\n\t\t\tparam = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\t\t} else {\n\t\t\tparam = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n\t\t\tparam.setSimpleName(name);\n\t\t}\n\t\treturn param;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtTypeReference<T> getTypeReference(TypeBinding binding) {\n\t\treturn getTypeReference(binding, false);\n\t}\n\t/**\n\t * @param resolveGeneric if true then it never returns CtTypeParameterReference, but it's superClass instead\n\t */\n\t<T> CtTypeReference<T> getTypeReference(TypeBinding binding, boolean resolveGeneric) {\n\t\tif (binding == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCtTypeReference<?> ref;\n\n\t\tif (binding instanceof RawTypeBinding) {\n\t\t\tref = getTypeReference(((ParameterizedTypeBinding) binding).genericType());\n\t\t} else if (binding instanceof ParameterizedTypeBinding) {\n\t\t\tif (binding.actualType() != null && binding.actualType() instanceof LocalTypeBinding) {\n\t\t\t\t// When we define a nested class in a method and when the enclosing class of this method\n\t\t\t\t// is a parameterized type binding, JDT give a ParameterizedTypeBinding for the nested class\n\t\t\t\t// and hide the real class in actualType().\n\t\t\t\tref = getTypeReference(binding.actualType());\n\t\t\t} else {\n\t\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\t\tthis.exploringParameterizedBindings.put(binding, ref);\n\t\t\t\tif (binding.isAnonymousType()) {\n\t\t\t\t\tref.setSimpleName(\"\");\n\t\t\t\t} else {\n\t\t\t\t\tref.setSimpleName(String.valueOf(binding.sourceName()));\n\t\t\t\t\tif (binding.enclosingType() != null) {\n\t\t\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tref.setPackage(getPackageReference(binding.getPackage()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (binding.actualType() instanceof MissingTypeBinding) {\n\t\t\t\tref = getTypeReference(binding.actualType());\n\t\t\t}\n\n\t\t\tif (((ParameterizedTypeBinding) binding).arguments != null) {\n\t\t\t\tfor (TypeBinding b : ((ParameterizedTypeBinding) binding).arguments) {\n\t\t\t\t\tif (bindingCache.containsKey(b)) {\n\t\t\t\t\t\tref.addActualTypeArgument(getCtCircularTypeReference(b));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!this.exploringParameterizedBindings.containsKey(b)) {\n\t\t\t\t\t\t\tthis.exploringParameterizedBindings.put(b, null);\n\t\t\t\t\t\t\tCtTypeReference typeRefB = getTypeReference(b);\n\t\t\t\t\t\t\tthis.exploringParameterizedBindings.put(b, typeRefB);\n\t\t\t\t\t\t\tref.addActualTypeArgument(typeRefB);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tCtTypeReference typeRefB = this.exploringParameterizedBindings.get(b);\n\t\t\t\t\t\t\tif (typeRefB != null) {\n\t\t\t\t\t\t\t\tref.addActualTypeArgument(typeRefB.clone());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (binding instanceof MissingTypeBinding) {\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t\tref.setPackage(getPackageReference(binding.getPackage()));\n\t\t\tif (!this.jdtTreeBuilder.getContextBuilder().ignoreComputeImports) {\n\t\t\t\tfinal CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());\n\t\t\t\tif (declaring instanceof CtPackageReference) {\n\t\t\t\t\tref.setPackage((CtPackageReference) declaring);\n\t\t\t\t} else if (declaring instanceof CtTypeReference) {\n\t\t\t\t\tref.setDeclaringType((CtTypeReference) declaring);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (binding instanceof BinaryTypeBinding) {\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tif (binding.enclosingType() != null) {\n\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t} else {\n\t\t\t\tref.setPackage(getPackageReference(binding.getPackage()));\n\t\t\t}\n\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t} else if (binding instanceof TypeVariableBinding) {\n\t\t\tboolean oldBounds = bounds;\n\n\t\t\tif (binding instanceof CaptureBinding) {\n\t\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\t\t\t\tbounds = true;\n\t\t\t} else {\n\t\t\t\tTypeVariableBinding typeParamBinding = (TypeVariableBinding) binding;\n\t\t\t\tif (resolveGeneric) {\n\t\t\t\t\t//it is called e.g. by ExecutableReference, which must not use CtParameterTypeReference\n\t\t\t\t\t//but it needs it's bounding type instead\n\t\t\t\t\tReferenceBinding superClass = typeParamBinding.superclass;\n\t\t\t\t\tReferenceBinding[] superInterfaces = typeParamBinding.superInterfaces();\n\n\t\t\t\t\tCtTypeReference refSuperClass = null;\n\n\t\t\t\t\t// if the type parameter has a super class other than java.lang.Object, we get it\n\t\t\t\t\t// superClass.superclass() is null if it's java.lang.Object\n\t\t\t\t\tif (superClass != null && !(superClass.superclass() == null)) {\n\n\t\t\t\t\t\t// this case could happen with Enum<E extends Enum<E>> for example:\n\t\t\t\t\t\t// in that case we only want to have E -> Enum -> E\n\t\t\t\t\t\t// to conserve the same behavior as JavaReflectionTreeBuilder\n\t\t\t\t\t\tif (!(superClass instanceof ParameterizedTypeBinding) || !this.exploringParameterizedBindings.containsKey(superClass)) {\n\t\t\t\t\t\t\trefSuperClass = this.getTypeReference(superClass, resolveGeneric);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// if the type parameter has a super interface, then we'll get it too, as a superclass\n\t\t\t\t\t// type parameter can only extends an interface or a class, so we don't make the distinction\n\t\t\t\t\t// in Spoon. Moreover we can only have one extends in a type parameter.\n\t\t\t\t\t} else if (superInterfaces != null && superInterfaces.length == 1) {\n\t\t\t\t\t\trefSuperClass = this.getTypeReference(superInterfaces[0], resolveGeneric);\n\t\t\t\t\t}\n\t\t\t\t\tif (refSuperClass == null) {\n\t\t\t\t\t\trefSuperClass = this.jdtTreeBuilder.getFactory().Type().getDefaultBoundingType();\n\t\t\t\t\t}\n\t\t\t\t\tref = refSuperClass.clone();\n\t\t\t\t} else {\n\t\t\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeParameterReference();\n\t\t\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tTypeVariableBinding b = (TypeVariableBinding) binding;\n\t\t\tif (bounds) {\n\t\t\t\tif (b instanceof CaptureBinding && ((CaptureBinding) b).wildcard != null) {\n\t\t\t\t\tbounds = oldBounds;\n\t\t\t\t\treturn getTypeReference(((CaptureBinding) b).wildcard, resolveGeneric);\n\t\t\t\t} else if (b.superclass != null && b.firstBound == b.superclass) {\n\t\t\t\t\tbounds = false;\n\t\t\t\t\tbindingCache.put(binding, ref);\n\t\t\t\t\tif (ref instanceof CtWildcardReference) {\n\t\t\t\t\t\t((CtWildcardReference) ref).setBoundingType(getTypeReference(b.superclass, resolveGeneric));\n\t\t\t\t\t}\n\t\t\t\t\tbounds = oldBounds;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bounds && b.superInterfaces != null && b.superInterfaces != Binding.NO_SUPERINTERFACES) {\n\t\t\t\tbindingCache.put(binding, ref);\n\t\t\t\tList<CtTypeReference<?>> bounds = new ArrayList<>();\n\t\t\t\tCtTypeParameterReference typeParameterReference = (CtTypeParameterReference) ref;\n\t\t\t\tif (!(typeParameterReference.isDefaultBoundingType())) { // if it's object we can ignore it\n\t\t\t\t\tbounds.add(typeParameterReference.getBoundingType());\n\t\t\t\t}\n\t\t\t\tfor (ReferenceBinding superInterface : b.superInterfaces) {\n\t\t\t\t\tbounds.add(getTypeReference(superInterface, resolveGeneric));\n\t\t\t\t}\n\t\t\t\tif (ref instanceof CtWildcardReference) {\n\t\t\t\t\t((CtWildcardReference) ref).setBoundingType(this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (binding instanceof CaptureBinding) {\n\t\t\t\tbounds = false;\n\t\t\t}\n\t\t} else if (binding instanceof BaseTypeBinding) {\n\t\t\tString name = new String(binding.sourceName());\n\t\t\t//always create new TypeReference, because clonning from a cache clones invalid SourcePosition\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tref.setSimpleName(name);\n\t\t} else if (binding instanceof WildcardBinding) {\n\t\t\tWildcardBinding wildcardBinding = (WildcardBinding) binding;\n\t\t\tCtWildcardReference wref = this.jdtTreeBuilder.getFactory().Core().createWildcardReference();\n\t\t\tref = wref;\n\n\t\t\tif (wildcardBinding.boundKind == Wildcard.SUPER) {\n\t\t\t\twref.setUpper(false);\n\t\t\t}\n\n\t\t\tif (wildcardBinding.bound != null) {\n\t\t\t\tif (bindingCache.containsKey(wildcardBinding.bound)) {\n\t\t\t\t\twref.setBoundingType(getCtCircularTypeReference(wildcardBinding.bound));\n\t\t\t\t} else {\n\t\t\t\t\twref.setBoundingType(getTypeReference(((WildcardBinding) binding).bound));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (binding instanceof LocalTypeBinding) {\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tif (binding.isAnonymousType()) {\n\t\t\t\tref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t} else {\n\t\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t\t\tif (((LocalTypeBinding) binding).enclosingMethod == null && binding.enclosingType() != null && binding.enclosingType() instanceof LocalTypeBinding) {\n\t\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t\t} else if (binding.enclosingMethod() != null) {\n\t\t\t\t\tref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n\t\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (binding instanceof SourceTypeBinding) {\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tif (binding.isAnonymousType()) {\n\t\t\t\tref.setSimpleName(JDTTreeBuilderHelper.computeAnonymousName(((SourceTypeBinding) binding).constantPoolName()));\n\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t} else {\n\t\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t\t\tif (binding.enclosingType() != null) {\n\t\t\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t\t\t} else {\n\t\t\t\t\tref.setPackage(getPackageReference(binding.getPackage()));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (binding instanceof ArrayBinding) {\n\t\t\tCtArrayTypeReference<Object> arrayref;\n\t\t\tarrayref = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n\t\t\tref = arrayref;\n\t\t\tfor (int i = 1; i < binding.dimensions(); i++) {\n\t\t\t\tCtArrayTypeReference<Object> tmp = this.jdtTreeBuilder.getFactory().Core().createArrayTypeReference();\n\t\t\t\tarrayref.setComponentType(tmp);\n\t\t\t\tarrayref = tmp;\n\t\t\t}\n\t\t\tarrayref.setComponentType(getTypeReference(binding.leafComponentType(), resolveGeneric));\n\t\t} else if (binding instanceof PolyTypeBinding) {\n\t\t\t// JDT can't resolve the type of this binding and we only have a string.\n\t\t\t// In this case, we return a type Object because we can't know more about it.\n\t\t\tref = this.jdtTreeBuilder.getFactory().Type().objectType();\n\t\t} else if (binding instanceof ProblemReferenceBinding) {\n\t\t\t// Spoon is able to analyze also without the classpath\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tref.setSimpleName(new String(binding.readableName()));\n\t\t\tfinal CtReference declaring = this.getDeclaringReferenceFromImports(binding.sourceName());\n\t\t\tsetPackageOrDeclaringType(ref, declaring);\n\t\t} else if (binding instanceof JDTTreeBuilder.SpoonReferenceBinding) {\n\t\t\tref = this.jdtTreeBuilder.getFactory().Core().createTypeReference();\n\t\t\tref.setSimpleName(new String(binding.sourceName()));\n\t\t\tref.setDeclaringType(getTypeReference(binding.enclosingType()));\n\t\t} else if (binding instanceof IntersectionTypeBinding18) {\n\t\t\tList<CtTypeReference<?>> bounds = new ArrayList<>();\n\t\t\tfor (ReferenceBinding superInterface : binding.getIntersectingTypes()) {\n\t\t\t\tbounds.add(getTypeReference(superInterface));\n\t\t\t}\n\t\t\tref = this.jdtTreeBuilder.getFactory().Type().createIntersectionTypeReferenceWithBounds(bounds);\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unknown TypeBinding: \" + binding.getClass() + \" \" + binding);\n\t\t}\n\t\tbindingCache.remove(binding);\n\t\tthis.exploringParameterizedBindings.remove(binding);\n\t\treturn (CtTypeReference<T>) ref;\n\t}\n\n\tprivate CtTypeReference<?> getCtCircularTypeReference(TypeBinding b) {\n\t\treturn bindingCache.get(b).clone();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtVariableReference<T> getVariableReference(MethodBinding methbin) {\n\t\tCtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n\t\tref.setSimpleName(new String(methbin.selector));\n\t\tref.setType(getTypeReference(methbin.returnType));\n\n\t\tif (methbin.declaringClass != null) {\n\t\t\tref.setDeclaringType(getTypeReference(methbin.declaringClass));\n\t\t} else {\n\t\t\tref.setDeclaringType(ref.getType());\n\t\t}\n\t\treturn ref;\n\t}\n\n\t<T> CtFieldReference<T> getVariableReference(FieldBinding varbin) {\n\t\tCtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n\t\tif (varbin == null) {\n\t\t\treturn ref;\n\t\t}\n\t\tref.setSimpleName(new String(varbin.name));\n\t\tref.setType(this.<T>getTypeReference(varbin.type));\n\n\t\tif (varbin.declaringClass != null) {\n\t\t\tref.setDeclaringType(getTypeReference(varbin.declaringClass));\n\t\t} else {\n\t\t\tref.setDeclaringType(ref.getType() == null ? null : ref.getType().clone());\n\t\t}\n\t\tref.setFinal(varbin.isFinal());\n\t\tref.setStatic((varbin.modifiers & ClassFileConstants.AccStatic) != 0);\n\t\treturn ref;\n\t}\n\n\t<T> CtFieldReference<T> getVariableReference(FieldBinding fieldBinding, char[] tokens) {\n\t\tfinal CtFieldReference<T> ref = getVariableReference(fieldBinding);\n\t\tif (fieldBinding != null) {\n\t\t\treturn ref;\n\t\t}\n\t\tref.setSimpleName(CharOperation.charToString(tokens));\n\t\treturn ref;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t<T> CtVariableReference<T> getVariableReference(VariableBinding varbin) {\n\n\t\tif (varbin instanceof FieldBinding) {\n\t\t\treturn getVariableReference((FieldBinding) varbin);\n\t\t} else if (varbin instanceof LocalVariableBinding) {\n\t\t\tfinal LocalVariableBinding localVariableBinding = (LocalVariableBinding) varbin;\n\t\t\tif (localVariableBinding.declaration instanceof Argument && localVariableBinding.declaringScope instanceof MethodScope) {\n\t\t\t\tCtParameterReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createParameterReference();\n\t\t\t\tref.setSimpleName(new String(varbin.name));\n\t\t\t\tref.setType(getTypeReference(varbin.type));\n\t\t\t\treturn ref;\n\t\t\t} else if (localVariableBinding.declaration.binding instanceof CatchParameterBinding) {\n\t\t\t\tCtCatchVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createCatchVariableReference();\n\t\t\t\tref.setSimpleName(new String(varbin.name));\n\t\t\t\tCtTypeReference<T> ref2 = getTypeReference(varbin.type);\n\t\t\t\tref.setType(ref2);\n\t\t\t\treturn ref;\n\t\t\t} else {\n\t\t\t\tCtLocalVariableReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createLocalVariableReference();\n\t\t\t\tref.setSimpleName(new String(varbin.name));\n\t\t\t\tCtTypeReference<T> ref2 = getTypeReference(varbin.type);\n\t\t\t\tref.setType(ref2);\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t} else {\n\t\t\t// unknown VariableBinding, the caller must do something\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t<T> CtVariableReference<T> getVariableReference(ProblemBinding binding) {\n\t\tCtFieldReference<T> ref = this.jdtTreeBuilder.getFactory().Core().createFieldReference();\n\t\tif (binding == null) {\n\t\t\treturn ref;\n\t\t}\n\t\tref.setSimpleName(new String(binding.name));\n\t\tref.setType(getTypeReference(binding.searchType));\n\t\treturn ref;\n\t}\n\n\tList<CtTypeReference<?>> getBoundedTypesReferences(TypeBinding[] genericTypeArguments) {\n\t\tList<CtTypeReference<?>> res = new ArrayList<>(genericTypeArguments.length);\n\t\tfor (TypeBinding tb : genericTypeArguments) {\n\t\t\tres.add(getBoundedTypeReference(tb));\n\t\t}\n\t\treturn res;\n\t}\n\n\t/**\n\t * Sets {@code declaring} as inner of {@code ref}, as either the package or the declaring type\n\t */\n\tvoid setPackageOrDeclaringType(CtTypeReference<?> ref, CtReference declaring) {\n\t\tif (declaring instanceof CtPackageReference) {\n\t\t\tref.setPackage((CtPackageReference) declaring);\n\t\t} else if (declaring instanceof CtTypeReference) {\n\t\t\tref.setDeclaringType((CtTypeReference) declaring);\n\t\t} else if (declaring == null) {\n\t\t\ttry {\n\t\t\t\t// sometimes JDT does not provide the information that ref comes from java.lang\n\t\t\t\t// it seems to occurs in particular with anonymous inner classes: see #1307\n\t\t\t\t// In that case, we try to load the class to check if it belongs to java.lang\n\t\t\t\tClass.forName(\"java.lang.\" + ref.getSimpleName());\n\t\t\t\tCtPackageReference javaLangPackageReference = this.jdtTreeBuilder.getFactory().Core().createPackageReference();\n\t\t\t\tjavaLangPackageReference.setSimpleName(\"java.lang\");\n\t\t\t\tref.setPackage(javaLangPackageReference);\n\t\t\t} catch (NoClassDefFoundError | ClassNotFoundException e) {\n\t\t\t\t// in that case we consider the package should be the same as the current one. Fix #1293\n\t\t\t\tref.setPackage(jdtTreeBuilder.getContextBuilder().compilationUnitSpoon.getDeclaredPackage().getReference());\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new AssertionError(\"unexpected declaring type: \" + declaring.getClass() + \" of \" + declaring);\n\t\t}\n\t}\n\n\t/**\n\t * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression.\n\t * Here, we make the job of JDT and bind their variables accesses to their parameters.\n\t *\n\t * @param singleNameReference Name of the variable access.\n\t * @return executable reference which corresponds to the lambda.\n\t */\n\tpublic CtExecutableReference<?> getLambdaExecutableReference(SingleNameReference singleNameReference) {\n\t\tASTPair potentialLambda = null;\n\t\tfor (ASTPair astPair : jdtTreeBuilder.getContextBuilder().stack) {\n\t\t\tif (astPair.node instanceof LambdaExpression) {\n\t\t\t\tpotentialLambda = astPair;\n\t\t\t\t// stop at innermost lambda, fixes #1100\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (potentialLambda == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLambdaExpression lambdaJDT = (LambdaExpression) potentialLambda.node;\n\t\tfor (Argument argument : lambdaJDT.arguments()) {\n\t\t\tif (CharOperation.equals(argument.name, singleNameReference.token)) {\n\t\t\t\tCtTypeReference<?> declaringType = null;\n\t\t\t\tif (lambdaJDT.enclosingScope instanceof MethodScope) {\n\t\t\t\t\tdeclaringType = jdtTreeBuilder.getReferencesBuilder().getTypeReference(((MethodScope) lambdaJDT.enclosingScope).parent.enclosingSourceType());\n\t\t\t\t}\n\t\t\t\tCtLambda<?> ctLambda = (CtLambda<?>) potentialLambda.element;\n\t\t\t\tList<CtTypeReference<?>> parametersType = new ArrayList<>();\n\t\t\t\tList<CtParameter<?>> parameters = ctLambda.getParameters();\n\t\t\t\tfor (CtParameter<?> parameter : parameters) {\n\t\t\t\t\tparametersType.add(getMethodParameterType(parameter));\n\t\t\t\t}\n\t\t\t\treturn jdtTreeBuilder.getFactory().Executable().createReference(declaringType, ctLambda.getType(), ctLambda.getSimpleName(), parametersType);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate CtTypeReference<?> getMethodParameterType(CtParameter<?> param) {\n\t\tCtTypeReference<?> paramType = param.getType();\n\t\tif (paramType instanceof CtTypeParameterReference) {\n\t\t\tparamType = ((CtTypeParameterReference) paramType).getBoundingType();\n\t\t}\n\t\tif (paramType == null) {\n\t\t\tparamType = param.getFactory().Type().OBJECT;\n\t\t}\n\t\treturn paramType.clone();\n\t}\n\n\tpublic CtModuleReference getModuleReference(ModuleReference moduleReference) {\n\t\tString moduleName = new String(moduleReference.moduleName);\n\t\tCtModule module = this.jdtTreeBuilder.getFactory().Module().getModule(moduleName);\n\t\tif (module == null) {\n\t\t\tCtModuleReference ctModuleReference = this.jdtTreeBuilder.getFactory().Core().createModuleReference();\n\t\t\tctModuleReference.setSimpleName(moduleName);\n\t\t\treturn ctModuleReference;\n\t\t} else {\n\t\t\treturn module.getReference();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/compiler/FilteringFolder.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.util.ArrayList;\n\nimport spoon.compiler.SpoonResource;\n\n/**\n * A filtering resource, see https://github.com/INRIA/spoon/issues/877\n *\n */\npublic class FilteringFolder extends VirtualFolder {\n\n\t/** Removes all resources matching the given Java regex\n\t * Eg. resources3.removeIfMatches(\".*packageprotected.*\");\n\t */\n\tpublic FilteringFolder removeAllThatMatch(String regex) {\n\t\tfor (SpoonResource f : new ArrayList<>(files)) {\n\t\t\tif (f.getPath().matches(regex)) {\n\t\t\t\tfiles.remove(f);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n}\n"
    }, {
      "name" : "support/compiler/ZipFile.java",
      "weight" : 68.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.compiler;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\n\nimport spoon.compiler.SpoonFile;\nimport spoon.compiler.SpoonFolder;\n\npublic class ZipFile implements SpoonFile {\n\n\tbyte[] buffer;\n\n\tString name;\n\n\tZipFolder parent;\n\n\tpublic ZipFile(ZipFolder parent, String name, byte[] buffer) {\n\t\tthis.buffer = buffer;\n\t\tthis.name = name;\n\t\tthis.parent = parent;\n\t}\n\n\t@Override\n\tpublic InputStream getContent() {\n\t\treturn new ByteArrayInputStream(buffer);\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic SpoonFolder getParent() {\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic File getFileSystemParent() {\n\t\treturn getParent().getFileSystemParent();\n\t}\n\n\t@Override\n\tpublic boolean isFile() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isJava() {\n\t\treturn getName().endsWith(\".java\");\n\t}\n\n\t@Override\n\tpublic String getPath() {\n\t\treturn toString();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn parent + \"!\" + getName();\n\t}\n\n\t@Override\n\tpublic boolean isArchive() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic File toFile() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isActualFile() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn toString().equals(obj.toString());\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn toString().hashCode();\n\t}\n\n}\n"
    }, {
      "name" : "support/comparator/SignatureComparator.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.comparator;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.visitor.SignaturePrinter;\n\nimport java.io.Serializable;\nimport java.util.Comparator;\n\n/**\n * Compares executables (method, executable-references) based on a signature.\n */\npublic class SignatureComparator implements Comparator<CtElement>, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic int compare(CtElement o1, CtElement o2) {\n\t\tSignaturePrinter signaturePrinter1 = new SignaturePrinter();\n\t\tSignaturePrinter signaturePrinter2 = new SignaturePrinter();\n\t\tsignaturePrinter1.scan(o1);\n\t\tsignaturePrinter2.scan(o2);\n\t\treturn signaturePrinter1.getSignature().compareTo(signaturePrinter2.getSignature());\n\t}\n\n}\n"
    }, {
      "name" : "support/comparator/FixedOrderBasedOnFileNameCompilationUnitComparator.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.comparator;\n\nimport org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n\nimport java.util.Comparator;\n\npublic class FixedOrderBasedOnFileNameCompilationUnitComparator implements Comparator<CompilationUnitDeclaration> {\n\t@Override\n\tpublic int compare(CompilationUnitDeclaration o1, CompilationUnitDeclaration o2) {\n\t\tString s1 = new String(o1.getFileName());\n\t\tString s2 = new String(o2.getFileName());\n\t\treturn s1.compareTo(s2);\n\t}\n}\n"
    }, {
      "name" : "support/comparator/DeepRepresentationComparator.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.comparator;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport java.io.Serializable;\nimport java.util.Comparator;\n\n/**\n * Compares based on a toString representation.\n */\npublic class DeepRepresentationComparator implements Comparator<CtElement>, Serializable {\n\n\t@Override\n\tpublic int compare(CtElement o1, CtElement o2) {\n\t\tif (o1.getPosition().isValidPosition() == false) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (o2.getPosition().isValidPosition() == false) {\n\t\t\treturn -1;\n\t\t}\n\t\tString current = getDeepRepresentation(o1);\n\t\tString other = getDeepRepresentation(o2);\n\t\tif (current.length() <= 0 || other.length() <= 0) {\n\t\t\tthrow new ClassCastException(\"Unable to compare elements\");\n\t\t}\n\t\treturn current.compareTo(other);\n\n\t}\n\n\tprivate String getDeepRepresentation(CtElement elem) {\n\t\treturn elem.toString();\n\t}\n\n}\n"
    }, {
      "name" : "support/comparator/CtLineElementComparator.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.comparator;\n\nimport java.io.Serializable;\nimport java.util.Comparator;\n\nimport spoon.reflect.declaration.CtElement;\n\n/**\n * Comparator of compile-time elements. Elements are sorted by position in\n * source files.\n */\npublic class CtLineElementComparator implements Comparator<CtElement>, Serializable {\n\n\t/**\n\t * Reurns -1 if o1 is before o2 in the file\n\t */\n\t@Override\n\tpublic int compare(CtElement o1, CtElement o2) {\n\t\tif (o1.getPosition().isValidPosition() == false) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (o2.getPosition().isValidPosition() == false) {\n\t\t\t// ensures that compare(x,y) = - compare(y,x)\n\t\t\treturn 1;\n\t\t}\n\n\t\tint pos1 = o1.getPosition().getSourceStart();\n\t\tint pos2 = o2.getPosition().getSourceStart();\n\n\t\tif (pos1 == pos2) {\n\t\t\tint pos3 = o1.getPosition().getSourceEnd();\n\t\t\tint pos4 = o2.getPosition().getSourceEnd();\n\t\t\treturn (pos3 < pos4) ? -1 : 1;\n\t\t}\n\n\t\treturn (pos1 < pos2) ? -1 : 1;\n\t}\n\n}\n"
    }, {
      "name" : "support/comparator/QualifiedNameComparator.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.comparator;\n\nimport java.io.Serializable;\nimport java.util.Comparator;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.reference.CtReference;\n\n/** compares based on names (with a preference for qualified names if available) */\npublic class QualifiedNameComparator implements Comparator<CtElement>, Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static final QualifiedNameComparator INSTANCE = new QualifiedNameComparator();\n\n\t@Override\n\tpublic int compare(CtElement o1, CtElement o2) {\n\t\ttry {\n\t\t\t// qualified names if available\n\t\t\t// note: there is no common interface between\n\t\t\t// CtPackage.getQualifiedName and CtTypeInformation.getQualifiedName\n\t\t\tif (o1 instanceof CtTypeInformation && o2 instanceof CtTypeInformation) {\n\t\t\t\treturn ((CtTypeInformation) o1).getQualifiedName().compareTo(((CtTypeInformation) o2).getQualifiedName());\n\t\t\t}\n\t\t\tif (o1 instanceof CtPackage && o2 instanceof CtPackage) {\n\t\t\t\treturn ((CtPackage) o1).getQualifiedName().compareTo(((CtPackage) o2).getQualifiedName());\n\t\t\t}\n\n\t\t\t// otherwise names\n\t\t\t// note: there is no common interface between\n\t\t\t// CtReference.getSimpleName and CtTNamedElement.getSimpleName\n\t\t\tif (o1 instanceof CtReference && o2 instanceof CtReference) {\n\t\t\t\treturn ((CtReference) o1).getSimpleName().compareTo(((CtReference) o2).getSimpleName());\n\t\t\t}\n\t\t\tif (o1 instanceof CtNamedElement && o2 instanceof CtNamedElement) {\n\t\t\t\treturn ((CtNamedElement) o1).getSimpleName().compareTo(((CtNamedElement) o2).getSimpleName());\n\t\t\t}\n\t\t\tthrow new IllegalArgumentException();\n\t\t} catch (NullPointerException e) {\n\t\t\t// when o1 or o2 is null, or no name are available\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\n"
    }, {
      "name" : "support/CompressionType.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\n/**\n *\tDifferent types of compressions used, e.g. for serialization\n *\t@see SerializationModelStreamer\n */\npublic enum CompressionType {\n\tNONE,\n\tGZIP,\n\tLZMA,\n\tBZIP2;\n}\n"
    }, {
      "name" : "support/template/UndefinedParameterException.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.template;\n\nimport spoon.SpoonException;\n\npublic class UndefinedParameterException extends SpoonException {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic UndefinedParameterException() {\n\t}\n\n\tpublic UndefinedParameterException(String message) {\n\t\tsuper(message);\n\t}\n\n\tpublic UndefinedParameterException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n}\n"
    }, {
      "name" : "support/template/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines the substitution and matching engines for Java templates.</p>\n */\npackage spoon.support.template;\n"
    }, {
      "name" : "support/template/Parameters.java",
      "weight" : 259.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.template;\n\nimport spoon.SpoonException;\nimport spoon.pattern.PatternBuilder;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.util.RtHelper;\nimport spoon.template.Parameter;\nimport spoon.template.Template;\nimport spoon.template.TemplateParameter;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * This class defines an API to manipulate template parameters.\n */\npublic abstract class Parameters {\n\n\tprivate Parameters() {\n\t}\n\n\t/**\n\t * The prefix \"_FIELD_\" for a parameter that represents a fields in order to\n\t * avoid name clashes.\n\t */\n\tprotected static final String fieldPrefix = \"_FIELD_\";\n\n\t/**\n\t * Gets the index of a one-dimension array (helper).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Integer getIndex(CtExpression<?> e) {\n\t\tif (e.getParent() instanceof CtArrayAccess) {\n\t\t\tCtExpression<Integer> indexExpression = ((CtArrayAccess<?, CtExpression<Integer>>) e.getParent()).getIndexExpression();\n\t\t\treturn ((CtLiteral<Integer>) indexExpression).getValue();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets a template field parameter value.\n\t */\n\tpublic static Object getValue(Template<?> template, String parameterName, Integer index) {\n\t\tField rtField = null;\n\t\ttry {\n\t\t\tfor (Field f : RtHelper.getAllFields(template.getClass())) {\n\t\t\t\tif (isParameterSource(f)) {\n\t\t\t\t\tif (parameterName.equals(getParameterName(f))) {\n\t\t\t\t\t\trtField = f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new UndefinedParameterException(e);\n\t\t}\n\t\tObject tparamValue = getValue(template, parameterName, rtField);\n\t\tif (rtField.getType().isArray() && (index != null)) {\n\t\t\ttparamValue = ((Object[]) tparamValue)[index];\n\t\t}\n\t\treturn tparamValue;\n\t}\n\tprivate static Object getValue(Template<?> template, String parameterName, Field rtField) {\n\t\tif (rtField == null) {\n\t\t\tthrow new UndefinedParameterException();\n\t\t}\n\t\ttry {\n\t\t\tif (Modifier.isFinal(rtField.getModifiers())) {\n\t\t\t\tMap<String, Object> m = finals.get(template);\n\t\t\t\tif (m == null) {\n\t\t\t\t\t//BUG: parameters marked as final will always return null, even if they have a value!\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treturn m.get(parameterName);\n\t\t\t}\n\t\t\trtField.setAccessible(true);\n\t\t\treturn rtField.get(template);\n\t\t} catch (Exception e) {\n\t\t\tthrow new UndefinedParameterException(e);\n\t\t}\n\t}\n\n\tstatic Map<Template<?>, Map<String, Object>> finals = new HashMap<>();\n\n\tpublic static CtField<?> getParameterField(CtClass<? extends Template<?>> templateClass, String parameterName) {\n\t\tfor (CtTypeMember typeMember : templateClass.getTypeMembers()) {\n\t\t\tif (!(typeMember instanceof CtField)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCtField<?> f = (CtField<?>) typeMember;\n\t\t\tParameter p = f.getAnnotation(Parameter.class);\n\t\t\tif (p == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f.getSimpleName().equals(parameterName)) {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t\tif (parameterName.equals(p.value())) {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets a template field parameter value.\n\t */\n\t@SuppressWarnings(\"null\")\n\tpublic static void setValue(Template<?> template, String parameterName, Integer index, Object value) {\n\t\ttry {\n\t\t\tField rtField = null;\n\t\t\tfor (Field f : RtHelper.getAllFields(template.getClass())) {\n\t\t\t\tif (isParameterSource(f)) {\n\t\t\t\t\tif (parameterName.equals(getParameterName(f))) {\n\t\t\t\t\t\trtField = f;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rtField == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Modifier.isFinal(rtField.getModifiers())) {\n\t\t\t\tMap<String, Object> m = finals.get(template);\n\t\t\t\tif (m == null) {\n\t\t\t\t\tfinals.put(template, m = new HashMap<>());\n\t\t\t\t}\n\t\t\t\tm.put(parameterName, value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trtField.setAccessible(true);\n\t\t\trtField.set(template, value);\n\t\t\tif (rtField.getType().isArray()) {\n\t\t\t\t// TODO: RP: THIS IS WRONG!!!! tparamValue is never used or set!\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new UndefinedParameterException();\n\t\t}\n\t}\n\n\tprivate static String getParameterName(Field f) {\n\t\tString name = f.getName();\n\t\tParameter p = f.getAnnotation(Parameter.class);\n\t\tif ((p != null) && !p.value().isEmpty()) {\n\t\t\tname = p.value();\n\t\t}\n\t\treturn name;\n\t}\n\n\tprivate static String getParameterName(CtFieldReference<?> f) {\n\t\tString name = f.getSimpleName();\n\t\tParameter p = f.getDeclaration().getAnnotation(Parameter.class);\n\t\tif ((p != null) && !p.value().isEmpty()) {\n\t\t\tname = p.value();\n\t\t}\n\t\treturn name;\n\t}\n\n\t/**\n\t * Gets the names of all the template parameters of a given template type\n\t * (including the ones defined by the super types).\n\t */\n\tpublic static List<String> getNames(CtClass<? extends Template<?>> templateType) {\n\t\tList<String> params = new ArrayList<>();\n\t\ttry {\n\t\t\tfor (CtFieldReference<?> f : templateType.getAllFields()) {\n\t\t\t\tif (isParameterSource(f)) {\n\t\t\t\t\tparams.add(getParameterName(f));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(\"Getting of template parameters failed\", e);\n\t\t}\n\t\treturn params;\n\t}\n\t/**\n\t * Gets the Map of names to template parameter value for all the template parameters of a given template type\n\t * (including the ones defined by the super types).\n\t */\n\tpublic static Map<String, Object> getNamesToValues(Template<?> template, CtClass<? extends Template<?>> templateType) {\n\t\t//use linked hash map to assure same order of parameter names. There are cases during substitution of parameters when substitution order matters. E.g. SubstitutionVisitor#substituteName(...)\n\t\tMap<String, Object> params = new LinkedHashMap<>();\n\t\ttry {\n\t\t\tfor (CtFieldReference<?> f : templateType.getAllFields()) {\n\t\t\t\tif (isParameterSource(f)) {\n\t\t\t\t\tString parameterName = getParameterName(f);\n\t\t\t\t\tparams.put(parameterName, getValue(template, parameterName, (Field) f.getActualField()));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(\"Getting of template parameters failed\", e);\n\t\t}\n\t\treturn params;\n\t}\n\n\t/**\n\t * Gets the Map of names to template parameter values for all the template parameters of a given template type\n\t * + adds mapping of template model reference to target type as parameter too\n\t * @param f\n\t * \t\tthe factory\n\t * @param targetType\n\t * \t\tthe target type of the substitution (can be null), which will be done with result parameters\n\t * @param template\n\t * \t\tthe template that holds the parameter values\n\t */\n\tpublic static Map<String, Object> getTemplateParametersAsMap(Factory f, CtType<?> targetType, Template<?> template) {\n\t\tMap<String, Object> params = new HashMap<>(getNamesToValues(template, (CtClass) f.Class().get(template.getClass())));\n\t\t//detect reference to to be generated type\n\t\tCtTypeReference<?> targetTypeRef = targetType == null ? null : targetType.getReference();\n\t\tif (targetType == null) {\n\t\t\t//legacy templates has target type stored under variable whose name was equal to simple name of template type\n\t\t\tObject targetTypeObject = params.get(template.getClass().getSimpleName());\n\t\t\tif (targetTypeObject != null) {\n\t\t\t\tif (targetTypeObject instanceof CtTypeReference<?>) {\n\t\t\t\t\ttargetTypeRef = (CtTypeReference<?>) targetTypeObject;\n\t\t\t\t} else if (targetTypeObject instanceof String) {\n\t\t\t\t\ttargetTypeRef = f.Type().createReference((String) targetTypeObject);\n\t\t\t\t} else if (targetTypeObject instanceof Class) {\n\t\t\t\t\ttargetTypeRef = f.Type().createReference((Class<?>) targetTypeObject);\n\t\t\t\t} else  {\n\t\t\t\t\tthrow new SpoonException(\"Unsupported definition of target type by value of class \" + targetTypeObject.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * there is required to replace all template model references by target type reference.\n\t\t * Handle that request as template parameter too\n\t\t */\n\t\tif (targetTypeRef != null) {\n\t\t\tparams.put(PatternBuilder.TARGET_TYPE, targetTypeRef);\n\t\t}\n\t\treturn params;\n\t}\n\n\t/**\n\t * Tells if a given field is a template parameter.\n\t */\n\tpublic static boolean isParameterSource(CtFieldReference<?> ref) {\n\t\tCtField<?> field = ref.getDeclaration();\n\t\tif (field == null) {\n\t\t\t// we must have the source of this fieldref, otherwise we cannot use it as template parameter\n\t\t\treturn false;\n\t\t}\n\t\tif (field.getAnnotation(Parameter.class) != null) {\n\t\t\t//it is the template field which represents template parameter, because of \"Parameter\" annotation\n\t\t\treturn true;\n\t\t}\n\t\tif (ref.getType() instanceof CtTypeParameterReference) {\n\t\t\t//the template fields, which are using generic type like <T>, are not template parameters\n\t\t\treturn false;\n\t\t}\n\t\tif (\"this\".equals(ref.getSimpleName())) {\n\t\t\t//the reference to this is not template parameter\n\t\t\treturn false;\n\t\t}\n\t\t//the type of template field is TemplateParameter.\n\t\treturn ref.getType().isSubtypeOf(getTemplateParameterType(ref.getFactory()));\n\t}\n\n\t/**\n\t * Tells if a given field is a template parameter.\n\t */\n\tpublic static boolean isParameterSource(Field field) {\n\t\treturn (field.getAnnotation(Parameter.class) != null) || TemplateParameter.class.isAssignableFrom(field.getType());\n\t}\n\n\tstatic CtTypeReference<TemplateParameter<?>> templateParameterType;\n\n\t@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprivate static synchronized CtTypeReference<TemplateParameter<?>> getTemplateParameterType(Factory factory) {\n\t\tif (templateParameterType == null) {\n\t\t\ttemplateParameterType = (CtTypeReference) factory.Type().createReference(TemplateParameter.class);\n\t\t}\n\t\treturn templateParameterType;\n\t}\n\n\t/**\n\t * Creates an empty template parameter of the <code>T</code> type where\n\t * {@link TemplateParameter#S()} does not return <code>null</code> in case\n\t * the template code needs to be executed such as in static initializers.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> TemplateParameter<T> NIL(Class<? extends T> type) {\n\t\tif (Number.class.isAssignableFrom(type)) {\n\t\t\treturn (TemplateParameter<T>) new TemplateParameter<Number>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Number S() {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn new TemplateParameter<T>() {\n\t\t\t@Override\n\t\t\tpublic T S() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * returns all the runtime fields of a template representing a template parameter\n\t */\n\tpublic static List<Field> getAllTemplateParameterFields(Class<? extends Template> clazz) {\n\t\tif (!Template.class.isAssignableFrom(clazz)) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tList<Field> result = new ArrayList<>();\n\t\tfor (Field f : RtHelper.getAllFields(clazz)) {\n\t\t\tif (isParameterSource(f)) {\n\t\t\t\tresult.add(f);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * returns all the compile_time fields of a template representing a template parameter\n\t */\n\tpublic static List<CtField<?>> getAllTemplateParameterFields(Class<? extends Template<?>> clazz, Factory factory) {\n\t\tCtClass<?> c = factory.Class().get(clazz);\n\t\tif (c == null) {\n\t\t\tthrow new IllegalArgumentException(\"Template not in template classpath\");\n\t\t}\n\n\t\tList<CtField<?>> result = new ArrayList<>();\n\n\t\tfor (Field f : getAllTemplateParameterFields(clazz)) {\n\t\t\tresult.add(c.getField(f.getName()));\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n"
    }, {
      "name" : "support/DefaultOutputDestinationHandler.java",
      "weight" : 60.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\n\nimport java.io.File;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\n/**\n * Default behavior for the destination of the spoon.\n */\npublic class DefaultOutputDestinationHandler implements OutputDestinationHandler {\n\n\tprivate File defaultOutputDirectory;\n\tprivate Environment environment;\n\n\tpublic DefaultOutputDestinationHandler(File defaultOutputDirectory, Environment environment) {\n\t\tthis.defaultOutputDirectory = defaultOutputDirectory;\n\t\tthis.environment = environment;\n\t}\n\n\t@Override\n\tpublic Path getOutputPath(CtModule module, CtPackage pack, CtType type) {\n\t\tPath directory = getDirectoryPath(module, pack, type);\n\t\tPath moduleDir = getModulePath(module);\n\t\tPath packagePath = getPackagePath(pack);\n\t\tString fileName = getFileName(pack, type);\n\n\t\treturn Paths.get(directory.toString(), moduleDir.toString(), packagePath.toString(), fileName);\n\t}\n\n\t/**\n\t * @return return the filename of the current element\n\t * @param pack\n\t * @param type\n\t */\n\tprotected String getFileName(CtPackage pack, CtType type) {\n\t\tString fileName;\n\t\tif (type != null) {\n\t\t\tfileName = type.getSimpleName() + DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\t\t} else if (pack != null) {\n\t\t\tfileName = DefaultJavaPrettyPrinter.JAVA_PACKAGE_DECLARATION;\n\t\t} else {\n\t\t\tfileName = DefaultJavaPrettyPrinter.JAVA_MODULE_DECLARATION;\n\t\t}\n\t\treturn fileName;\n\t}\n\n\t/**\n\t * @return the path of the package\n\t * @param pack\n\t */\n\tprotected Path getPackagePath(CtPackage pack) {\n\t\tPath packagePath = Paths.get(\".\");\n\t\tif (pack != null && !pack.isUnnamedPackage()) {\n\t\t\tpackagePath = Paths.get(pack.getQualifiedName().replace('.', File.separatorChar));\n\t\t}\n\t\treturn packagePath;\n\t}\n\n\t/**\n\t * @return return the path of the module\n\t * @param module\n\t */\n\tprotected Path getModulePath(CtModule module) {\n\t\tPath moduleDir = Paths.get(\".\");\n\t\tif (module != null && !module.isUnnamedModule() && environment.getComplianceLevel() > 8) {\n\t\t\tmoduleDir = Paths.get(module.getSimpleName());\n\t\t}\n\t\treturn moduleDir;\n\t}\n\n\t/**\n\t * @return the root path of the destination\n\t * @param module\n\t * @param pack\n\t * @param type\n\t */\n\tprotected Path getDirectoryPath(CtModule module, CtPackage pack, CtType type) {\n\t\treturn Paths.get(getDefaultOutputDirectory().getAbsolutePath());\n\t}\n\n\t@Override\n\tpublic File getDefaultOutputDirectory() {\n\t\treturn defaultOutputDirectory;\n\t}\n\n\tpublic Environment getEnvironment() {\n\t\treturn environment;\n\t}\n}\n"
    }, {
      "name" : "support/util/SortedList.java",
      "weight" : 42.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\n\npublic class SortedList<E> extends LinkedList<E> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tComparator<? super E> comparator;\n\n\tpublic SortedList(Comparator<? super E> comparator) {\n\t\tthis.comparator = comparator;\n\t}\n\n\t@Override\n\tpublic boolean add(E o) {\n\t\tfor (ListIterator<E> iterator = this.listIterator(); iterator.hasNext();) {\n\t\t\tE e = iterator.next();\n\t\t\tif (comparator.compare(o, e) < 0) {\n\t\t\t\titerator.previous();\n\t\t\t\titerator.add(o);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn super.add(o);\n\t}\n\n\t@Override\n\tpublic void add(int index, E element) {\n\t\tthrow new IllegalArgumentException(\"cannot force a position with a sorted list that has its own ordering\");\n\t}\n\n\t@Override\n\tpublic boolean addAll(Collection<? extends E> c) {\n\t\tboolean ret = true;\n\t\tfor (E e : c) {\n\t\t\tret &= add(e);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Comparator<? super E> getComparator() {\n\t\treturn comparator;\n\t}\n\n\tpublic void setComparator(Comparator<? super E> comparator) {\n\t\tthis.comparator = comparator;\n\t}\n\n}\n"
    }, {
      "name" : "support/util/EmptyIterator.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class EmptyIterator<E> implements Iterator<E> {\n\tprivate static final EmptyIterator<Object> EMPTY_ITERATOR = new EmptyIterator<>();\n\n\tpublic static <T> Iterator<T> instance() {\n\t\treturn (Iterator<T>) EMPTY_ITERATOR;\n\t}\n\n\tEmptyIterator() {\n\t}\n\n\t@Override\n\tpublic boolean hasNext() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic E next() {\n\t\tthrow new NoSuchElementException();\n\t}\n\n\t@Override\n\tpublic void remove() {\n\t\tthrow new IllegalStateException();\n\t}\n}\n"
    }, {
      "name" : "support/util/internal/MapUtils.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util.internal;\n\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\npublic abstract class MapUtils {\n\n\tprivate MapUtils() {\n\t}\n\n\t/**\n\t * @return existing value of `key` from `map`. If value doesn't exist yet for `key` yet,\n\t * then `valueCreator` is used to create new value, which is then assigned to `key` and returned\n\t */\n\tpublic static <K, V> V getOrCreate(Map<K, V> map, K key, Supplier<V> valueCreator) {\n\t\treturn getOrCreate(map, key, valueCreator, null);\n\t}\n\t/**\n\t * @param initializer is called immediately after the value is added to the map\n\t * @return existing value of `key` from `map`. If value doesn't exist yet for `key` yet,\n\t * then `valueCreator` is used to create new value, which is then assigned to `key` and returned\n\t */\n\tpublic static <K, V> V getOrCreate(Map<K, V> map, K key, Supplier<V> valueCreator, Consumer<V> initializer) {\n\t\tV value = map.get(key);\n\t\tif (value == null) {\n\t\t\tvalue = valueCreator.get();\n\t\t\tmap.put(key, value);\n\t\t\tif (initializer != null) {\n\t\t\t\tinitializer.accept(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n"
    }, {
      "name" : "support/util/SignatureBasedSortedSet.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.support.comparator.SignatureComparator;\n\nimport java.util.Collection;\nimport java.util.TreeSet;\n\n/** maintains unicity with method signatures */\npublic class SignatureBasedSortedSet<E extends CtExecutable<?>> extends TreeSet<E> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic SignatureBasedSortedSet(Collection<E> elements) {\n\t\tthis();\n\t\taddAll(elements);\n\t}\n\n\tpublic SignatureBasedSortedSet() {\n\t\tsuper(new SignatureComparator());\n\t}\n\n}\n"
    }, {
      "name" : "support/util/ImmutableMapImpl.java",
      "weight" : 104.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport spoon.support.Internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n *\n * Internal class only, not in the public API.\n *\n * Spoon implementation of {@link ImmutableMap}\n */\n@Internal\npublic class ImmutableMapImpl implements ImmutableMap {\n\n\tprotected final ImmutableMap parent;\n\tprotected final Map<String, Object> map;\n\n\tpublic ImmutableMapImpl(Map<String, Object> map) {\n\t\tthis(null, map);\n\t}\n\tprivate ImmutableMapImpl(ImmutableMap parent, Map<String, Object> map) {\n\t\tthis.parent = parent;\n\t\tthis.map = Collections.unmodifiableMap(map);\n\t}\n\n\tpublic ImmutableMapImpl(Map<String, Object> map, String parameterName, Object value) {\n\t\tthis(null, map, parameterName, value);\n\t}\n\n\tprivate ImmutableMapImpl(ImmutableMap parent, Map<String, Object> map, String parameterName, Object value) {\n\t\tthis.parent = null;\n\t\tMap<String, Object> copy = new HashMap<>(map.size() + 1);\n\t\tcopy.putAll(map);\n\t\tcopy.put(parameterName, value);\n\t\tthis.map = Collections.unmodifiableMap(copy);\n\t}\n\n\tpublic ImmutableMapImpl() {\n\t\tthis.parent = null;\n\t\tthis.map = Collections.emptyMap();\n\t}\n\n\t@Override\n\tpublic ImmutableMapImpl checkpoint() {\n\t\treturn new ImmutableMapImpl(this, Collections.emptyMap());\n\t}\n\n\t@Override\n\tpublic boolean hasValue(String parameterName) {\n\t\tif (map.containsKey(parameterName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (parent != null) {\n\t\t\treturn parent.hasValue(parameterName);\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Object getValue(String parameterName) {\n\t\tObject v = map.get(parameterName);\n\t\tif (v == null && parent != null) {\n\t\t\tv = parent.getValue(parameterName);\n\t\t}\n\t\treturn v;\n\t}\n\n\t@Override\n\tpublic ImmutableMap putValue(String parameterName, Object value) {\n\t\treturn new ImmutableMapImpl(parent, map, parameterName, value);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tappendMap(sb, map);\n\t\tif (parent != null) {\n\t\t\tsb.append(\"\\nparent:\\n\");\n\t\t\tsb.append(parent.toString());\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static void appendMap(StringBuilder sb, Map<String, Object> map) {\n\t\tList<String> paramNames = new ArrayList<>(map.keySet());\n\t\tparamNames.sort((a, b) -> a.compareTo(b));\n\t\tfor (String name : paramNames) {\n\t\t\tif (sb.length() > 0) {\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t\tsb.append(name).append('=').append(map.get(name));\n\t\t}\n\t}\n\n\t@Override\n\tpublic Map<String, Object> asMap() {\n\t\tif (parent != null) {\n\t\t\tMap<String, Object> merged = new HashMap<>();\n\t\t\tmerged.putAll(parent.asMap());\n\t\t\tmerged.putAll(map);\n\t\t\treturn Collections.unmodifiableMap(merged);\n\t\t}\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getModifiedValues() {\n\t\treturn map;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj instanceof ImmutableMap) {\n\t\t\tobj = ((ImmutableMap) obj).asMap();\n\t\t}\n\t\tif (obj instanceof Map) {\n\t\t\tMap map = (Map) obj;\n\t\t\treturn asMap().equals(map);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "support/util/ByteSerialization.java",
      "weight" : 23.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\npublic class ByteSerialization {\n\n\tprivate ByteSerialization() { }\n\n\tpublic static byte[] serialize(Object obj) throws IOException {\n\t\tByteArrayOutputStream bo = new ByteArrayOutputStream();\n\t\ttry (ObjectOutputStream so = new ObjectOutputStream(bo)) {\n\t\t\tso.writeObject(obj);\n\t\t\tso.flush();\n\t\t\treturn bo.toByteArray();\n\t\t}\n\t}\n\n\tpublic static Object deserialize(byte[] serializedObject) throws Exception {\n\t\tByteArrayInputStream bi = new ByteArrayInputStream(serializedObject);\n\t\ttry (ObjectInputStream si = new ObjectInputStream(bi)) {\n\t\t\treturn si.readObject();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/util/ImmutableMap.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.util.Map;\n\n/**\n *\n * An immutable map.\n * (eg unmodifiable storage of parameter name-value pairs).\n * The values may be primitive values or List, Set, Map of values.\n * All internal containers are unmodifiable too.\n *\n * Internal class only, not in the public API.\n */\npublic interface ImmutableMap {\n\n\t/**\n\t * @param parameterName to be checked parameter name\n\t * @return true if there is defined some value for the parameter. null can be a value too\n\t */\n\tboolean hasValue(String parameterName);\n\n\t/**\n\t * @param parameterName the name of the parameter\n\t * @return a value of the parameter under the name `parameterNamer\n\t */\n\tObject getValue(String parameterName);\n\n\t/**\n\t * @param parameterName to be set parameter name\n\t * @param value the new value\n\t * @return copies this {@link ImmutableMap}, sets the new value there and returns that copy\n\t */\n\tImmutableMap putValue(String parameterName, Object value);\n\n\t/**\n\t * @return underlying unmodifiable Map&lt;String, Object&gt;\n\t */\n\tMap<String, Object> asMap();\n\n\t/**\n\t * @return a new instance of {@link ImmutableMap}, which inherits all values from this {@link ImmutableMap}\n\t * Any call of {@link #putValue(String, Object)} is remembered in local Map of parameters.\n\t * At the end of process the {@link #getModifiedValues()} can be used to return all the parameters which were changed\n\t * after local {@link ImmutableMap} was created\n\t */\n\tImmutableMap checkpoint();\n\n\t/**\n\t * @return the modified parameters since last call to {@link #checkpoint()}\n\t */\n\tMap<String, Object> getModifiedValues();\n}\n"
    }, {
      "name" : "support/util/RtHelper.java",
      "weight" : 140.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * This class is a helper for runtime reflection.\n */\npublic abstract class RtHelper {\n\n\tprivate RtHelper() {\n\t}\n\n\t/**\n\t * Gets all the runtime fields for a given class (including the\n\t * superclasses and superinterfaces).\n\t */\n\tpublic static Field[] getAllFields(Class<?> c) {\n\t\tList<Field> fields = new ArrayList<>();\n\t\taddAllFields(c, fields);\n\t\tField[] result = new Field[fields.size()];\n\t\treturn fields.toArray(result);\n\t}\n\n\tprivate static void addAllFields(Class<?> c, List<Field> fields) {\n\t\tif (c != null && c != Object.class) {\n\t\t\tCollections.addAll(fields, c.getDeclaredFields());\n\t\t\taddAllFields(c.getSuperclass(), fields);\n\t\t\tfor (Class<?> iface : c.getInterfaces()) {\n\t\t\t\taddAllFields(iface, fields);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets all the field references for a given class (including the\n\t * superclasses').\n\t */\n\tpublic static Collection<CtFieldReference<?>> getAllFields(Class<?> c, Factory factory) {\n\t\tCollection<CtFieldReference<?>> l = new ArrayList<>();\n\t\tfor (Field f : getAllFields(c)) {\n\t\t\tl.add(factory.Field().createReference(f));\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * Gets all the runtime methods for a given class or interface (including\n\t * the superclasses' or interfaces').\n\t */\n\tpublic static Method[] getAllMethods(Class<?> c) {\n\t\tList<Method> methods = new ArrayList<>();\n\t\tif (c.isInterface()) {\n\t\t\tgetAllIMethods(c, methods);\n\t\t} else {\n\t\t\twhile (c != null && c != Object.class) {\n\t\t\t\tCollections.addAll(methods, c.getDeclaredMethods());\n\t\t\t\tc = c.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tMethod[] result = new Method[methods.size()];\n\t\treturn methods.toArray(result);\n\t}\n\n\tprivate static void getAllIMethods(Class<?> c, List<Method> methods) {\n\t\tCollections.addAll(methods, c.getDeclaredMethods());\n\t\tfor (Class<?> i : c.getInterfaces()) {\n\t\t\tgetAllIMethods(i, methods);\n\t\t}\n\t}\n\n\t/**\n\t * Actually invokes from a compile-time invocation (by using runtime\n\t * reflection).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T invoke(CtInvocation<T> i)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tObject target = i.getTarget() == null ? null : ((CtLiteral<?>) i.getTarget()).getValue();\n\t\tList<Object> args = new ArrayList<>();\n\t\tfor (CtExpression<?> e : i.getArguments()) {\n\t\t\targs.add(((CtLiteral<?>) e).getValue());\n\t\t}\n\t\tClass<?> c = i.getExecutable().getDeclaringType().getActualClass();\n\t\tArrayList<Class<?>> argTypes = new ArrayList<>();\n\t\tfor (CtTypeReference<?> type : i.getExecutable().getActualTypeArguments()) {\n\t\t\targTypes.add(type.getActualClass());\n\t\t}\n\t\treturn (T) c.getMethod(i.getExecutable().getSimpleName(), argTypes.toArray(new Class[0]))\n\t\t\t\t.invoke(target, args.toArray());\n\t}\n\n\t/**\n\t * Return the set of modifiers defined by the modifiers integer\n\t * (java.lang.reflect).\n\t */\n\tpublic static Set<ModifierKind> getModifiers(int mod) {\n\t\tSet<ModifierKind> set = new HashSet<>();\n\t\tif (Modifier.isAbstract(mod)) {\n\t\t\tset.add(ModifierKind.ABSTRACT);\n\t\t}\n\t\tif (Modifier.isFinal(mod)) {\n\t\t\tset.add(ModifierKind.FINAL);\n\t\t}\n\t\tif (Modifier.isNative(mod)) {\n\t\t\tset.add(ModifierKind.NATIVE);\n\t\t}\n\t\tif (Modifier.isPrivate(mod)) {\n\t\t\tset.add(ModifierKind.PRIVATE);\n\t\t}\n\t\tif (Modifier.isProtected(mod)) {\n\t\t\tset.add(ModifierKind.PROTECTED);\n\t\t}\n\t\tif (Modifier.isPublic(mod)) {\n\t\t\tset.add(ModifierKind.PUBLIC);\n\t\t}\n\t\tif (Modifier.isStatic(mod)) {\n\t\t\tset.add(ModifierKind.STATIC);\n\t\t}\n\t\tif (Modifier.isStrict(mod)) {\n\t\t\tset.add(ModifierKind.STRICTFP);\n\t\t}\n\t\tif (Modifier.isSynchronized(mod)) {\n\t\t\tset.add(ModifierKind.SYNCHRONIZED);\n\t\t}\n\t\tif (Modifier.isTransient(mod)) {\n\t\t\tset.add(ModifierKind.TRANSIENT);\n\t\t}\n\t\tif (Modifier.isVolatile(mod)) {\n\t\t\tset.add(ModifierKind.VOLATILE);\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * return all executables of this class\n\t */\n\tpublic static Collection<CtExecutableReference<?>> getAllExecutables(Class<?> clazz, Factory factory) {\n\t\tCollection<CtExecutableReference<?>> l = new ArrayList<>();\n\t\tfor (Method m : clazz.getDeclaredMethods()) {\n\t\t\tl.add(factory.Method().createReference(m));\n\t\t}\n\t\tfor (Constructor<?> c : clazz.getDeclaredConstructors()) {\n\t\t\tl.add(factory.Constructor().createReference(c));\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * Looks for first public method of clazz (or any super class or super interface),\n\t * whose name is equal to methodName and number of parameters is numParams\n\t * @param clazz\n\t * @param methodName\n\t * @param numParams\n\t * @return the found method or null\n\t */\n\tpublic static Method getMethod(Class<?> clazz, String methodName, int numParams) {\n\t\tMethod[] methods = clazz.getMethods();\n\t\tfor (Method method : methods) {\n\t\t\tif (method.isSynthetic() == false && method.getName().equals(methodName)) {\n\t\t\t\tClass<?>[] params = method.getParameterTypes();\n\t\t\t\tif (params.length == numParams) {\n\t\t\t\t\treturn method;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "support/util/ModelList.java",
      "weight" : 183.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\n\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.List;\n\nimport spoon.SpoonException;\nimport spoon.support.modelobs.FineModelChangeListener;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\n/**\n * The implementation of the {@link List}, which is used by Spoon model objects.\n * It assures:\n * 1) each inserted {@link CtElement} gets assigned correct parent\n * 2) each change is reported in {@link FineModelChangeListener}\n */\npublic abstract class ModelList<T extends CtElement> extends AbstractList<T> implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate List<T> list = CtElementImpl.emptyList();\n\n\tprotected ModelList() {\n\t}\n\n\tprotected abstract CtElement getOwner();\n\tprotected abstract CtRole getRole();\n\tprotected abstract int getDefaultCapacity();\n\tprotected void onSizeChanged(int newSize) {\n\t}\n\n\t@Override\n\tpublic T get(int index) {\n\t\treturn list.get(index);\n\t}\n\n\t/**\n\t * sets the new content of this List\n\t * @param elements new content of this list\n\t */\n\tpublic void set(Collection<T> elements) {\n\t\t//TODO the best would be to detect added/removed statements and to fire modifications only for them\n\t\tthis.clear();\n\t\tif (elements != null && elements.isEmpty() == false) {\n\t\t\tthis.addAll(elements);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn list.size();\n\t}\n\n\t@Override\n\tpublic T set(int index, T element) {\n\t\tT oldElement = list.get(index);\n\t\tif (oldElement == element) {\n\t\t\t//no change\n\t\t\treturn oldElement;\n\t\t}\n\t\tCtElement owner = getOwner();\n\t\tensureModifiableList();\n\t\tgetModelChangeListener().onListDelete(owner, getRole(), list, index, oldElement);\n\t\tlinkToParent(owner, element);\n\t\tgetModelChangeListener().onListAdd(owner, getRole(), list, index, element);\n\t\tlist.set(index, element);\n\t\tupdateModCount();\n\t\treturn oldElement;\n\t}\n\n\tstatic void linkToParent(CtElement owner, CtElement element) {\n\t\tif (owner.getFactory().getEnvironment().checksAreSkipped() == false && element.isParentInitialized() && element.getParent() != owner) {\n\t\t\t//the `e` already has an different parent. Check if it is still linked to that parent\n\t\t\tif (element.getRoleInParent() != null) {\n\t\t\t\tthrow new SpoonException(\"The default behavior has changed, a new check has been added! Don't worry, you can disable this check\\n\"\n\t\t\t\t\t\t\t+ \"with one of the following options:\\n\"\n\t\t\t\t\t\t\t+ \" - by configuring Spoon with getEnvironment().setSelfChecks(true)\\n\"\t\t\t\t\t\t\t+ \" - by removing the node from its previous parent (element.delete())\\n\"\n\t\t\t\t\t\t\t+ \" - by cloning the node before adding it here (element.clone())\\n\"\n\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telement.setParent(owner);\n\t}\n\n\t@Override\n\tpublic boolean contains(Object o) {\n\t\treturn list.contains(o);\n\t}\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn list.isEmpty();\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn list.toArray();\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\treturn list.toArray(a);\n\t}\n\n\t@Override\n\tpublic boolean add(T e) {\n\t\tif (e == null) {\n\t\t\treturn false;\n\t\t}\n\t\tCtElement owner = getOwner();\n\t\tensureModifiableList();\n\t\tlinkToParent(owner, e);\n\t\tgetModelChangeListener().onListAdd(owner, getRole(), list, e);\n\t\tboolean result = list.add(e);\n\t\tupdateModCount();\n\t\tonSizeChanged(list.size());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean remove(Object o) {\n\t\tif (list.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tint size = list.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\t//first do not use equals, but same\n\t\t\tif (list.get(i) == o) {\n\t\t\t\tremove(i);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tint idx = list.indexOf(o);\n\t\tif (idx >= 0) {\n\t\t\tremove(idx);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn list.containsAll(c);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tgetModelChangeListener().onListDeleteAll(getOwner(), getRole(), list, new ArrayList<>(list));\n\t\tlist = CtElementImpl.emptyList();\n\t\tmodCount++;\n\t\tonSizeChanged(list.size());\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\treturn list.equals(o);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn list.hashCode();\n\t}\n\n\t@Override\n\tpublic void add(int index, T element) {\n\t\tif (element == null) {\n\t\t\treturn;\n\t\t}\n\t\tCtElement owner = getOwner();\n\t\tensureModifiableList();\n\t\tlinkToParent(owner, element);\n\t\tgetModelChangeListener().onListAdd(owner, getRole(), list, index, element);\n\t\tlist.add(index, element);\n\t\tupdateModCount();\n\t\tonSizeChanged(list.size());\n\t}\n\n\t@Override\n\tpublic T remove(int index) {\n\t\tT oldElement = list.get(index);\n\t\tgetModelChangeListener().onListDelete(getOwner(), getRole(), list, index, oldElement);\n\t\tlist.remove(index);\n\t\tupdateModCount();\n\t\tonSizeChanged(list.size());\n\t\treturn oldElement;\n\t}\n\n\t@Override\n\tpublic int indexOf(Object o) {\n\t\treturn list.indexOf(o);\n\t}\n\n\t@Override\n\tpublic int lastIndexOf(Object o) {\n\t\treturn list.lastIndexOf(o);\n\t}\n\n\t/**\n\t * This ArrayList wrapper is needed to get access to protected ArrayList#modCount\n\t * To be able to read modCount from `list` and to copy it into this.modCount\n\t * To manage the {@link ConcurrentModificationException}.\n\t * See https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html#modCount\n\t */\n\tprivate static class InternalList<T> extends ArrayList<T> {\n\t\tInternalList(int initialCapacity) {\n\t\t\tsuper(initialCapacity);\n\t\t}\n\n\t\tint getModCount() {\n\t\t\treturn modCount;\n\t\t}\n\t}\n\n\tprotected void updateModCount() {\n\t\tif (list instanceof InternalList) {\n\t\t\tmodCount = ((InternalList) list).getModCount();\n\t\t}\n\t}\n\n\tprivate void ensureModifiableList() {\n\t\tif (list == CtElementImpl.<T>emptyList()) {\n\t\t\tlist = new InternalList<>(getDefaultCapacity());\n\t\t}\n\t}\n\n\tprivate FineModelChangeListener getModelChangeListener() {\n\t\treturn getOwner().getFactory().getEnvironment().getModelChangeListener();\n\t}\n}\n"
    }, {
      "name" : "support/util/EmptyClearableSet.java",
      "weight" : 52.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.io.Serializable;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic final class EmptyClearableSet<E> extends AbstractSet<E> implements Serializable {\n\tprivate static final long serialVersionUID = 0L;\n\n\tprivate static final EmptyClearableSet<Object> EMPTY_SET = new EmptyClearableSet<>();\n\n\tpublic static <T> Set<T> instance() {\n\t\treturn (Set<T>) EMPTY_SET;\n\t}\n\n\tprivate EmptyClearableSet() {\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treturn EmptyIterator.instance();\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean contains(Object obj) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn c.isEmpty();\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn new Object[0];\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\tif (a.length > 0) {\n\t\t\ta[0] = null;\n\t\t}\n\t\treturn a;\n\t}\n\n\t// Preserves singleton property\n\tprivate Object readResolve() {\n\t\treturn EMPTY_SET;\n\t}\n}\n"
    }, {
      "name" : "support/util/QualifiedNameBasedSortedSet.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.util.Collection;\nimport java.util.TreeSet;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.comparator.QualifiedNameComparator;\n\npublic class QualifiedNameBasedSortedSet<E extends CtElement> extends\n\t\tTreeSet<E> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic QualifiedNameBasedSortedSet(Collection<E> elements) {\n\t\tthis();\n\t\taddAll(elements);\n\t}\n\n\tpublic QualifiedNameBasedSortedSet() {\n\t\tsuper(new QualifiedNameComparator());\n\t}\n\n}\n"
    }, {
      "name" : "support/util/ModelSet.java",
      "weight" : 122.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.io.Serializable;\nimport java.util.AbstractSet;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport spoon.SpoonException;\nimport spoon.support.modelobs.FineModelChangeListener;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport static spoon.support.util.ModelList.linkToParent;\n\n/**\n * The implementation of the {@link Set}, which is used by Spoon model objects.\n * It assures:\n * 1) each inserted {@link CtElement} gets assigned correct parent\n * 2) each change is reported in {@link FineModelChangeListener}\n */\npublic abstract class ModelSet<T extends CtElement> extends AbstractSet<T> implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate final Set<T> set;\n\n\tprotected ModelSet(Comparator<? super CtElement> comparator) {\n\t\tset = new TreeSet<>(comparator);\n\t}\n\n\tprotected abstract CtElement getOwner();\n\tprotected abstract CtRole getRole();\n\tprotected void onSizeChanged(int newSize) {\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn set.size();\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn set.isEmpty();\n\t}\n\n\t@Override\n\tpublic boolean contains(Object o) {\n\t\treturn set.contains(o);\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn set.toArray();\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\treturn set.toArray(a);\n\t}\n\n\t@Override\n\tpublic boolean add(T e) {\n\t\tif (e == null || set.contains(e)) {\n\t\t\treturn false;\n\t\t}\n\t\tCtElement owner = getOwner();\n\t\tlinkToParent(owner, e);\n\t\tgetModelChangeListener().onSetAdd(owner, getRole(), set, e);\n\t\tset.add(e);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean remove(Object o) {\n\t\tif (set.contains(o) == false) {\n\t\t\treturn false;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tT e = (T) o;\n\t\tgetModelChangeListener().onSetDelete(getOwner(), getRole(), set, e);\n\t\tif (set.remove(o) == false) {\n\t\t\tthrow new SpoonException(\"Element was contained in the Set, but Set#remove returned false. Not removed??\");\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn set.containsAll(c);\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tif (set.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\t\tgetModelChangeListener().onSetDeleteAll(getOwner(), getRole(), set, new LinkedHashSet<>(set));\n\t\tset.clear();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\treturn set.equals(o);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn set.hashCode();\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\n\t\treturn new Itr();\n\t}\n\n\tprivate class Itr implements Iterator<T> {\n\t\tfinal Iterator<T> delegate;\n\t\tT lastReturned = null;\n\t\tItr() {\n\t\t\tdelegate = set.iterator();\n\t\t}\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn delegate.hasNext();\n\t\t}\n\t\t@Override\n\t\tpublic T next() {\n\t\t\tlastReturned = delegate.next();\n\t\t\treturn lastReturned;\n\t\t}\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tModelSet.this.remove(lastReturned);\n\t\t}\n\t}\n\n\tprivate FineModelChangeListener getModelChangeListener() {\n\t\treturn getOwner().getFactory().getEnvironment().getModelChangeListener();\n\t}\n\n\tpublic void set(Collection<T> elements) {\n\t\t//TODO the best would be to detect added/removed statements and to fire modifications only for them\n\t\tthis.clear();\n\t\tif (elements != null && elements.isEmpty() == false) {\n\t\t\tthis.addAll(elements);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/util/EmptyClearableList.java",
      "weight" : 98.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.util;\n\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\nimport java.util.RandomAccess;\n\npublic final class EmptyClearableList<E> extends AbstractList<E> implements RandomAccess, Serializable {\n\tprivate static final long serialVersionUID = 0L;\n\n\tprivate static final EmptyClearableList<Object> EMPTY_LIST = new EmptyClearableList<>();\n\n\tpublic static <T> List<T> instance() {\n\t\treturn (List<T>) EMPTY_LIST;\n\t}\n\n\tprivate EmptyClearableList() {\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic Iterator<E> iterator() {\n\t\treturn EmptyIterator.instance();\n\t}\n\n\t@Override\n\tpublic ListIterator<E> listIterator() {\n\t\treturn (ListIterator<E>) EmptyListIterator.EMPTY_LIST_ITERATOR;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean contains(Object obj) {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean containsAll(Collection<?> c) {\n\t\treturn c.isEmpty();\n\t}\n\n\t@Override\n\tpublic Object[] toArray() {\n\t\treturn new Object[0];\n\t}\n\n\t@Override\n\tpublic <T> T[] toArray(T[] a) {\n\t\tif (a.length > 0) {\n\t\t\ta[0] = null;\n\t\t}\n\t\treturn a;\n\t}\n\n\t@Override\n\tpublic E get(int index) {\n\t\tthrow new IndexOutOfBoundsException(\"Index: \" + index);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\treturn (o instanceof List) && ((List<?>) o).isEmpty();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn 1;\n\t}\n\n\t// Preserves singleton property\n\tprivate Object readResolve() {\n\t\treturn EMPTY_LIST;\n\t}\n\n\tprivate static final class EmptyListIterator<E> extends EmptyIterator<E> implements ListIterator<E> {\n\t\tstatic final EmptyListIterator<Object> EMPTY_LIST_ITERATOR = new EmptyListIterator<>();\n\n\t\t@Override\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic E previous() {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextIndex() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int previousIndex() {\n\t\t\treturn -1;\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(E e) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\n\t\t@Override\n\t\tpublic void add(E e) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/RuntimeProcessingManager.java",
      "weight" : 103.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport org.apache.log4j.Level;\nimport spoon.processing.ProcessInterruption;\nimport spoon.processing.ProcessingManager;\nimport spoon.processing.Processor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.visitor.ProcessingVisitor;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * This processing manager implements a blocking processing policy that consists\n * of applying the processors in a FIFO order until no processors remain to be\n * applied.\n */\npublic class RuntimeProcessingManager implements ProcessingManager {\n\tProcessor<?> current;\n\n\tFactory factory;\n\n\tList<Processor<?>> processors;\n\n\tProcessingVisitor visitor;\n\n\t/**\n\t * Creates a new processing manager that maintains a queue of processors to\n\t * be applied to a given factory.\n\t *\n\t * @param factory\n\t * \t\tthe factory on which the processing applies (contains the\n\t * \t\tmeta-model)\n\t */\n\tpublic RuntimeProcessingManager(Factory factory) {\n\t\tsetFactory(factory);\n\t}\n\n\t@Override\n\tpublic void addProcessor(Class<? extends Processor<?>> type) {\n\t\ttry {\n\t\t\tProcessor<?> p = type.newInstance();\n\t\t\tp.setFactory(factory);\n\t\t\tp.init();\n\t\t\taddProcessor(p);\n\t\t} catch (Exception e) {\n\t\t\tfactory.getEnvironment().report(null, Level.ERROR, \"Unable to instantiate processor \\\"\" + type.getName() + \"\\\" - Your processor should have a constructor with no arguments\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean addProcessor(Processor<?> p) {\n\t\tp.setFactory(getFactory());\n\t\treturn getProcessors().add(p);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void addProcessor(String qualifiedName) {\n\t\ttry {\n\t\t\taddProcessor((Class<? extends Processor<?>>) getFactory().getEnvironment().getInputClassLoader().loadClass(qualifiedName));\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tfactory.getEnvironment().report(null, Level.ERROR, \"Unable to load processor \\\"\" + qualifiedName + \"\\\" - Check your classpath.\");\n\t\t}\n\t}\n\n\tpublic Processor<?> getCurrentProcessor() {\n\t\treturn current;\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic List<Processor<?>> getProcessors() {\n\t\tif (processors == null) {\n\t\t\tprocessors = new LinkedList<>();\n\t\t}\n\t\treturn processors;\n\t}\n\n\tprivate ProcessingVisitor getVisitor() {\n\t\tif (visitor == null) {\n\t\t\tvisitor = new ProcessingVisitor(getFactory());\n\t\t}\n\t\treturn visitor;\n\t}\n\n\t@Override\n\tpublic void process(Collection<? extends CtElement> elements) {\n\t\tfor (Processor<?> p : getProcessors()) {\n\t\t\tcurrent = p;\n\t\t\tprocess(elements, p);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively processes elements and their children with a given processor.\n\t */\n\tpublic void process(Collection<? extends CtElement> elements, Processor<?> processor) {\n\t\ttry {\n\t\t\tgetFactory().getEnvironment().debugMessage(\"processing with '\" + processor.getClass().getName() + \"'...\");\n\t\t\tcurrent = processor;\n\t\t\tfor (CtElement e : elements) {\n\t\t\t\tprocess(e, processor);\n\t\t\t}\n\t\t} catch (ProcessInterruption ignored) {\n\t\t}\n\t}\n\n\t@Override\n\tpublic void process(CtElement element) {\n\t\tfor (Processor<?> p : getProcessors()) {\n\t\t\tcurrent = p;\n\t\t\tprocess(element, p);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively processes an element and its children with a given processor.\n\t */\n\tpublic void process(CtElement element, Processor<?> processor) {\n\t\tgetFactory().getEnvironment().debugMessage(\n\t\t\t\t\"processing '\" + ((element instanceof CtNamedElement) ? ((CtNamedElement) element).getSimpleName() : element.toString()) + \"' with '\" + processor.getClass().getName() + \"'...\");\n\t\tprocessor.init();\n\t\tgetVisitor().setProcessor(processor);\n\t\tgetVisitor().scan(element);\n\t\tprocessor.processingDone();\n\t}\n\n\t@Override\n\tpublic void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t\tfactory.getEnvironment().setManager(this);\n\t}\n\n\n}\n"
    }, {
      "name" : "support/SerializationModelStreamer.java",
      "weight" : 70.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.commons.compress.compressors.CompressorException;\nimport org.apache.commons.compress.compressors.CompressorStreamFactory;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream;\nimport org.apache.commons.compress.compressors.lzma.LZMACompressorInputStream;\nimport org.apache.commons.compress.compressors.lzma.LZMACompressorOutputStream;\n\nimport spoon.Launcher;\nimport spoon.reflect.ModelStreamer;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.Filter;\n\n/**\n * This class provides a regular Java serialization-based implementation of the\n * model streamer.\n */\npublic class SerializationModelStreamer implements ModelStreamer {\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic SerializationModelStreamer() {\n\t}\n\n\t@Override\n\tpublic void save(Factory f, OutputStream out) throws IOException {\n\t\tif (f.getEnvironment().getCompressionType() == CompressionType.GZIP) {\n\t\t\tout = new GZIPOutputStream(out);\n\t\t} else if (f.getEnvironment().getCompressionType() == CompressionType.LZMA) {\n\t\t\tout = new LZMACompressorOutputStream(out);\n\t\t} else if (f.getEnvironment().getCompressionType() == CompressionType.BZIP2) {\n\t\t\tout = new BZip2CompressorOutputStream(out);\n\t\t}\n\t\ttry (ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(out))) {\n\t\t\toos.writeObject(f);\n\t\t\toos.flush();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Factory load(InputStream in) throws IOException {\n\t\ttry {\n\t\t\tBufferedInputStream buffered = new BufferedInputStream(in);\n\t\t\ttry {\n\t\t\t\tString s = CompressorStreamFactory.detect(buffered);\n\t\t\t\tif (s.equals(CompressorStreamFactory.GZIP)) {\n\t\t\t\t\tin = new GZIPInputStream(buffered);\n\t\t\t\t} else if (s.equals(CompressorStreamFactory.LZMA)) {\n\t\t\t\t\tin = new LZMACompressorInputStream(buffered);\n\t\t\t\t} else if (s.equals(CompressorStreamFactory.BZIP2)) {\n\t\t\t\t\tin = new BZip2CompressorInputStream(buffered);\n\t\t\t\t}\n\t\t\t} catch (CompressorException e) {\n\t\t\t\tin = buffered;\n\t\t\t}\n\t\t\tObjectInputStream ois = new ObjectInputStream(in);\n\t\t\tfinal Factory f = (Factory) ois.readObject();\n\t\t\t//create query using factory directly\n\t\t\t//because any try to call CtElement#map or CtElement#filterChildren will fail on uninitialized factory\n\t\t\tf.createQuery(f.Module().getAllModules().toArray()).filterChildren(new Filter<CtElement>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean matches(CtElement e) {\n\t\t\t\t\te.setFactory(f);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}).list();\n\t\t\treturn f;\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\tthrow new IOException(e.getMessage());\n\t\t}\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/reference/CtTypeReferenceImpl.java",
      "weight" : 718.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.SpoonClassNotFoundException;\nimport spoon.support.reflect.declaration.CtElementImpl;\nimport spoon.support.util.RtHelper;\nimport spoon.support.util.internal.MapUtils;\nimport spoon.support.visitor.ClassTypingContext;\n\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.DECLARING_TYPE;\nimport static spoon.reflect.path.CtRole.IS_SHADOW;\nimport static spoon.reflect.path.CtRole.PACKAGE_REF;\nimport static spoon.reflect.path.CtRole.TYPE_ARGUMENT;\n\npublic class CtTypeReferenceImpl<T> extends CtReferenceImpl implements CtTypeReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> actualTypeArguments = CtElementImpl.emptyList();\n\n\t@MetamodelPropertyField(role = DECLARING_TYPE)\n\tCtTypeReference<?> declaringType;\n\n\t@MetamodelPropertyField(role = PACKAGE_REF)\n\tprivate CtPackageReference pack;\n\n\tpublic CtTypeReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTypeReference(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> box() {\n\t\tif (!isPrimitive()) {\n\t\t\treturn this;\n\t\t}\n\t\tif (\"int\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Integer.class);\n\t\t}\n\t\tif (\"float\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Float.class);\n\t\t}\n\t\tif (\"long\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Long.class);\n\t\t}\n\t\tif (\"char\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Character.class);\n\t\t}\n\t\tif (\"double\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Double.class);\n\t\t}\n\t\tif (\"boolean\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Boolean.class);\n\t\t}\n\t\tif (\"short\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Short.class);\n\t\t}\n\t\tif (\"byte\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Byte.class);\n\t\t}\n\t\tif (\"void\".equals(getSimpleName())) {\n\t\t\treturn getFactory().Type().createReference(Void.class);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getActualClass() {\n\t\tif (isPrimitive()) {\n\t\t\tString simpleN = getSimpleName();\n\t\t\tif (\"boolean\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) boolean.class;\n\t\t\t} else if (\"byte\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) byte.class;\n\t\t\t} else if (\"double\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) double.class;\n\t\t\t} else if (\"int\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) int.class;\n\t\t\t} else if (\"short\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) short.class;\n\t\t\t} else if (\"char\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) char.class;\n\t\t\t} else if (\"long\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) long.class;\n\t\t\t} else if (\"float\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) float.class;\n\t\t\t} else if (\"void\".equals(simpleN)) {\n\t\t\t\treturn (Class<T>) void.class;\n\t\t\t}\n\t\t}\n\t\treturn findClass();\n\t}\n\n\tprivate static Map<String, Class> classByQName = Collections.synchronizedMap(new HashMap<>());\n\tprivate static ClassLoader lastClassLoader = null;\n\n\t/**\n\t * Finds the class requested in {@link #getActualClass()}.\n\t *\n\t * Looks for the class in the standard Java classpath, but also in the sourceClassPath given as option.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected Class<T> findClass() {\n\t\tString qualifiedName = getQualifiedName();\n\t\tClassLoader classLoader = getFactory().getEnvironment().getInputClassLoader();\n\n\t\t// an array class should not crash\n\t\t// see https://github.com/INRIA/spoon/pull/2882\n\t\tif (getSimpleName().contains(\"[]\")) {\n\t\t\t// Class.forName does not work for primitive types and arrays :-(\n\t\t\t// we have to work-around\n\t\t\t// original idea from https://bugs.openjdk.java.net/browse/JDK-4031337\n\t\t\treturn (Class<T>) RtHelper.getAllFields((Launcher.parseClass(\"public class Foo { public \" + getQualifiedName() + \" field; }\").newInstance().getClass()))[0].getType();\n\t\t}\n\n\t\tif (classLoader != lastClassLoader) {\n\t\t\t//clear cache because class loader changed\n\t\t\tclassByQName.clear();\n\t\t\tlastClassLoader = classLoader;\n\t\t}\n\t\treturn MapUtils.getOrCreate(classByQName, qualifiedName, () -> {\n\t\t\ttry {\n\t\t\t\t// creating a classloader on the fly is not the most efficient\n\t\t\t\t// but it decreases the amount of state to maintain\n\t\t\t\t// since getActualClass is only used in rare cases, that's OK.\n\t\t\t\treturn (Class<T>) classLoader.loadClass(qualifiedName);\n\t\t\t} catch (Throwable e) {\n\t\t\t\tthrow new SpoonClassNotFoundException(\"cannot load class: \" + getQualifiedName(), e);\n\t\t\t}\n\t\t});\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getActualTypeArguments() {\n\t\treturn actualTypeArguments;\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\treturn getActualClass();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtType<T> getDeclaration() {\n\t\treturn getFactory().Type().get(getQualifiedName());\n\t}\n\n\t@Override\n\tpublic CtType<T> getTypeDeclaration() {\n\t\tCtType<T> t = getFactory().Type().get(getQualifiedName());\n\t\tif (t != null) {\n\t\t\treturn t;\n\t\t}\n\t\ttry {\n\t\t\treturn getFactory().Type().get(getActualClass());\n\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\t// this only happens in noclasspath\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getDeclaringType() {\n\t\treturn declaringType;\n\t}\n\n\t@Override\n\tpublic CtPackageReference getPackage() {\n\t\treturn pack;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\tif (getDeclaringType() != null) {\n\t\t\treturn getDeclaringType().getQualifiedName() + CtType.INNERTTYPE_SEPARATOR + getSimpleName();\n\t\t} else if (getPackage() != null && !getPackage().isUnnamedPackage()) {\n\t\t\treturn getPackage().getSimpleName() + CtPackage.PACKAGE_SEPARATOR + getSimpleName();\n\t\t} else {\n\t\t\treturn getSimpleName();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isPrimitive() {\n\t\treturn (\"boolean\".equals(getSimpleName()) || \"byte\".equals(getSimpleName()) || \"double\".equals(getSimpleName()) || \"int\".equals(getSimpleName()) || \"short\".equals(getSimpleName())\n\t\t\t\t|| \"char\".equals(getSimpleName()) || \"long\".equals(getSimpleName()) || \"float\".equals(getSimpleName()) || \"void\".equals(getSimpleName()));\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\tif (type instanceof CtTypeParameterReference) {\n\t\t\treturn false;\n\t\t}\n\t\tif (NULL_TYPE_NAME.equals(getSimpleName()) || NULL_TYPE_NAME.equals(type.getSimpleName())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (isPrimitive() || type.isPrimitive()) {\n\t\t\treturn equals(type);\n\t\t}\n\t\tif (this instanceof CtArrayTypeReference) {\n\t\t\tif (type instanceof CtArrayTypeReference) {\n\t\t\t\treturn ((CtArrayTypeReference<?>) this).getComponentType().isSubtypeOf(((CtArrayTypeReference<?>) type).getComponentType());\n\t\t\t}\n\t\t\tif (Array.class.getName().equals(type.getQualifiedName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (Object.class.getName().equals(type.getQualifiedName())) {\n\t\t\t//everything is a sub type of Object\n\t\t\treturn true;\n\t\t}\n\t\treturn new ClassTypingContext(this).isSubtypeOf(type);\n\t}\n\n\t/**\n\t * Detects if this type is an code responsible for implementing of that type.<br>\n\t * In means it detects whether this type can access protected members of that type\n\t * @return true if this type or any declaring type recursively is subtype of type or directly is the type.\n\t */\n\tprivate boolean isImplementationOf(CtTypeReference<?> type) {\n\t\tCtTypeReference<?> impl = this;\n\t\twhile (impl != null) {\n\t\t\tif (impl.isSubtypeOf(type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\timpl = impl.getDeclaringType();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <C extends CtActualTypeContainer> C setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments) {\n\t\tif (actualTypeArguments == null || actualTypeArguments.isEmpty()) {\n\t\t\tthis.actualTypeArguments = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.actualTypeArguments = new ArrayList<>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, TYPE_ARGUMENT, this.actualTypeArguments, new ArrayList<>(this.actualTypeArguments));\n\t\tthis.actualTypeArguments.clear();\n\t\tfor (CtTypeReference<?> actualTypeArgument : actualTypeArguments) {\n\t\t\taddActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypeReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {\n\t\tif (declaringType != null) {\n\t\t\tdeclaringType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, DECLARING_TYPE, declaringType, this.declaringType);\n\t\tthis.declaringType = declaringType;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypeReference<T>> C setPackage(CtPackageReference pack) {\n\t\tif (pack != null) {\n\t\t\tpack.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, PACKAGE_REF, pack, this.pack);\n\t\tthis.pack = pack;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtIntersectionTypeReference<T> asCtIntersectionTypeReference() {\n\t\treturn (CtIntersectionTypeReference<T>) this;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> unbox() {\n\t\tif (isPrimitive()) {\n\t\t\treturn this;\n\t\t}\n\t\tClass<T> actualClass;\n\t\ttry {\n\t\t\tactualClass = getActualClass();\n\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\treturn this;\n\t\t}\n\t\tif (actualClass == Integer.class) {\n\t\t\treturn getFactory().Type().createReference(int.class);\n\t\t}\n\t\tif (actualClass == Float.class) {\n\t\t\treturn getFactory().Type().createReference(float.class);\n\t\t}\n\t\tif (actualClass == Long.class) {\n\t\t\treturn getFactory().Type().createReference(long.class);\n\t\t}\n\t\tif (actualClass == Character.class) {\n\t\t\treturn getFactory().Type().createReference(char.class);\n\t\t}\n\t\tif (actualClass == Double.class) {\n\t\t\treturn getFactory().Type().createReference(double.class);\n\t\t}\n\t\tif (actualClass == Boolean.class) {\n\t\t\treturn getFactory().Type().createReference(boolean.class);\n\t\t}\n\t\tif (actualClass == Short.class) {\n\t\t\treturn getFactory().Type().createReference(short.class);\n\t\t}\n\t\tif (actualClass == Byte.class) {\n\t\t\treturn getFactory().Type().createReference(byte.class);\n\t\t}\n\t\tif (actualClass == Void.class) {\n\t\t\treturn getFactory().Type().createReference(void.class);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic Collection<CtFieldReference<?>> getDeclaredFields() {\n\t\tCtType<?> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getDeclaredFields();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tprivate void handleParentNotFound(SpoonClassNotFoundException cnfe) {\n\t\tString msg = \"cannot load class: \" + getQualifiedName() + \" with class loader \"\n\t\t\t\t+ Thread.currentThread().getContextClassLoader();\n\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t// should not be thrown in 'noClasspath' environment (#775)\n\t\t\tLauncher.LOGGER.warn(msg);\n\t\t} else {\n\t\t\tthrow cnfe;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtFieldReference<?> getDeclaredField(String name) {\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtType<?> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getDeclaredField(name);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtFieldReference<?> getDeclaredOrInheritedField(String fieldName) {\n\t\tCtType<?> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getDeclaredOrInheritedField(fieldName);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getDeclaredExecutables() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t == null) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\treturn Collections.emptyList();\n\t\t\t} else {\n\t\t\t\tthrow new SpoonException(\"Type not found \" + getQualifiedName());\n\t\t\t}\n\t\t} else {\n\t\t\treturn t.getDeclaredExecutables();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Collection<CtFieldReference<?>> getAllFields() {\n\t\tCtType<?> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getAllFields();\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getAllExecutables() {\n\t\tCollection<CtExecutableReference<?>> l = new ArrayList<>();\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\tl.addAll(t.getAllExecutables());\n\t\t}\n\t\treturn l;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getModifiers();\n\t\t}\n\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn t.getSuperclass();\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtTypeReference<?>> getSuperInterfaces() {\n\t\t//we need a interface type references whose parent is connected to CtType, otherwise TypeParameterReferences cannot be resolved well\n\t\tCtType<?> t = getTypeDeclaration();\n\t\tif (t != null) {\n\t\t\treturn Collections.unmodifiableSet(t.getSuperInterfaces());\n\t\t}\n\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t}\n\n\t@Override\n\tpublic boolean isAnonymous() {\n\t\ttry {\n\t\t\tInteger.parseInt(getSimpleName());\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isLocalType() {\n\t\tif (this.getDeclaration() != null) {\n\t\t\treturn (this.getDeclaration().isLocalType());\n\t\t}\n\t\t// A local type doesn't have a fully qualified name but have an identifier\n\t\t// to know which is the local type member wanted by the developer.\n\t\t// Oracle documentation: https://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html#jls-6.7\n\t\t// JDT documentation: http://help.eclipse.org/juno/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ITypeBinding.html#getQualifiedName()\n\t\tfinal Pattern pattern = Pattern.compile(\"^([0-9]+)([a-zA-Z]+)$\");\n\t\tfinal Matcher m = pattern.matcher(getSimpleName());\n\t\treturn m.find();\n\t}\n\n\t@Override\n\tpublic <C extends CtActualTypeContainer> C addActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (actualTypeArgument == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tactualTypeArguments = new ArrayList<>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tactualTypeArgument.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, TYPE_ARGUMENT, this.actualTypeArguments, actualTypeArgument);\n\t\tactualTypeArguments.add(actualTypeArgument);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, TYPE_ARGUMENT, actualTypeArguments, actualTypeArguments.indexOf(actualTypeArgument), actualTypeArgument);\n\t\treturn actualTypeArguments.remove(actualTypeArgument);\n\t}\n\n\t@Override\n\tpublic boolean isClass() {\n\t\tCtType<T> t = getTypeDeclaration();\n\n\t\tif (t == null) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn t.isClass();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isInterface() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t == null) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn t.isInterface();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isAnnotationType() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t == null) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn t.isAnnotationType();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isEnum() {\n\t\tCtType<T> t = getTypeDeclaration();\n\t\tif (t == null) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthrow new SpoonClassNotFoundException(getQualifiedName() + \" cannot be found\");\n\t\t\t}\n\t\t} else {\n\t\t\treturn t.isEnum();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean canAccess(CtTypeReference<?> type) {\n\t\ttry {\n\t\t\tif (type.getTypeDeclaration() == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tSet<ModifierKind> modifiers = type.getModifiers();\n\n\t\t\tif (modifiers.contains(ModifierKind.PUBLIC)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (modifiers.contains(ModifierKind.PROTECTED)) {\n\t\t\t\t//the accessed type is protected in scope of declaring type.\n\t\t\t\tCtTypeReference<?> declaringType = type.getDeclaringType();\n\t\t\t\tif (declaringType == null) {\n\t\t\t\t\t//top level type cannot be protected. So this is a model inconsistency.\n\t\t\t\t\tthrow new SpoonException(\"The protected class \" + type.getQualifiedName() + \" has no declaring class.\");\n\t\t\t\t}\n\t\t\t\tif (isImplementationOf(declaringType)) {\n\t\t\t\t\t//type is visible in code which implements declaringType\n\t\t\t\t\treturn true;\n\t\t\t\t} //else it is visible in same package, like package protected\n\t\t\t\treturn isInSamePackage(type);\n\t\t\t}\n\t\t\tif (modifiers.contains(ModifierKind.PRIVATE)) {\n\t\t\t\t//it is visible in scope of the same class only\n\t\t\t\treturn type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n\t\t\t}\n\t\t\t/*\n\t\t\t * no modifier, we have to check if it is nested type and if yes, if parent is interface or class.\n\t\t\t * In case of no parent then implicit access is package protected\n\t\t\t * In case of parent is interface, then implicit access is PUBLIC\n\t\t\t * In case of parent is class, then implicit access is package protected\n\t\t\t */\n\t\t\tCtTypeReference<?> declaringTypeRef = type.getDeclaringType();\n\t\t\tif (declaringTypeRef != null && declaringTypeRef.isInterface()) {\n\t\t\t\t//the declaring type is interface, then implicit access is PUBLIC\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//package protected\n\t\t\t//visible only in scope of the same package\n\t\t\treturn isInSamePackage(type);\n\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\thandleParentNotFound(e);\n\t\t\t//if the modifiers cannot be resolved then we expect that it is visible\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean canAccess(CtTypeMember typeMember) {\n\t\tCtType<?> declaringType = typeMember.getDeclaringType();\n\t\tif (declaringType == null) {\n\t\t\t//noclasspath mode\n\t\t\treturn true;\n\t\t}\n\t\tCtTypeReference<?> declaringTypeRef = declaringType.getReference();\n\t\tif (!canAccess(declaringTypeRef)) {\n\t\t\treturn false;\n\t\t}\n\t\tSet<ModifierKind> modifiers = typeMember.getModifiers();\n\n\t\tif (modifiers.contains(ModifierKind.PUBLIC)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (modifiers.contains(ModifierKind.PROTECTED)) {\n\t\t\tif (isImplementationOf(declaringTypeRef)) {\n\t\t\t\t//type is visible in code which implements declaringType\n\t\t\t\treturn true;\n\t\t\t} //else it is visible in same package, like package protected\n\t\t\treturn isInSamePackage(declaringTypeRef);\n\t\t}\n\t\tif (modifiers.contains(ModifierKind.PRIVATE)) {\n\t\t\t//it is visible in scope of the same class only\n\t\t\treturn declaringType.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n\t\t}\n\t\t/*\n\t\t * no modifier, we have to check if it is nested type and if yes, if parent is interface or class.\n\t\t * In case of no parent then implicit access is package protected\n\t\t * In case of parent is interface, then implicit access is PUBLIC\n\t\t * In case of parent is class, then implicit access is package protected\n\t\t */\n\t\tCtType<?> declaringTypeDeclaringType = declaringType.getDeclaringType();\n\t\tif (declaringTypeDeclaringType != null && declaringTypeDeclaringType.isInterface()) {\n\t\t\t//the declaring type is interface, then implicit access is PUBLIC\n\t\t\treturn true;\n\t\t}\n\t\t//package protected\n\t\t//visible only in scope of the same package\n\t\treturn isInSamePackage(declaringTypeRef);\n\t}\n\n\tprivate boolean isInSamePackage(CtTypeReference<?> type) {\n\t\treturn type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName());\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTopLevelType() {\n\t\tCtTypeReference<?> type = this;\n\t\twhile (true) {\n\t\t\tCtTypeReference<?> parentType = type.getDeclaringType();\n\t\t\tif (parentType == null) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\ttype = parentType;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getAccessType() {\n\t\tCtTypeReference<?> declType = this.getDeclaringType();\n\t\tif (declType == null) {\n\t\t\tthrow new SpoonException(\"The declaring type is expected, but \" + getQualifiedName() + \" is top level type\");\n\t\t}\n\t\tCtType<?> contextType = getParent(CtType.class);\n\t\tif (contextType == null) {\n\t\t\treturn declType;\n\t\t}\n\t\tCtTypeReference<?> contextTypeRef = contextType.getReference();\n\t\tif (contextTypeRef != null && contextTypeRef.canAccess(declType) == false) {\n\t\t\t//search for visible declaring type\n\t\t\tCtTypeReference<?> visibleDeclType = null;\n\t\t\tCtTypeReference<?> type = contextTypeRef;\n\t\t\t//search which type or declaring type of startType extends from nestedType\n\t\t\twhile (visibleDeclType == null && type != null) {\n\t\t\t\tvisibleDeclType = getLastVisibleSuperClassExtendingFrom(type, declType);\n\t\t\t\tif (visibleDeclType != null) {\n\t\t\t\t\t//found one!\n\t\t\t\t\tapplyActualTypeArguments(visibleDeclType, declType);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//try class hierarchy of declaring type\n\t\t\t\ttype = type.getDeclaringType();\n\t\t\t}\n\t\t\tdeclType = visibleDeclType;\n\t\t}\n\t\tif (declType == null) {\n\t\t\tthrow new SpoonException(\"Cannot compute access path to type: \" + this.getQualifiedName() + \" in context of type: \" + contextType.getQualifiedName());\n\t\t}\n\t\treturn declType;\n\t}\n\n\t/**\n\t * adds the actualTypeArguments of sourceTypeRef to targetTypeRef. Type of targetTypeRef extends from type of sourceTypeRef\n\t * @param targetTypeRef\n\t * @param sourceTypeRef\n\t */\n\tprivate static void applyActualTypeArguments(CtTypeReference<?> targetTypeRef, CtTypeReference<?> sourceTypeRef) {\n\t\tCtTypeReference<?> targetDeclType = targetTypeRef.getDeclaringType();\n\t\tCtTypeReference<?> sourceDeclType = sourceTypeRef.getDeclaringType();\n\t\tif (targetDeclType != null && sourceDeclType != null && targetDeclType.isSubtypeOf(sourceDeclType)) {\n\t\t\tapplyActualTypeArguments(targetDeclType, sourceDeclType);\n\t\t}\n\t\tif (targetTypeRef.isSubtypeOf(sourceTypeRef) == false) {\n\t\t\tthrow new SpoonException(\"Invalid arguments. targetTypeRef \" + targetTypeRef.getQualifiedName() + \" must be a sub type of sourceTypeRef \" + sourceTypeRef.getQualifiedName());\n\t\t}\n\t\tList<CtTypeReference<?>> newTypeArgs = new ArrayList<>();\n\t\t/*\n\t\t * for now simply copy the type arguments, to have it fixed fast. But it is not correct!\n\t\t *\n\t\t * For example in this case\n\t\t *\n\t\t * class A<T,K>{}\n\t\t *\n\t\t * class B<U,T> extends A<T,Integer>\n\t\t *\n\t\t * The sourceTypeRef: A<T,K>\n\t\t * has to be applied to\n\t\t * targetTypeRef: B<?,T>\n\t\t */\n\t\tfor (CtTypeReference<?> l_tr : sourceTypeRef.getActualTypeArguments()) {\n\t\t\tnewTypeArgs.add(l_tr.clone());\n\t\t}\n\t\ttargetTypeRef.setActualTypeArguments(newTypeArgs);\n\t}\n\n\t/**\n\t *\n\t * @param sourceType\n\t * @param targetType\n\t * @return sourceType or last super class of sourceType, which extends from targetType and which is visible from sourceType or null if sourceType does not extends from targetType\n\t */\n\tprivate static CtTypeReference<?> getLastVisibleSuperClassExtendingFrom(CtTypeReference<?> sourceType, CtTypeReference<?> targetType) {\n\t\tString targetQN = targetType.getQualifiedName();\n\t\tCtTypeReference<?> adept = sourceType;\n\t\tCtTypeReference<?> type = sourceType;\n\t\twhile (true) {\n\t\t\tif (targetQN.equals(type.getQualifiedName())) {\n\t\t\t\treturn adept;\n\t\t\t}\n\t\t\ttype = type.getSuperclass();\n\t\t\tif (type == null) {\n\t\t\t\t//there is no super type which extends from targetType\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (sourceType.canAccess(type)) {\n\t\t\t\t//this super type is still visible. It is adept for returning\n\t\t\t\tadept = type;\n\t\t\t}\n\t\t}\n\t}\n\n\t@MetamodelPropertyField(role = IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> clone() {\n\t\treturn (CtTypeReference<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getTypeParameterDeclaration() {\n\n\t\tCtElement parent = this.getParent();\n\n\t\t// case 1: this is an actual type argument of a type reference eg List<E>\n\t\tif (parent instanceof CtTypeReference) {\n\t\t\tCtType t = ((CtTypeReference) parent).getTypeDeclaration();\n\t\t\treturn findTypeParamDeclarationByPosition(t, ((CtTypeReference) parent).getActualTypeArguments().indexOf(this));\n\t\t}\n\n\t\t// case 2: this is an actual type argument of a method/constructor reference\n\t\tif (parent instanceof CtExecutableReference) {\n\t\t\tCtExecutable<?> exec = ((CtExecutableReference<?>) parent).getExecutableDeclaration();\n\t\t\tif (exec instanceof CtMethod || exec instanceof CtConstructor) {\n\t\t\t\treturn findTypeParamDeclarationByPosition((CtFormalTypeDeclarer) exec, ((CtTypeReference) parent).getActualTypeArguments().indexOf(this));\n\t\t\t}\n\t\t}\n\n\t\tif (parent instanceof CtFormalTypeDeclarer) {\n\t\t\tCtFormalTypeDeclarer exec = (CtFormalTypeDeclarer) parent;\n\t\t\tif (exec instanceof CtMethod || exec instanceof CtConstructor) {\n\t\t\t\tfor (CtTypeParameter typeParam : exec.getFormalCtTypeParameters()) {\n\t\t\t\t\tif (typeParam.getSimpleName().equals(getSimpleName())) {\n\t\t\t\t\t\treturn typeParam;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isGenerics() {\n\t\tif (getDeclaration() instanceof CtTypeParameter) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (CtTypeReference ref : getActualTypeArguments()) {\n\t\t\tif (ref.isGenerics()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate CtTypeParameter findTypeParamDeclarationByPosition(CtFormalTypeDeclarer type, int position) {\n\t\treturn type.getFormalCtTypeParameters().get(position);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\tif (getActualTypeArguments().isEmpty()) {\n\t\t\treturn this;\n\t\t}\n\t\tCtTypeReference<?> erasedRef = clone();\n\t\terasedRef.getActualTypeArguments().clear();\n\t\treturn erasedRef;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic boolean isImplicitParent() {\n\t\tif (pack != null) {\n\t\t\treturn pack.isImplicit();\n\t\t} else if (declaringType != null) {\n\t\t\treturn declaringType.isImplicit();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReferenceImpl<T> setImplicitParent(boolean parentIsImplicit) {\n\t\tif (pack != null) {\n\t\t\tpack.setImplicit(parentIsImplicit);\n\t\t} else if (declaringType != null) {\n\t\t\tdeclaringType.setImplicit(parentIsImplicit);\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic boolean isArray() {\n\t\treturn getSimpleName().contains(\"[\");\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtTypeParameterReferenceImpl.java",
      "weight" : 169.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class CtTypeParameterReferenceImpl extends CtTypeReferenceImpl<Object> implements CtTypeParameterReference {\n\tprivate static final long serialVersionUID = 1L;\n\n\n\tpublic CtTypeParameterReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic boolean isDefaultBoundingType() {\n\t\treturn (getBoundingType().equals(getFactory().Type().getDefaultBoundingType()));\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTypeParameterReference(this);\n\t}\n\n\t@Override\n\tpublic boolean isPrimitive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<Object> getActualClass() {\n\t\treturn (Class<Object>) getBoundingType().getActualClass();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeReference<?>> getActualTypeArguments() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtActualTypeContainer> C setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtActualTypeContainer> C addActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic boolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<?> getBoundingType() {\n\t\tCtTypeParameter typeParam = getDeclaration();\n\t\tif (typeParam != null) {\n\t\t\tCtTypeReference<?> typeRef = typeParam.getSuperclass();\n\t\t\tif (typeRef != null) {\n\t\t\t\treturn typeRef;\n\t\t\t}\n\t\t}\n\t\treturn getFactory().Type().getDefaultBoundingType();\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\t// this is never annotated\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getDeclaration() {\n\t\tif (!isParentInitialized()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tCtElement e = this;\n\t\tCtElement parent = getParent();\n\n\t\tif (parent instanceof CtTypeParameter && Objects.equals(getSimpleName(), ((CtTypeParameter) parent).getSimpleName())) {\n\t\t\t/*\n\t\t\t * a special case of newly created (unbound) CtTypeParameterReference,\n\t\t\t * whose CtTypeParameter is linked as parent - to temporary remember CtTypeParameterReference bounds\n\t\t\t * See ReferenceBuilder#getTypeReference(TypeBinding)\n\t\t\t */\n\t\t\treturn (CtTypeParameter) parent;\n\t\t}\n\n\t\tif (parent instanceof CtTypeReference) {\n\t\t\tif (!parent.isParentInitialized()) {\n\t\t\t\t// we might enter in that case because of a call\n\t\t\t\t// of getSuperInterfaces() for example\n\t\t\t\tCtTypeReference typeReference = (CtTypeReference) parent;\n\t\t\t\te = typeReference.getTypeDeclaration();\n\t\t\t\tif (e == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparent = parent.getParent();\n\t\t\t}\n\t\t}\n\n\t\tif (parent instanceof CtExecutableReference) {\n\t\t\tCtExecutableReference parentExec = (CtExecutableReference) parent;\n\t\t\tif (!parentExec.getDeclaringType().equals(e)) {\n\t\t\t\tCtElement parent2 = parentExec.getExecutableDeclaration();\n\t\t\t\tif (parent2 instanceof CtMethod) {\n\t\t\t\t\te = parent2;\n\t\t\t\t} else {\n\t\t\t\t\te = e.getParent(CtFormalTypeDeclarer.class);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\te = e.getParent(CtFormalTypeDeclarer.class);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(e instanceof CtFormalTypeDeclarer)) {\n\t\t\t\te = e.getParent(CtFormalTypeDeclarer.class);\n\t\t\t}\n\t\t}\n\n\t\t// case #1: we're a type of a method parameter, a local variable, ...\n\t\t// the strategy is to look in the parents\n\t\t// collecting all formal type declarers of the hierarchy\n\t\twhile (e != null) {\n\t\t\tCtTypeParameter result = findTypeParamDeclaration((CtFormalTypeDeclarer) e, this.getSimpleName());\n\t\t\tif (result != null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\te = e.getParent(CtFormalTypeDeclarer.class);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate CtTypeParameter findTypeParamDeclaration(CtFormalTypeDeclarer type, String refName) {\n\t\tfor (CtTypeParameter typeParam : type.getFormalCtTypeParameters()) {\n\t\t\tif (typeParam.getSimpleName().equals(refName)) {\n\t\t\t\treturn typeParam;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtType<Object> getTypeDeclaration() {\n\t\treturn getDeclaration();\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\tCtTypeParameter typeParam = getDeclaration();\n\t\tif (typeParam == null) {\n\t\t\tthrow new SpoonException(\"Cannot resolve type erasure of the type parameter reference, which is not able to found it's declaration.\");\n\t\t}\n\t\treturn typeParam.getTypeErasure();\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\treturn getTypeDeclaration().isSubtypeOf(type);\n\t}\n\n\t@Override\n\tpublic CtTypeParameterReference clone() {\n\t\treturn (CtTypeParameterReference) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isGenerics() {\n\t\tif (getDeclaration() instanceof CtTypeParameter) {\n\t\t\treturn true;\n\t\t}\n\t\treturn getBoundingType() != null && getBoundingType().isGenerics();\n\t}\n\n\tprotected boolean isWildcard() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isImplicitParent() {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic CtTypeParameterReferenceImpl setImplicitParent(boolean packageIsImplicit) {\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtVariableReferenceImpl.java",
      "weight" : 54.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.Collections;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.TYPE;\n\npublic abstract class CtVariableReferenceImpl<T> extends CtReferenceImpl implements CtVariableReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TYPE)\n\tCtTypeReference<T> type;\n\n\tpublic CtVariableReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\t// nothing\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <C extends CtVariableReference<T>> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\t// this is never available through reflection\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtVariable<T> getDeclaration() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\tCtVariable<T> v = getDeclaration();\n\t\tif (v != null) {\n\t\t\treturn v.getModifiers();\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic CtVariableReference<T> clone() {\n\t\treturn (CtVariableReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtModuleReferenceImpl.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.lang.reflect.AnnotatedElement;\n\npublic class CtModuleReferenceImpl extends CtReferenceImpl implements CtModuleReference {\n\n\tpublic CtModuleReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic CtModule getDeclaration() {\n\t\treturn this.getFactory().Module().getOrCreate(this.getSimpleName());\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtModuleReference(this);\n\t}\n\n\t@Override\n\tpublic CtModuleReference clone() {\n\t\treturn (CtModuleReference) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtWildcardReferenceImpl.java",
      "weight" : 77.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport static spoon.reflect.path.CtRole.BOUNDING_TYPE;\nimport static spoon.reflect.path.CtRole.IS_UPPER;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.UnsettableProperty;\n\npublic class CtWildcardReferenceImpl extends CtTypeParameterReferenceImpl implements CtWildcardReference {\n\n\t@MetamodelPropertyField(role = BOUNDING_TYPE)\n\tprivate CtTypeReference<?> superType;\n\n\t@MetamodelPropertyField(role = IS_UPPER)\n\tboolean upper = true;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtWildcardReference(this);\n\t}\n\n\tpublic CtWildcardReferenceImpl() {\n\t\tsimplename = \"?\";\n\t\tsetBoundingType(null);\n\t}\n\n\t@Override\n\tpublic boolean isUpper() {\n\t\treturn upper;\n\t}\n\n\t@Override\n\tpublic <T extends CtWildcardReference> T setUpper(boolean upper) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, IS_UPPER, upper, this.upper);\n\t\tthis.upper = upper;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtWildcardReference> T setBoundingType(CtTypeReference<?> superType) {\n\t\tif (superType != null) {\n\t\t\tsuperType.setParent(this);\n\t\t}\n\n\t\t// ugly but else make testSetterInNodes failed\n\t\tif (superType == null) { // if null, set bounding type to object\n\t\t\tsuperType = getFactory().Type().objectType();\n\t\t\tsuperType.setImplicit(true);\n\t\t\tsuperType.setParent(this);\n\t\t}\n\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BOUNDING_TYPE, superType, this.superType);\n\t\tthis.superType = superType;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getBoundingType() {\n\t\treturn superType;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <T extends CtReference> T setSimpleName(String simplename) {\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtWildcardReference clone() {\n\t\treturn (CtWildcardReference) super.clone();\n\t}\n\n\t@Override\n\tpublic CtType<Object> getTypeDeclaration() {\n\t\treturn getFactory().Type().get(Object.class);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<Object> getActualClass() {\n\t\tif (isUpper()) {\n\t\t\treturn (Class<Object>) getBoundingType().getActualClass();\n\t\t}\n\t\treturn Object.class;\n\t}\n\n\t@Override\n\tprotected boolean isWildcard() {\n\t\treturn true;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtTypeMemberWildcardImportReferenceImpl.java",
      "weight" : 89.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport static spoon.reflect.path.CtRole.PACKAGE_REF;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collections;\nimport java.util.List;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.Experimental;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\n/**\n * This class intends to be used only to represent the reference of a\n * static import of all members of a type:\n *\n * import static org.junit.Assert.*;\n */\n@Experimental\npublic class CtTypeMemberWildcardImportReferenceImpl extends CtElementImpl implements CtTypeMemberWildcardImportReference {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE_REF)\n\tprivate CtTypeReference<?> typeReference;\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeReference() {\n\t\treturn typeReference;\n\t}\n\n\t@Override\n\tpublic CtTypeMemberWildcardImportReferenceImpl setTypeReference(CtTypeReference<?> typeReference) {\n\t\tif (typeReference != null) {\n\t\t\ttypeReference.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, PACKAGE_REF, typeReference, this.typeReference);\n\t\tthis.typeReference = typeReference;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn typeReference == null ? null : typeReference.getQualifiedName() + \".*\";\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <T extends CtReference> T setSimpleName(String simpleName) {\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTypeMemberWildcardImportReference(this);\n\t}\n\n\t@Override\n\tpublic CtTypeMemberWildcardImportReferenceImpl clone() {\n\t\treturn (CtTypeMemberWildcardImportReferenceImpl) super.clone();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtType<?> getDeclaration() {\n\t\treturn typeReference == null ? null : typeReference.getTypeDeclaration();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtAnnotation<? extends Annotation>> getAnnotations() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E addAnnotation(CtAnnotation<? extends Annotation> annotation) {\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic boolean removeAnnotation(CtAnnotation<? extends Annotation> annotation) {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotations) {\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic boolean isImplicit() {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E setImplicit(boolean implicit) {\n\t\treturn (E) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtLocalVariableReferenceImpl.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction;\n\n/**\n * An implementation for {@link CtLocalVariableReference}.\n */\npublic class CtLocalVariableReferenceImpl<T>\n\t\textends CtVariableReferenceImpl<T> implements CtLocalVariableReference<T> {\n\n\t/**\n\t * Id for serialization.\n\t */\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Default constructor.\n\t */\n\tpublic CtLocalVariableReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtLocalVariableReference(this);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic CtLocalVariable<T> getDeclaration() {\n\t\t// without a factory, we are not able to filter for local variables\n\t\tfinal Factory factory = getFactory();\n\t\tif (factory == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal String simpleName = getSimpleName();\n\n\t\t//handle the CtLocalVariableReference which were created by CtLocalVariable#getReference() and which are not yet part of model, so we cannot found them using standard rules\n\t\tif (parent instanceof CtLocalVariable) {\n\t\t\tCtLocalVariable<T> var = (CtLocalVariable<T>) parent;\n\t\t\tif (simpleName.equals(var.getSimpleName())) {\n\t\t\t\treturn var;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\t// successively iterate through all parents of this reference and\n\t\t\t// return first result (which must be the closest declaration\n\t\t\t// respecting visible scope)\n\t\t\tCtVariable<?> var = map(new PotentialVariableDeclarationFunction(simpleName)).first();\n\t\t\tif (var instanceof CtLocalVariable) {\n\t\t\t\treturn (CtLocalVariable<T>) var;\n\t\t\t}\n\t\t\tif (var != null) {\n\t\t\t\t//we have found another variable declaration with same simple name, which hides declaration of this local variable reference\n\t\t\t\t//handle it as not found\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\t// handle this case as 'not found'\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtLocalVariableReference<T> clone() {\n\t\treturn (CtLocalVariableReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtUnboundVariableReferenceImpl.java",
      "weight" : 30.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.reference.CtUnboundVariableReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\n/** represents a reference to an unbound field (used when no full classpath is available */\npublic class CtUnboundVariableReferenceImpl<T> extends CtVariableReferenceImpl<T> implements CtUnboundVariableReference<T> {\n\tprivate static final long serialVersionUID = -932423216089690817L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtUnboundVariableReference(this);\n\t}\n\n\t@Override\n\tpublic CtUnboundVariableReference<T> clone() {\n\t\treturn (CtUnboundVariableReference<T>) super.clone();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtAnnotation<? extends Annotation>> getAnnotations() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotations) {\n\t\treturn (E) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtFieldReferenceImpl.java",
      "weight" : 161.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.SpoonClassNotFoundException;\nimport spoon.support.util.RtHelper;\n\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Member;\nimport java.util.Collections;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.DECLARING_TYPE;\nimport static spoon.reflect.path.CtRole.IS_FINAL;\nimport static spoon.reflect.path.CtRole.IS_STATIC;\n\npublic class CtFieldReferenceImpl<T> extends CtVariableReferenceImpl<T> implements CtFieldReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = DECLARING_TYPE)\n\tCtTypeReference<?> declaringType;\n\n\t@MetamodelPropertyField(role = IS_FINAL)\n\tboolean fina = false;\n\n\t@MetamodelPropertyField(role = IS_STATIC)\n\tboolean stat = false;\n\n\tpublic CtFieldReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtFieldReference(this);\n\t}\n\n\t@Override\n\tpublic Member getActualField() {\n\t\tCtTypeReference<?> typeRef = getDeclaringType();\n\t\tif (typeRef == null) {\n\t\t\tthrow new SpoonException(\"Declaring type of field \" + getSimpleName() + \" isn't defined\");\n\t\t}\n\t\tClass<?> clazz;\n\t\ttry {\n\t\t\tclazz = typeRef.getActualClass();\n\t\t} catch (SpoonClassNotFoundException e) {\n\t\t\tif (getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\tLauncher.LOGGER.info(\"The class \" + typeRef.getQualifiedName() + \" of field \" + getSimpleName() + \" is not on class path. Problem ignored in noclasspath mode\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.isAnnotation()) {\n\t\t\t\treturn clazz.getDeclaredMethod(getSimpleName());\n\t\t\t} else {\n\t\t\t\treturn clazz.getDeclaredField(getSimpleName());\n\t\t\t}\n\t\t} catch (NoSuchMethodException | NoSuchFieldException e) {\n\t\t\tthrow new SpoonException(\"The field \" + getQualifiedName() + \" not found\", e);\n\t\t}\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\treturn (AnnotatedElement) getActualField();\n\t}\n\n\t// @Override\n\t// public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n\t// A annotation = super.getAnnotation(annotationType);\n\t// if (annotation != null) {\n\t// return annotation;\n\t// }\n\t// // use reflection\n\t// Class<?> c = getDeclaringType().getActualClass();\n\t// if (c.isAnnotation()) {\n\t// for (Method m : RtHelper.getAllMethods(c)) {\n\t// if (!getSimpleName().equals(m.getName())) {\n\t// continue;\n\t// }\n\t// m.setAccessible(true);\n\t// return m.getAnnotation(annotationType);\n\t// }\n\t// } else {\n\t// for (Field f : RtHelper.getAllFields(c)) {\n\t// if (!getSimpleName().equals(f.getName())) {\n\t// continue;\n\t// }\n\t// f.setAccessible(true);\n\t// return f.getAnnotation(annotationType);\n\t// }\n\t// }\n\t// return null;\n\t// }\n\n\t// @Override\n\t// public Annotation[] getAnnotations() {\n\t// Annotation[] annotations = super.getAnnotations();\n\t// if (annotations != null) {\n\t// return annotations;\n\t// }\n\t// // use reflection\n\t// Class<?> c = getDeclaringType().getActualClass();\n\t// for (Field f : RtHelper.getAllFields(c)) {\n\t// if (!getSimpleName().equals(f.getName())) {\n\t// continue;\n\t// }\n\t// f.setAccessible(true);\n\t// return f.getAnnotations();\n\t// }\n\t// // If the fields belong to an annotation type, they are actually\n\t// // methods\n\t// for (Method m : RtHelper.getAllMethods(c)) {\n\t// if (!getSimpleName().equals(m.getName())) {\n\t// continue;\n\t// }\n\t// m.setAccessible(true);\n\t// return m.getAnnotations();\n\t// }\n\t// return null;\n\t// }\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtField<T> getDeclaration() {\n\t\treturn fromDeclaringType();\n\t}\n\n\tprivate CtField<T> fromDeclaringType() {\n\t\tif (declaringType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtType<?> type = declaringType.getDeclaration();\n\t\tif (type != null) {\n\t\t\treturn (CtField<T>) type.getField(getSimpleName());\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtField<T> getFieldDeclaration() {\n\t\tif (declaringType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtType<?> type = declaringType.getTypeDeclaration();\n\t\tif (type != null) {\n\t\t\tfinal CtField<T> ctField = (CtField<T>) type.getField(getSimpleName());\n\t\t\tif (ctField == null && type instanceof CtEnum) {\n\t\t\t\treturn ((CtEnum) type).getEnumValue(getSimpleName());\n\t\t\t}\n\t\t\treturn ctField;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getDeclaringType() {\n\t\treturn declaringType;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\n\t\tif (declaringType != null) {\n\t\t\treturn getDeclaringType().getQualifiedName() + \"#\" + getSimpleName();\n\t\t} else {\n\t\t\treturn  \"<unknown>#\" + getSimpleName();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn fina;\n\t}\n\n\t/**\n\t * Tells if the referenced field is static.\n\t */\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn stat;\n\t}\n\n\t@Override\n\tpublic <C extends CtFieldReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {\n\t\tif (declaringType != null) {\n\t\t\tdeclaringType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, DECLARING_TYPE, declaringType, this.declaringType);\n\t\tthis.declaringType = declaringType;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtFieldReference<T>> C setFinal(boolean fina) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, IS_FINAL, fina, this.fina);\n\t\tthis.fina = fina;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtFieldReference<T>> C setStatic(boolean stat) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, IS_STATIC, stat, this.stat);\n\t\tthis.stat = stat;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\tCtVariable<?> v = getDeclaration();\n\t\tif (v != null) {\n\t\t\treturn v.getModifiers();\n\t\t}\n\t\t// the modifiers of the \"class\" of AClass.class is the empty set\n\t\tif (this.isParentInitialized()\n\t\t\t\t&& this.getParent() instanceof CtFieldAccess\n\t\t\t\t&& ((CtFieldAccess) this.getParent()).getTarget() instanceof CtTypeAccess) {\n\t\t\treturn emptySet();\n\t\t}\n\t\tMember m = getActualField();\n\t\tif (m != null) {\n\t\t\treturn RtHelper.getModifiers(m.getModifiers());\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic CtFieldReference<T> clone() {\n\t\treturn (CtFieldReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtPackageReferenceImpl.java",
      "weight" : 38.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.lang.reflect.AnnotatedElement;\n\npublic class CtPackageReferenceImpl extends CtReferenceImpl implements CtPackageReference {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic CtPackageReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic CtPackage getDeclaration() {\n\t\treturn getFactory().Package().get(getSimpleName());\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtPackageReference(this);\n\t}\n\n\t@Override\n\tpublic Package getActualPackage() {\n\t\treturn Package.getPackage(getSimpleName());\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\treturn getActualPackage();\n\t}\n\n\t@Override\n\tpublic CtPackageReference clone() {\n\t\treturn (CtPackageReference) super.clone();\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\treturn this.getSimpleName();\n\t}\n\n\t@Override\n\tpublic boolean isUnnamedPackage() {\n\t\treturn getSimpleName().isEmpty();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtParameterReferenceImpl.java",
      "weight" : 61.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.util.List;\n\npublic class CtParameterReferenceImpl<T> extends CtVariableReferenceImpl<T> implements CtParameterReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic CtParameterReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtParameterReference(this);\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<?> getDeclaringExecutable() {\n\t\tCtParameter<T> declaration = getDeclaration();\n\t\tif (declaration == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn declaration.getParent().getReference();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtParameter<T> getDeclaration() {\n\t\tfinal CtParameter<T> ctParameter = lookupDynamically();\n\t\tif (ctParameter != null) {\n\t\t\treturn ctParameter;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate CtParameter<T> lookupDynamically() {\n\t\tCtElement element = this;\n\t\tCtParameter optional = null;\n\t\tString name = getSimpleName();\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tCtExecutable executable = element.getParent(CtExecutable.class);\n\t\t\t\tif (executable == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tfor (CtParameter parameter : (List<CtParameter>) executable.getParameters()) {\n\t\t\t\t\tif (name.equals(parameter.getSimpleName())) {\n\t\t\t\t\t\toptional = parameter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telement = executable;\n\t\t\t} while (optional == null);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn optional;\n\t}\n\n\t@Override\n\tpublic CtParameterReference<T> clone() {\n\t\treturn (CtParameterReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtCatchVariableReferenceImpl.java",
      "weight" : 39.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtCatchVariableReferenceImpl<T> extends CtVariableReferenceImpl<T> implements CtCatchVariableReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic CtCatchVariableReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCatchVariableReference(this);\n\t}\n\n\t@Override\n\tpublic CtCatchVariable<T> getDeclaration() {\n\t\tCtElement element = this;\n\t\tString name = getSimpleName();\n\t\tCtCatchVariable var;\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tCtCatch catchBlock = element.getParent(CtCatch.class);\n\t\t\t\tif (catchBlock == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar = catchBlock.getParameter();\n\t\t\t\telement = catchBlock;\n\t\t\t} while (!name.equals(var.getSimpleName()));\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn null;\n\t\t}\n\t\treturn var;\n\t}\n\n\t@Override\n\tpublic CtCatchVariableReference<T> clone() {\n\t\treturn (CtCatchVariableReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtIntersectionTypeReferenceImpl.java",
      "weight" : 86.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.BOUND;\n\n\npublic class CtIntersectionTypeReferenceImpl<T> extends CtTypeReferenceImpl<T> implements CtIntersectionTypeReference<T> {\n\t@MetamodelPropertyField(role = BOUND)\n\tList<CtTypeReference<?>> bounds = CtElementImpl.emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtIntersectionTypeReference(this);\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getBounds() {\n\t\treturn Collections.unmodifiableList(bounds);\n\t}\n\n\t@Override\n\tpublic <C extends CtIntersectionTypeReference> C setBounds(List<CtTypeReference<?>> bounds) {\n\t\tif (bounds == null || bounds.isEmpty()) {\n\t\t\tthis.bounds = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.bounds == CtElementImpl.<CtTypeReference<?>>emptySet()) {\n\t\t\tthis.bounds = new ArrayList<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, BOUND, this.bounds, new ArrayList<>(this.bounds));\n\t\tthis.bounds.clear();\n\t\tfor (CtTypeReference<?> bound : bounds) {\n\t\t\taddBound(bound);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtIntersectionTypeReference> C addBound(CtTypeReference<?> bound) {\n\t\tif (bound == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tbounds = new ArrayList<>();\n\t\t}\n\t\tif (!bounds.contains(bound)) {\n\t\t\tbound.setParent(this);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, BOUND, this.bounds, bound);\n\t\t\tbounds.add(bound);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeBound(CtTypeReference<?> bound) {\n\t\tif (bounds == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, BOUND, bounds, bounds.indexOf(bound), bound);\n\t\treturn bounds.remove(bound);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\tif (bounds == null || bounds.isEmpty()) {\n\t\t\treturn getFactory().Type().OBJECT;\n\t\t}\n\t\treturn bounds.get(0).getTypeErasure();\n\t}\n\n\t@Override\n\tpublic CtIntersectionTypeReference<T> clone() {\n\t\treturn (CtIntersectionTypeReference<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isImplicitParent() {\n\t\tif (bounds != null && bounds.size() > 0) {\n\t\t\treturn bounds.get(0).isImplicitParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic CtIntersectionTypeReferenceImpl<T> setImplicitParent(boolean packageIsImplicit) {\n\t\tif (bounds != null && bounds.size() > 0) {\n\t\t\tbounds.get(0).setImplicitParent(packageIsImplicit);\n\t\t}\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtArrayTypeReferenceImpl.java",
      "weight" : 101.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.SpoonClassNotFoundException;\n\nimport java.lang.reflect.Array;\n\nimport static spoon.reflect.path.CtRole.TYPE;\n\npublic class CtArrayTypeReferenceImpl<T> extends CtTypeReferenceImpl<T> implements CtArrayTypeReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TYPE)\n\tCtTypeReference<?> componentType;\n\n\tpublic CtArrayTypeReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtArrayTypeReference(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getComponentType() {\n\t\tif (componentType == null) {\n\t\t\t// a sensible default component type to facilitate object creation and testing\n\t\t\tcomponentType = getFactory().Type().objectType();\n\t\t\tcomponentType.setParent(this);\n\t\t}\n\t\treturn componentType;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getArrayType() {\n\t\treturn getLastComponentTypeReference(componentType);\n\t}\n\n\tprivate CtTypeReference<?> getLastComponentTypeReference(CtTypeReference<?> component) {\n\t\treturn component instanceof CtArrayTypeReference ? getLastComponentTypeReference(((CtArrayTypeReference) component).getComponentType()) : component;\n\t}\n\n\t@Override\n\tpublic <C extends CtArrayTypeReference<T>> C setComponentType(CtTypeReference<?> componentType) {\n\t\tif (componentType != null) {\n\t\t\tcomponentType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, componentType, this.componentType);\n\t\tthis.componentType = componentType;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn getComponentType().getSimpleName() + \"[]\";\n\t}\n\n\t@Override\n\tpublic <T extends CtReference> T setSimpleName(String simplename) {\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\treturn getComponentType().getQualifiedName() + \"[]\";\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic Class<T> getActualClass() {\n\t\tClass<?> c = getComponentType().getActualClass();\n\t\tif (c == null) {\n\t\t\tthrow new SpoonClassNotFoundException(\"you should never call getActualClass! (\" + getComponentType().getQualifiedName() + \" not found in the classpath)\", null);\n\t\t}\n\t\treturn (Class<T>) Array.newInstance(c, 0).getClass();\n\t}\n\n\t@Override\n\tpublic int getDimensionCount() {\n\t\tif (getComponentType() instanceof CtArrayTypeReference) {\n\t\t\treturn ((CtArrayTypeReference<?>) getComponentType()).getDimensionCount() + 1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\tCtTypeReference<?> originCT = getComponentType();\n\t\tCtTypeReference<?> erasedCT = originCT.getTypeErasure();\n\t\tif (originCT == erasedCT) {\n\t\t\treturn this;\n\t\t}\n\t\tCtArrayTypeReference<?> erased = this.clone();\n\t\terased.setComponentType(erasedCT);\n\t\treturn erased;\n\t}\n\n\t@Override\n\tpublic CtArrayTypeReference<T> clone() {\n\t\treturn (CtArrayTypeReference<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isImplicitParent() {\n\t\tif (componentType != null) {\n\t\t\treturn componentType.isImplicitParent();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic CtArrayTypeReferenceImpl<T> setImplicitParent(boolean packageIsImplicit) {\n\t\tif (componentType != null) {\n\t\t\tcomponentType.setImplicitParent(packageIsImplicit);\n\t\t}\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtReferenceImpl.java",
      "weight" : 63.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.io.Serializable;\nimport java.lang.reflect.AnnotatedElement;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static spoon.reflect.path.CtRole.NAME;\n\npublic abstract class CtReferenceImpl extends CtElementImpl implements CtReference, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = NAME)\n\tprotected String simplename = \"\";\n\n\tpublic CtReferenceImpl() {\n\t}\n\n\tprotected abstract AnnotatedElement getActualAnnotatedElement();\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn simplename;\n\t}\n\n\t@Override\n\tpublic <T extends CtReference> T setSimpleName(String simplename) {\n\t\tFactory factory = getFactory();\n\t\tif (factory == null) {\n\t\t\tthis.simplename = simplename;\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (factory instanceof FactoryImpl) {\n\t\t\tsimplename = ((FactoryImpl) factory).dedup(simplename);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, NAME, simplename, this.simplename);\n\t\tthis.simplename = simplename;\n\t\treturn (T) this;\n\t}\n\n\t@UnsettableProperty\n\t@Override\n\tpublic <E extends CtElement> E setComments(List<CtComment> comments) {\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic abstract void accept(CtVisitor visitor);\n\n\t@Override\n\tpublic CtReference clone() {\n\t\treturn (CtReference) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof CtReference) {\n\t\t\tCtReference ref = (CtReference) o;\n\t\t\tif (!Objects.equals(getSimpleName(), ref.getSimpleName())) {\n\t\t\t\t//fast fallback when simple names are not equal\n\t\t\t\t//it is much faster then EqualsVisitor\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.equals(o);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/reference/CtExecutableReferenceImpl.java",
      "weight" : 391.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.reference;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.NamedElementFilter;\nimport spoon.support.reflect.declaration.CtElementImpl;\nimport spoon.support.util.RtHelper;\nimport spoon.support.visitor.ClassTypingContext;\nimport spoon.support.visitor.SignaturePrinter;\n\nimport java.lang.reflect.AnnotatedElement;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.DECLARING_TYPE;\nimport static spoon.reflect.path.CtRole.IS_STATIC;\nimport static spoon.reflect.path.CtRole.ARGUMENT_TYPE;\nimport static spoon.reflect.path.CtRole.TYPE;\nimport static spoon.reflect.path.CtRole.TYPE_ARGUMENT;\n\npublic class CtExecutableReferenceImpl<T> extends CtReferenceImpl implements CtExecutableReference<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = IS_STATIC)\n\tboolean stat = false;\n\n\t@MetamodelPropertyField(role = TYPE_ARGUMENT)\n\tList<CtTypeReference<?>> actualTypeArguments = CtElementImpl.emptyList();\n\n\t@MetamodelPropertyField(role = TYPE)\n\tCtTypeReference<?> declaringType;\n\n\t@MetamodelPropertyField(role = TYPE)\n\t/**\n\t * For methods, stores the return type of the method. (not pretty-printed).\n\t * For constructors, stores the type of the target constructor (pretty-printed).\n\t */\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = ARGUMENT_TYPE)\n\tList<CtTypeReference<?>> parameters = CtElementImpl.emptyList();\n\n\tpublic CtExecutableReferenceImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtExecutableReference(this);\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getActualTypeArguments() {\n\t\treturn actualTypeArguments;\n\t}\n\n\t@Override\n\tpublic boolean isConstructor() {\n\t\treturn getSimpleName().equals(CONSTRUCTOR_NAME);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtExecutable<T> getDeclaration() {\n\t\tfinal CtTypeReference<?> typeRef = getDeclaringType();\n\t\tif (typeRef == null || typeRef.getDeclaration() == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getCtExecutable(typeRef.getDeclaration());\n\t}\n\n\t@Override\n\tpublic CtExecutable<T> getExecutableDeclaration() {\n\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\t\tif (declaringType == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (declaringType instanceof CtArrayTypeReference && this.isConstructor()) {\n\t\t\tCtConstructor constructor = this.getFactory().createInvisibleArrayConstructor();\n\t\t\tconstructor.setType(declaringType);\n\t\t\treturn constructor;\n\t\t}\n\n\t\treturn getCtExecutable(declaringType.getTypeDeclaration());\n\t}\n\n\tprivate CtExecutable<T> getCtExecutable(CtType<?> typeDecl) {\n\t\tif (typeDecl == null) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<?>[] arrayParameters = parameters.toArray(new CtTypeReferenceImpl<?>[0]);\n\t\tCtExecutable<T> method = typeDecl.getMethod(getSimpleName(), arrayParameters);\n\t\tif ((method == null) && (typeDecl instanceof CtClass) && this.isConstructor()) {\n\t\t\ttry {\n\t\t\t\tCtClass<?> zeClass = (CtClass) typeDecl;\n\t\t\t\tCtConstructor<?> constructor = zeClass.getConstructor(arrayParameters);\n\t\t\t\treturn (CtExecutable<T>) constructor;\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t} else if (method == null && getSimpleName().startsWith(CtExecutableReference.LAMBDA_NAME_PREFIX)) {\n\t\t\tfinal List<CtLambda> elements = typeDecl.getElements(new NamedElementFilter<>(CtLambda.class, getSimpleName()));\n\t\t\tif (elements.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn elements.get(0);\n\t\t}\n\t\treturn method;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getDeclaringType() {\n\t\treturn declaringType;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getParameters() {\n\t\treturn unmodifiableList(parameters);\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutableReference<T>> C setParameters(List<CtTypeReference<?>> parameters) {\n\t\tif (parameters == null || parameters.isEmpty()) {\n\t\t\tthis.parameters = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.parameters == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.parameters = new ArrayList<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, ARGUMENT_TYPE, this.parameters, new ArrayList<>(this.parameters));\n\t\tthis.parameters.clear();\n\t\tfor (CtTypeReference<?> parameter : parameters) {\n\t\t\taddParameter(parameter);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\tprivate boolean addParameter(CtTypeReference<?> parameter) {\n\t\tif (parameter == null) {\n\t\t\treturn false;\n\t\t}\n\t\tcheckMethodParameterTypeRef(parameter);\n\t\tparameter.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, ARGUMENT_TYPE, this.parameters, parameter);\n\t\treturn this.parameters.add(parameter);\n\t}\n\n\tprivate void checkMethodParameterTypeRef(CtTypeReference<?> parameterType) {\n\t\tif (parameterType instanceof CtTypeParameterReference && !(parameterType instanceof CtWildcardReference)) {\n\t\t\tthrow new SpoonException(\"CtExecutableReference cannot use CtTypeParameterReference. Use boundingType of CtTypeParameterReference instead.\");\n\t\t}\n\t\tif (parameterType instanceof CtArrayTypeReference) {\n\t\t\tcheckMethodParameterTypeRef(((CtArrayTypeReference<?>) parameterType).getComponentType());\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <S extends T> CtExecutableReference<S> getOverridingExecutable(CtTypeReference<?> subType) {\n\t\tif ((subType == null) || subType.equals(getDeclaringType())) {\n\t\t\treturn null;\n\t\t}\n\t\tCtType<?> t = subType.getDeclaration();\n\t\tif (t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!(t instanceof CtClass)) {\n\t\t\treturn null;\n\t\t}\n\t\tCtClass<?> c = (CtClass<?>) t;\n\t\tfor (CtMethod<?> m : c.getMethods()) {\n\t\t\tif (m.getReference().isOverriding(this)) {\n\t\t\t\treturn (CtExecutableReference<S>) m.getReference();\n\t\t\t}\n\t\t}\n\t\treturn getOverridingExecutable(c.getSuperclass());\n\t}\n\n\t@Override\n\tpublic boolean isOverriding(CtExecutableReference<?> executable) {\n\t\tCtExecutable<?> exec = executable.getExecutableDeclaration();\n\t\tCtExecutable<?> thisExec = getExecutableDeclaration();\n\t\tif (exec == null || thisExec == null) {\n\t\t\t//the declaration of this executable is not in spoon model\n\t\t\t//use light detection algorithm, which ignores generic types\n\t\t\tfinal boolean isSame = getSimpleName().equals(executable.getSimpleName()) && getParameters().equals(executable.getParameters()) && getActualTypeArguments().equals(executable.getActualTypeArguments());\n\t\t\tif (!isSame) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\t\t\treturn declaringType != null && declaringType.isSubtypeOf(executable.getDeclaringType());\n\t\t}\n\t\tif (exec instanceof CtMethod<?> && thisExec instanceof CtMethod<?>) {\n\t\t\treturn new ClassTypingContext(((CtTypeMember) thisExec).getDeclaringType()).isOverriding((CtMethod<?>) thisExec, (CtMethod<?>) exec);\n\t\t}\n\t\t//it is not a method. So we can return true only if it is reference to the this executable\n\t\treturn exec == getDeclaration();\n\t}\n\n\t@Override\n\tpublic <C extends CtActualTypeContainer> C setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments) {\n\t\tif (actualTypeArguments == null || actualTypeArguments.isEmpty()) {\n\t\t\tthis.actualTypeArguments = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.actualTypeArguments = new ArrayList<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, TYPE_ARGUMENT, this.actualTypeArguments, new ArrayList<>(this.actualTypeArguments));\n\t\tthis.actualTypeArguments.clear();\n\t\tfor (CtTypeReference<?> actualTypeArgument : actualTypeArguments) {\n\t\t\taddActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutableReference<T>> C setDeclaringType(CtTypeReference<?> declaringType) {\n\t\tif (declaringType != null) {\n\t\t\tdeclaringType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, DECLARING_TYPE, declaringType, this.declaringType);\n\t\tthis.declaringType = declaringType;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutableReference<T>> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tprotected AnnotatedElement getActualAnnotatedElement() {\n\t\tif (isConstructor()) {\n\t\t\treturn getActualConstructor();\n\t\t} else {\n\t\t\treturn getActualMethod();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Method getActualMethod() {\n\t\tList<CtTypeReference<?>> parameters = this.getParameters();\n\n\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\t\tif (declaringType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tmethod_loop:\n\t\tfor (Method m : declaringType.getActualClass().getDeclaredMethods()) {\n\t\t\tif (!m.getDeclaringClass().isSynthetic() && m.isSynthetic()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!m.getName().equals(getSimpleName())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (m.getParameterTypes().length != parameters.size()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < parameters.size(); i++) {\n\t\t\t\tClass<?> methodParameterType = m.getParameterTypes()[i];\n\t\t\t\tClass<?> currentParameterType = parameters.get(i).getActualClass();\n\t\t\t\tif (methodParameterType != currentParameterType) {\n\t\t\t\t\tcontinue method_loop;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn m;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Constructor<?> getActualConstructor() {\n\t\tList<CtTypeReference<?>> parameters = this.getParameters();\n\n\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\t\tif (declaringType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tconstructor_loop:\n\t\tfor (Constructor<?> c : declaringType.getActualClass().getDeclaredConstructors()) {\n\t\t\tif (c.getParameterTypes().length != parameters.size()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < parameters.size(); i++) {\n\t\t\t\tif (c.getParameterTypes()[i] != parameters.get(i).getActualClass()) {\n\t\t\t\t\tcontinue constructor_loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn c;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn stat;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutableReference<T>> C setStatic(boolean stat) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, IS_STATIC, stat, this.stat);\n\t\tthis.stat = stat;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\tCtExecutable<T> e = getDeclaration();\n\t\tif (e != null) {\n\t\t\tif (e instanceof CtMethod) {\n\t\t\t\treturn ((CtMethod<T>) e).hasModifier(ModifierKind.FINAL);\n\t\t\t} else if (e instanceof CtConstructor) {\n\t\t\t\treturn ((CtConstructor<T>) e).hasModifier(ModifierKind.FINAL);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tMethod m = getActualMethod();\n\t\treturn m != null && Modifier.isFinal(m.getModifiers());\n\t}\n\n\tpublic Set<ModifierKind> getModifiers() {\n\t\tCtExecutable<T> e = getDeclaration();\n\t\tif (e != null) {\n\t\t\tif (e instanceof CtMethod) {\n\t\t\t\treturn ((CtMethod<T>) e).getModifiers();\n\t\t\t} else if (e instanceof CtConstructor) {\n\t\t\t\treturn ((CtConstructor<T>) e).getModifiers();\n\t\t\t}\n\t\t\treturn CtElementImpl.emptySet();\n\t\t}\n\t\tMethod m = getActualMethod();\n\t\tif (m != null) {\n\t\t\treturn RtHelper.getModifiers(m.getModifiers());\n\t\t}\n\t\tConstructor<?> c = getActualConstructor();\n\t\tif (c != null) {\n\t\t\treturn RtHelper.getModifiers(c.getModifiers());\n\t\t}\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<?> getOverridingExecutable() {\n\t\tCtTypeReference<Object> objectType = getFactory().Type().OBJECT;\n\t\tCtTypeReference<?> declaringType = getDeclaringType();\n\t\tif (declaringType == null) {\n\t\t\treturn getOverloadedExecutable(objectType, objectType);\n\t\t}\n\t\tCtTypeReference<?> st = declaringType.getSuperclass();\n\t\tif (st == null) {\n\t\t\treturn getOverloadedExecutable(objectType, objectType);\n\t\t}\n\t\treturn getOverloadedExecutable(st, objectType);\n\t}\n\n\tprivate CtExecutableReference<?> getOverloadedExecutable(CtTypeReference<?> t, CtTypeReference<Object> objectType) {\n\t\tif (t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (CtExecutableReference<?> e : t.getDeclaredExecutables()) {\n\t\t\tif (this.isOverriding(e)) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\tif (t.equals(objectType)) {\n\t\t\treturn null;\n\t\t}\n\t\tCtTypeReference<?> st = t.getSuperclass();\n\t\tif (st == null) {\n\t\t\treturn getOverloadedExecutable(objectType, objectType);\n\t\t}\n\t\treturn getOverloadedExecutable(t.getSuperclass(), objectType);\n\t}\n\n\t@Override\n\tpublic <C extends CtActualTypeContainer> C addActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (actualTypeArgument == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tactualTypeArguments = new ArrayList<>(METHOD_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tactualTypeArgument.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, TYPE_ARGUMENT, this.actualTypeArguments, actualTypeArgument);\n\t\tactualTypeArguments.add(actualTypeArgument);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (actualTypeArguments == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, TYPE_ARGUMENT, actualTypeArguments, actualTypeArguments.indexOf(actualTypeArgument), actualTypeArgument);\n\t\treturn actualTypeArguments.remove(actualTypeArgument);\n\t}\n\n\t@Override\n\tpublic String getSignature() {\n\t\tfinal SignaturePrinter pr = new SignaturePrinter();\n\t\tpr.scan(this);\n\t\treturn pr.getSignature();\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<T> clone() {\n\t\treturn (CtExecutableReference<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package provides an implementation of the spoon.reflect package.</p>\n * <p>The classes of this package should not be instantiated directly, but by using {@link spoon.reflect.factory.Factory}.</p>\n */\npackage spoon.support.reflect;\n"
    }, {
      "name" : "support/reflect/CtModifierHandler.java",
      "weight" : 149.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport static spoon.reflect.path.CtRole.MODIFIER;\n\npublic class CtModifierHandler implements Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate Set<CtExtendedModifier> modifiers = CtElementImpl.emptySet();\n\n\tprivate CtElement element;\n\n\tpublic CtModifierHandler(CtElement element) {\n\t\tthis.element = element;\n\t}\n\n\tpublic Factory getFactory() {\n\t\treturn element.getFactory();\n\t}\n\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn Collections.unmodifiableSet(this.modifiers);\n\t}\n\n\tpublic CtModifierHandler setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tif (extendedModifiers != null && !extendedModifiers.isEmpty()) {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDeleteAll(element, MODIFIER, this.modifiers, new HashSet<>(this.modifiers));\n\t\t\tif (this.modifiers == CtElementImpl.<CtExtendedModifier>emptySet()) {\n\t\t\t\tthis.modifiers = new HashSet<>();\n\t\t\t} else {\n\t\t\t\tthis.modifiers.clear();\n\t\t\t}\n\t\t\tfor (CtExtendedModifier extendedModifier : extendedModifiers) {\n\t\t\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(element, MODIFIER, this.modifiers, extendedModifier.getKind());\n\t\t\t\tthis.modifiers.add(extendedModifier);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifiers.stream().map(CtExtendedModifier::getKind).collect(Collectors.toSet());\n\t}\n\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\tpublic CtModifierHandler setModifiers(Set<ModifierKind> modifiers) {\n\t\tif (modifiers == null) {\n\t\t\tmodifiers = Collections.emptySet();\n\t\t}\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDeleteAll(element, MODIFIER, this.modifiers, new HashSet<>(this.modifiers));\n\t\t\tthis.modifiers.clear();\n\t\t\tfor (ModifierKind modifier : modifiers) {\n\t\t\t\taddModifier(modifier);\n\t\t\t}\n\t\treturn this;\n\t}\n\n\tpublic CtModifierHandler addModifier(ModifierKind modifier) {\n\t\tif (this.modifiers == CtElementImpl.<CtExtendedModifier>emptySet()) {\n\t\t\tthis.modifiers = new HashSet<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(element, MODIFIER, this.modifiers, modifier);\n\t\t// we always add explicit modifiers, then we have to remove first implicit one\n\t\tmodifiers.remove(new CtExtendedModifier(modifier, true));\n\t\tmodifiers.add(new CtExtendedModifier(modifier));\n\t\treturn this;\n\t}\n\n\tpublic CtModifierHandler removeModifier(ModifierKind modifier) {\n\t\tif (this.modifiers == CtElementImpl.<CtExtendedModifier>emptySet()) {\n\t\t\treturn this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDelete(element, MODIFIER, modifiers, modifier);\n\t\t// we want to remove implicit OR explicit modifier\n\t\tmodifiers.remove(new CtExtendedModifier(modifier));\n\t\tmodifiers.remove(new CtExtendedModifier(modifier, true));\n\t\treturn this;\n\t}\n\n\tpublic CtModifierHandler setVisibility(ModifierKind visibility) {\n\t\tif (visibility != ModifierKind.PUBLIC && visibility != ModifierKind.PROTECTED && visibility != ModifierKind.PRIVATE) {\n\t\t\tthrow new SpoonException(\"setVisibility could only be called with a private, public or protected argument value. Given argument: \" + visibility);\n\t\t}\n\t\tif (hasModifier(visibility)) {\n\t\t\treturn this;\n\t\t}\n\t\tif (isPublic()) {\n\t\t\tremoveModifier(ModifierKind.PUBLIC);\n\t\t}\n\t\tif (isProtected()) {\n\t\t\tremoveModifier(ModifierKind.PROTECTED);\n\t\t}\n\t\tif (isPrivate()) {\n\t\t\tremoveModifier(ModifierKind.PRIVATE);\n\t\t}\n\t\taddModifier(visibility);\n\t\treturn this;\n\t}\n\n\tpublic ModifierKind getVisibility() {\n\t\tif (isPublic()) {\n\t\t\treturn ModifierKind.PUBLIC;\n\t\t}\n\t\tif (isProtected()) {\n\t\t\treturn ModifierKind.PROTECTED;\n\t\t}\n\t\tif (isPrivate()) {\n\t\t\treturn ModifierKind.PRIVATE;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic boolean isPublic() {\n\t\treturn getModifiers().contains(ModifierKind.PUBLIC);\n\t}\n\n\tpublic boolean isProtected() {\n\t\treturn getModifiers().contains(ModifierKind.PROTECTED);\n\t}\n\n\tpublic boolean isPrivate() {\n\t\treturn getModifiers().contains(ModifierKind.PRIVATE);\n\t}\n\n\tpublic boolean isAbstract() {\n\t\treturn getModifiers().contains(ModifierKind.ABSTRACT);\n\t}\n\n\tpublic boolean isStatic() {\n\t\treturn getModifiers().contains(ModifierKind.STATIC);\n\t}\n\n\tpublic boolean isFinal() {\n\t\treturn getModifiers().contains(ModifierKind.FINAL);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getModifiers().hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof CtModifierHandler)) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal CtModifierHandler other = (CtModifierHandler) obj;\n\t\tif (getVisibility() == null) {\n\t\t\tif (other.getVisibility() != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (other.getVisibility() == null) {\n\t\t\treturn false;\n\t\t} else  if (!getVisibility().equals(other.getVisibility())) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getModifiers().size() != other.getModifiers().size()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn getModifiers().containsAll(other.getModifiers());\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtNewArrayImpl.java",
      "weight" : 102.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.NEW_ARRAY_DEFAULT_EXPRESSIONS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.DIMENSION;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtNewArrayImpl<T> extends CtExpressionImpl<T> implements CtNewArray<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = DIMENSION)\n\tList<CtExpression<Integer>> dimensionExpressions = emptyList();\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tList<CtExpression<?>> expressions = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtNewArray(this);\n\t}\n\n\t@Override\n\tpublic List<CtExpression<Integer>> getDimensionExpressions() {\n\t\treturn dimensionExpressions;\n\t}\n\n\t@Override\n\tpublic List<CtExpression<?>> getElements() {\n\t\treturn expressions;\n\t}\n\n\t@Override\n\tpublic <C extends CtNewArray<T>> C setDimensionExpressions(List<CtExpression<Integer>> dimensionExpressions) {\n\t\tif (dimensionExpressions == null || dimensionExpressions.isEmpty()) {\n\t\t\tthis.dimensionExpressions = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, DIMENSION, this.dimensionExpressions, new ArrayList<>(this.dimensionExpressions));\n\t\tthis.dimensionExpressions.clear();\n\t\tfor (CtExpression<Integer> expr : dimensionExpressions) {\n\t\t\taddDimensionExpression(expr);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtNewArray<T>> C addDimensionExpression(CtExpression<Integer> dimension) {\n\t\tif (dimension == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (dimensionExpressions == CtElementImpl.<CtExpression<Integer>>emptyList()) {\n\t\t\tdimensionExpressions = new ArrayList<>(NEW_ARRAY_DEFAULT_EXPRESSIONS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tdimension.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, DIMENSION, this.dimensionExpressions, dimension);\n\t\tdimensionExpressions.add(dimension);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeDimensionExpression(CtExpression<Integer> dimension) {\n\t\tif (dimensionExpressions == CtElementImpl.<CtExpression<Integer>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, DIMENSION, dimensionExpressions, dimensionExpressions.indexOf(dimension), dimension);\n\t\treturn dimensionExpressions.remove(dimension);\n\t}\n\n\t@Override\n\tpublic <C extends CtNewArray<T>> C setElements(List<CtExpression<?>> expressions) {\n\t\tif (expressions == null || expressions.isEmpty()) {\n\t\t\tthis.expressions = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, EXPRESSION, this.expressions, new ArrayList<>(this.expressions));\n\t\tthis.expressions.clear();\n\t\tfor (CtExpression<?> expr : expressions) {\n\t\t\taddElement(expr);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtNewArray<T>> C addElement(CtExpression<?> expression) {\n\t\tif (expression == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (expressions == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\tthis.expressions = new ArrayList<>();\n\t\t}\n\t\texpression.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, EXPRESSION, this.expressions, expression);\n\t\texpressions.add(expression);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeElement(CtExpression<?> expression) {\n\t\tif (expressions == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, EXPRESSION, expressions, expressions.indexOf(expression), expression);\n\t\treturn expressions.remove(expression);\n\t}\n\n\t@Override\n\tpublic CtNewArray<T> clone() {\n\t\treturn (CtNewArray<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtVariableWriteImpl.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtVariableWriteImpl<T> extends CtVariableAccessImpl<T> implements CtVariableWrite<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtVariableWrite(this);\n\t}\n\n\t@Override\n\tpublic CtVariableWrite<T> clone() {\n\t\treturn (CtVariableWrite<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtFieldReadImpl.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtFieldReadImpl<T> extends CtFieldAccessImpl<T> implements CtFieldRead<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtFieldRead(this);\n\t}\n\n\t@Override\n\tpublic CtFieldRead<T> clone() {\n\t\treturn (CtFieldRead<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtForImpl.java",
      "weight" : 120.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.FOR_INIT_STATEMENTS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.FOR_UPDATE_STATEMENTS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.FOR_INIT;\nimport static spoon.reflect.path.CtRole.FOR_UPDATE;\n\npublic class CtForImpl extends CtLoopImpl implements CtFor {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<Boolean> expression;\n\n\t@MetamodelPropertyField(role = FOR_INIT)\n\tList<CtStatement> forInit = emptyList();\n\n\t@MetamodelPropertyField(role = FOR_UPDATE)\n\tList<CtStatement> forUpdate = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtFor(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <T extends CtFor> T setExpression(CtExpression<Boolean> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtStatement> getForInit() {\n\t\treturn forInit;\n\t}\n\n\t@Override\n\tpublic <T extends CtFor> T addForInit(CtStatement statement) {\n\t\tif (statement == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (forInit == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\tforInit = new ArrayList<>(FOR_INIT_STATEMENTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tstatement.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, FOR_INIT, this.forInit, statement);\n\t\tforInit.add(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtFor> T setForInit(List<CtStatement> statements) {\n\t\tif (statements == null || statements.isEmpty()) {\n\t\t\tthis.forInit = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, FOR_INIT, this.forInit, new ArrayList<>(this.forInit));\n\t\tthis.forInit.clear();\n\t\tfor (CtStatement stmt : statements) {\n\t\t\taddForInit(stmt);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeForInit(CtStatement statement) {\n\t\tif (forInit == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, FOR_INIT, forInit, forInit.indexOf(statement), statement);\n\t\treturn forInit.remove(statement);\n\t}\n\n\t@Override\n\tpublic List<CtStatement> getForUpdate() {\n\t\treturn forUpdate;\n\t}\n\n\t@Override\n\tpublic <T extends CtFor> T addForUpdate(CtStatement statement) {\n\t\tif (statement == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (forUpdate == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\tforUpdate = new ArrayList<>(FOR_UPDATE_STATEMENTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tstatement.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, FOR_UPDATE, this.forUpdate, statement);\n\t\tforUpdate.add(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtFor> T setForUpdate(List<CtStatement> statements) {\n\t\tif (statements == null || statements.isEmpty()) {\n\t\t\tthis.forUpdate = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, FOR_UPDATE, this.forUpdate, new ArrayList<>(this.forUpdate));\n\t\tthis.forUpdate.clear();\n\t\tfor (CtStatement stmt : statements) {\n\t\t\taddForUpdate(stmt);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeForUpdate(CtStatement statement) {\n\t\tif (forUpdate == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, FOR_UPDATE, forUpdate, forUpdate.indexOf(statement), statement);\n\t\treturn forUpdate.remove(statement);\n\t}\n\n\t@Override\n\tpublic CtFor clone() {\n\t\treturn (CtFor) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtIfImpl.java",
      "weight" : 76.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.ELSE;\nimport static spoon.reflect.path.CtRole.THEN;\n\npublic class CtIfImpl extends CtStatementImpl implements CtIf {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CONDITION)\n\tCtExpression<Boolean> condition;\n\n\t@MetamodelPropertyField(role = ELSE)\n\tCtStatement elseStatement;\n\n\t@MetamodelPropertyField(role = THEN)\n\tCtStatement thenStatement;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtIf(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getCondition() {\n\t\treturn condition;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <S extends CtStatement> S getElseStatement() {\n\t\treturn (S) elseStatement;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <S extends CtStatement> S getThenStatement() {\n\t\treturn (S) thenStatement;\n\t}\n\n\t@Override\n\tpublic <T extends CtIf> T setCondition(CtExpression<Boolean> condition) {\n\t\tif (condition != null) {\n\t\t\tcondition.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CONDITION, condition, this.condition);\n\t\tthis.condition = condition;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtIf> T setElseStatement(CtStatement elseStatement) {\n\t\tif (elseStatement != null) {\n\t\t\telseStatement.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, ELSE, elseStatement, this.elseStatement);\n\t\tthis.elseStatement = elseStatement;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtIf> T setThenStatement(CtStatement thenStatement) {\n\t\t// then branch might be null: `if (condition) ;`\n\t\tif (thenStatement != null) {\n\t\t\tthenStatement.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, THEN, thenStatement, this.thenStatement);\n\t\tthis.thenStatement = thenStatement;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtIf clone() {\n\t\treturn (CtIf) super.clone();\n\t}\n\n\t@Override\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\tpublic CtCodeElement getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtWhileImpl.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtWhileImpl extends CtLoopImpl implements CtWhile {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<Boolean> expression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtWhile(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getLoopingExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <T extends CtWhile> T setLoopingExpression(CtExpression<Boolean> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtWhile clone() {\n\t\treturn (CtWhile) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtStatementListImpl.java",
      "weight" : 163.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.Query;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.BLOCK_STATEMENTS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.STATEMENT;\n\npublic class CtStatementListImpl<R> extends CtCodeElementImpl implements CtStatementList {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = STATEMENT)\n\tList<CtStatement> statements = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtStatementList(this);\n\t}\n\n\t@Override\n\tpublic List<CtStatement> getStatements() {\n\t\treturn statements;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T setStatements(List<CtStatement> stmts) {\n\t\tif (stmts == null || stmts.isEmpty()) {\n\t\t\tthis.statements = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, STATEMENT, this.statements, new ArrayList<>(this.statements));\n\t\tthis.statements.clear();\n\t\tfor (CtStatement stmt : stmts) {\n\t\t\taddStatement(stmt);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(CtStatement statement) {\n\t\treturn this.addStatement(this.statements.size(), statement);\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(int index, CtStatement statement) {\n\t\tif (statement == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.statements == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\tthis.statements = new ArrayList<>(BLOCK_STATEMENTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tstatement.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, STATEMENT, this.statements, index, statement);\n\t\tthis.statements.add(index, statement);\n\t\treturn (T) this;\n\t}\n\n\tprivate void ensureModifiableStatementsList() {\n\t\tif (this.statements == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\tthis.statements = new ArrayList<>(BLOCK_STATEMENTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatementList statements) {\n\t\tensureModifiableStatementsList();\n\t\tfor (CtStatement statement : statements.getStatements()) {\n\t\t\tstatement.setParent(this);\n\t\t\tthis.addStatement(0, statement);\n\t\t}\n\t\tif (isImplicit() && this.statements.size() > 1) {\n\t\t\tsetImplicit(false);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatement statement) {\n\t\tensureModifiableStatementsList();\n\t\tstatement.setParent(this);\n\t\tthis.addStatement(0, statement);\n\n\t\tif (isImplicit() && this.statements.size() > 1) {\n\t\t\tsetImplicit(false);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatement statement) {\n\t\tensureModifiableStatementsList();\n\t\taddStatement(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatementList statements) {\n\t\tList<CtStatement> tobeInserted = new ArrayList<>(statements.getStatements());\n\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t//note: one element MUST NOT be part of two models.\n\t\tstatements.setStatements(null);\n\t\tfor (CtStatement s : tobeInserted) {\n\t\t\tinsertEnd(s);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T getStatement(int i) {\n\t\treturn (T) statements.get(i);\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T getLastStatement() {\n\t\treturn (T) statements.get(statements.size() - 1);\n\t}\n\n\t@Override\n\tpublic void removeStatement(CtStatement statement) {\n\t\tif (this.statements == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\treturn;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, STATEMENT, statements, statements.indexOf(statement), statement);\n\t\tstatements.remove(statement);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setPosition(SourcePosition position) {\n\t\tfor (CtStatement s : statements) {\n\t\t\ts.setPosition(position);\n\t\t}\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic Iterator<CtStatement> iterator() {\n\t\treturn statements.iterator();\n\t}\n\n\t@Override\n\tpublic CtStatementList clone() {\n\t\treturn (CtStatementList) super.clone();\n\t}\n\n\tpublic CtStatementList getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtThrowImpl.java",
      "weight" : 41.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtThrowImpl extends CtStatementImpl implements CtThrow {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<? extends Throwable> throwExpression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtThrow(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<? extends Throwable> getThrownExpression() {\n\t\treturn throwExpression;\n\t}\n\n\t@Override\n\tpublic <T extends CtThrow> T setThrownExpression(CtExpression<? extends Throwable> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.throwExpression);\n\t\tthis.throwExpression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtThrow clone() {\n\t\treturn (CtThrow) super.clone();\n\t}\n\n\t@Override\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\tpublic CtCodeElement getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/code/CtJavaDocImpl.java",
      "weight" : 115.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.javadoc.internal.Javadoc;\nimport spoon.javadoc.internal.JavadocBlockTag;\nimport spoon.javadoc.internal.JavadocDescriptionElement;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.util.ModelList;\n\nimport java.util.List;\n\nimport static spoon.support.compiler.jdt.JDTCommentBuilder.cleanComment;\n\npublic class CtJavaDocImpl extends CtCommentImpl implements CtJavaDoc {\n\n\t/** the structured object resulting from parsing */\n\tprivate transient Javadoc javadoc;\n\n\t@MetamodelPropertyField(role = CtRole.COMMENT_TAG)\n\tprivate final ModelList<CtJavaDocTag> tags = new ModelList<CtJavaDocTag>() {\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtJavaDocImpl.this;\n\t\t}\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.COMMENT_TAG;\n\t\t}\n\t\t@Override\n\t\tprotected int getDefaultCapacity() {\n\t\t\treturn 2;\n\t\t}\n\t};\n\n\tpublic CtJavaDocImpl() {\n\t\tsuper(CommentType.JAVADOC);\n\t}\n\n\t@Override\n\tpublic List<CtJavaDocTag> getTags() {\n\t\treturn tags;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDoc> E setTags(List<CtJavaDocTag> tags) {\n\t\tthis.tags.set(tags);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDoc> E addTag(CtJavaDocTag tag) {\n\t\tthis.tags.add(tag);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDoc> E addTag(int index, CtJavaDocTag tag) {\n\t\tthis.tags.add(index, tag);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDoc> E removeTag(int index) {\n\t\tthis.tags.remove(index);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDoc> E removeTag(CtJavaDocTag tag) {\n\t\tthis.tags.remove(tag);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic String getShortDescription() {\n\t\tint indexEndSentence = this.getContent().indexOf('.');\n\t\tif (indexEndSentence == -1) {\n\t\t\tindexEndSentence = this.getContent().indexOf('\\n');\n\t\t}\n\t\tif (indexEndSentence != -1) {\n\t\t\treturn this.getContent().substring(0, indexEndSentence + 1).trim();\n\t\t} else {\n\t\t\treturn this.getContent().trim();\n\t\t}\n\t}\n\n\t/**\n\t * Parses the content string to split in two: the description and the Javadoc tags\n\t */\n\t@Override\n\tpublic <E extends CtComment> E setContent(String content) {\n\t\ttags.clear();\n\n\t\t// avoiding NPE later\n\t\tif (content == null) {\n\t\t\tcontent = \"\";\n\t\t}\n\n\t\tString longDescription = \"\";\n\t\tString currentTagContent = \"\";\n\t\tCtJavaDocTag.TagType currentTag = null;\n\n\t\tjavadoc = Javadoc.parse(cleanComment(content));\n\t\tfor (JavadocBlockTag tag: javadoc.getBlockTags()) {\n\t\t\taddTag(getFactory().createJavaDocTag(tag.getContent().toText(), CtJavaDocTag.TagType.tagFromName(tag.getTagName())));\n\t\t}\n\n\t\t// we cannot call super.setContent because it calls cleanComment (which has already been done above)\n\t\t// and we don't want to clean the comment twice\n\t\tString contentWithTags = javadoc.getDescription().toText().trim(); // trim is required for backward compatibility\n\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.COMMENT_CONTENT, contentWithTags, this.content);\n\t\tthis.content = contentWithTags;\n\n\t\treturn (E) this;\n\t}\n\n\n\n\t@Override\n\tpublic String getLongDescription() {\n\t\tint indexStartLongDescription = getShortDescription().length();\n\n\t\tif (indexStartLongDescription < this.getContent().trim().length()) {\n\t\t\treturn this.getContent().substring(indexStartLongDescription).trim();\n\t\t} else {\n\t\t\treturn this.getContent().trim();\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtJavaDoc(this);\n\t}\n\n\t@Override\n\tpublic CtJavaDoc clone() {\n\t\treturn (CtJavaDoc) super.clone();\n\t}\n\n\t@Override\n\tpublic List<JavadocDescriptionElement> getJavadocElements() {\n\t\treturn javadoc.getDescription().getElements();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCatchImpl.java",
      "weight" : 57.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.PARAMETER;\n\npublic class CtCatchImpl extends CtCodeElementImpl implements CtCatch {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = BODY)\n\tCtBlock<?> body;\n\n\t@MetamodelPropertyField(role = PARAMETER)\n\tCtCatchVariable<? extends Throwable> parameter;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCatch(this);\n\t}\n\n\t@Override\n\tpublic CtBlock<?> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic CtCatchVariable<? extends Throwable> getParameter() {\n\t\treturn parameter;\n\t}\n\n\t@Override\n\tpublic <T extends CtBodyHolder> T setBody(CtStatement statement) {\n\t\tif (statement != null) {\n\t\t\tCtBlock<?> body = getFactory().Code().getOrCreateCtBlock(statement);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, body, this.body);\n\t\t\tif (body != null) {\n\t\t\t\tbody.setParent(this);\n\t\t\t}\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectDelete(this, BODY, this.body);\n\t\t\tthis.body = null;\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtCatch> T setParameter(CtCatchVariable<? extends Throwable> parameter) {\n\t\tif (parameter != null) {\n\t\t\tparameter.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, PARAMETER, parameter, this.parameter);\n\t\tthis.parameter = parameter;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtCatch clone() {\n\t\treturn (CtCatch) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtAssignmentImpl.java",
      "weight" : 111.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.ASSIGNED;\nimport static spoon.reflect.path.CtRole.ASSIGNMENT;\nimport static spoon.reflect.path.CtRole.CAST;\nimport static spoon.reflect.path.CtRole.TYPE;\n\npublic class CtAssignmentImpl<T, A extends T> extends CtStatementImpl implements CtAssignment<T, A> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = ASSIGNED)\n\tCtExpression<T> assigned;\n\n\t@MetamodelPropertyField(role = ASSIGNMENT)\n\tCtExpression<A> assignment;\n\n\t@MetamodelPropertyField(role = TYPE)\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = CAST)\n\tList<CtTypeReference<?>> typeCasts = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtAssignment(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getAssigned() {\n\t\treturn assigned;\n\t}\n\n\t@Override\n\tpublic CtExpression<A> getAssignment() {\n\t\treturn assignment;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getTypeCasts() {\n\t\treturn typeCasts;\n\t}\n\n\t@Override\n\tpublic <C extends CtAssignment<T, A>> C setAssigned(CtExpression<T> assigned) {\n\t\tif (assigned != null) {\n\t\t\tassigned.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, ASSIGNED, assigned, this.assigned);\n\t\tthis.assigned = assigned;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtRHSReceiver<A>> C setAssignment(CtExpression<A> assignment) {\n\t\tif (assignment != null) {\n\t\t\tassignment.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, ASSIGNMENT, assignment, this.assignment);\n\t\tthis.assignment = assignment;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExpression<T>> C setTypeCasts(List<CtTypeReference<?>> casts) {\n\t\tif (casts == null || casts.isEmpty()) {\n\t\t\tthis.typeCasts = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.typeCasts = new ArrayList<>(CASTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CAST, this.typeCasts, new ArrayList<>(this.typeCasts));\n\t\tthis.typeCasts.clear();\n\t\tfor (CtTypeReference<?> cast : casts) {\n\t\t\taddTypeCast(cast);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExpression<T>> C addTypeCast(CtTypeReference<?> type) {\n\t\tif (type == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\ttypeCasts = new ArrayList<>(CASTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\ttype.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CAST, typeCasts, type);\n\t\ttypeCasts.add(type);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic T S() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtAssignment<T, A> clone() {\n\t\treturn (CtAssignment<T, A>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCaseImpl.java",
      "weight" : 165.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.Query;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class CtCaseImpl<E> extends CtStatementImpl implements CtCase<E> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.EXPRESSION)\n\tCtExpression<E> caseExpression;\n\n\t@MetamodelPropertyField(role = CtRole.STATEMENT)\n\tList<CtStatement> statements = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCase(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<E> getCaseExpression() {\n\t\treturn caseExpression;\n\t}\n\n\t@Override\n\tpublic List<CtStatement> getStatements() {\n\t\treturn statements;\n\t}\n\n\t@Override\n\tpublic <T extends CtCase<E>> T setCaseExpression(CtExpression<E> caseExpression) {\n\t\tif (caseExpression != null) {\n\t\t\tcaseExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.CASE, caseExpression, this.caseExpression);\n\t\tthis.caseExpression = caseExpression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T setStatements(List<CtStatement> statements) {\n\t\tif (statements == null || statements.isEmpty()) {\n\t\t\tthis.statements = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.STATEMENT, this.statements, new ArrayList<>(this.statements));\n\t\tthis.statements.clear();\n\t\tfor (CtStatement stmt : statements) {\n\t\t\taddStatement(stmt);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(CtStatement statement) {\n\t\treturn this.addStatement(this.statements.size(), statement);\n\t}\n\n\tprivate void ensureModifiableStatementsList() {\n\t\tif (this.statements == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\tthis.statements = new ArrayList<>(ModelElementContainerDefaultCapacities.CASE_STATEMENTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(int index, CtStatement statement) {\n\t\tif (statement == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tthis.ensureModifiableStatementsList();\n\t\tstatement.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.STATEMENT, this.statements, index, statement);\n\t\tstatements.add(index, statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatement statement) {\n\t\tensureModifiableStatementsList();\n\t\tstatement.setParent(this);\n\t\tthis.addStatement(0, statement);\n\n\t\tif (isImplicit() && this.statements.size() > 1) {\n\t\t\tsetImplicit(false);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatementList statements) {\n\t\tthis.ensureModifiableStatementsList();\n\t\tfor (CtStatement statement : statements.getStatements()) {\n\t\t\tstatement.setParent(this);\n\t\t\tthis.addStatement(0, statement);\n\t\t}\n\t\tif (isImplicit() && this.statements.size() > 1) {\n\t\t\tsetImplicit(false);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatement statement) {\n\t\tensureModifiableStatementsList();\n\t\taddStatement(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatementList statements) {\n\t\tList<CtStatement> tobeInserted = new ArrayList<>(statements.getStatements());\n\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t//note: one element MUST NOT be part of two models.\n\t\tstatements.setStatements(null);\n\t\tfor (CtStatement s : tobeInserted) {\n\t\t\tinsertEnd(s);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T getStatement(int i) {\n\t\treturn (T) statements.get(i);\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T getLastStatement() {\n\t\treturn (T) statements.get(statements.size() - 1);\n\t}\n\n\t@Override\n\tpublic void removeStatement(CtStatement statement) {\n\t\tif (statements == CtElementImpl.<CtStatement>emptyList()) {\n\t\t\treturn;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.STATEMENT, statements, statements.indexOf(statement), statement);\n\t\tstatements.remove(statement);\n\t}\n\n\t@Override\n\tpublic Iterator<CtStatement> iterator() {\n\t\treturn getStatements().iterator();\n\t}\n\n\t@Override\n\tpublic CtCase<E> clone() {\n\t\treturn (CtCase<E>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCommentImpl.java",
      "weight" : 94.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtJavaDoc;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.util.Objects;\n\nimport static spoon.support.compiler.jdt.JDTCommentBuilder.cleanComment;\n\npublic class CtCommentImpl extends CtStatementImpl implements CtComment {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.COMMENT_CONTENT)\n\tprotected String content;\n\n\t@MetamodelPropertyField(role = CtRole.COMMENT_TYPE)\n\tprivate CommentType type;\n\n\tpublic CtCommentImpl() {\n\t}\n\n\tprotected CtCommentImpl(CommentType type) {\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\n\t@Override\n\tpublic String getRawContent() {\n\t\tSourcePosition pos = getPosition();\n\t\tCtCompilationUnit cu = pos.getCompilationUnit();\n\t\tif (cu != null) {\n\t\t\tString source = cu.getOriginalSourceCode();\n\t\t\tif (source != null) {\n\t\t\t\treturn source.substring(pos.getSourceStart(), pos.getSourceEnd() + 1);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic <E extends CtComment> E setContent(String content) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.COMMENT_CONTENT, content, this.content);\n\t\tthis.content = cleanComment(content);\n\t\treturn (E) this;\n\t}\n\n\t/**\n\t * FOR ADVANCED USAGE ONLY\n\t * Set the comment content, without cleaning the comment, if the cleaning behavior to get a canonical version does not work for you.\n\t * Does not ensure any AST contract such as calling the change listener\n\t * You have to cast your comment to CtCommentImpl, it's not beautiful, but it's known :-)\n\t */\n\tpublic <E extends CtComment> E _setRawContent(String content) {\n\t\tthis.content = content;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CommentType getCommentType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <E extends CtComment> E setCommentType(CommentType commentType) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, commentType, this.type);\n\t\ttype = commentType;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtComment(this);\n\t}\n\n\t/**\n\t * The comments are not printed during the CtElement equality.\n\t * The method is this overridden for CtComment.\n\t */\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tCtCommentImpl ctComment = (CtCommentImpl) o;\n\n\t\tif (!Objects.equals(content, ctComment.content)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn type == ctComment.type;\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = super.hashCode();\n\t\tresult = 31 * result + (content != null ? content.hashCode() : 0);\n\t\tresult = 31 * result + (type != null ? type.hashCode() : 0);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic CtComment clone() {\n\t\treturn (CtComment) super.clone();\n\t}\n\n\t@Override\n\tpublic CtJavaDoc asJavaDoc() {\n\t\tif (this instanceof CtJavaDoc) {\n\t\t\treturn (CtJavaDoc) this;\n\t\t}\n\t\tthrow new IllegalStateException(\"not a javadoc comment\");\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtLambdaImpl.java",
      "weight" : 215.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtLambda;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.declaration.CtElementImpl;\nimport spoon.support.util.QualifiedNameBasedSortedSet;\nimport spoon.support.visitor.SignaturePrinter;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.NAME;\nimport static spoon.reflect.path.CtRole.PARAMETER;\nimport static spoon.reflect.path.CtRole.THROWN;\n\npublic class CtLambdaImpl<T> extends CtExpressionImpl<T> implements CtLambda<T> {\n\t@MetamodelPropertyField(role = NAME)\n\tString simpleName = \"\";\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<T> expression;\n\t@MetamodelPropertyField(role = BODY)\n\tCtBlock<?> body;\n\t@MetamodelPropertyField(role = PARAMETER)\n\tList<CtParameter<?>> parameters = emptyList();\n\t@MetamodelPropertyField(role = THROWN)\n\tSet<CtTypeReference<? extends Throwable>> thrownTypes = emptySet();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtLambda(this);\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn simpleName;\n\t}\n\n\t@Override\n\tpublic <C extends CtNamedElement> C setSimpleName(String simpleName) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, NAME, simpleName, this.simpleName);\n\t\tthis.simpleName = simpleName;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtBlock<T> getBody() {\n\t\treturn (CtBlock<T>) body;\n\t}\n\n\t@Override\n\tpublic <C extends CtBodyHolder> C setBody(CtStatement statement) {\n\t\tif (statement != null) {\n\t\t\tCtBlock<?> body = getFactory().Code().getOrCreateCtBlock(statement);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, body, this.body);\n\t\t\tif (expression != null && body != null) {\n\t\t\t\tthrow new SpoonException(\"A lambda can't have two bodys.\");\n\t\t\t}\n\t\t\tif (body != null) {\n\t\t\t\tbody.setParent(this);\n\t\t\t}\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectDelete(this, BODY, this.body);\n\t\t\tthis.body = null;\n\t\t}\n\n\t\treturn (C) this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R> CtMethod<R> getOverriddenMethod() {\n\t\t//The type of this lambda expression. For example: `Consumer<Integer>`\n\t\tCtTypeReference<T> lambdaTypeRef = getType();\n\t\tif (lambdaTypeRef == null) {\n\t\t\t//it can be null in noclasspath mode, so we do not know which method is called, by lambda\n\t\t\treturn null;\n\t\t}\n\t\tCtType<T> lambdaType = lambdaTypeRef.getTypeDeclaration();\n\t\tif (lambdaType.isInterface() == false) {\n\t\t\tthrow new SpoonException(\"The lambda can be based on interface only. But type \" + lambdaTypeRef.getQualifiedName() + \" is not an interface\");\n\t\t}\n\t\tSet<CtMethod<?>> lambdaTypeMethods = lambdaType.getAllMethods();\n\t\tCtMethod<?> lambdaExecutableMethod = null;\n\t\tif (lambdaTypeMethods.size() == 1) {\n\t\t\t//even the default method can be used, if it is the only one\n\t\t\tlambdaExecutableMethod = lambdaTypeMethods.iterator().next();\n\t\t} else {\n\t\t\tfor (CtMethod<?> method : lambdaTypeMethods) {\n\t\t\t\tif (getFactory().Method().OBJECT_METHODS.stream().anyMatch(method::isOverriding)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (method.isDefaultMethod() || method.hasModifier(ModifierKind.PRIVATE) || method.hasModifier(ModifierKind.STATIC)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (lambdaExecutableMethod != null) {\n\t\t\t\t\tthrow new SpoonException(\"The lambda can be based on interface, which has only one method. But \" + lambdaTypeRef.getQualifiedName() + \" has at least two: \" + lambdaExecutableMethod.getSignature() + \" and \" + method.getSignature());\n\t\t\t\t}\n\t\t\t\tlambdaExecutableMethod = method;\n\t\t\t}\n\t\t}\n\t\tif (lambdaExecutableMethod == null) {\n\t\t\tthrow new SpoonException(\"The lambda can be based on interface, which has one method. But \" + lambdaTypeRef.getQualifiedName() + \" has no one\");\n\t\t}\n\t\treturn (CtMethod<R>) lambdaExecutableMethod;\n\t}\n\n\t@Override\n\tpublic List<CtParameter<?>> getParameters() {\n\t\treturn unmodifiableList(parameters);\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutable<T>> C setParameters(List<CtParameter<?>> params) {\n\t\tif (params == null || params.isEmpty()) {\n\t\t\tthis.parameters = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\tthis.parameters = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, PARAMETER, this.parameters, new ArrayList<>(this.parameters));\n\t\tthis.parameters.clear();\n\t\tfor (CtParameter<?> p : params) {\n\t\t\taddParameter(p);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutable<T>> C addParameter(CtParameter<?> parameter) {\n\t\tif (parameter == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\tparameters = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tparameter.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, PARAMETER, this.parameters, parameter);\n\t\tparameters.add(parameter);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeParameter(CtParameter<?> parameter) {\n\t\tif (parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, PARAMETER, parameters, parameters.indexOf(parameter), parameter);\n\t\treturn parameters.remove(parameter);\n\t}\n\n\t@Override\n\tpublic Set<CtTypeReference<? extends Throwable>> getThrownTypes() {\n\t\treturn thrownTypes;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtExecutable<T>> C setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutable<T>> C addThrownType(CtTypeReference<? extends Throwable> throwType) {\n\t\tif (throwType == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {\n\t\t\tthrownTypes = new QualifiedNameBasedSortedSet<>();\n\t\t}\n\t\tthrowType.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(this, THROWN, this.thrownTypes, throwType);\n\t\tthrownTypes.add(throwType);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeThrownType(CtTypeReference<? extends Throwable> throwType) {\n\t\tif (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDelete(this, THROWN, thrownTypes, throwType);\n\t\treturn thrownTypes.remove(throwType);\n\t}\n\n\t@Override\n\tpublic String getSignature() {\n\t\tfinal SignaturePrinter pr = new SignaturePrinter();\n\t\tpr.scan(this);\n\t\treturn pr.getSignature();\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<T> getReference() {\n\t\treturn getFactory().Executable().createReference(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <C extends CtLambda<T>> C setExpression(CtExpression<T> expression) {\n\t\tif (body != null && expression != null) {\n\t\t\tthrow new SpoonException(\"A lambda can't have two bodies.\");\n\t\t} else {\n\t\t\tif (expression != null) {\n\t\t\t\texpression.setParent(this);\n\t\t\t}\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\t\tthis.expression = expression;\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtLambda<T> clone() {\n\t\treturn (CtLambda<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtSynchronizedImpl.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtSynchronizedImpl extends CtStatementImpl implements CtSynchronized {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = BODY)\n\tCtBlock<?> block;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<?> expression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtSynchronized(this);\n\t}\n\n\t@Override\n\tpublic CtBlock<?> getBlock() {\n\t\treturn block;\n\t}\n\n\t@Override\n\tpublic CtExpression<?> getExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <T extends CtSynchronized> T setBlock(CtBlock<?> block) {\n\t\tif (block != null) {\n\t\t\tblock.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, block, this.block);\n\t\tthis.block = block;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtSynchronized> T setExpression(CtExpression<?> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtSynchronized clone() {\n\t\treturn (CtSynchronized) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtOperatorAssignmentImpl.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\n\npublic class CtOperatorAssignmentImpl<T, A extends T> extends CtAssignmentImpl<T, A> implements CtOperatorAssignment<T, A> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = OPERATOR_KIND)\n\tBinaryOperatorKind kind;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtOperatorAssignment(this);\n\t}\n\n\t@Override\n\tpublic BinaryOperatorKind getKind() {\n\t\treturn kind;\n\t}\n\n\t@Override\n\tpublic <C extends CtOperatorAssignment<T, A>> C setKind(BinaryOperatorKind kind) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, OPERATOR_KIND, kind, this.kind);\n\t\tthis.kind = kind;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtOperatorAssignment<T, A> clone() {\n\t\treturn (CtOperatorAssignment<T, A>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtForEachImpl.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtForEach;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.FOREACH_VARIABLE;\n\npublic class CtForEachImpl extends CtLoopImpl implements CtForEach {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<?> expression;\n\n\t@MetamodelPropertyField(role = FOREACH_VARIABLE)\n\tCtLocalVariable<?> variable;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtForEach(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<?> getExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic CtLocalVariable<?> getVariable() {\n\t\treturn variable;\n\t}\n\n\t@Override\n\tpublic <T extends CtForEach> T setExpression(CtExpression<?> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtForEach> T setVariable(CtLocalVariable<?> variable) {\n\t\tif (variable != null) {\n\t\t\tvariable.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, FOREACH_VARIABLE, variable, this.variable);\n\t\tthis.variable = variable;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtForEach clone() {\n\t\treturn (CtForEach) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtAssertImpl.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtAssert;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtAssertImpl<T> extends CtStatementImpl implements CtAssert<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CONDITION)\n\tCtExpression<Boolean> asserted;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<T> value;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtAssert(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getAssertExpression() {\n\t\treturn asserted;\n\t}\n\n\t@Override\n\tpublic <A extends CtAssert<T>> A setAssertExpression(CtExpression<Boolean> asserted) {\n\t\tif (asserted != null) {\n\t\t\tasserted.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CONDITION, asserted, this.asserted);\n\t\tthis.asserted = asserted;\n\t\treturn (A) this;\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getExpression() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic <A extends CtAssert<T>> A setExpression(CtExpression<T> value) {\n\t\tif (value != null) {\n\t\t\tvalue.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, value, this.value);\n\t\tthis.value = value;\n\t\treturn (A) this;\n\t}\n\n\t@Override\n\tpublic CtAssert<T> clone() {\n\t\treturn (CtAssert<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtSuperAccessImpl.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtSuperAccess;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.TARGET;\n\npublic class CtSuperAccessImpl<T> extends CtVariableReadImpl<T> implements CtSuperAccess<T> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtSuperAccess(this);\n\t}\n\n\t@MetamodelPropertyField(role = TARGET)\n\tCtExpression<?> target;\n\n\t@Override\n\tpublic CtExpression<?> getTarget() {\n\t\treturn target;\n\t}\n\n\t@Override\n\tpublic <C extends CtTargetedExpression<T, CtExpression<?>>> C setTarget(CtExpression<?> target) {\n\t\tif (target != null) {\n\t\t\ttarget.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET, target, this.target);\n\t\tthis.target = target;\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtSuperAccess<T> clone() {\n\t\treturn (CtSuperAccess<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtFieldWriteImpl.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtFieldWriteImpl<T> extends CtFieldAccessImpl<T> implements CtFieldWrite<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtFieldWrite(this);\n\t}\n\n\t@Override\n\tpublic CtFieldWrite<T> clone() {\n\t\treturn (CtFieldWrite<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtJavaDocTagImpl.java",
      "weight" : 66.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtJavaDocTag;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport static spoon.reflect.path.CtRole.COMMENT_CONTENT;\nimport static spoon.reflect.path.CtRole.JAVADOC_TAG_VALUE;\nimport static spoon.reflect.path.CtRole.DOCUMENTATION_TYPE;\n\npublic class CtJavaDocTagImpl extends CtElementImpl implements CtJavaDocTag {\n\n\t@MetamodelPropertyField(role = DOCUMENTATION_TYPE)\n\tprivate CtJavaDocTag.TagType type;\n\t@MetamodelPropertyField(role = COMMENT_CONTENT)\n\tprivate String content;\n\t@MetamodelPropertyField(role = JAVADOC_TAG_VALUE)\n\tprivate String param;\n\n\t@Override\n\tpublic TagType getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDocTag> E setType(String type) {\n\t\tthis.setType(CtJavaDocTag.TagType.tagFromName(type));\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDocTag> E setType(TagType type) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, DOCUMENTATION_TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDocTag> E setContent(String content) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, COMMENT_CONTENT, content, this.content);\n\t\tthis.content = content;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic String getParam() {\n\t\treturn param;\n\t}\n\n\t@Override\n\tpublic <E extends CtJavaDocTag> E setParam(String param) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, JAVADOC_TAG_VALUE, param, this.param);\n\t\tthis.param = param;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtJavaDocTag(this);\n\t}\n\n\t@Override\n\tpublic CtJavaDocTag clone() {\n\t\treturn (CtJavaDocTag) super.clone();\n\t}\n\n\t@Override\n\tpublic String toString()\t{\n\t\treturn this.getType().toString()\t//Tag type, with @ sign included\n\t\t\t\t+ \" \"\t//Space required between tag type and parameter\n\t\t\t\t+ this.param + System.lineSeparator()\t//Tag parameter\n\t\t\t\t+ \"\\t\\t\" + this.content + System.lineSeparator();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtConstructorCallImpl.java",
      "weight" : 173.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtAbstractInvocation;\nimport spoon.reflect.code.CtConstructorCall;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.ARGUMENT;\nimport static spoon.reflect.path.CtRole.EXECUTABLE_REF;\nimport static spoon.reflect.path.CtRole.LABEL;\n\npublic class CtConstructorCallImpl<T> extends CtTargetedExpressionImpl<T, CtExpression<?>> implements CtConstructorCall<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = ARGUMENT)\n\tList<CtExpression<?>> arguments = emptyList();\n\t@MetamodelPropertyField(role = EXECUTABLE_REF)\n\tCtExecutableReference<T> executable;\n\t@MetamodelPropertyField(role = LABEL)\n\tString label;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtConstructorCall(this);\n\t}\n\n\t@Override\n\tpublic List<CtExpression<?>> getArguments() {\n\t\treturn arguments;\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<T> getExecutable() {\n\t\tif (executable == null) {\n\t\t\t// default reference\n\t\t\texecutable = getFactory().Core().createExecutableReference();\n\t\t\texecutable.setParent(this);\n\t\t}\n\t\treturn executable;\n\t}\n\n\t@Override\n\tpublic String getLabel() {\n\t\treturn label;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatement statement) {\n\t\tCtStatementImpl.insertAfter(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatement statement) {\n\t\tCtStatementImpl.insertBefore(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatementList statements) {\n\t\tCtStatementImpl.insertAfter(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatementList statements) {\n\t\tCtStatementImpl.insertBefore(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C setArguments(List<CtExpression<?>> arguments) {\n\t\tif (arguments == null || arguments.isEmpty()) {\n\t\t\tthis.arguments = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\tthis.arguments = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, ARGUMENT, this.arguments, new ArrayList<>(this.arguments));\n\t\tthis.arguments.clear();\n\t\tfor (CtExpression<?> expr : arguments) {\n\t\t\taddArgument(expr);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\tprivate <C extends CtAbstractInvocation<T>> C addArgument(int position, CtExpression<?> argument) {\n\t\tif (argument == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\targuments = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\targument.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, ARGUMENT, this.arguments, position, argument);\n\t\targuments.add(position, argument);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C addArgument(CtExpression<?> argument) {\n\t\treturn addArgument(arguments.size(), argument);\n\t}\n\n\t@Override\n\tpublic void removeArgument(CtExpression<?> argument) {\n\t\tif (arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\treturn;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, ARGUMENT, arguments, arguments.indexOf(argument), argument);\n\t\targuments.remove(argument);\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C setExecutable(CtExecutableReference<T> executable) {\n\t\tif (executable != null) {\n\t\t\texecutable.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXECUTABLE_REF, executable, this.executable);\n\t\tthis.executable = executable;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C setLabel(String label) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, LABEL, label, this.label);\n\t\tthis.label = label;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeReference<?>> getActualTypeArguments() {\n\t\treturn getExecutable() == null ? CtElementImpl.<CtTypeReference<?>>emptyList() : getExecutable().getActualTypeArguments();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments) {\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().setActualTypeArguments(actualTypeArguments);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().addActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic boolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (getExecutable() != null) {\n\t\t\treturn getExecutable().removeActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<T> getType() {\n\t\treturn getExecutable() == null ? null : getExecutable().getType();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().setType(type);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtConstructorCall<T> clone() {\n\t\treturn (CtConstructorCall<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtTryWithResourceImpl.java",
      "weight" : 61.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtTryWithResource;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.RESOURCES_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.TRY_RESOURCE;\n\npublic class CtTryWithResourceImpl extends CtTryImpl implements CtTryWithResource {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TRY_RESOURCE)\n\tList<CtLocalVariable<?>> resources = emptyList();\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTryWithResource(this);\n\t}\n\n\t@Override\n\tpublic List<CtLocalVariable<?>> getResources() {\n\t\treturn resources;\n\t}\n\n\t@Override\n\tpublic <T extends CtTryWithResource> T setResources(List<CtLocalVariable<?>> resources) {\n\t\tif (resources == null || resources.isEmpty()) {\n\t\t\tthis.resources = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, TRY_RESOURCE, this.resources, new ArrayList<>(this.resources));\n\t\tthis.resources.clear();\n\t\tfor (CtLocalVariable<?> l : resources) {\n\t\t\taddResource(l);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtTryWithResource> T addResource(CtLocalVariable<?> resource) {\n\t\tif (resource == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (resources == CtElementImpl.<CtLocalVariable<?>>emptyList()) {\n\t\t\tresources = new ArrayList<>(RESOURCES_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tresource.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, TRY_RESOURCE, this.resources, resource);\n\t\tresources.add(resource);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeResource(CtLocalVariable<?> resource) {\n\t\tif (resources == CtElementImpl.<CtLocalVariable<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, TRY_RESOURCE, resources, resources.indexOf(resource), resource);\n\t\treturn resources.remove(resource);\n\t}\n\n\t@Override\n\tpublic CtTryWithResource clone() {\n\t\treturn (CtTryWithResource) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtLocalVariableImpl.java",
      "weight" : 175.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtLocalVariableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\n\nimport java.util.Set;\n\npublic class CtLocalVariableImpl<T> extends CtStatementImpl implements CtLocalVariable<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.DEFAULT_EXPRESSION)\n\tCtExpression<T> defaultExpression;\n\n\t@MetamodelPropertyField(role = CtRole.NAME)\n\tString name = \"\";\n\n\t@MetamodelPropertyField(role = CtRole.TYPE)\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\t@MetamodelPropertyField(role = CtRole.IS_INFERRED)\n\tprivate boolean inferred;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtLocalVariable(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getDefaultExpression() {\n\t\treturn defaultExpression;\n\t}\n\n\t@Override\n\tpublic CtLocalVariableReference<T> getReference() {\n\t\treturn getFactory().Code().createLocalVariableReference(this);\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> defaultExpression) {\n\t\tif (defaultExpression != null) {\n\t\t\tdefaultExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.DEFAULT_EXPRESSION, defaultExpression, this.defaultExpression);\n\t\tthis.defaultExpression = defaultExpression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtNamedElement> C setSimpleName(String simpleName) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.NAME, simpleName, this.name);\n\t\tthis.name = simpleName;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\tif (getModifiers().contains(ModifierKind.PUBLIC)) {\n\t\t\treturn ModifierKind.PUBLIC;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PROTECTED)) {\n\t\t\treturn ModifierKind.PROTECTED;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PRIVATE)) {\n\t\t\treturn ModifierKind.PRIVATE;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtExpression<T> getAssignment() {\n\t\treturn getDefaultExpression();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtRHSReceiver<T>> C setAssignment(CtExpression<T> assignment) {\n\t\tsetDefaultExpression(assignment);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isInferred() {\n\t\treturn this.inferred;\n\t}\n\n\t@Override\n\tpublic <U extends CtLocalVariable<T>> U setInferred(boolean inferred) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_INFERRED, inferred, this.inferred);\n\t\tthis.inferred = inferred;\n\t\treturn (U) this;\n\t}\n\n\t@Override\n\tpublic CtLocalVariable<T> clone() {\n\t\treturn (CtLocalVariable<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtTypeAccessImpl.java",
      "weight" : 60.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.ACCESSED_TYPE;\n\npublic class CtTypeAccessImpl<A> extends CtExpressionImpl<Void> implements CtTypeAccess<A> {\n\n\t@MetamodelPropertyField(role = ACCESSED_TYPE)\n\tprivate CtTypeReference<A> type;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTypeAccess(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<A> getAccessedType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypeAccess<A>> C setAccessedType(CtTypeReference<A> accessedType) {\n\t\tif (accessedType != null) {\n\t\t\taccessedType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, ACCESSED_TYPE, accessedType, this.type);\n\t\ttype = accessedType;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<Void> getType() {\n\t\treturn (CtTypeReference<Void>) getFactory().Type().VOID_PRIMITIVE.clone().<CtTypeAccess>setParent(this);\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<Void> type) {\n\t\t// type is used in setAccessedType now.\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic boolean isImplicit() {\n\t\tif (type != null) {\n\t\t\treturn type.isImplicit();\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <E extends CtElement> E setImplicit(boolean implicit) {\n\t\tif (type != null) {\n\t\t\ttype.setImplicit(implicit);\n\t\t}\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtTypeAccess<A> clone() {\n\t\treturn (CtTypeAccess<A>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtLiteralImpl.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtLiteralImpl<T> extends CtExpressionImpl<T> implements CtLiteral<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.VALUE)\n\tT value;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtLiteral(this);\n\t}\n\n\t@Override\n\tpublic T getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic <C extends CtLiteral<T>> C setValue(T value) {\n\t\tif (this.value instanceof CtElement) {\n\t\t\t((CtElement) this.value).setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, value, this.value);\n\t\tthis.value = value;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtLiteral<T> clone() {\n\t\treturn (CtLiteral<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtNewClassImpl.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtNewClass;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.NESTED_TYPE;\n\npublic class CtNewClassImpl<T> extends CtConstructorCallImpl<T> implements CtNewClass<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = NESTED_TYPE)\n\tCtClass<?> anonymousClass;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtNewClass(this);\n\t}\n\n\t@Override\n\tpublic CtClass<?> getAnonymousClass() {\n\t\treturn anonymousClass;\n\t}\n\n\t@Override\n\tpublic <N extends CtNewClass> N setAnonymousClass(CtClass<?> anonymousClass) {\n\t\tif (anonymousClass != null) {\n\t\t\tanonymousClass.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, NESTED_TYPE, anonymousClass, this.anonymousClass);\n\t\tthis.anonymousClass = anonymousClass;\n\t\treturn (N) this;\n\t}\n\n\t@Override\n\tpublic CtNewClass<T> clone() {\n\t\treturn (CtNewClass<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCatchVariableImpl.java",
      "weight" : 215.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtMultiTypedElement;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtCatchVariableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CtCatchVariableImpl<T> extends CtCodeElementImpl implements CtCatchVariable<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.NAME)\n\tString name = \"\";\n\n\t@MetamodelPropertyField(role = CtRole.MULTI_TYPE)\n\tList<CtTypeReference<?>> types = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCatchVariable(this);\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtExpression<T> getDefaultExpression() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtCatchVariableReference<T> getReference() {\n\t\treturn getFactory().Code().createCatchVariableReference(this);\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn name;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<T> getType() {\n\t\tif (types.isEmpty()) {\n\t\t\treturn null;\n\t\t} else if (types.size() == 1) {\n\t\t\treturn (CtTypeReference<T>) types.get(0);\n\t\t}\n\t\t//compute common super type of exceptions\n\t\tList<CtTypeReference<?>> superTypesOfFirst = types.get(0).map(new SuperInheritanceHierarchyFunction()\n\t\t\t\t.includingInterfaces(false)\n\t\t\t\t.includingSelf(true)\n\t\t\t\t.returnTypeReferences(true)).list();\n\t\tif (superTypesOfFirst.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tint commonSuperTypeIdx = 0;\n\t\t//index of Throwable. Last is Object\n\t\tint throwableIdx = superTypesOfFirst.size() - 2;\n\t\tfor (int i = 1; i < types.size() && commonSuperTypeIdx != throwableIdx; i++) {\n\t\t\tCtTypeReference<?> nextException = types.get(i);\n\t\t\twhile (commonSuperTypeIdx < throwableIdx) {\n\t\t\t\tif (nextException.isSubtypeOf(superTypesOfFirst.get(commonSuperTypeIdx))) {\n\t\t\t\t\t//nextException is sub type of actually selected commonSuperType\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//try next super type\n\t\t\t\tcommonSuperTypeIdx++;\n\t\t\t}\n\t\t}\n\t\treturn (CtTypeReference<T>) superTypesOfFirst.get(commonSuperTypeIdx);\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> defaultExpression) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtNamedElement> C setSimpleName(String simpleName) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.NAME, simpleName, this.name);\n\t\tthis.name = simpleName;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tsetMultiTypes(type == null ? emptyList() : Collections.singletonList(type));\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtMultiTypedElement> T addMultiType(CtTypeReference<?> type) {\n\t\tif (type == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (types == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\ttypes = new ArrayList<>(ModelElementContainerDefaultCapacities.CATCH_VARIABLE_MULTI_TYPES_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\ttype.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.MULTI_TYPE, this.types, type);\n\t\ttypes.add(type);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeMultiType(CtTypeReference<?> ref) {\n\t\tif (this.types == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.MULTI_TYPE, types, types.indexOf(ref), ref);\n\t\treturn types.remove(ref);\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getMultiTypes() {\n\t\treturn types;\n\t}\n\n\t@Override\n\tpublic <T extends CtMultiTypedElement> T setMultiTypes(List<CtTypeReference<?>> types) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.MULTI_TYPE, this.types, new ArrayList<>(this.types));\n\t\tif (types == null || types.isEmpty()) {\n\t\t\tthis.types = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.types == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.types = new ArrayList<>();\n\t\t}\n\t\tthis.types.clear();\n\t\tfor (CtTypeReference<?> t : types) {\n\t\t\taddMultiType(t);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\tif (getModifiers().contains(ModifierKind.PUBLIC)) {\n\t\t\treturn ModifierKind.PUBLIC;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PROTECTED)) {\n\t\t\treturn ModifierKind.PROTECTED;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PRIVATE)) {\n\t\t\treturn ModifierKind.PRIVATE;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtCatchVariable<T> clone() {\n\t\treturn (CtCatchVariable<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtInvocationImpl.java",
      "weight" : 169.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtAbstractInvocation;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtActualTypeContainer;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.ARGUMENT;\nimport static spoon.reflect.path.CtRole.EXECUTABLE_REF;\nimport static spoon.reflect.path.CtRole.LABEL;\n\npublic class CtInvocationImpl<T> extends CtTargetedExpressionImpl<T, CtExpression<?>> implements CtInvocation<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = LABEL)\n\tString label;\n\n\t@MetamodelPropertyField(role = ARGUMENT)\n\tList<CtExpression<?>> arguments = emptyList();\n\n\t@MetamodelPropertyField(role = EXECUTABLE_REF)\n\tCtExecutableReference<T> executable;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtInvocation(this);\n\t}\n\n\t@Override\n\tpublic List<CtExpression<?>> getArguments() {\n\t\treturn arguments;\n\t}\n\n\tprivate <C extends CtAbstractInvocation<T>> C addArgument(int position, CtExpression<?> argument) {\n\t\tif (argument == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\targuments = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\targument.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, ARGUMENT, this.arguments, position, argument);\n\t\targuments.add(position, argument);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C addArgument(CtExpression<?> argument) {\n\t\treturn addArgument(arguments.size(), argument);\n\t}\n\n\t@Override\n\tpublic void removeArgument(CtExpression<?> argument) {\n\t\tif (arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\treturn;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, ARGUMENT, arguments, arguments.indexOf(argument), argument);\n\t\targuments.remove(argument);\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<T> getExecutable() {\n\t\tif (executable == null) {\n\t\t\t// default reference\n\t\t\texecutable = getFactory().Core().createExecutableReference();\n\t\t\texecutable.setParent(this);\n\t\t}\n\t\treturn executable;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatement statement) {\n\t\tCtStatementImpl.insertAfter(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatement statement) {\n\t\tCtStatementImpl.insertBefore(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatementList statements) {\n\t\tCtStatementImpl.insertAfter(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatementList statements) {\n\t\tCtStatementImpl.insertBefore(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C setArguments(List<CtExpression<?>> arguments) {\n\t\tif (arguments == null || arguments.isEmpty()) {\n\t\t\tthis.arguments = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.arguments == CtElementImpl.<CtExpression<?>>emptyList()) {\n\t\t\tthis.arguments = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, ARGUMENT, this.arguments, new ArrayList<>(this.arguments));\n\t\tthis.arguments.clear();\n\t\tfor (CtExpression<?> expr : arguments) {\n\t\t\taddArgument(expr);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtAbstractInvocation<T>> C setExecutable(CtExecutableReference<T> executable) {\n\t\tif (executable != null) {\n\t\t\texecutable.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXECUTABLE_REF, executable, this.executable);\n\t\tthis.executable = executable;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String getLabel() {\n\t\treturn label;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C setLabel(String label) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, LABEL, label, this.label);\n\t\tthis.label = label;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<T> getType() {\n\t\treturn getExecutable() == null ? null : getExecutable().getType();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().setType(type);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getActualTypeArguments() {\n\t\treturn getExecutable() == null ? CtElementImpl.<CtTypeReference<?>>emptyList() : getExecutable().getActualTypeArguments();\n\t}\n\n\t@Override\n\tpublic <T extends CtActualTypeContainer> T setActualTypeArguments(List<? extends CtTypeReference<?>> actualTypeArguments) {\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().setActualTypeArguments(actualTypeArguments);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtActualTypeContainer> T addActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (getExecutable() != null) {\n\t\t\tgetExecutable().addActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeActualTypeArgument(CtTypeReference<?> actualTypeArgument) {\n\t\tif (getExecutable() != null) {\n\t\t\treturn getExecutable().removeActualTypeArgument(actualTypeArgument);\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic CtInvocation<T> clone() {\n\t\treturn (CtInvocation<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtLoopImpl.java",
      "weight" : 45.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtLoop;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtType;\n\nimport static spoon.reflect.path.CtRole.BODY;\n\npublic abstract class CtLoopImpl extends CtStatementImpl implements CtLoop {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = BODY)\n\tCtStatement body;\n\n\t@Override\n\tpublic CtStatement getBody() {\n\t\treturn body;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends CtBodyHolder> T setBody(CtStatement statement) {\n\t\tif (statement != null) {\n\t\t\tCtBlock<?> body = getFactory().Code().getOrCreateCtBlock(statement);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, body, this.body);\n\t\t\tif (body != null) {\n\t\t\t\tbody.setParent(this);\n\t\t\t}\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectDelete(this, BODY, this.body);\n\t\t\tthis.body = null;\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtLoop clone() {\n\t\treturn (CtLoop) super.clone();\n\t}\n\n\t@Override\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\tpublic CtCodeElement getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCodeSnippetExpressionImpl.java",
      "weight" : 37.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeSnippetExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.compiler.SnippetCompilationError;\nimport spoon.support.compiler.SnippetCompilationHelper;\n\nimport static spoon.reflect.path.CtRole.SNIPPET;\n\npublic class CtCodeSnippetExpressionImpl<T> extends CtExpressionImpl<T> implements CtCodeSnippetExpression<T> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCodeSnippetExpression(this);\n\t}\n\n\t@MetamodelPropertyField(role = SNIPPET)\n\tString value;\n\n\t@Override\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic <C extends CtCodeSnippet> C setValue(String value) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SNIPPET, value, this.value);\n\t\tthis.value = value;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <E extends CtExpression<T>> E compile() throws SnippetCompilationError {\n\t\treturn (E) SnippetCompilationHelper.compileExpression(this);\n\t}\n\n\t@Override\n\tpublic CtCodeSnippetExpression<T> clone() {\n\t\treturn (CtCodeSnippetExpression<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtStatementImpl.java",
      "weight" : 234.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLoop;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.LABEL;\n\npublic abstract class CtStatementImpl extends CtCodeElementImpl implements CtStatement {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic static void insertAfter(CtStatement target, CtStatement statement)\n\tthrows ParentNotInitializedException {\n\t\tCtStatementList sts = target.getFactory().Core().createStatementList();\n\t\tsts.addStatement(statement);\n\t\tinsertAfter(target, sts);\n\t}\n\n\tpublic static void insertAfter(CtStatement target, CtStatementList statements)\n\tthrows ParentNotInitializedException {\n\t\tCtElement e = target.getParent();\n\t\tif (e instanceof CtExecutable) {\n\t\t\tthrow new RuntimeException(\"cannot insert in this context (use insertEnd?)\");\n\t\t}\n\n\t\tnew InsertVisitor(target, statements, InsertType.AFTER).scan(e);\n\t}\n\n\t/** insert `statement` just before target */\n\tpublic static void insertBefore(CtStatement target, CtStatement statement)\n\tthrows ParentNotInitializedException {\n\t\tCtStatementList sts = target.getFactory().Core().createStatementList();\n\t\tsts.addStatement(statement);\n\t\tinsertBefore(target, sts);\n\t}\n\n\t/** inserts all statements of `statementsToBeInserted` just before `target` */\n\tpublic static void insertBefore(CtStatement target, CtStatementList statementsToBeInserted)\n\tthrows ParentNotInitializedException {\n\t\tCtElement targetParent = target.getParent();\n\t\tif (targetParent instanceof CtExecutable) {\n\t\t\tthrow new SpoonException(\"cannot insert in this context (use insertEnd?)\");\n\t\t}\n\t\ttry {\n\t\t\tif (target.getParent(CtConstructor.class) != null) {\n\t\t\t\tif (target instanceof CtInvocation && ((CtInvocation<?>) target).getExecutable().getSimpleName().startsWith(CtExecutableReference.CONSTRUCTOR_NAME)) {\n\t\t\t\t\tthrow new SpoonException(\"cannot insert a statement before a super or this invocation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ParentNotInitializedException ignore) {\n\t\t\t// no parent set somewhere\n\t\t}\n\t\tnew InsertVisitor(target, statementsToBeInserted, InsertType.BEFORE).scan(targetParent);\n\t}\n\n\tprivate static class InsertVisitor extends CtInheritanceScanner {\n\t\tprivate final CtStatement target;\n\t\tprivate final CtStatementList statementsToBeInserted;\n\t\tprivate final InsertType insertType;\n\n\t\tInsertVisitor(CtStatement target, CtStatementList statementsToBeInserted, InsertType insertType) {\n\t\t\tthis.target = target;\n\t\t\tthis.statementsToBeInserted = statementsToBeInserted;\n\t\t\tthis.insertType = insertType;\n\t\t}\n\n\t\t@Override\n\t\tpublic <R> void visitCtBlock(CtBlock<R> e) {\n\t\t\tsuper.visitCtBlock(e);\n\n\t\t\tinsertType.insertFromFirstStatement(e, target, statementsToBeInserted);\n\t\t}\n\n\t\t@Override\n\t\tpublic void visitCtIf(CtIf e) {\n\t\t\tsuper.visitCtIf(e);\n\n\t\t\tboolean inThen = true;\n\t\t\tCtStatement stat = e.getThenStatement();\n\t\t\tif (stat != target) {\n\t\t\t\tstat = e.getElseStatement();\n\t\t\t\tinThen = false;\n\t\t\t}\n\t\t\tif (stat != target) {\n\t\t\t\tthrow new IllegalArgumentException(\"should not happen\");\n\t\t\t}\n\t\t\tif (stat instanceof CtBlock) {\n\t\t\t\tinsertType.insert((CtBlock<?>) stat, statementsToBeInserted);\n\t\t\t} else {\n\t\t\t\tCtBlock<?> block = insertNewBlock(stat);\n\t\t\t\tif (inThen) {\n\t\t\t\t\te.setThenStatement(block);\n\t\t\t\t} else {\n\t\t\t\t\te.setElseStatement(block);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic <E> void visitCtSwitch(CtSwitch<E> e) {\n\t\t\tsuper.visitCtSwitch(e);\n\n\t\t\tfor (CtStatement s : statementsToBeInserted) {\n\t\t\t\tif (!(s instanceof CtCase)) {\n\t\t\t\t\tthrow new RuntimeException(\"cannot insert something that is not case in a switch\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.setCases(insertType.insertFromLastStatement(e.getCases(), target, statementsToBeInserted));\n\t\t}\n\n\t\t@Override\n\t\tpublic <E> void visitCtCase(CtCase<E> e) {\n\t\t\tsuper.visitCtCase(e);\n\n\t\t\ttarget.setParent(e);\n\t\t\te.setStatements(insertType.insertFromLastStatement(e.getStatements(), target, statementsToBeInserted));\n\t\t}\n\n\t\t@Override\n\t\tpublic void scanCtLoop(CtLoop loop) {\n\t\t\tsuper.scanCtLoop(loop);\n\n\t\t\tCtStatement stat = loop.getBody();\n\t\t\tif (stat instanceof CtBlock) {\n\t\t\t\tinsertType.insert((CtBlock<?>) stat, statementsToBeInserted);\n\t\t\t} else {\n\t\t\t\tCtBlock<?> block = insertNewBlock(stat);\n\t\t\t\ttarget.setParent(block);\n\t\t\t\tloop.setBody(block);\n\t\t\t}\n\t\t}\n\n\t\tprivate CtBlock<?> insertNewBlock(CtStatement stat) {\n\t\t\tCtBlock<?> block = target.getFactory().Core().createBlock();\n\t\t\tblock.addStatement(stat);\n\t\t\tinsertType.insertFromFirstStatement(block, target, statementsToBeInserted);\n\t\t\treturn block;\n\t\t}\n\t}\n\n\tprivate enum InsertType {\n\t\tBEFORE {\n\t\t\t@Override\n\t\t\tvoid insert(CtBlock<?> block, CtStatementList statementsToBeInserted) {\n\t\t\t\tblock.insertBegin(statementsToBeInserted);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid insertFromFirstStatement(CtBlock<?> block, CtStatement target, CtStatementList statementsToBeInserted) {\n\t\t\t\tfinal List<CtStatement> copy = new ArrayList<>(block.getStatements());\n\t\t\t\tint indexOfTargetElement = indexOfReference(block.getStatements(), target);\n\t\t\t\tfor (CtStatement ctStatement : statementsToBeInserted) {\n\t\t\t\t\tcopy.add(indexOfTargetElement++, ctStatement);\n\t\t\t\t}\n\t\t\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t\t\t//note: one element MUST NOT be part of two models.\n\t\t\t\tstatementsToBeInserted.setStatements(null);\n\t\t\t\tblock.setStatements(copy);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\t<T extends CtElement> List<T> insertFromLastStatement(List<T> statements, CtStatement target, CtStatementList statementsToBeInserted) {\n\t\t\t\tfinal List<T> copy = new ArrayList<>(statements);\n\t\t\t\tint indexOfTargetElement = indexOfReference(statements, target);\n\t\t\t\tfor (int j = statementsToBeInserted.getStatements().size() - 1; j >= 0; j--) {\n\t\t\t\t\tcopy.add(indexOfTargetElement, (T) statementsToBeInserted.getStatements().get(j));\n\t\t\t\t}\n\t\t\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t\t\t//note: one element MUST NOT be part of two models.\n\t\t\t\tstatementsToBeInserted.setStatements(null);\n\t\t\t\treturn copy;\n\t\t\t}\n\t\t},\n\t\tAFTER {\n\t\t\t@Override\n\t\t\tvoid insert(CtBlock<?> block, CtStatementList statementsToBeInserted) {\n\t\t\t\tblock.insertEnd(statementsToBeInserted);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tvoid insertFromFirstStatement(CtBlock<?> block, CtStatement target, CtStatementList statementsToBeInserted) {\n\t\t\t\tfinal List<CtStatement> copy = new ArrayList<>(block.getStatements());\n\t\t\t\tint indexOfTargetElement = indexOfReference(block.getStatements(), target);\n\t\t\t\tfor (CtStatement s : statementsToBeInserted) {\n\t\t\t\t\tcopy.add(++indexOfTargetElement, s);\n\t\t\t\t}\n\t\t\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t\t\t//note: one element MUST NOT be part of two models.\n\t\t\t\tstatementsToBeInserted.setStatements(null);\n\t\t\t\tblock.setStatements(copy);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\t<T extends CtElement> List<T> insertFromLastStatement(List<T> statements, CtStatement target, CtStatementList statementsToBeInserted) {\n\t\t\t\tfinal List<T> copy = new ArrayList<>(statements);\n\t\t\t\tint indexOfTargetElement = indexOfReference(copy, target) + 1;\n\t\t\t\tfor (int j = statementsToBeInserted.getStatements().size() - 1; j >= 0; j--) {\n\t\t\t\t\tcopy.add(indexOfTargetElement, (T) statementsToBeInserted.getStatements().get(j));\n\t\t\t\t}\n\t\t\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t\t\t//note: one element MUST NOT be part of two models.\n\t\t\t\tstatementsToBeInserted.setStatements(null);\n\t\t\t\treturn copy;\n\t\t\t}\n\t\t};\n\n\t\tpublic int indexOfReference(List statements, CtElement target) {\n\t\t\tint indexOfTargetElement = -1;\n\t\t\t// check the reference not the equality\n\t\t\tfor (int i = 0; i < statements.size(); i++) {\n\t\t\t\tif (statements.get(i) == target) {\n\t\t\t\t\tindexOfTargetElement = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn indexOfTargetElement;\n\t\t}\n\t\tabstract void insert(CtBlock<?> block, CtStatementList statementsToBeInserted);\n\t\tabstract void insertFromFirstStatement(CtBlock<?> block, CtStatement target, CtStatementList statementsToBeInserted);\n\t\tabstract <T extends CtElement> List<T> insertFromLastStatement(List<T> statements, CtStatement target, CtStatementList statementsToBeInserted);\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T insertBefore(CtStatement statement) throws ParentNotInitializedException {\n\t\tinsertBefore(this, statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T insertBefore(CtStatementList statements) throws ParentNotInitializedException {\n\t\tinsertBefore(this, statements);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T insertAfter(CtStatement statement) throws ParentNotInitializedException {\n\t\tinsertAfter(this, statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T insertAfter(CtStatementList statements) throws ParentNotInitializedException {\n\t\tinsertAfter(this, statements);\n\t\treturn (T) this;\n\t}\n\n\t@MetamodelPropertyField(role = LABEL)\n\tString label;\n\n\t@Override\n\tpublic String getLabel() {\n\t\treturn label;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatement> T setLabel(String label) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, LABEL, label, this.label);\n\t\tthis.label = label;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtStatement clone() {\n\t\treturn (CtStatement) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtDoImpl.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtDoImpl extends CtLoopImpl implements CtDo {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<Boolean> expression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtDo(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getLoopingExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <T extends CtDo> T setLoopingExpression(CtExpression<Boolean> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtDo clone() {\n\t\treturn (CtDo) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtCodeElementImpl.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.support.reflect.declaration.CtElementImpl;\nimport spoon.support.reflect.eval.VisitorPartialEvaluator;\n\npublic abstract class CtCodeElementImpl extends CtElementImpl implements CtCodeElement {\n\tprivate static final long serialVersionUID = 1L;\n\n\tpublic CtCodeElementImpl() {\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R extends CtCodeElement> R partiallyEvaluate() {\n\t\tVisitorPartialEvaluator eval = new VisitorPartialEvaluator();\n\t\treturn eval.evaluate((R) this);\n\t}\n\n\t@Override\n\tpublic CtCodeElement clone() {\n\t\treturn (CtCodeElement) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtConditionalImpl.java",
      "weight" : 64.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.CONDITION;\nimport static spoon.reflect.path.CtRole.ELSE;\nimport static spoon.reflect.path.CtRole.THEN;\n\npublic class CtConditionalImpl<T> extends CtExpressionImpl<T> implements CtConditional<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = ELSE)\n\tCtExpression<T> elseExpression;\n\n\t@MetamodelPropertyField(role = CONDITION)\n\tCtExpression<Boolean> condition;\n\n\t@MetamodelPropertyField(role = THEN)\n\tCtExpression<T> thenExpression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtConditional(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getElseExpression() {\n\t\treturn elseExpression;\n\t}\n\n\t@Override\n\tpublic CtExpression<Boolean> getCondition() {\n\t\treturn condition;\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getThenExpression() {\n\t\treturn thenExpression;\n\t}\n\n\t@Override\n\tpublic <C extends CtConditional<T>> C setElseExpression(CtExpression<T> elseExpression) {\n\t\tif (elseExpression != null) {\n\t\t\telseExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, ELSE, elseExpression, this.elseExpression);\n\t\tthis.elseExpression = elseExpression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtConditional<T>> C setCondition(CtExpression<Boolean> condition) {\n\t\tif (condition != null) {\n\t\t\tcondition.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CONDITION, condition, this.condition);\n\t\tthis.condition = condition;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtConditional<T>> C setThenExpression(CtExpression<T> thenExpression) {\n\t\tif (thenExpression != null) {\n\t\t\tthenExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, THEN, thenExpression, this.thenExpression);\n\t\tthis.thenExpression = thenExpression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtConditional<T> clone() {\n\t\treturn (CtConditional<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtBinaryOperatorImpl.java",
      "weight" : 62.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.BinaryOperatorKind;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.LEFT_OPERAND;\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\nimport static spoon.reflect.path.CtRole.RIGHT_OPERAND;\n\npublic class CtBinaryOperatorImpl<T> extends CtExpressionImpl<T> implements CtBinaryOperator<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = OPERATOR_KIND)\n\tBinaryOperatorKind kind;\n\n\t@MetamodelPropertyField(role = LEFT_OPERAND)\n\tCtExpression<?> leftHandOperand;\n\n\t@MetamodelPropertyField(role = RIGHT_OPERAND)\n\tCtExpression<?> rightHandOperand;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtBinaryOperator(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<?> getLeftHandOperand() {\n\t\treturn leftHandOperand;\n\t}\n\n\t@Override\n\tpublic CtExpression<?> getRightHandOperand() {\n\t\treturn rightHandOperand;\n\t}\n\n\t@Override\n\tpublic <C extends CtBinaryOperator<T>> C setLeftHandOperand(CtExpression<?> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, LEFT_OPERAND, expression, this.leftHandOperand);\n\t\tleftHandOperand = expression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtBinaryOperator<T>> C setRightHandOperand(CtExpression<?> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, RIGHT_OPERAND, expression, this.rightHandOperand);\n\t\trightHandOperand = expression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtBinaryOperator<T>> C setKind(BinaryOperatorKind kind) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, OPERATOR_KIND, kind, this.kind);\n\t\tthis.kind = kind;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic BinaryOperatorKind getKind() {\n\t\treturn kind;\n\t}\n\n\t@Override\n\tpublic CtBinaryOperator<T> clone() {\n\t\treturn (CtBinaryOperator<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtContinueImpl.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtLabelledFlowBreak;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.ParentFunction;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TARGET_LABEL;\n\npublic class CtContinueImpl extends CtStatementImpl implements CtContinue {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TARGET_LABEL)\n\tString targetLabel;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtContinue(this);\n\t}\n\n\t@Override\n\tpublic String getTargetLabel() {\n\t\treturn targetLabel;\n\t}\n\n\t@Override\n\tpublic <T extends CtLabelledFlowBreak> T setTargetLabel(String targetLabel) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET_LABEL, targetLabel, this.targetLabel);\n\t\tthis.targetLabel = targetLabel;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtStatement getLabelledStatement() {\n\t\tList<CtStatement> listParents = this.map(new ParentFunction().includingSelf(true)).list();\n\n\t\tfor (CtElement parent : listParents) {\n\t\t\tif (parent instanceof CtStatement) {\n\t\t\t\tCtStatement statement = (CtStatement) parent;\n\n\t\t\t\tif (statement.getLabel() != null && statement.getLabel().equals(this.getTargetLabel())) {\n\t\t\t\t\treturn statement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtContinue clone() {\n\t\treturn (CtContinue) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtArrayWriteImpl.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtArrayWrite;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtArrayWriteImpl<T> extends CtArrayAccessImpl<T, CtExpression<?>> implements CtArrayWrite<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtArrayWrite(this);\n\t}\n\n\t@Override\n\tpublic CtArrayWrite<T> clone() {\n\t\treturn (CtArrayWrite<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtSwitchImpl.java",
      "weight" : 78.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCase;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtSwitch;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.SWITCH_CASES_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.CASE;\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtSwitchImpl<S> extends CtStatementImpl implements CtSwitch<S> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CASE)\n\tList<CtCase<? super S>> cases = emptyList();\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<S> expression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtSwitch(this);\n\t}\n\n\t@Override\n\tpublic List<CtCase<? super S>> getCases() {\n\t\treturn cases;\n\t}\n\n\t@Override\n\tpublic CtExpression<S> getSelector() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <T extends CtSwitch<S>> T setCases(List<CtCase<? super S>> cases) {\n\t\tif (cases == null || cases.isEmpty()) {\n\t\t\tthis.cases = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CASE, this.cases, new ArrayList<>(this.cases));\n\t\tthis.cases.clear();\n\t\tfor (CtCase<? super S> aCase : cases) {\n\t\t\taddCase(aCase);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtSwitch<S>> T setSelector(CtExpression<S> selector) {\n\t\tif (selector != null) {\n\t\t\tselector.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, selector, this.expression);\n\t\tthis.expression = selector;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtSwitch<S>> T addCase(CtCase<? super S> c) {\n\t\tif (c == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (cases == CtElementImpl.<CtCase<? super S>>emptyList()) {\n\t\t\tcases = new ArrayList<>(SWITCH_CASES_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tc.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CASE, this.cases, c);\n\t\tcases.add(c);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeCase(CtCase<? super S> c) {\n\t\tif (cases == CtElementImpl.<CtCase<? super S>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CASE, cases, cases.indexOf(c), c);\n\t\treturn cases.remove(c);\n\t}\n\n\t@Override\n\tpublic CtSwitch<S> clone() {\n\t\treturn (CtSwitch<S>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtReturnImpl.java",
      "weight" : 41.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic class CtReturnImpl<R> extends CtStatementImpl implements CtReturn<R> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<R> returnedExpression;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtReturn(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<R> getReturnedExpression() {\n\t\treturn returnedExpression;\n\t}\n\n\t@Override\n\tpublic <T extends CtReturn<R>> T setReturnedExpression(CtExpression<R> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.returnedExpression);\n\t\tthis.returnedExpression = expression;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtReturn<R> clone() {\n\t\treturn (CtReturn<R>) super.clone();\n\t}\n\n\t@Override\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\tpublic CtCodeElement getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtArrayReadImpl.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtArrayRead;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtArrayReadImpl<T> extends CtArrayAccessImpl<T, CtExpression<?>> implements CtArrayRead<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtArrayRead(this);\n\t}\n\n\t@Override\n\tpublic CtArrayRead<T> clone() {\n\t\treturn (CtArrayRead<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtBreakImpl.java",
      "weight" : 46.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtLabelledFlowBreak;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.ParentFunction;\n\nimport java.util.List;\n\nimport static spoon.reflect.path.CtRole.TARGET_LABEL;\n\npublic class CtBreakImpl extends CtStatementImpl implements CtBreak {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TARGET_LABEL)\n\tString targetLabel;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtBreak(this);\n\t}\n\n\t@Override\n\tpublic String getTargetLabel() {\n\t\treturn targetLabel;\n\t}\n\n\t@Override\n\tpublic <T extends CtLabelledFlowBreak> T setTargetLabel(String targetLabel) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET_LABEL, targetLabel, this.targetLabel);\n\t\tthis.targetLabel = targetLabel;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtStatement getLabelledStatement() {\n\t\tList<CtStatement> listParents = this.map(new ParentFunction().includingSelf(true)).list();\n\n\t\tfor (CtElement parent : listParents) {\n\t\t\tif (parent instanceof CtStatement) {\n\t\t\t\tCtStatement statement = (CtStatement) parent;\n\n\t\t\t\tif (statement.getLabel() != null && statement.getLabel().equals(this.getTargetLabel())) {\n\t\t\t\t\treturn statement;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtBreak clone() {\n\t\treturn (CtBreak) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtArrayAccessImpl.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtArrayAccess;\nimport spoon.reflect.code.CtExpression;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\n\npublic abstract class CtArrayAccessImpl<T, V extends CtExpression<?>> extends CtTargetedExpressionImpl<T, V> implements CtArrayAccess<T, V> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tprivate CtExpression<Integer> expression;\n\n\t@Override\n\tpublic CtExpression<Integer> getIndexExpression() {\n\t\treturn expression;\n\t}\n\n\t@Override\n\tpublic <C extends CtArrayAccess<T, V>> C setIndexExpression(CtExpression<Integer> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.expression);\n\t\tthis.expression = expression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtArrayAccess<T, V> clone() {\n\t\treturn (CtArrayAccess<T, V>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtExecutableReferenceExpressionImpl.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExecutableReferenceExpression;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXECUTABLE_REF;\n\npublic class CtExecutableReferenceExpressionImpl<T, E extends CtExpression<?>> extends CtTargetedExpressionImpl<T, E> implements CtExecutableReferenceExpression<T, E> {\n\t@MetamodelPropertyField(role = EXECUTABLE_REF)\n\tCtExecutableReference<T> executable;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtExecutableReferenceExpression(this);\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<T> getExecutable() {\n\t\treturn executable;\n\t}\n\n\t@Override\n\tpublic <C extends CtExecutableReferenceExpression<T, E>> C setExecutable(CtExecutableReference<T> executable) {\n\t\tif (executable != null) {\n\t\t\texecutable.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXECUTABLE_REF, executable, this.executable);\n\t\tthis.executable = executable;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtExecutableReferenceExpression<T, E> clone() {\n\t\treturn (CtExecutableReferenceExpression<T, E>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtTryImpl.java",
      "weight" : 111.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtTry;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.CATCH_CASES_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.CATCH;\nimport static spoon.reflect.path.CtRole.FINALIZER;\n\npublic class CtTryImpl extends CtStatementImpl implements CtTry {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = BODY)\n\tCtBlock<?> body;\n\n\t@MetamodelPropertyField(role = CATCH)\n\tList<CtCatch> catchers = emptyList();\n\n\t@MetamodelPropertyField(role = FINALIZER)\n\tCtBlock<?> finalizer;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTry(this);\n\t}\n\n\t@Override\n\tpublic List<CtCatch> getCatchers() {\n\t\treturn catchers;\n\t}\n\n\t@Override\n\tpublic <T extends CtTry> T setCatchers(List<CtCatch> catchers) {\n\t\tif (catchers == null || catchers.isEmpty()) {\n\t\t\tthis.catchers = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CATCH, this.catchers, new ArrayList<>(this.catchers));\n\t\tthis.catchers.clear();\n\t\tfor (CtCatch c : catchers) {\n\t\t\taddCatcher(c);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtTry> T addCatcher(CtCatch catcher) {\n\t\tif (catcher == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (catchers == CtElementImpl.<CtCatch>emptyList()) {\n\t\t\tcatchers = new ArrayList<>(CATCH_CASES_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tcatcher.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CATCH, this.catchers, catcher);\n\t\tcatchers.add(catcher);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeCatcher(CtCatch catcher) {\n\t\tif (catchers == CtElementImpl.<CtCatch>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CATCH, catchers, catchers.indexOf(catcher), catcher);\n\t\treturn catchers.remove(catcher);\n\t}\n\n\t@Override\n\tpublic CtBlock<?> getFinalizer() {\n\t\treturn finalizer;\n\t}\n\n\t@Override\n\tpublic <T extends CtTry> T setFinalizer(CtBlock<?> finalizer) {\n\t\tif (finalizer != null) {\n\t\t\tfinalizer.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, FINALIZER, finalizer, this.finalizer);\n\t\tthis.finalizer = finalizer;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtBlock<?> getBody() {\n\t\treturn body;\n\t}\n\n\t@Override\n\tpublic <T extends CtBodyHolder> T setBody(CtStatement statement) {\n\t\tif (statement != null) {\n\t\t\tCtBlock<?> body = getFactory().Code().getOrCreateCtBlock(statement);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, body, this.body);\n\t\t\tif (body != null) {\n\t\t\t\tbody.setParent(this);\n\t\t\t}\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectDelete(this, BODY, this.body);\n\t\t\tthis.body = null;\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtTry clone() {\n\t\treturn (CtTry) super.clone();\n\t}\n\n\t@Override\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\tpublic CtCodeElement getSubstitution(CtType<?> targetType) {\n\t\treturn clone();\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/code/CtAnnotationFieldAccessImpl.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtAnnotationFieldAccessImpl<T> extends CtFieldAccessImpl<T> implements CtAnnotationFieldAccess<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtAnnotationFieldAccess(this);\n\t}\n\n\t@Override\n\tpublic CtAnnotationFieldAccessImpl<T> clone() {\n\t\treturn (CtAnnotationFieldAccessImpl<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtUnaryOperatorImpl.java",
      "weight" : 81.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.UnaryOperatorKind;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport static spoon.reflect.path.CtRole.EXPRESSION;\nimport static spoon.reflect.path.CtRole.LABEL;\nimport static spoon.reflect.path.CtRole.OPERATOR_KIND;\n\npublic class CtUnaryOperatorImpl<T> extends CtExpressionImpl<T> implements CtUnaryOperator<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = OPERATOR_KIND)\n\tUnaryOperatorKind kind;\n\n\t@MetamodelPropertyField(role = LABEL)\n\tString label;\n\n\t@MetamodelPropertyField(role = EXPRESSION)\n\tCtExpression<T> operand;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtUnaryOperator(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getOperand() {\n\t\treturn operand;\n\t}\n\n\t@Override\n\tpublic UnaryOperatorKind getKind() {\n\t\treturn kind;\n\t}\n\n\t@Override\n\tpublic String getLabel() {\n\t\treturn label;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatement statement) {\n\t\tCtStatementImpl.insertAfter(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatement statement) {\n\t\tCtStatementImpl.insertBefore(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatementList statements) {\n\t\tCtStatementImpl.insertAfter(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatementList statements) {\n\t\tCtStatementImpl.insertBefore(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtUnaryOperator> C setOperand(CtExpression<T> expression) {\n\t\tif (expression != null) {\n\t\t\texpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, EXPRESSION, expression, this.operand);\n\t\tthis.operand = expression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtUnaryOperator> C setKind(UnaryOperatorKind kind) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, OPERATOR_KIND, kind, this.kind);\n\t\tthis.kind = kind;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C setLabel(String label) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, LABEL, label, this.label);\n\t\tthis.label = label;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtUnaryOperator<T> clone() {\n\t\treturn (CtUnaryOperator<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtTargetedExpressionImpl.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtTargetedExpression;\n\nimport static spoon.reflect.path.CtRole.TARGET;\n\npublic abstract class CtTargetedExpressionImpl<E, T extends CtExpression<?>> extends CtExpressionImpl<E> implements CtTargetedExpression<E, T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TARGET)\n\tT target;\n\n\t@Override\n\tpublic T getTarget() {\n\t\treturn target;\n\t}\n\n\t@Override\n\tpublic <C extends CtTargetedExpression<E, T>> C setTarget(T target) {\n\t\tif (target != null) {\n\t\t\ttarget.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET, target, this.target);\n\t\tthis.target = target;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtTargetedExpression<E, T> clone() {\n\t\treturn (CtTargetedExpression<E, T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtExpressionImpl.java",
      "weight" : 72.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.reflect.declaration.CtElementImpl;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.CASTS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.CAST;\nimport static spoon.reflect.path.CtRole.TYPE;\n\npublic abstract class CtExpressionImpl<T> extends CtCodeElementImpl implements CtExpression<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TYPE)\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = CAST)\n\tList<CtTypeReference<?>> typeCasts = emptyList();\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getTypeCasts() {\n\t\treturn typeCasts;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExpression<T>> C setTypeCasts(List<CtTypeReference<?>> casts) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CAST, this.typeCasts, new ArrayList<>(this.typeCasts));\n\t\tif (casts == null || casts.isEmpty()) {\n\t\t\tthis.typeCasts = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\tthis.typeCasts = new ArrayList<>(CASTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tthis.typeCasts.clear();\n\t\tfor (CtTypeReference<?> cast : casts) {\n\t\t\taddTypeCast(cast);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtExpression<T>> C addTypeCast(CtTypeReference<?> type) {\n\t\tif (type == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (typeCasts == CtElementImpl.<CtTypeReference<?>>emptyList()) {\n\t\t\ttypeCasts = new ArrayList<>(CASTS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\ttype.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CAST, this.typeCasts, type);\n\t\ttypeCasts.add(type);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic T S() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtExpression<T> clone() {\n\t\treturn (CtExpression<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtVariableAccessImpl.java",
      "weight" : 50.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtVariableReference;\nimport spoon.support.DerivedProperty;\n\nimport static spoon.reflect.path.CtRole.VARIABLE;\n\npublic abstract class CtVariableAccessImpl<T> extends CtExpressionImpl<T> implements CtVariableAccess<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = VARIABLE)\n\tCtVariableReference<T> variable;\n\n\t@Override\n\tpublic CtVariableReference<T> getVariable() {\n\t\tif (variable == null && getFactory() != null) {\n\t\t\tvariable = getFactory().Core().createLocalVariableReference();\n\t\t\tvariable.setParent(this);\n\t\t}\n\t\treturn variable;\n\t}\n\n\t@Override\n\tpublic <C extends CtVariableAccess<T>> C setVariable(CtVariableReference<T> variable) {\n\t\tif (variable != null) {\n\t\t\tvariable.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, VARIABLE, variable, this.variable);\n\t\tthis.variable = variable;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<T> getType() {\n\t\treturn getVariable().getType();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tif (type != null) {\n\t\t\tgetVariable().setType(type);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtVariableAccess<T> clone() {\n\t\treturn (CtVariableAccess<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtBlockImpl.java",
      "weight" : 164.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.Query;\nimport spoon.support.util.ModelList;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class CtBlockImpl<R> extends CtStatementImpl implements CtBlock<R> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.STATEMENT)\n\tprivate final ModelList<CtStatement> statements = new ModelList<CtStatement>() {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtBlockImpl.this;\n\t\t}\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.STATEMENT;\n\t\t}\n\t\t@Override\n\t\tprotected int getDefaultCapacity() {\n\t\t\treturn ModelElementContainerDefaultCapacities.BLOCK_STATEMENTS_CONTAINER_DEFAULT_CAPACITY;\n\t\t}\n\t\t@Override\n\t\tprotected void onSizeChanged(int newSize) {\n\t\t\tif (isImplicit() && (newSize > 1 || newSize == 0)) {\n\t\t\t\tsetImplicit(false);\n\t\t\t}\n\t\t}\n\t};\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtBlock(this);\n\t}\n\n\t@Override\n\tpublic List<CtStatement> getStatements() {\n\t\treturn this.statements;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends CtStatement> T getStatement(int i) {\n\t\treturn (T) statements.get(i);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T extends CtStatement> T getLastStatement() {\n\t\treturn (T) statements.get(statements.size() - 1);\n\t}\n\n\tprivate boolean shouldInsertAfterSuper() {\n\t\ttry {\n\t\t\tif (getParent() != null && getParent() instanceof CtConstructor && !getStatements().isEmpty()) {\n\t\t\t\tCtStatement first = getStatements().get(0);\n\t\t\t\tif (first instanceof CtInvocation && ((CtInvocation<?>) first).getExecutable().isConstructor()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ParentNotInitializedException ignore) {\n\t\t\t// CtBlock hasn't a parent. So, it isn't in a constructor.\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatementList statements) {\n\t\tif (this.shouldInsertAfterSuper()) {\n\t\t\tgetStatements().get(0).insertAfter(statements);\n\t\t\treturn (T) this;\n\t\t}\n\t\tList<CtStatement> copy = new ArrayList<>(statements.getStatements());\n\t\tstatements.setStatements(null);\n\t\tthis.statements.addAll(0, copy);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBegin(CtStatement statement) {\n\t\tif (this.shouldInsertAfterSuper()) {\n\t\t\tgetStatements().get(0).insertAfter(statement);\n\t\t\treturn (T) this;\n\t\t}\n\t\tthis.statements.add(0, statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatement statement) {\n\t\taddStatement(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertEnd(CtStatementList statements) {\n\t\tList<CtStatement> tobeInserted = new ArrayList<>(statements.getStatements());\n\t\t//remove statements from the `statementsToBeInserted` before they are added to spoon model\n\t\t//note: one element MUST NOT be part of two models.\n\t\tstatements.setStatements(null);\n\t\tthis.statements.addAll(this.statements.size(), tobeInserted);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertAfter(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertAfter(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatement statement) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T insertBefore(Filter<? extends CtStatement> insertionPoints, CtStatementList statements) {\n\t\tfor (CtStatement e : Query.getElements(this, insertionPoints)) {\n\t\t\te.insertBefore(statements);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T setStatements(List<CtStatement> statements) {\n\t\tthis.statements.set(statements);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(CtStatement statement) {\n\t\tthis.statements.add(statement);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtStatementList> T addStatement(int index, CtStatement statement) {\n\t\tthis.statements.add(index, statement);\n\t\treturn (T) this;\n\t}\n\n\n\t@Override\n\tpublic void removeStatement(CtStatement statement) {\n\t\tthis.statements.remove(statement);\n\t}\n\n\t@Override\n\tpublic Iterator<CtStatement> iterator() {\n\t\treturn this.statements.iterator();\n\t}\n\n\t@Override\n\tpublic R S() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtBlock<R> clone() {\n\t\treturn (CtBlock<R>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtVariableReadImpl.java",
      "weight" : 14.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtVariableReadImpl<T> extends CtVariableAccessImpl<T> implements CtVariableRead<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtVariableRead(this);\n\t}\n\n\t@Override\n\tpublic CtVariableRead<T> clone() {\n\t\treturn (CtVariableRead<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtThisAccessImpl.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtThisAccess;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtThisAccessImpl<T> extends CtTargetedExpressionImpl<T, CtExpression<?>> implements CtThisAccess<T> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtThisAccess(this);\n\t}\n\n\t@Override\n\tpublic CtThisAccess<T> clone() {\n\t\treturn (CtThisAccess<T>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/code/CtFieldAccessImpl.java",
      "weight" : 41.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtTargetedExpression;\nimport spoon.reflect.reference.CtFieldReference;\n\nimport static spoon.reflect.path.CtRole.TARGET;\n\npublic abstract class CtFieldAccessImpl<T> extends CtVariableAccessImpl<T> implements CtFieldAccess<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = TARGET)\n\tCtExpression<?> target;\n\n\t@Override\n\tpublic CtExpression<?> getTarget() {\n\t\treturn target;\n\t}\n\n\t@Override\n\tpublic <C extends CtTargetedExpression<T, CtExpression<?>>> C setTarget(CtExpression<?> target) {\n\t\tif (target != null) {\n\t\t\ttarget.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TARGET, target, this.target);\n\t\tthis.target = target;\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtFieldReference<T> getVariable() {\n\t\tif (variable != null) {\n\t\t\treturn (CtFieldReference<T>) variable;\n\t\t}\n\t\tif (getFactory() != null) {\n\t\t\tCtFieldReference<Object> fieldReference = getFactory().Core().createFieldReference();\n\t\t\tfieldReference.setParent(this);\n\t\t\treturn (CtFieldReference<T>) fieldReference;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtFieldAccess<T> clone() {\n\t\treturn (CtFieldAccess<T>) super.clone();\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/code/CtCodeSnippetStatementImpl.java",
      "weight" : 37.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.code;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeSnippetStatement;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtCodeSnippet;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.compiler.SnippetCompilationError;\nimport spoon.support.compiler.SnippetCompilationHelper;\n\nimport static spoon.reflect.path.CtRole.SNIPPET;\n\npublic class CtCodeSnippetStatementImpl extends CtStatementImpl implements CtCodeSnippetStatement {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCodeSnippetStatement(this);\n\t}\n\n\t@MetamodelPropertyField(role = SNIPPET)\n\tString value;\n\n\t@Override\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic <C extends CtCodeSnippet> C setValue(String value) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SNIPPET, value, this.value);\n\t\tthis.value = value;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <S extends CtStatement> S compile() throws SnippetCompilationError {\n\t\treturn (S) SnippetCompilationHelper.compileStatement(this);\n\t}\n\n\t@Override\n\tpublic CtCodeSnippetStatement clone() {\n\t\treturn (CtCodeSnippetStatement) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/cu/position/SourcePositionImpl.java",
      "weight" : 175.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu.position;\n\nimport spoon.SpoonException;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\nimport spoon.reflect.cu.position.NoSourcePosition;\n\nimport java.io.File;\nimport java.io.Serializable;\n\n/**\n * This immutable class represents the position of a Java program element in a source\n * file.\n */\npublic class SourcePositionImpl implements SourcePosition, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Search the line number corresponding to a specific position\n\t */\n\tprotected int searchLineNumber(int position) {\n\t\tint[] lineSeparatorPositions = getLineSeparatorPositions();\n\t\tif (lineSeparatorPositions == null) {\n\t\t\treturn 1;\n\t\t}\n\t\tint length = lineSeparatorPositions.length;\n\t\tif (length == 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tint g = 0;\n\t\tint d = length - 1;\n\t\tint m = 0;\n\t\tint start;\n\t\twhile (g <= d) {\n\t\t\tm = (g + d) / 2;\n\t\t\tif (position < (start = lineSeparatorPositions[m])) {\n\t\t\t\td = m - 1;\n\t\t\t} else if (position > start) {\n\t\t\t\tg = m + 1;\n\t\t\t} else {\n\t\t\t\treturn m + 1;\n\t\t\t}\n\t\t}\n\t\tif (position < lineSeparatorPositions[m]) {\n\t\t\treturn m + 1;\n\t\t}\n\t\treturn m + 2;\n\t}\n\n\t/**\n\t * Search the column number\n\t */\n\tprotected int searchColumnNumber(int position) {\n\t\tint[] lineSeparatorPositions = getLineSeparatorPositions();\n\t\tif (lineSeparatorPositions == null) {\n\t\t\treturn -1;\n\t\t}\n\t\tint length = lineSeparatorPositions.length;\n\t\tif (length == 0) {\n\t\t\treturn position;\n\t\t}\n\t\tif (lineSeparatorPositions[0] > position) {\n\t\t\treturn position;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i < lineSeparatorPositions.length - 1; i++) {\n\t\t\tif (lineSeparatorPositions[i] < position && (lineSeparatorPositions[i + 1] > position)) {\n\t\t\t\treturn position - lineSeparatorPositions[i];\n\t\t\t}\n\t\t}\n\t\tint tabCount = 0;\n\t\tint tabSize = 0;\n\t\tif (getCompilationUnit() != null) {\n\t\t\ttabSize = getCompilationUnit().getFactory().getEnvironment().getTabulationSize();\n\t\t\tString source = getCompilationUnit().getOriginalSourceCode();\n\t\t\tfor (int j = lineSeparatorPositions[i]; j < position; j++) {\n\t\t\t\tif (source.charAt(j) == '\\t') {\n\t\t\t\t\ttabCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (position - lineSeparatorPositions[i]) - tabCount + (tabCount * tabSize);\n\t}\n\n\t/** The position of the first byte of this element (incl. documentation and modifiers) */\n\tprivate final int sourceStart;\n\n\t/** The position of the last byte of this element */\n\tprivate final int sourceEnd;\n\n\t/** The line number of the start of the element, if appropriate (eg the method name).\n\t * Computed lazily by {@link #getLine()}\n\t */\n\tprivate int sourceStartline = -1;\n\n\tpublic SourcePositionImpl(CompilationUnit compilationUnit, int sourceStart, int sourceEnd, int[] lineSeparatorPositions) {\n\t\tcheckArgsAreAscending(sourceStart, sourceEnd + 1);\n\t\tif (compilationUnit == null) {\n\t\t\tthrow new SpoonException(\"Mandatory parameter compilationUnit is null\");\n\t\t}\n\t\tthis.compilationUnit = compilationUnit;\n\t\t//TODD: this check will be removed after we remove lineSeparatorPositions from the Constructor\n\t\tif (compilationUnit.getLineSeparatorPositions() != lineSeparatorPositions) {\n\t\t\tthrow new SpoonException(\"Unexpected lineSeparatorPositions\");\n\t\t}\n\t\tthis.sourceEnd = sourceEnd;\n\t\tthis.sourceStart = sourceStart;\n\t}\n\n\t@Override\n\tpublic boolean isValidPosition() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int getColumn() {\n\t\treturn searchColumnNumber(sourceStart);\n\t}\n\n\t@Override\n\tpublic int getEndColumn() {\n\t\treturn searchColumnNumber(sourceEnd);\n\t}\n\n\t@Override\n\tpublic File getFile() {\n\t\treturn compilationUnit == null ? null : compilationUnit.getFile();\n\t}\n\n\t@Override\n\tpublic int getLine() {\n\t\tif (sourceStartline == -1) {\n\t\t\tthis.sourceStartline = searchLineNumber(this.sourceStart);\n\t\t}\n\t\treturn sourceStartline;\n\t}\n\n\t@Override\n\tpublic int getEndLine() {\n\t\treturn searchLineNumber(sourceEnd);\n\t}\n\n\t@Override\n\tpublic int getSourceEnd() {\n\t\treturn this.sourceEnd;\n\t}\n\n\t@Override\n\tpublic int getSourceStart() {\n\t\treturn this.sourceStart;\n\t}\n\n\t/**\n\t * Returns a string representation of this position in the form\n\t * \"sourcefile:line\", or \"sourcefile\" if no line number is available.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tif (getFile() == null) {\n\t\t\treturn \"(unknown file)\";\n\t\t}\n\t\tint ln = getLine();\n\t\treturn (ln >= 1) ? \"(\" + getFile().getAbsolutePath().replace('\\\\', '/').replace(\"C:/\", \"/\") + \":\" + ln + \")\" : getFile().getAbsolutePath().replace('\\\\', '/').replace(\"C:/\", \"/\");\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof SourcePosition)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (obj instanceof NoSourcePosition) {\n\t\t\treturn false;\n\t\t}\n\t\tSourcePosition s = (SourcePosition) obj;\n\t\treturn (getFile() == null ? s.getFile() == null : getFile().equals(s.getFile())) && getSourceEnd() == s.getSourceEnd() && getSourceStart() == s.getSourceStart();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + getLine();\n\t\tresult = prime * result + getColumn();\n\t\tresult = prime * result + (getFile() != null ? getFile().hashCode() : 1);\n\t\treturn result;\n\t}\n\n\tprivate final CompilationUnit compilationUnit;\n\n\t@Override\n\tpublic CompilationUnit getCompilationUnit() {\n\t\treturn compilationUnit;\n\t}\n\n\t/**\n\t * Helper for debugging purposes. Displays |startIndex; endIndex|sourceCode| of this {@link SourcePosition}\n\t * If this instance is {@link DeclarationSourcePosition} or {@link BodyHolderSourcePosition}\n\t * Then details about name, modifiers and body are included in resulting string too\n\t * @return details about source code of this {@link SourcePosition}\n\t */\n\tpublic String getSourceDetails() {\n\t\treturn getFragment(getSourceStart(), getSourceEnd());\n\t}\n\n\tprotected String getFragment(int start, int end) {\n\t\treturn \"|\" + start + \";\" + end + \"|\" + getCompilationUnit().getOriginalSourceCode().substring(start, end + 1) + \"|\";\n\t}\n\n\t/**\n\t * fails when `values` are not sorted ascending\n\t * It is used to check whether start/end values of SourcePosition are consistent\n\t */\n\tprotected static void checkArgsAreAscending(int...values) {\n\t\tint last = -1;\n\t\tfor (int value : values) {\n\t\t\tif (value < 0) {\n\t\t\t\tthrow new SpoonException(\"SourcePosition value must not be negative\");\n\t\t\t}\n\t\t\tif (last > value) {\n\t\t\t\tthrow new SpoonException(\"SourcePosition values must be ascending or equal\");\n\t\t\t}\n\t\t\tlast = value;\n\t\t}\n\t}\n\n\tprivate int[] getLineSeparatorPositions() {\n\t\treturn compilationUnit == null ? null : compilationUnit.getLineSeparatorPositions();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/cu/position/CompoundSourcePositionImpl.java",
      "weight" : 49.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu.position;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.position.CompoundSourcePosition;\n\nimport java.io.Serializable;\n\n/**\n * This class represents the position of a Java program element in a source\n * file.\n */\npublic class CompoundSourcePositionImpl extends SourcePositionImpl\n\t\timplements CompoundSourcePosition, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int declarationSourceStart;\n\tprivate int declarationSourceEnd;\n\n\tpublic CompoundSourcePositionImpl(CompilationUnit compilationUnit, int sourceStart, int sourceEnd,\n\t\t\tint declarationSourceStart, int declarationSourceEnd,\n\t\t\tint[] lineSeparatorPositions) {\n\t\tsuper(compilationUnit,\n\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\tlineSeparatorPositions);\n\t\tcheckArgsAreAscending(declarationSourceStart, sourceStart, sourceEnd + 1, declarationSourceEnd + 1);\n\t\tthis.declarationSourceStart = declarationSourceStart;\n\t\tthis.declarationSourceEnd = declarationSourceEnd;\n\t}\n\n\t@Override\n\tpublic int getSourceEnd() {\n\t\treturn declarationSourceEnd;\n\t}\n\n\t@Override\n\tpublic int getSourceStart() {\n\t\treturn declarationSourceStart;\n\t}\n\n\t@Override\n\tpublic int getNameStart() {\n\t\treturn super.getSourceStart();\n\t}\n\n\t@Override\n\tpublic int getNameEnd() {\n\t\treturn super.getSourceEnd();\n\t}\n\n\t@Override\n\tpublic int getEndLine() {\n\t\treturn searchLineNumber(declarationSourceEnd);\n\t}\n\n\t@Override\n\tpublic int getEndColumn() {\n\t\treturn searchColumnNumber(declarationSourceEnd);\n\t}\n\n\t@Override\n\tpublic String getSourceDetails() {\n\t\treturn super.getSourceDetails()\n\t\t\t\t+ \"\\nname = \" + getFragment(getNameStart(), getNameEnd());\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/cu/position/BodyHolderSourcePositionImpl.java",
      "weight" : 40.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu.position;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.position.BodyHolderSourcePosition;\n\nimport java.io.Serializable;\n\n/**\n * This class represents the position of a Java program element in a source\n * file.\n */\npublic class BodyHolderSourcePositionImpl extends DeclarationSourcePositionImpl\n\t\timplements BodyHolderSourcePosition, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int bodyStart;\n\tprivate int bodyEnd;\n\n\tpublic BodyHolderSourcePositionImpl(\n\t\t\tCompilationUnit compilationUnit,\n\t\t\tint sourceStart, int sourceEnd,\n\t\t\tint modifierSourceStart, int modifierSourceEnd,\n\t\t\tint declarationSourceStart, int declarationSourceEnd,\n\t\t\tint bodyStart,\n\t\t\tint bodyEnd,\n\t\t\tint[] lineSeparatorPositions) {\n\t\tsuper(compilationUnit,\n\t\t\t\tsourceStart, sourceEnd,\n\t\t\t\tmodifierSourceStart, modifierSourceEnd,\n\t\t\t\tdeclarationSourceStart, declarationSourceEnd,\n\t\t\t\tlineSeparatorPositions);\n\t\tcheckArgsAreAscending(declarationSourceStart, modifierSourceStart, modifierSourceEnd + 1, sourceStart, sourceEnd + 1, bodyStart, bodyEnd + 1, declarationSourceEnd + 1);\n\t\tthis.bodyStart = bodyStart;\n\t\tthis.bodyEnd = bodyEnd;\n\t}\n\n\t@Override\n\tpublic int getBodyStart() {\n\t\treturn bodyStart;\n\t}\n\n\t@Override\n\tpublic int getBodyEnd() {\n\t\treturn bodyEnd;\n\t}\n\n\t@Override\n\tpublic String getSourceDetails() {\n\t\treturn super.getSourceDetails()\n\t\t\t\t+ \"\\nbody = \" + getFragment(getBodyStart(), getBodyEnd());\n\t}\n}\n"
    }, {
      "name" : "support/reflect/cu/position/DeclarationSourcePositionImpl.java",
      "weight" : 40.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu.position;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.position.DeclarationSourcePosition;\n\nimport java.io.Serializable;\n\n/**\n * This class represents the position of a Java program element in a source\n * file.\n */\npublic class DeclarationSourcePositionImpl extends CompoundSourcePositionImpl\n\t\timplements DeclarationSourcePosition, Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate int modifierSourceEnd;\n\tprivate int modifierSourceStart;\n\n\tpublic DeclarationSourcePositionImpl(CompilationUnit compilationUnit, int sourceStart, int sourceEnd,\n\t\t\tint modifierSourceStart, int modifierSourceEnd, int declarationSourceStart, int declarationSourceEnd,\n\t\t\tint[] lineSeparatorPositions) {\n\t\tsuper(compilationUnit,\n\t\t\t\tsourceStart, sourceEnd, declarationSourceStart, declarationSourceEnd,\n\t\t\t\tlineSeparatorPositions);\n\t\tcheckArgsAreAscending(declarationSourceStart, modifierSourceStart, modifierSourceEnd + 1, sourceStart, sourceEnd + 1, declarationSourceEnd + 1);\n\t\tthis.modifierSourceStart = modifierSourceStart;\n\t\tif (this.modifierSourceStart == 0) {\n\t\t\tthis.modifierSourceStart = declarationSourceStart;\n\t\t}\n\t\tthis.modifierSourceEnd = modifierSourceEnd;\n\t}\n\n\t@Override\n\tpublic int getModifierSourceStart() {\n\t\treturn modifierSourceStart;\n\t}\n\n\tpublic void setModifierSourceEnd(int modifierSourceEnd) {\n\t\tthis.modifierSourceEnd = modifierSourceEnd;\n\t}\n\n\t@Override\n\tpublic int getModifierSourceEnd() {\n\t\treturn modifierSourceEnd;\n\t}\n\n\t@Override\n\tpublic String getSourceDetails() {\n\t\treturn getFragment(getSourceStart(), getSourceEnd())\n\t\t\t\t+ \"\\nmodifier = \" + getFragment(getModifierSourceStart(), getModifierSourceEnd())\n\t\t\t\t+ \"\\nname = \" + getFragment(getNameStart(), getNameEnd());\n\t}\n\n}\n"
    }, {
      "name" : "support/reflect/cu/position/PartialSourcePositionImpl.java",
      "weight" : 19.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu.position;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.position.NoSourcePosition;\n\nimport java.io.File;\n\n/**\n * This class intends to create a source position containing only a compilation unit.\n */\npublic class PartialSourcePositionImpl extends NoSourcePosition {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate CompilationUnit compilationUnit;\n\n\tpublic PartialSourcePositionImpl(CompilationUnit compilationUnit) {\n\t\tthis.compilationUnit = compilationUnit;\n\t}\n\n\t@Override\n\tpublic File getFile() {\n\t\treturn compilationUnit.getFile();\n\t}\n\n\t@Override\n\tpublic CompilationUnit getCompilationUnit() {\n\t\treturn compilationUnit;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/cu/CompilationUnitImpl.java",
      "weight" : 55.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.cu;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.support.reflect.declaration.CtCompilationUnitImpl;\n\n/**\n * Implements a compilation unit. In Java, a compilation unit can contain only one\n * public type declaration and other secondary types declarations (not public).\n */\npublic class CompilationUnitImpl extends CtCompilationUnitImpl implements CompilationUnit {\n\tprivate static final long serialVersionUID = 2L;\n\n\t@Deprecated\n\t@Override\n\tpublic int beginOfLineIndex(int index) {\n\t\tint cur = index;\n\t\twhile (cur >= 0 && getOriginalSourceCode().charAt(cur) != '\\n') {\n\t\t\tcur--;\n\t\t}\n\t\treturn cur + 1;\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic int nextLineIndex(int index) {\n\t\tint cur = index;\n\t\twhile (cur < getOriginalSourceCode().length()\n\t\t\t\t&& getOriginalSourceCode().charAt(cur) != '\\n') {\n\t\t\tcur++;\n\t\t}\n\t\treturn cur + 1;\n\t}\n\n\t@Deprecated\n\t@Override\n\tpublic int getTabCount(int index) {\n\t\tint cur = index;\n\t\tint tabCount = 0;\n\t\tint whiteSpaceCount = 0;\n\t\twhile (cur < getOriginalSourceCode().length()\n\t\t\t\t&& (getOriginalSourceCode().charAt(cur) == ' ' || getOriginalSourceCode()\n\t\t\t\t.charAt(cur) == '\\t')) {\n\t\t\tif (getOriginalSourceCode().charAt(cur) == '\\t') {\n\t\t\t\ttabCount++;\n\t\t\t}\n\t\t\tif (getOriginalSourceCode().charAt(cur) == ' ') {\n\t\t\t\twhiteSpaceCount++;\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\ttabCount += whiteSpaceCount\n\t\t\t\t/ getFactory().getEnvironment().getTabulationSize();\n\t\treturn tabCount;\n\t}\n\n\tprivate boolean autoImport = true;\n\n\t@Deprecated\n\tpublic boolean isAutoImport() {\n\t\treturn autoImport;\n\t}\n\n\t@Deprecated\n\tpublic void setAutoImport(boolean autoImport) {\n\t\tthis.autoImport = autoImport;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/CtExtendedModifier.java",
      "weight" : 69.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.cu.SourcePositionHolder;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.support.sniper.internal.ElementSourceFragment;\n\nimport java.io.Serializable;\n\n/** Represents a modifier (eg \"public\").\n * When a modifier is \"implicit\", it does not appear in the source code (eg public for interface methods)\n * ModifierKind in kept for sake of full backward-compatibility.\n */\npublic class CtExtendedModifier implements SourcePositionHolder, Serializable {\n\tprivate boolean implicit;\n\tprivate ModifierKind kind;\n\tprivate SourcePosition position;\n\n\tpublic CtExtendedModifier(ModifierKind kind) {\n\t\tthis.kind = kind;\n\t}\n\n\tpublic CtExtendedModifier(ModifierKind kind, boolean implicit) {\n\t\tthis(kind);\n\t\tthis.implicit = implicit;\n\t}\n\n\tpublic boolean isImplicit() {\n\t\treturn implicit;\n\t}\n\n\tpublic void setImplicit(boolean implicit) {\n\t\tthis.implicit = implicit;\n\t}\n\n\tpublic ModifierKind getKind() {\n\t\treturn kind;\n\t}\n\n\tpublic void setKind(ModifierKind kind) {\n\t\tthis.kind = kind;\n\t}\n\n\t@Override\n\tpublic SourcePosition getPosition() {\n\t\tif (position == null) {\n\t\t\treturn SourcePosition.NOPOSITION;\n\t\t}\n\t\treturn position;\n\t}\n\n\tpublic void setPosition(SourcePosition position) {\n\t\tthis.position = position;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tCtExtendedModifier that = (CtExtendedModifier) o;\n\t\treturn (implicit == that.implicit && kind == that.kind);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = (implicit ? 1 : 0);\n\t\tresult = 31 * result + (kind != null ? kind.hashCode() : 0);\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic ElementSourceFragment getOriginalSourceFragment() {\n\t\tSourcePosition sp = this.getPosition();\n\t\tCompilationUnit compilationUnit = sp.getCompilationUnit();\n\t\tif (compilationUnit != null) {\n\t\t\tElementSourceFragment rootFragment = compilationUnit.getOriginalSourceFragment();\n\t\t\treturn rootFragment.getSourceFragmentOf(this, sp.getSourceStart(), sp.getSourceEnd() + 1);\n\t\t} else {\n\t\t\treturn ElementSourceFragment.NO_SOURCE_FRAGMENT;\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtTypeParameterImpl.java",
      "weight" : 323.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.visitor.GenericTypeAdapter;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.SUPER_TYPE;\n\npublic class CtTypeParameterImpl extends CtTypeImpl<Object> implements CtTypeParameter {\n\t@MetamodelPropertyField(role = SUPER_TYPE)\n\tCtTypeReference<?> superClass;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtTypeParameter(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\treturn superClass;\n\t}\n\n\t@Override\n\tpublic <C extends CtType<Object>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\tif (superClass != null) {\n\t\t\tsuperClass.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SUPER_TYPE, superClass, this.superClass);\n\t\tthis.superClass = superClass;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\treturn simpleName;\n\t}\n\n\t@Override\n\tpublic CtTypeParameterReference getReference() {\n\t\treturn getFactory().Type().createReference(this);\n\t}\n\n\t@Override\n\tpublic boolean isGenerics() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic CtTypeParameter clone() {\n\t\treturn (CtTypeParameter) super.clone();\n\t}\n\n\t@Override\n\tpublic CtFormalTypeDeclarer getTypeParameterDeclarer() {\n\t\ttry {\n\t\t\treturn getParent(CtFormalTypeDeclarer.class);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <F, C extends CtType<Object>> C addFieldAtTop(CtField<F> field) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <F, C extends CtType<Object>> C addField(CtField<F> field) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <F, C extends CtType<Object>> C addField(int index, CtField<F> field) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<Object>> C setFields(List<CtField<?>> fields) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <F> boolean removeField(CtField<F> field) {\n\t\t// unsettable property\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic CtField<?> getField(String name) {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtField<?>> getFields() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <N, C extends CtType<Object>> C addNestedType(CtType<N> nestedType) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <N> boolean removeNestedType(CtType<N> nestedType) {\n\t\t// unsettable property\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<Object>> C setNestedTypes(Set<CtType<?>> nestedTypes) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <N extends CtType<?>> N getNestedType(String name) {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtType<?>> getNestedTypes() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtPackage getPackage() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isTopLevel() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isPrimitive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isAnonymous() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isLocalType() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<CtFieldReference<?>> getAllFields() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\tpublic List<CtFieldReference<?>> getDeclaredFields() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> superTypeRef) {\n\t\tif (superTypeRef instanceof CtTypeParameterReference) {\n\t\t\t//the type is type parameter too. Use appropriate sub type checking algorithm\n\t\t\tCtTypeParameter superTypeParam = (CtTypeParameter) superTypeRef.getDeclaration();\n\t\t\treturn isSubtypeOf(getFactory().Type().createTypeAdapter(getTypeParameterDeclarer()), this, superTypeParam);\n\t\t}\n\t\t//type is normal type\n\t\treturn getTypeErasure().isSubtypeOf(superTypeRef);\n\t}\n\n\tprivate static boolean isSubtypeOf(GenericTypeAdapter typeAdapter, CtTypeParameter subTypeParam, CtTypeParameter superTypeParam) {\n\t\twhile (subTypeParam != null) {\n\t\t\tif (isSameInSameScope(subTypeParam, typeAdapter.adaptType(superTypeParam))) {\n\t\t\t\t//both type params are same\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tCtTypeReference<?> superTypeOfSubTypeParam = subTypeParam.getSuperclass();\n\t\t\tif (superTypeOfSubTypeParam == null) {\n\t\t\t\t//there is no super type defined, so they are different type parameters\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (superTypeOfSubTypeParam instanceof CtTypeParameterReference) {\n\t\t\t\tsubTypeParam = ((CtTypeParameterReference) superTypeOfSubTypeParam).getDeclaration();\n\t\t\t} else {\n\t\t\t\t//the super type is not type parameter. Normal type cannot be a super type of generic parameter\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Note: This method expects that both arguments are already adapted to the same scope\n\t * @param typeParam a type param 1\n\t * @param typeRef a reference to some type 2\n\t * @return true if typeParam and typeRef represents same type parameter.\n\t */\n\tprivate static boolean isSameInSameScope(CtTypeParameter typeParam, CtTypeReference<?> typeRef) {\n\t\tif (typeRef instanceof CtTypeParameterReference) {\n\t\t\treturn typeParam.getSimpleName().equals(((CtTypeParameterReference) typeRef).getSimpleName());\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\tCtTypeReference<?> boundType = getBound(this);\n\t\treturn boundType.getTypeErasure();\n\t}\n\n\tprivate static CtTypeReference<?> getBound(CtTypeParameter typeParam) {\n\t\tCtTypeReference<?> bound = typeParam.getSuperclass();\n\t\tif (bound == null) {\n\t\t\tbound = typeParam.getFactory().Type().OBJECT;\n\t\t}\n\t\treturn bound;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <M, C extends CtType<Object>> C addMethod(CtMethod<M> method) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <M> boolean removeMethod(CtMethod<M> method) {\n\t\t// unsettable property\n\t\treturn false;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <S, C extends CtType<Object>> C addSuperInterface(CtTypeReference<S> interfac) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <S> boolean removeSuperInterface(CtTypeReference<S> interfac) {\n\t\t// unsettable property\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>... parameterTypes) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <R> CtMethod<R> getMethod(String name, CtTypeReference<?>... parameterTypes) {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtMethod<?>> getMethods() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic Set<CtMethod<?>> getMethodsAnnotatedWith(CtTypeReference<?>... annotationTypes) {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\tpublic List<CtMethod<?>> getMethodsByName(String name) {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtTypeReference<?>> getSuperInterfaces() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<Object>> C setMethods(Set<CtMethod<?>> methods) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<Object>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Collection<CtExecutableReference<?>> getDeclaredExecutables() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Collection<CtExecutableReference<?>> getAllExecutables() {\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtMethod<?>> getAllMethods() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeMember> getTypeMembers() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<Object>> C setTypeMembers(List<CtTypeMember> members) {\n\t\treturn (C) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtClassImpl.java",
      "weight" : 241.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.SpoonException;\nimport spoon.SpoonModelBuilder.InputType;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtCodeElement;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.compiler.jdt.JDTBasedSpoonCompiler;\nimport spoon.support.reflect.code.CtStatementImpl;\nimport spoon.support.reflect.eval.VisitorPartialEvaluator;\nimport spoon.support.util.SignatureBasedSortedSet;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.CONSTRUCTOR;\nimport static spoon.reflect.path.CtRole.ANNONYMOUS_EXECUTABLE;\nimport static spoon.reflect.path.CtRole.SUPER_TYPE;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtClass}.\n *\n * @author Renaud Pawlak\n */\npublic class CtClassImpl<T> extends CtTypeImpl<T> implements CtClass<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = SUPER_TYPE)\n\tCtTypeReference<?> superClass;\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtClass(this);\n\t}\n\n\t@Override\n\tpublic List<CtAnonymousExecutable> getAnonymousExecutables() {\n\t\tList<CtAnonymousExecutable> anonymousExecutables = new ArrayList<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtAnonymousExecutable) {\n\t\t\t\tanonymousExecutables.add((CtAnonymousExecutable) typeMember);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(anonymousExecutables);\n\t}\n\n\t@Override\n\tpublic CtConstructor<T> getConstructor(CtTypeReference<?>... parameterTypes) {\n\t\tfor (CtTypeMember typeMember : getTypeMembers()) {\n\t\t\tif (!(typeMember instanceof CtConstructor)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCtConstructor<T> c = (CtConstructor<T>) typeMember;\n\t\t\tif (hasSameParameters(c, parameterTypes)) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtConstructor<T>> getConstructors() {\n\t\tSet<CtConstructor<T>> constructors = new SignatureBasedSortedSet<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtConstructor) {\n\t\t\t\tconstructors.add((CtConstructor<T>) typeMember);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableSet(constructors);\n\t}\n\n\t@Override\n\tpublic <C extends CtClass<T>> C addAnonymousExecutable(CtAnonymousExecutable e) {\n\t\tif (e == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\te.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, ANNONYMOUS_EXECUTABLE, typeMembers, e);\n\t\treturn addTypeMember(e);\n\t}\n\n\t@Override\n\tpublic boolean removeAnonymousExecutable(CtAnonymousExecutable e) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, ANNONYMOUS_EXECUTABLE, typeMembers, typeMembers.indexOf(e), e);\n\t\treturn removeTypeMember(e);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\treturn superClass;\n\t}\n\n\t@Override\n\tpublic <C extends CtClass<T>> C setAnonymousExecutables(List<CtAnonymousExecutable> anonymousExecutables) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, ANNONYMOUS_EXECUTABLE, typeMembers, new ArrayList<>(getAnonymousExecutables()));\n\t\tif (anonymousExecutables == null || anonymousExecutables.isEmpty()) {\n\t\t\tthis.typeMembers.removeAll(getAnonymousExecutables());\n\t\t\treturn (C) this;\n\t\t}\n\t\ttypeMembers.removeAll(getAnonymousExecutables());\n\t\tfor (CtAnonymousExecutable exec : anonymousExecutables) {\n\t\t\taddAnonymousExecutable(exec);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtClass<T>> C setConstructors(Set<CtConstructor<T>> constructors) {\n\t\tSet<CtConstructor<T>> oldConstructor = getConstructors();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CONSTRUCTOR, typeMembers, oldConstructor);\n\t\tif (constructors == null || constructors.isEmpty()) {\n\t\t\tthis.typeMembers.removeAll(oldConstructor);\n\t\t\treturn (C) this;\n\t\t}\n\t\ttypeMembers.removeAll(oldConstructor);\n\t\tfor (CtConstructor<T> constructor : constructors) {\n\t\t\taddConstructor(constructor);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtClass<T>> C addConstructor(CtConstructor<T> constructor) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CONSTRUCTOR, typeMembers, constructor);\n\t\treturn addTypeMember(constructor);\n\t}\n\n\t@Override\n\tpublic void removeConstructor(CtConstructor<T> constructor) {\n\t\tremoveTypeMember(constructor);\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\tif (superClass != null) {\n\t\t\tsuperClass.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, SUPER_TYPE, superClass, this.superClass);\n\t\tthis.superClass = superClass;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isClass() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isAnonymous() {\n\t\ttry {\n\t\t\tInteger.parseInt(getSimpleName());\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\treturn getReference().isSubtypeOf(type);\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatement statement) {\n\t\tCtStatementImpl.insertAfter(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertAfter(CtStatementList statements) {\n\t\tCtStatementImpl.insertAfter(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatement statement) {\n\t\tCtStatementImpl.insertBefore(this, statement);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtStatement> C insertBefore(CtStatementList statements) {\n\t\tCtStatementImpl.insertBefore(this, statements);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String getLabel() {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtStatement> C setLabel(String label) {\n\t\treturn (C) this;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <R extends CtCodeElement> R partiallyEvaluate() {\n\t\tVisitorPartialEvaluator eval = new VisitorPartialEvaluator();\n\t\treturn eval.evaluate((R) this);\n\t}\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getDeclaredExecutables() {\n\t\tCollection<CtExecutableReference<?>> declaredExecutables = super.getDeclaredExecutables();\n\t\tList<CtExecutableReference<?>> l = new ArrayList<>(declaredExecutables.size() + getConstructors().size());\n\t\tl.addAll(declaredExecutables);\n\t\tfor (CtExecutable<?> c : getConstructors()) {\n\t\t\tl.add(c.getReference());\n\t\t}\n\t\treturn Collections.unmodifiableList(l);\n\t}\n\n\t@Override\n\tpublic CtClass<T> clone() {\n\t\treturn (CtClass<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic T newInstance() {\n\t\ttry {\n\t\t\tJDTBasedSpoonCompiler spooner = new JDTBasedSpoonCompiler(getFactory());\n\t\t\tspooner.compile(InputType.CTTYPES); // compiling the types of the factory\n\t\t\ttry (NewInstanceClassloader classloader = new NewInstanceClassloader(spooner.getBinaryOutputDirectory())) {\n\t\t\t\tClass<?> klass = classloader.loadClass(getQualifiedName());\n\t\t\t\treturn (T) klass.newInstance();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\tprivate class NewInstanceClassloader extends URLClassLoader {\n\t\tNewInstanceClassloader(File binaryOutputDirectory) throws MalformedURLException {\n\t\t\tsuper(new URL[] { binaryOutputDirectory.toURI().toURL()});\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> loadClass(String s) throws ClassNotFoundException {\n\t\t\ttry {\n\t\t\t\treturn findClass(s);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn super.loadClass(s);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** adding the constructors and static executables */\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getAllExecutables() {\n\t\tSet<CtExecutableReference<?>> l = (Set<CtExecutableReference<?>>) super.getAllExecutables();\n\t\tfor (CtConstructor c : getConstructors()) {\n\t\t\tl.add(c.getReference());\n\t\t}\n\t\tfor (CtExecutable<?> anon : getAnonymousExecutables()) {\n\t\t\tl.add(anon.getReference());\n\t\t}\n\t\treturn l;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtEnumValueImpl.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\n\npublic class CtEnumValueImpl<T> extends CtFieldImpl<T> implements CtEnumValue<T> {\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtEnumValue(this);\n\t}\n\n\t@Override\n\tpublic CtEnumValue clone() {\n\t\treturn (CtEnumValue) super.clone();\n\t}\n\n\t@DerivedProperty\n\t@Override\n\tpublic CtExpression<T> getAssignment() {\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtExecutableImpl.java",
      "weight" : 153.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.util.QualifiedNameBasedSortedSet;\nimport spoon.support.visitor.SignaturePrinter;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\nimport static spoon.reflect.path.CtRole.BODY;\nimport static spoon.reflect.path.CtRole.PARAMETER;\nimport static spoon.reflect.path.CtRole.THROWN;\n\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtExecutable}.\n *\n * @author Renaud Pawlak\n */\npublic abstract class CtExecutableImpl<R> extends CtNamedElementImpl implements CtExecutable<R> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = BODY)\n\tCtBlock<?> body;\n\n\t@MetamodelPropertyField(role = PARAMETER)\n\tList<CtParameter<?>> parameters = emptyList();\n\n\t@MetamodelPropertyField(role = THROWN)\n\tSet<CtTypeReference<? extends Throwable>> thrownTypes = emptySet();\n\n\tpublic CtExecutableImpl() {\n\t}\n\n\tpublic CtType<?> getDeclaringType() {\n\t\treturn (CtType<?>) parent;\n\t}\n\n\tpublic <T> CtType<T> getTopLevelType() {\n\t\treturn getDeclaringType().getTopLevelType();\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtBlock<R> getBody() {\n\t\treturn (CtBlock<R>) body;\n\t}\n\n\t@Override\n\tpublic <T extends CtBodyHolder> T setBody(CtStatement statement) {\n\t\tif (statement != null) {\n\t\t\tCtBlock<?> body = getFactory().Code().getOrCreateCtBlock(statement);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, BODY, body, this.body);\n\t\t\tif (body != null) {\n\t\t\t\tbody.setParent(this);\n\t\t\t}\n\t\t\tthis.body = body;\n\t\t} else {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectDelete(this, BODY, this.body);\n\t\t\tthis.body = null;\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtParameter<?>> getParameters() {\n\t\treturn parameters;\n\t}\n\n\t@Override\n\tpublic <T extends CtExecutable<R>> T setParameters(List<CtParameter<?>> parameters) {\n\t\tif (parameters == null || parameters.isEmpty()) {\n\t\t\tthis.parameters = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\tthis.parameters = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, PARAMETER, this.parameters, new ArrayList<>(this.parameters));\n\t\tthis.parameters.clear();\n\t\tfor (CtParameter<?> p : parameters) {\n\t\t\taddParameter(p);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtExecutable<R>> T addParameter(CtParameter<?> parameter) {\n\t\tif (parameter == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\tparameters = new ArrayList<>(PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tparameter.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, PARAMETER, this.parameters, parameter);\n\t\tparameters.add(parameter);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeParameter(CtParameter<?> parameter) {\n\t\tif (parameters == CtElementImpl.<CtParameter<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, PARAMETER, parameters, parameters.indexOf(parameter), parameter);\n\t\treturn parameters.remove(parameter);\n\t}\n\n\t@Override\n\tpublic Set<CtTypeReference<? extends Throwable>> getThrownTypes() {\n\t\treturn thrownTypes;\n\t}\n\n\t@Override\n\tpublic <T extends CtExecutable<R>> T setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\tif (thrownTypes == null || thrownTypes.isEmpty()) {\n\t\t\tthis.thrownTypes = CtElementImpl.emptySet();\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {\n\t\t\tthis.thrownTypes = new QualifiedNameBasedSortedSet<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDeleteAll(this, THROWN, this.thrownTypes, new HashSet<Object>(this.thrownTypes));\n\t\tthis.thrownTypes.clear();\n\t\tfor (CtTypeReference<? extends Throwable> thrownType : thrownTypes) {\n\t\t\taddThrownType(thrownType);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtExecutable<R>> T addThrownType(CtTypeReference<? extends Throwable> throwType) {\n\t\tif (throwType == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {\n\t\t\tthrownTypes = new QualifiedNameBasedSortedSet<>();\n\t\t}\n\t\tthrowType.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(this, THROWN, this.thrownTypes, throwType);\n\t\tthrownTypes.add(throwType);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean removeThrownType(CtTypeReference<? extends Throwable> throwType) {\n\t\tif (thrownTypes == CtElementImpl.<CtTypeReference<? extends Throwable>>emptySet()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDelete(this, THROWN, thrownTypes, throwType);\n\t\treturn thrownTypes.remove(throwType);\n\t}\n\n\t@Override\n\tpublic String getSignature() {\n\t\tfinal SignaturePrinter pr = new SignaturePrinter();\n\t\tpr.scan(this);\n\t\treturn pr.getSignature();\n\t}\n\n\t@Override\n\tpublic CtExecutableReference<R> getReference() {\n\t\treturn getFactory().Executable().createReference(this);\n\t}\n\n\t@Override\n\tpublic CtExecutable<R> clone() {\n\t\treturn (CtExecutable<R>) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtAnnotationMethodImpl.java",
      "weight" : 83.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtBodyHolder;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport static spoon.reflect.path.CtRole.DEFAULT_EXPRESSION;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtAnnotationMethod}.\n */\npublic class CtAnnotationMethodImpl<T> extends CtMethodImpl<T> implements CtAnnotationMethod<T> {\n\t@MetamodelPropertyField(role = DEFAULT_EXPRESSION)\n\tCtExpression<T> defaultExpression;\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtAnnotationMethod(this);\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getDefaultExpression() {\n\t\treturn defaultExpression;\n\t}\n\n\t@Override\n\tpublic <C extends CtAnnotationMethod<T>> C setDefaultExpression(CtExpression<T> assignedExpression) {\n\t\tif (assignedExpression != null) {\n\t\t\tassignedExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, DEFAULT_EXPRESSION, assignedExpression, this.defaultExpression);\n\t\tthis.defaultExpression = assignedExpression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtBlock<T> getBody() {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <T extends CtBodyHolder> T setBody(CtStatement statement) {\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtTypeReference<? extends Throwable>> getThrownTypes() {\n\t\treturn emptySet();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <U extends CtExecutable<T>> U setThrownTypes(Set<CtTypeReference<? extends Throwable>> thrownTypes) {\n\t\treturn (U) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtParameter<?>> getParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <U extends CtExecutable<T>> U setParameters(List<CtParameter<?>> parameters) {\n\t\treturn (U) this;\n\t}\n\n\t@Override\n\tpublic CtAnnotationMethod<T> clone() {\n\t\treturn (CtAnnotationMethod<T>) super.clone();\n\t}\n}\n\n\n"
    }, {
      "name" : "support/reflect/declaration/CtAnonymousExecutableImpl.java",
      "weight" : 164.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class CtAnonymousExecutableImpl extends CtExecutableImpl<Void> implements CtAnonymousExecutable {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtAnonymousExecutable(this);\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\tif (getModifiers().contains(ModifierKind.PUBLIC)) {\n\t\t\treturn ModifierKind.PUBLIC;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PROTECTED)) {\n\t\t\treturn ModifierKind.PROTECTED;\n\t\t}\n\t\tif (getModifiers().contains(ModifierKind.PRIVATE)) {\n\t\t\treturn ModifierKind.PRIVATE;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn modifierHandler.hasModifier(modifier);\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtParameter<?>> getParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic CtExecutable setParameters(List list) {\n\t\t// unsettable property\n\t\treturn this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic CtExecutable addParameter(CtParameter parameter) {\n\t\t// unsettable property\n\t\treturn this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic boolean removeParameter(CtParameter parameter) {\n\t\treturn false;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtTypeReference<? extends Throwable>> getThrownTypes() {\n\t\treturn emptySet();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic CtExecutable setThrownTypes(Set thrownTypes) {\n\t\t// unsettable property\n\t\treturn this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic CtExecutable addThrownType(CtTypeReference throwType) {\n\t\t// unsettable property\n\t\treturn this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic boolean removeThrownType(CtTypeReference throwType) {\n\t\t// unsettable property\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn \"\";\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <T extends CtNamedElement> T setSimpleName(String simpleName) {\n\t\t// unsettable property\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<Void> getType() {\n\t\treturn factory.Type().VOID_PRIMITIVE;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<Void> type) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic CtAnonymousExecutable clone() {\n\t\treturn (CtAnonymousExecutable) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtImportImpl.java",
      "weight" : 83.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.declaration.CtImportKind;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtTypeMemberWildcardImportReference;\nimport spoon.reflect.visitor.CtImportVisitor;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.reflect.reference.CtTypeMemberWildcardImportReferenceImpl;\n\npublic class CtImportImpl extends CtElementImpl implements CtImport {\n\t@MetamodelPropertyField(role = CtRole.IMPORT_REFERENCE)\n\tprivate CtReference localReference;\n\n\tpublic CtImportImpl() {\n\t}\n\n\t@Override\n\tpublic CtImportKind getImportKind() {\n\t\tif (this.localReference == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.localReference instanceof CtFieldReference) {\n\t\t\treturn CtImportKind.FIELD;\n\t\t} else if (this.localReference instanceof CtExecutableReference) {\n\t\t\treturn CtImportKind.METHOD;\n\t\t} else if (this.localReference instanceof CtPackageReference) {\n\t\t\treturn CtImportKind.ALL_TYPES;\n\t\t} else if (this.localReference instanceof CtTypeMemberWildcardImportReferenceImpl) {\n\t\t\treturn CtImportKind.ALL_STATIC_MEMBERS;\n\t\t} else if (this.localReference instanceof CtTypeReference) {\n\t\t\treturn CtImportKind.TYPE;\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Only CtFieldReference, CtExecutableReference, CtPackageReference and CtTypeReference are accepted reference types.\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtImport> T setReference(CtReference reference) {\n\t\tif (reference != null) {\n\t\t\treference.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IMPORT_REFERENCE, reference, this.localReference);\n\t\tthis.localReference = reference;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtReference getReference() {\n\t\treturn this.localReference;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtImport(this);\n\t}\n\n\t@Override\n\tpublic void accept(CtImportVisitor visitor) {\n\t\tswitch (getImportKind()) {\n\t\tcase TYPE:\n\t\t\tvisitor.visitTypeImport((CtTypeReference<?>) localReference);\n\t\t\tbreak;\n\n\t\tcase METHOD:\n\t\t\tvisitor.visitMethodImport((CtExecutableReference<?>) localReference);\n\t\t\tbreak;\n\n\t\tcase FIELD:\n\t\t\tvisitor.visitFieldImport((CtFieldReference<?>) localReference);\n\t\t\tbreak;\n\n\t\tcase ALL_TYPES:\n\t\t\tvisitor.visitAllTypesImport((CtPackageReference) localReference);\n\t\t\tbreak;\n\n\t\tcase ALL_STATIC_MEMBERS:\n\t\t\tvisitor.visitAllStaticMembersImport((CtTypeMemberWildcardImportReference) localReference);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new SpoonException(\"Unexpected import kind: \" + getImportKind());\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtImportImpl clone() {\n\t\treturn (CtImportImpl) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtModuleImpl.java",
      "weight" : 365.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtModuleDirective;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.comparator.CtLineElementComparator;\nimport spoon.support.util.SortedList;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CtModuleImpl extends CtNamedElementImpl implements CtModule {\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate boolean openModule;\n\n\t@MetamodelPropertyField(role = CtRole.MODULE_DIRECTIVE)\n\tprivate List<CtModuleDirective> moduleDirectives = CtElementImpl.emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.SUB_PACKAGE)\n\tprivate CtPackage rootPackage;\n\n\tpublic CtModuleImpl() {\n\t}\n\n\t@Override\n\tpublic boolean isUnnamedModule() {\n\t\treturn TOP_LEVEL_MODULE_NAME.equals(this.getSimpleName());\n\t}\n\n\t@Override\n\tpublic boolean isOpenModule() {\n\t\treturn this.openModule;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setModuleDirectives(List<CtModuleDirective> moduleDirectives) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.MODULE_DIRECTIVE, this.moduleDirectives, new ArrayList<>(this.moduleDirectives));\n\t\tif (moduleDirectives == null || moduleDirectives.isEmpty()) {\n\t\t\tthis.moduleDirectives = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.moduleDirectives == CtElementImpl.<CtModuleDirective>emptyList()) {\n\t\t\tthis.moduleDirectives = new SortedList<>(new CtLineElementComparator());\n\t\t}\n\t\tthis.moduleDirectives.clear();\n\n\t\tfor (CtModuleDirective moduleDirective : moduleDirectives) {\n\t\t\tthis.addModuleDirective(moduleDirective);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addModuleDirective(CtModuleDirective moduleDirective) {\n\t\tif (moduleDirective == null) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tif (this.moduleDirectives == CtElementImpl.<CtModuleDirective>emptyList()) {\n\t\t\tthis.moduleDirectives = new SortedList<>(new CtLineElementComparator());\n\t\t}\n\t\tif (!this.moduleDirectives.contains(moduleDirective)) {\n\t\t\tmoduleDirective.setParent(this);\n\t\t\tCtRole role = CtRole.MODULE_DIRECTIVE.getMatchingSubRoleFor(moduleDirective);\n\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, role, this.moduleDirectives, moduleDirective);\n\t\t\tthis.moduleDirectives.add(moduleDirective);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addModuleDirectiveAt(int position, CtModuleDirective moduleDirective) {\n\t\tif (moduleDirective == null) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tif (this.moduleDirectives == CtElementImpl.<CtModuleDirective>emptyList()) {\n\t\t\tthis.moduleDirectives = new SortedList<>(new CtLineElementComparator());\n\t\t}\n\t\tif (!this.moduleDirectives.contains(moduleDirective)) {\n\t\t\tmoduleDirective.setParent(this);\n\t\t\tCtRole role = CtRole.MODULE_DIRECTIVE.getMatchingSubRoleFor(moduleDirective);\n\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, role, this.moduleDirectives, position, moduleDirective);\n\t\t\tthis.moduleDirectives.add(position, moduleDirective);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtModuleDirective> getModuleDirectives() {\n\t\treturn Collections.unmodifiableList(this.moduleDirectives);\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeModuleDirective(CtModuleDirective moduleDirective) {\n\t\tif (moduleDirective == null || this.moduleDirectives.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.moduleDirectives.contains(moduleDirective)) {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.MODULE_DIRECTIVE.getMatchingSubRoleFor(moduleDirective), this.moduleDirectives, this.moduleDirectives.indexOf(moduleDirective), moduleDirective);\n\t\t\tif (this.moduleDirectives.size() == 1) {\n\t\t\t\tthis.moduleDirectives = CtElementImpl.emptyList();\n\t\t\t} else {\n\t\t\t\tthis.moduleDirectives.remove(moduleDirective);\n\t\t\t}\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setIsOpenModule(boolean openModule) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.MODIFIER, openModule, this.openModule);\n\t\tthis.openModule = openModule;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtUsedService> getUsedServices() {\n\t\tif (this.moduleDirectives.isEmpty()) {\n\t\t\treturn CtElementImpl.emptyList();\n\t\t} else {\n\t\t\tList<CtUsedService> usedServices = new ArrayList<>();\n\t\t\tfor (CtModuleDirective moduleDirective : this.moduleDirectives) {\n\t\t\t\tif (moduleDirective instanceof CtUsedService) {\n\t\t\t\t\tusedServices.add((CtUsedService) moduleDirective);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(usedServices);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setUsedServices(List<CtUsedService> consumedServices) {\n\t\tif (consumedServices == null || consumedServices.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tList<CtUsedService> usedServices = getUsedServices();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.SERVICE_TYPE, this.moduleDirectives, new ArrayList<>(usedServices));\n\t\tthis.moduleDirectives.removeAll(usedServices);\n\n\t\tfor (CtUsedService consumedService : consumedServices) {\n\t\t\tthis.addModuleDirective(consumedService);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addUsedService(CtUsedService consumedService) {\n\t\tif (consumedService == null) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tthis.addModuleDirective(consumedService);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeUsedService(CtUsedService usedService) {\n\t\tif (usedService == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\treturn this.removeModuleDirective(usedService);\n\t}\n\n\t@Override\n\tpublic List<CtPackageExport> getExportedPackages() {\n\t\tif (this.moduleDirectives.isEmpty()) {\n\t\t\treturn CtElementImpl.emptyList();\n\t\t} else {\n\t\t\tList<CtPackageExport> exportedPackages = new ArrayList<>();\n\t\t\tfor (CtModuleDirective moduleDirective : this.moduleDirectives) {\n\t\t\t\tif (moduleDirective instanceof CtPackageExport) {\n\t\t\t\t\tCtPackageExport exportedPackage = (CtPackageExport) moduleDirective;\n\t\t\t\t\tif (!exportedPackage.isOpenedPackage()) {\n\t\t\t\t\t\texportedPackages.add(exportedPackage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(exportedPackages);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setExportedPackages(List<CtPackageExport> exportedPackages) {\n\t\tif (exportedPackages == null || exportedPackages.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tList<CtPackageExport> oldExportedPackages = getExportedPackages();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.EXPORTED_PACKAGE, this.moduleDirectives, new ArrayList<>(oldExportedPackages));\n\t\tthis.moduleDirectives.removeAll(oldExportedPackages);\n\n\t\tfor (CtPackageExport exportedPackage : exportedPackages) {\n\t\t\texportedPackage.setOpenedPackage(false);\n\t\t\tthis.addModuleDirective(exportedPackage);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addExportedPackage(CtPackageExport exportedPackage) {\n\t\tif (exportedPackage == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\texportedPackage.setOpenedPackage(false);\n\t\tthis.addModuleDirective(exportedPackage);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeExportedPackage(CtPackageExport exportedPackage) {\n\t\tif (exportedPackage == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\treturn this.removeModuleDirective(exportedPackage);\n\t}\n\n\t@Override\n\tpublic List<CtPackageExport> getOpenedPackages() {\n\t\tif (this.moduleDirectives.isEmpty()) {\n\t\t\treturn CtElementImpl.emptyList();\n\t\t} else {\n\t\t\tList<CtPackageExport> openedPackages = new ArrayList<>();\n\t\t\tfor (CtModuleDirective moduleDirective : this.moduleDirectives) {\n\t\t\t\tif (moduleDirective instanceof CtPackageExport) {\n\t\t\t\t\tCtPackageExport exportedPackage = (CtPackageExport) moduleDirective;\n\t\t\t\t\tif (exportedPackage.isOpenedPackage()) {\n\t\t\t\t\t\topenedPackages.add(exportedPackage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(openedPackages);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setOpenedPackages(List<CtPackageExport> openedPackages) {\n\t\tif (openedPackages == null || openedPackages.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tList<CtPackageExport> oldOpenedPackages = getOpenedPackages();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.OPENED_PACKAGE, this.moduleDirectives, new ArrayList<>(oldOpenedPackages));\n\t\tthis.moduleDirectives.removeAll(oldOpenedPackages);\n\n\t\tfor (CtPackageExport exportedPackage : openedPackages) {\n\t\t\texportedPackage.setOpenedPackage(true);\n\t\t\tthis.addModuleDirective(exportedPackage);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addOpenedPackage(CtPackageExport openedPackage) {\n\t\tif (openedPackage == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\topenedPackage.setOpenedPackage(true);\n\t\tthis.addModuleDirective(openedPackage);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeOpenedPackage(CtPackageExport openedPackage) {\n\t\tif (openedPackage == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\treturn this.removeModuleDirective(openedPackage);\n\t}\n\n\t@Override\n\tpublic List<CtModuleRequirement> getRequiredModules() {\n\t\tif (this.moduleDirectives.isEmpty()) {\n\t\t\treturn CtElementImpl.emptyList();\n\t\t} else {\n\t\t\tList<CtModuleRequirement> moduleRequirements = new ArrayList<>();\n\t\t\tfor (CtModuleDirective moduleDirective : this.moduleDirectives) {\n\t\t\t\tif (moduleDirective instanceof CtModuleRequirement) {\n\t\t\t\t\tmoduleRequirements.add((CtModuleRequirement) moduleDirective);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(moduleRequirements);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setRequiredModules(List<CtModuleRequirement> requiredModules) {\n\t\tif (requiredModules == null || requiredModules.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tList<CtModuleRequirement> oldRequiredModules = getRequiredModules();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.REQUIRED_MODULE, this.moduleDirectives, new ArrayList<>(oldRequiredModules));\n\t\tthis.moduleDirectives.removeAll(oldRequiredModules);\n\n\t\tfor (CtModuleRequirement moduleRequirement : requiredModules) {\n\t\t\tthis.addModuleDirective(moduleRequirement);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addRequiredModule(CtModuleRequirement requiredModule) {\n\t\tif (requiredModule == null) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tthis.addModuleDirective(requiredModule);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeRequiredModule(CtModuleRequirement requiredModule) {\n\t\tif (requiredModule == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\treturn this.removeModuleDirective(requiredModule);\n\t}\n\n\t@Override\n\tpublic List<CtProvidedService> getProvidedServices() {\n\t\tif (this.moduleDirectives.isEmpty()) {\n\t\t\treturn CtElementImpl.emptyList();\n\t\t} else {\n\t\t\tList<CtProvidedService> providedServices = new ArrayList<>();\n\t\t\tfor (CtModuleDirective moduleDirective : this.moduleDirectives) {\n\t\t\t\tif (moduleDirective instanceof CtProvidedService) {\n\t\t\t\t\tprovidedServices.add((CtProvidedService) moduleDirective);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Collections.unmodifiableList(providedServices);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setProvidedServices(List<CtProvidedService> providedServices) {\n\t\tif (providedServices == null || providedServices.isEmpty()) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tList<CtProvidedService> oldProvidedServices = getProvidedServices();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.PROVIDED_SERVICE, this.moduleDirectives, new ArrayList<>(oldProvidedServices));\n\t\tthis.moduleDirectives.removeAll(oldProvidedServices);\n\n\t\tfor (CtProvidedService providedService : providedServices) {\n\t\t\tthis.addModuleDirective(providedService);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T addProvidedService(CtProvidedService providedService) {\n\t\tif (providedService == null) {\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tthis.addModuleDirective(providedService);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T removeProvidedService(CtProvidedService providedService) {\n\t\tif (providedService == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\treturn this.removeModuleDirective(providedService);\n\t}\n\n\t@Override\n\tpublic CtPackage getRootPackage() {\n\t\treturn this.rootPackage;\n\t}\n\n\t@Override\n\tpublic <T extends CtModule> T setRootPackage(CtPackage rootPackage) {\n\t\tif (rootPackage != null) {\n\t\t\trootPackage.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.SUB_PACKAGE, rootPackage, this.rootPackage);\n\t\tthis.rootPackage = rootPackage;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtModule(this);\n\t}\n\n\t@Override\n\tpublic CtModuleReference getReference() {\n\t\treturn this.getFactory().Module().createReference(this);\n\t}\n\n\t@Override\n\tpublic CtModule clone() {\n\t\treturn (CtModule) super.clone();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic <T extends CtElement> T setParent(T parent) {\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtElement getParent() {\n\t\treturn getFactory().getModel().getUnnamedModule();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtUsedServiceImpl.java",
      "weight" : 31.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtUsedService;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtUsedServiceImpl extends CtElementImpl implements CtUsedService {\n\t@MetamodelPropertyField(role = CtRole.SERVICE_TYPE)\n\tprivate CtTypeReference serviceType;\n\n\t@Override\n\tpublic CtTypeReference getServiceType() {\n\t\treturn this.serviceType;\n\t}\n\n\t@Override\n\tpublic <T extends CtUsedService> T setServiceType(CtTypeReference usedService) {\n\t\tif (usedService != null) {\n\t\t\tusedService.setParent(this);\n\t\t}\n\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.SERVICE_TYPE, usedService, this.serviceType);\n\t\tthis.serviceType = usedService;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtUsedService(this);\n\t}\n\n\t@Override\n\tpublic CtUsedService clone() {\n\t\treturn (CtUsedService) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtPackageDeclarationImpl.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.visitor.CtVisitor;\n\npublic class CtPackageDeclarationImpl extends CtElementImpl implements CtPackageDeclaration {\n\tprivate static final long serialVersionUID = 1L;\n\t@MetamodelPropertyField(role = CtRole.PACKAGE_REF)\n\tprivate CtPackageReference reference;\n\n\t@Override\n\tpublic CtPackageDeclarationImpl setReference(CtPackageReference reference) {\n\t\tif (reference != null) {\n\t\t\treference.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.PACKAGE_REF, reference, this.reference);\n\t\tthis.reference = reference;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic CtPackageReference getReference() {\n\t\treturn this.reference;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtPackageDeclaration(this);\n\t}\n\n\t@Override\n\tpublic CtPackageDeclarationImpl clone() {\n\t\treturn (CtPackageDeclarationImpl) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtNamedElementImpl.java",
      "weight" : 38.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.reference.CtReference;\n\nimport static spoon.reflect.path.CtRole.NAME;\n\npublic abstract class CtNamedElementImpl extends CtElementImpl implements CtNamedElement {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = NAME)\n\tString simpleName = \"\";\n\n\t@Override\n\tpublic CtReference getReference() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn simpleName;\n\t}\n\n\t@Override\n\tpublic <T extends CtNamedElement> T setSimpleName(String simpleName) {\n\t\tFactory factory = getFactory();\n\t\tif (factory == null) {\n\t\t\tthis.simpleName = simpleName;\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (factory instanceof FactoryImpl) {\n\t\t\tsimpleName = ((FactoryImpl) factory).dedup(simpleName);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, NAME, simpleName, this.simpleName);\n\t\tthis.simpleName = simpleName;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtNamedElement clone() {\n\t\treturn (CtNamedElement) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtInterfaceImpl.java",
      "weight" : 48.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.UnsettableProperty;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CtInterfaceImpl<T> extends CtTypeImpl<T> implements CtInterface<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtInterface(this);\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\treturn getReference().isSubtypeOf(type);\n\t}\n\n\t@Override\n\tpublic boolean isInterface() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getDeclaredExecutables() {\n\t\tSet<CtTypeReference<?>> superInterfaces = getSuperInterfaces();\n\t\tif (superInterfaces.isEmpty()) {\n\t\t\treturn super.getDeclaredExecutables();\n\t\t}\n\t\tList<CtExecutableReference<?>> l = new ArrayList<>(super.getDeclaredExecutables());\n\t\tfor (CtTypeReference<?> sup : superInterfaces) {\n\t\t\tl.addAll(sup.getAllExecutables());\n\t\t}\n\t\treturn Collections.unmodifiableList(l);\n\t}\n\n\t@Override\n\tpublic CtInterface<T> clone() {\n\t\treturn (CtInterface<T>) super.clone();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtParameterImpl.java",
      "weight" : 157.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\n\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtParameter}.\n *\n * @author Renaud Pawlak\n */\npublic class CtParameterImpl<T> extends CtNamedElementImpl implements CtParameter<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE)\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = CtRole.IS_VARARGS)\n\tboolean varArgs = false;\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\tpublic CtParameterImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtParameter(this);\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtExpression<T> getDefaultExpression() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtParameterReference<T> getReference() {\n\t\treturn getFactory().Executable().createParameterReference(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> defaultExpression) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isVarArgs() {\n\t\treturn varArgs;\n\t}\n\n\t@Override\n\tpublic <C extends CtParameter<T>> C setVarArgs(boolean varArgs) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_VARARGS, varArgs, this.varArgs);\n\t\tthis.varArgs = varArgs;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\tmodifierHandler.getVisibility();\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtExecutable<?> getParent() {\n\t\treturn (CtExecutable<?>) super.getParent();\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (T) this;\n\t}\n\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtParameter<T> clone() {\n\t\treturn (CtParameter<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtEnumImpl.java",
      "weight" : 198.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.util.SignatureBasedSortedSet;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.path.CtRole.VALUE;\n\npublic class CtEnumImpl<T extends Enum<?>> extends CtClassImpl<T> implements CtEnum<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = VALUE)\n\tprivate List<CtEnumValue<?>> enumValues = CtElementImpl.emptyList();\n\n\t@MetamodelPropertyField(role = VALUE)\n\tprivate CtMethod<T[]> valuesMethod;\n\n\tprivate CtMethod<T> valueOfMethod;\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtEnum(this);\n\t}\n\n\t@Override\n\tpublic Set<CtMethod<?>> getAllMethods() {\n\t\tSet<CtMethod<?>> allMethods = new SignatureBasedSortedSet();\n\t\tallMethods.addAll(getMethods());\n\t\tallMethods.addAll(getFactory().Type().get(Enum.class).getMethods());\n\t\tallMethods.add(valuesMethod());\n\t\tallMethods.add(valueOfMethod());\n\t\treturn allMethods;\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\treturn getReference().isSubtypeOf(type);\n\t}\n\n\t@Override\n\tpublic <C extends CtEnum<T>> C addEnumValue(CtEnumValue<?> enumValue) {\n\t\tif (enumValue == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (enumValues == CtElementImpl.<CtEnumValue<?>>emptyList()) {\n\t\t\tenumValues = new ArrayList<>();\n\t\t}\n\t\tif (!enumValues.contains(enumValue)) {\n\t\t\tenumValue.setParent(this);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, VALUE, this.enumValues, enumValue);\n\t\t\tenumValues.add(enumValue);\n\t\t}\n\n\t\t// enum value already exists.\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeEnumValue(CtEnumValue<?> enumValue) {\n\t\tif (enumValues == CtElementImpl.<CtEnumValue<?>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, VALUE, enumValues, enumValues.indexOf(enumValue), enumValue);\n\t\treturn enumValues.remove(enumValue);\n\t}\n\n\t@Override\n\tpublic CtEnumValue<?> getEnumValue(String name) {\n\t\tfor (CtEnumValue<?> enumValue : enumValues) {\n\t\t\tif (enumValue.getSimpleName().equals(name)) {\n\t\t\t\treturn enumValue;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<CtEnumValue<?>> getEnumValues() {\n\t\treturn Collections.unmodifiableList(enumValues);\n\t}\n\n\t@Override\n\tpublic <C extends CtEnum<T>> C setEnumValues(List<CtEnumValue<?>> enumValues) {\n\t\tif (enumValues == null) {\n\t\t\tthis.enumValues = emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, VALUE, this.enumValues, new ArrayList<>(enumValues));\n\t\tif (enumValues.isEmpty()) {\n\t\t\tthis.enumValues = emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tthis.enumValues.clear();\n\t\tfor (CtEnumValue<?> enumValue : enumValues) {\n\t\t\taddEnumValue(enumValue);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtField<?>> getFields() {\n\t\tList<CtField<?>> result = new ArrayList<>();\n\t\tresult.addAll(getEnumValues());\n\t\tresult.addAll(super.getFields());\n\t\treturn Collections.unmodifiableList(result);\n\t}\n\n\t@Override\n\tpublic CtField<?> getField(String name) {\n\t\tfinal CtField<?> field = super.getField(name);\n\t\tif (field == null) {\n\t\t\treturn getEnumValue(name);\n\t\t}\n\t\treturn field;\n\t}\n\n\t@Override\n\tpublic CtEnum<T> clone() {\n\t\treturn (CtEnum<T>) super.clone();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\treturn getFactory().Type().createReference(Enum.class);\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\treturn (C) this;\n\t}\n\n\tprivate CtMethod valuesMethod() {\n\t\tif (valuesMethod == null) {\n\t\t\tvaluesMethod = getFactory().Core().createMethod();\n\t\t\tvaluesMethod.setParent(this);\n\t\t\tvaluesMethod.addModifier(ModifierKind.PUBLIC);\n\t\t\tvaluesMethod.addModifier(ModifierKind.STATIC);\n\t\t\tvaluesMethod.setSimpleName(\"values\");\n\t\t\tvaluesMethod.setImplicit(true);\n\t\t\tvaluesMethod.setType(factory.Type().createArrayReference(getReference()));\n\t\t}\n\t\treturn valuesMethod;\n\t}\n\n\tprivate CtMethod valueOfMethod() {\n\t\tif (valueOfMethod == null) {\n\t\t\tvalueOfMethod = getFactory().Core().createMethod();\n\t\t\tvalueOfMethod.setParent(this);\n\t\t\tvalueOfMethod.addModifier(ModifierKind.PUBLIC);\n\t\t\tvalueOfMethod.addModifier(ModifierKind.STATIC);\n\t\t\tvalueOfMethod.setSimpleName(\"valueOf\");\n\t\t\tvalueOfMethod.setImplicit(true);\n\t\t\tvalueOfMethod.addThrownType(\n\t\t\t\tgetFactory().Type().createReference(IllegalArgumentException.class));\n\t\t\tvalueOfMethod.setType(getReference());\n\t\t\tfactory.Method().createParameter(valueOfMethod, factory.Type().STRING, \"name\");\n\t\t}\n\t\treturn valueOfMethod;\n\t}\n\n\t@Override\n\tpublic <R> CtMethod<R> getMethod(String name, CtTypeReference<?>... parameterTypes) {\n\t\tif (\"values\".equals(name) && parameterTypes.length == 0) {\n\t\t\treturn valuesMethod();\n\t\t} else if (\"valueOf\".equals(name) && parameterTypes.length == 1 && parameterTypes[0].equals(factory.Type().STRING)) {\n\t\t\treturn valueOfMethod();\n\t\t} else {\n\t\t\treturn super.getMethod(name, parameterTypes);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>... parameterTypes) {\n\t\tif (\"values\".equals(name)\n\t\t\t&& parameterTypes.length == 0\n\t\t\t&& returnType.equals(getReference())) {\n\t\t\treturn valuesMethod();\n\t\t} else if (\"valueOf\".equals(name)\n\t\t\t&& parameterTypes.length == 1\n\t\t\t&& parameterTypes[0].equals(factory.Type().STRING)\n\t\t\t&& returnType.equals(factory.Type().createArrayReference(getReference()))) {\n\t\t\treturn valueOfMethod();\n\t\t} else {\n\t\t\treturn super.getMethod(returnType, name, parameterTypes);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isClass() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isEnum() {\n\t\treturn true;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\treturn (C) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/InvisibleArrayConstructorImpl.java",
      "weight" : 30.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\n\n/**\n * This class is used to represent the constructor of an array when calling with an expression like\n * <pre>\n *     String[]::new\n * </pre>\n *\n * Warning: this type is never present in the Spoon model.\n * It is created dynamically when calling the executable of an expression such as the one in the example.\n */\npublic class InvisibleArrayConstructorImpl<T> extends CtConstructorImpl<T> {\n\n\t@MetamodelPropertyField(role = CtRole.TYPE)\n\tprivate CtTypeReference<T> type;\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn this.type;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type == null) {\n\t\t\treturn (C) this;\n\t\t}\n\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.getType().toString() + \"::new\";\n\t}\n\n\t@Override\n\tpublic CtType<T> getDeclaringType() {\n\t\treturn this.getType().getTypeDeclaration();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtAnnotationTypeImpl.java",
      "weight" : 79.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtAnnotationType}.\n *\n * @author Renaud Pawlak\n */\npublic class CtAnnotationTypeImpl<T extends Annotation> extends CtTypeImpl<T> implements CtAnnotationType<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtAnnotationType(this);\n\t}\n\n\t@Override\n\tpublic boolean isAnnotationType() {\n\t\treturn true;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtTypeReference<?>> getSuperInterfaces() {\n\t\treturn Collections.emptySet();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<T>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isSubtypeOf(CtTypeReference<?> type) {\n\t\treturn getReference().isSubtypeOf(type);\n\t}\n\n\t@Override\n\tpublic CtAnnotationType<T> clone() {\n\t\treturn (CtAnnotationType<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic Set<CtAnnotationMethod<?>> getAnnotationMethods() {\n\t\tSet<CtAnnotationMethod<?>> annotationsMethods = new HashSet<>();\n\t\tfor (CtMethod<?> method : getMethods()) {\n\t\t\tif (method instanceof  CtAnnotationMethod) {\n\t\t\t\tannotationsMethods.add((CtAnnotationMethod<?>) method);\n\t\t\t}\n\t\t}\n\t\treturn annotationsMethods;\n\t}\n\n\t@Override\n\tpublic <M, C extends CtType<T>> C addMethod(CtMethod<M> method) {\n\t\treturn super.addMethod(method);\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtFieldImpl.java",
      "weight" : 163.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtRHSReceiver;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\n\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtField}.\n *\n * @author Renaud Pawlak\n */\npublic class CtFieldImpl<T> extends CtNamedElementImpl implements CtField<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.DEFAULT_EXPRESSION)\n\tCtExpression<T> defaultExpression;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE)\n\tCtTypeReference<T> type;\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\tpublic CtFieldImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtField(this);\n\t}\n\n\t@Override\n\tpublic CtType<?> getDeclaringType() {\n\t\treturn (CtType<?>) parent;\n\t}\n\n\t@Override\n\tpublic <T> CtType<T> getTopLevelType() {\n\t\treturn getDeclaringType().getTopLevelType();\n\t}\n\n\t@Override\n\tpublic CtExpression<T> getDefaultExpression() {\n\t\treturn defaultExpression;\n\t}\n\n\t@Override\n\tpublic CtFieldReference<T> getReference() {\n\t\treturn getFactory().Field().createReference(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic <C extends CtVariable<T>> C setDefaultExpression(CtExpression<T> defaultExpression) {\n\t\tif (defaultExpression != null) {\n\t\t\tdefaultExpression.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.DEFAULT_EXPRESSION, defaultExpression, this.defaultExpression);\n\t\tthis.defaultExpression = defaultExpression;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, type, this.type);\n\t\tthis.type = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (C) this;\n\t}\n\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\treturn modifierHandler.getVisibility();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtExpression<T> getAssignment() {\n\t\treturn getDefaultExpression();\n\t}\n\n\t@Override\n\tpublic <C extends CtRHSReceiver<T>> C setAssignment(CtExpression<T> assignment) {\n\t\tsetDefaultExpression(assignment);\n\t\treturn (C) this;\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtField<T> clone() {\n\t\treturn (CtField<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtCompilationUnitImpl.java",
      "weight" : 347.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtCompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtPackageDeclaration;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.filter.TypeFilter;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.cu.position.PartialSourcePositionImpl;\nimport spoon.support.sniper.internal.ElementSourceFragment;\nimport spoon.support.util.ModelList;\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\n\n/**\n * Implements a compilation unit. In Java, a compilation unit can contain only one\n * public type declaration and other secondary types declarations (not public).\n */\npublic class CtCompilationUnitImpl extends CtElementImpl implements CtCompilationUnit {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.DECLARED_TYPE_REF)\n\tprivate final ModelList<CtTypeReference<?>> declaredTypeReferences = new ModelList<CtTypeReference<?>>() {\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtCompilationUnitImpl.this;\n\t\t}\n\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.DECLARED_TYPE_REF;\n\t\t}\n\n\t\t@Override\n\t\tprotected int getDefaultCapacity() {\n\t\t\treturn ModelElementContainerDefaultCapacities.COMPILATION_UNIT_DECLARED_TYPES_CONTAINER_DEFAULT_CAPACITY;\n\t\t}\n\t};\n\n\t@MetamodelPropertyField(role = CtRole.PACKAGE_DECLARATION)\n\tprivate CtPackageDeclaration packageDeclaration;\n\n\t@MetamodelPropertyField(role = CtRole.DECLARED_IMPORT)\n\tprivate final ModelList<CtImport> imports = new ModelList<CtImport>() {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtCompilationUnitImpl.this;\n\t\t}\n\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.DECLARED_IMPORT;\n\t\t}\n\n\t\t@Override\n\t\tprotected int getDefaultCapacity() {\n\t\t\treturn ModelElementContainerDefaultCapacities.COMPILATION_UNIT_IMPORTS_CONTAINER_DEFAULT_CAPACITY;\n\t\t}\n\t};\n\n\t@MetamodelPropertyField(role = CtRole.DECLARED_MODULE_REF)\n\tprivate CtModuleReference moduleReference;\n\n\tprivate File file;\n\n\t/**\n\t * The index of line breaks, as computed by JDT.\n\t * Used to compute line numbers afterwards.\n\t */\n\tprivate int[] lineSeparatorPositions;\n\n\tprivate ElementSourceFragment rootFragment;\n\n\tprivate String originalSourceCode;\n\n\tprivate PartialSourcePositionImpl myPartialSourcePosition;\n\n\t@Override\n\tpublic UNIT_TYPE getUnitType() {\n\t\t// we try to guess based on the file name\n\t\tif (file != null) {\n\t\t\tif (file.getName().equals(DefaultJavaPrettyPrinter.JAVA_MODULE_DECLARATION)) {\n\t\t\t\treturn UNIT_TYPE.MODULE_DECLARATION;\n\t\t\t} else if (file.getName().equals(DefaultJavaPrettyPrinter.JAVA_PACKAGE_DECLARATION)) {\n\t\t\t\treturn UNIT_TYPE.PACKAGE_DECLARATION;\n\t\t\t} else {\n\t\t\t\treturn UNIT_TYPE.TYPE_DECLARATION;\n\t\t\t}\n\t\t// else we just check if there is a declared type\n\t\t} else {\n\t\t\tif (getDeclaredTypes().isEmpty()) {\n\t\t\t\tif (getDeclaredModuleReference() != null) {\n\t\t\t\t\treturn UNIT_TYPE.MODULE_DECLARATION;\n\t\t\t\t} else if (packageDeclaration != null) {\n\t\t\t\t\treturn UNIT_TYPE.PACKAGE_DECLARATION;\n\t\t\t\t} else {\n\t\t\t\t\treturn UNIT_TYPE.UNKNOWN;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn UNIT_TYPE.TYPE_DECLARATION;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic File getFile() {\n\t\treturn file;\n\t}\n\n\t@Override\n\tpublic CtType<?> getMainType() {\n\t\tif (getFile() == null) {\n\t\t\treturn getDeclaredTypes().get(0);\n\t\t}\n\t\tfor (CtType<?> t : getDeclaredTypes()) {\n\t\t\tString name = getFile().getName();\n\t\t\tname = name.substring(0, name.lastIndexOf('.'));\n\t\t\tif (t.getSimpleName().equals(name)) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t\tthrow new RuntimeException(\n\t\t\t\t\"inconsistent compilation unit: '\"\n\t\t\t\t\t\t+ file\n\t\t\t\t\t\t+ \"': declared types are \"\n\t\t\t\t\t\t+ getDeclaredTypes());\n\t}\n\n\t@Override\n\tpublic List<CtType<?>> getDeclaredTypes() {\n\t\treturn Collections.unmodifiableList(declaredTypeReferences.stream().map(ref -> ref.getTypeDeclaration()).collect(Collectors.toList()));\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference<?>> getDeclaredTypeReferences() {\n\t\treturn declaredTypeReferences;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setDeclaredTypeReferences(List<CtTypeReference<?>> types) {\n\t\tthis.declaredTypeReferences.set(types);\n\t\treturn this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtCompilationUnit setDeclaredTypes(List<CtType<?>> types) {\n\t\treturn setDeclaredTypeReferences(types.stream().map(CtType::getReference).collect(Collectors.toList()));\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtCompilationUnitImpl addDeclaredType(CtType<?> type) {\n\t\tif (type != null) {\n\t\t\taddDeclaredTypeReference(type.getReference());\n\t\t}\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl addDeclaredTypeReference(CtTypeReference<?> type) {\n\t\tthis.declaredTypeReferences.add(type);\n\t\treturn this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtModule getDeclaredModule() {\n\t\treturn this.moduleReference != null ? this.moduleReference.getDeclaration() : null;\n\t}\n\n\t@Override\n\tpublic CtModuleReference getDeclaredModuleReference() {\n\t\treturn moduleReference;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setDeclaredModule(CtModule module) {\n\t\tsetDeclaredModuleReference(module == null ? null : module.getReference());\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setDeclaredModuleReference(CtModuleReference module) {\n\t\t//Do not set compilation unit as parent of module\n\t\tif (module != null) {\n\t\t\tmodule.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.DECLARED_MODULE_REF, module, this.moduleReference);\n\t\tthis.moduleReference = module;\n\t\treturn this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtPackage getDeclaredPackage() {\n\t\tif (packageDeclaration != null) {\n\t\t\treturn packageDeclaration.getReference().getDeclaration();\n\t\t}\n\t\tif (declaredTypeReferences.size() > 0) {\n\t\t\treturn declaredTypeReferences.get(0).getPackage().getDeclaration();\n\t\t}\n\t\treturn getFactory().getModel().getRootPackage();\n\t}\n\n\t@Override\n\tpublic CtPackageDeclaration getPackageDeclaration() {\n\t\tif (packageDeclaration == null) {\n\t\t\tCtPackageReference packRef;\n\t\t\tif (declaredTypeReferences.size() > 0) {\n\t\t\t\tpackRef = declaredTypeReferences.get(0).getPackage().clone();\n\t\t\t} else {\n\t\t\t\tpackRef = getFactory().getModel().getRootPackage().getReference();\n\t\t\t}\n\t\t\tpackageDeclaration = getFactory().Package().createPackageDeclaration(packRef);\n\t\t}\n\t\treturn packageDeclaration;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setDeclaredPackage(CtPackage ctPackage) {\n\t\tsetPackageDeclaration(ctPackage == null ? null : getFactory().Package().createPackageDeclaration(ctPackage.getReference()));\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setPackageDeclaration(CtPackageDeclaration packageDeclaration) {\n\t\tif (packageDeclaration != null) {\n\t\t\tpackageDeclaration.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.PACKAGE_DECLARATION, packageDeclaration, this.packageDeclaration);\n\t\tthis.packageDeclaration = packageDeclaration;\n\t\treturn (CtCompilationUnitImpl) this;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setFile(File file) {\n\t\tthis.file = file;\n\t\t//reset cached position (if any)\n\t\tthis.position = SourcePosition.NOPOSITION;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic List<File> getBinaryFiles() {\n\t\tfinal List<File> binaries = new ArrayList<>();\n\t\tfinal String output = getFactory()\n\t\t\t\t.getEnvironment()\n\t\t\t\t.getBinaryOutputDirectory();\n\t\tif (output != null) {\n\t\t\tfinal File base = Paths\n\t\t\t\t\t.get(output, getDeclaredPackage()\n\t\t\t\t\t.getQualifiedName()\n\t\t\t\t\t.replace(\".\", File.separator))\n\t\t\t\t\t.toFile();\n\t\t\tif (base.isDirectory()) {\n\t\t\t\tfor (final CtType type : getDeclaredTypes()) {\n\t\t\t\t\t// Add main type, for instance, 'Foo.class'.\n\t\t\t\t\tfinal String nameOfType = type.getSimpleName();\n\t\t\t\t\tfinal File fileOfType = new File(\n\t\t\t\t\t\t\tbase, nameOfType + \".class\");\n\t\t\t\t\tif (fileOfType.isFile()) {\n\t\t\t\t\t\tbinaries.add(fileOfType);\n\t\t\t\t\t}\n\t\t\t\t\t// Add inner/anonymous types, for instance,\n\t\t\t\t\t// 'Foo$Bar.class'. Use 'getElements()' rather than\n\t\t\t\t\t// 'getNestedTypes()' to also fetch inner types of inner\n\t\t\t\t\t// types of inner types ... and so on.\n\t\t\t\t\tfor (final CtType inner : type.getElements(\n\t\t\t\t\t\t\tnew TypeFilter<>(CtType.class))) {\n\t\t\t\t\t\t// 'getElements' does not only return inner types but\n\t\t\t\t\t\t// also returns 'type' itself. Thus, we need to ensure\n\t\t\t\t\t\t// to not add 'type' twice.\n\t\t\t\t\t\tif (!inner.equals(type)) {\n\t\t\t\t\t\t\tfinal String nameOfInner =\n\t\t\t\t\t\t\t\t\tnameOfType + \"$\" + inner.getSimpleName();\n\t\t\t\t\t\t\tfinal File fileOfInnerType = new File(\n\t\t\t\t\t\t\t\t\tbase, nameOfInner + \".class\");\n\t\t\t\t\t\t\tif (fileOfInnerType.isFile()) {\n\t\t\t\t\t\t\t\tbinaries.add(fileOfInnerType);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn binaries;\n\t}\n\n\n\t@Override\n\tpublic String getOriginalSourceCode() {\n\n\t\tif (originalSourceCode == null && getFile() != null) {\n\t\t\ttry (FileInputStream s = new FileInputStream(getFile())) {\n\t\t\t\tbyte[] elementBytes = new byte[s.available()];\n\t\t\t\ts.read(elementBytes);\n\t\t\t\toriginalSourceCode = new String(elementBytes, this.getFactory().getEnvironment().getEncoding());\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn originalSourceCode;\n\t}\n\n\n\t@Override\n\tpublic ModelList<CtImport> getImports() {\n\t\treturn this.imports;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setImports(Collection<CtImport> imports) {\n\t\tthis.imports.set(imports);\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic ElementSourceFragment getOriginalSourceFragment() {\n\t\tif (rootFragment == null) {\n\t\t\tif (moduleReference != null) {\n\t\t\t\tthrow new SpoonException(\"Root source fragment of compilation unit of module is not supported\");\n\t\t\t}\n\t\t\tif (declaredTypeReferences.isEmpty()) {\n\t\t\t\tthrow new SpoonException(\"Root source fragment of compilation unit of package is not supported\");\n\t\t\t}\n\t\t\trootFragment = new ElementSourceFragment(this, null);\n\t\t\trootFragment.addTreeOfSourceFragmentsOfElement(this);\n\t\t}\n\t\treturn rootFragment;\n\t}\n\n\t@Override\n\tpublic int[] getLineSeparatorPositions() {\n\t\treturn lineSeparatorPositions;\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl setLineSeparatorPositions(int[] lineSeparatorPositions) {\n\t\tthis.lineSeparatorPositions = lineSeparatorPositions;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic SourcePosition getPosition() {\n\t\tif (position == SourcePosition.NOPOSITION) {\n\t\t\tString sourceCode = getOriginalSourceCode();\n\t\t\tif (sourceCode != null) {\n\t\t\t\tposition = getFactory().Core().createSourcePosition((CompilationUnit) this, 0, sourceCode.length() - 1, getLineSeparatorPositions());\n\t\t\t} else {\n\t\t\t\t//it is a virtual compilation unit (e.g. for Snippet)\n\t\t\t\tposition = getFactory().Core().createSourcePosition((CompilationUnit) this, 0, Integer.MAX_VALUE - 1, getLineSeparatorPositions());\n\t\t\t}\n\t\t}\n\t\treturn position;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E setPosition(SourcePosition position) {\n\t\treturn (E) this;\n\t}\n\n\t/**\n\t * @return a {@link SourcePosition} which points to this {@link CompilationUnit}. It always returns same value to safe memory.\n\t */\n\tpublic SourcePosition getOrCreatePartialSourcePosition() {\n\t\tif (myPartialSourcePosition == null) {\n\t\t\tmyPartialSourcePosition = new PartialSourcePositionImpl((CompilationUnit) this);\n\t\t}\n\t\treturn myPartialSourcePosition;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtCompilationUnit(this);\n\t}\n\n\t@Override\n\tpublic CtCompilationUnitImpl clone() {\n\t\treturn (CtCompilationUnitImpl) super.clone();\n\t}\n\n\t@Override\n\tpublic CtElement getParent() throws ParentNotInitializedException {\n\t\treturn null;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <E extends CtElement> E setParent(E parent) {\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.file.getName();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtConstructorImpl.java",
      "weight" : 183.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport static spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY;\n\npublic class CtConstructorImpl<T> extends CtExecutableImpl<T> implements CtConstructor<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE_PARAMETER)\n\tList<CtTypeParameter> formalCtTypeParameters = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtConstructor(this);\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtNamedElement> C setSimpleName(String simpleName) {\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic String getSimpleName() {\n\t\treturn CtExecutableReference.CONSTRUCTOR_NAME;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtType<T> getDeclaringType() {\n\t\treturn (CtType<T>) parent;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<T> getType() {\n\t\tif (getDeclaringType() == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getDeclaringType().getReference();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\t// unsettable property\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn formalCtTypeParameters;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\tif (formalTypeParameters == null || formalTypeParameters.isEmpty()) {\n\t\t\tthis.formalCtTypeParameters = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tthis.formalCtTypeParameters = new ArrayList<>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.TYPE_PARAMETER, this.formalCtTypeParameters, new ArrayList<>(this.formalCtTypeParameters));\n\t\tthis.formalCtTypeParameters.clear();\n\t\tfor (CtTypeParameter formalTypeParameter : formalTypeParameters) {\n\t\t\taddFormalCtTypeParameter(formalTypeParameter);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C addFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (formalTypeParameter == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.TYPE_PARAMETER, this.formalCtTypeParameters, formalTypeParameter);\n\t\tif (formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tformalCtTypeParameters = new ArrayList<>(TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tformalTypeParameter.setParent(this);\n\t\tformalCtTypeParameters.add(formalTypeParameter);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (!formalCtTypeParameters.contains(formalTypeParameter)) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.TYPE_PARAMETER, formalCtTypeParameters, formalCtTypeParameters.indexOf(formalTypeParameter), formalTypeParameter);\n\t\treturn formalCtTypeParameters.remove(formalTypeParameter);\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\treturn modifierHandler.getVisibility();\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (T) this;\n\t}\n\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtConstructor<T> clone() {\n\t\treturn (CtConstructor<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtTypeImpl.java",
      "weight" : 839.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.SpoonException;\nimport spoon.refactoring.Refactoring;\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.reflect.visitor.Query;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.filter.AllTypeMembersFunction;\nimport spoon.reflect.visitor.filter.NamedElementFilter;\nimport spoon.reflect.visitor.filter.ReferenceTypeFilter;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.comparator.CtLineElementComparator;\nimport spoon.support.compiler.SnippetCompilationHelper;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\nimport spoon.support.util.QualifiedNameBasedSortedSet;\nimport spoon.support.util.SignatureBasedSortedSet;\nimport spoon.support.visitor.ClassTypingContext;\n\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtType}.\n */\npublic abstract class CtTypeImpl<T> extends CtNamedElementImpl implements CtType<T> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE_PARAMETER)\n\tList<CtTypeParameter> formalCtTypeParameters = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.INTERFACE)\n\tSet<CtTypeReference<?>> interfaces = emptySet();\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\t@MetamodelPropertyField(role = {CtRole.TYPE_MEMBER, CtRole.FIELD, CtRole.CONSTRUCTOR, CtRole.ANNONYMOUS_EXECUTABLE, CtRole.METHOD, CtRole.NESTED_TYPE})\n\tList<CtTypeMember> typeMembers = emptyList();\n\n\tpublic CtTypeImpl() {\n\t}\n\n\t@Override\n\tpublic List<CtTypeMember> getTypeMembers() {\n\t\treturn Collections.unmodifiableList(typeMembers);\n\t}\n\n\t/** Adds a type member.\n\t * If it has a position, adds it at the right place according to the position (sourceStart).\n\t * If it is implicit, adds it at the beginning.\n\t * Otherwise, adds it at the end.\n\t */\n\t@Override\n\tpublic <C extends CtType<T>> C addTypeMember(CtTypeMember member) {\n\t\tif (member == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tComparator c = new CtLineElementComparator();\n\n\t\tif (member.isImplicit()) {\n\t\t\treturn addTypeMemberAt(0, member);\n\t\t}\n\n\t\t// by default, inserting at the end\n\t\tint insertionPosition = typeMembers.size();\n\n\t\t// we search for an insertion position only if this one has one position\n\t\tif (member.getPosition().isValidPosition()) {\n\t\t\tfor (int i = typeMembers.size() - 1; i >= 0; i--) {\n\t\t\t\tCtTypeMember m = this.typeMembers.get(i);\n\n\t\t\t\tif (m.isImplicit() || (m.getPosition().isValidPosition() && c.compare(member, m) > 0)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinsertionPosition--;\n\t\t\t}\n\t\t}\n\t\treturn addTypeMemberAt(insertionPosition, member);\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C addTypeMemberAt(int position, CtTypeMember member) {\n\t\tif (member == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.typeMembers == CtElementImpl.<CtTypeMember>emptyList()) {\n\t\t\tthis.typeMembers = new ArrayList<>();\n\t\t}\n\t\tif (!this.typeMembers.stream().anyMatch(m -> m == member)) {\n\t\t\tmember.setParent(this);\n\t\t\tCtRole role = CtRole.TYPE_MEMBER.getMatchingSubRoleFor(member);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, role, this.typeMembers, position, member);\n\t\t\tif (position < typeMembers.size()) {\n\t\t\t\tthis.typeMembers.add(position, member);\n\t\t\t} else {\n\t\t\t\tthis.typeMembers.add(member);\n\t\t\t}\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeTypeMember(CtTypeMember member) {\n\t\tCtRole role = CtRole.TYPE_MEMBER.getMatchingSubRoleFor(member);\n\t\tif (typeMembers.size() == 1) {\n\t\t\tif (typeMembers.contains(member)) {\n\t\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, role, this.typeMembers, this.typeMembers.indexOf(member), member);\n\t\t\t\ttypeMembers = emptyList();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (typeMembers.contains(member)) {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, role, this.typeMembers, this.typeMembers.indexOf(member), member);\n\t\t\treturn typeMembers.remove(member);\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setTypeMembers(List<CtTypeMember> members) {\n\t\tfor (CtTypeMember typeMember : new ArrayList<>(typeMembers)) {\n\t\t\tremoveTypeMember(typeMember);\n\t\t}\n\t\tif (members == null || members.isEmpty()) {\n\t\t\tthis.typeMembers = emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\ttypeMembers.clear();\n\t\tfor (CtTypeMember typeMember : members) {\n\t\t\taddTypeMember(typeMember);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <F, C extends CtType<T>> C addFieldAtTop(CtField<F> field) {\n\t\treturn addTypeMemberAt(0, field);\n\t}\n\n\t@Override\n\tpublic <F, C extends CtType<T>> C addField(CtField<F> field) {\n\t\treturn addTypeMember(field);\n\t}\n\n\t@Override\n\tpublic <F, C extends CtType<T>> C addField(int index, CtField<F> field) {\n\t\treturn addTypeMemberAt(index, field);\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setFields(List<CtField<?>> fields) {\n\t\tList<CtField<?>> oldFields = getFields();\n\t\tif (fields == null || fields.isEmpty()) {\n\t\t\tthis.typeMembers.removeAll(oldFields);\n\t\t\treturn (C) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.FIELD, this.typeMembers, new ArrayList<>(oldFields));\n\t\ttypeMembers.removeAll(oldFields);\n\t\tfor (CtField<?> field : fields) {\n\t\t\taddField(field);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <F> boolean removeField(CtField<F> field) {\n\t\treturn removeTypeMember(field);\n\t}\n\n\t@Override\n\tpublic CtField<?> getField(String name) {\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtField && ((CtField) typeMember).getSimpleName().equals(name)) {\n\t\t\t\treturn (CtField<?>) typeMember;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtFieldReference<?> getDeclaredField(String name) {\n\t\tCtField<?> field = getField(name);\n\t\treturn field != null ? getFactory().Field().createReference(field) : null;\n\t}\n\n\t@Override\n\tpublic CtFieldReference<?> getDeclaredOrInheritedField(String fieldName) {\n\t\tCtField<?> field = map(new AllTypeMembersFunction(CtField.class)).select(new NamedElementFilter<>(CtField.class, fieldName)).first();\n\t\treturn field == null ? null : field.getReference();\n\t}\n\n\n\t@Override\n\tpublic List<CtField<?>> getFields() {\n\t\tList<CtField<?>> fields = new ArrayList<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\tfields.add((CtField<?>) typeMember);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(fields);\n\t}\n\n\t@Override\n\tpublic <N, C extends CtType<T>> C addNestedType(CtType<N> nestedType) {\n\t\treturn addTypeMember(nestedType);\n\t}\n\n\t@Override\n\tpublic <N> boolean removeNestedType(CtType<N> nestedType) {\n\t\treturn removeTypeMember(nestedType);\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setNestedTypes(Set<CtType<?>> nestedTypes) {\n\t\tSet<CtType<?>> oldNestedTypes = getNestedTypes();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.NESTED_TYPE, typeMembers, oldNestedTypes);\n\t\tif (nestedTypes == null || nestedTypes.isEmpty()) {\n\t\t\tthis.typeMembers.removeAll(oldNestedTypes);\n\t\t\treturn (C) this;\n\t\t}\n\t\ttypeMembers.removeAll(oldNestedTypes);\n\t\tfor (CtType<?> nestedType : nestedTypes) {\n\t\t\taddNestedType(nestedType);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Set<CtTypeReference<?>> getUsedTypes(boolean includeSamePackage) {\n\t\tSet<CtTypeReference<?>> typeRefs = new QualifiedNameBasedSortedSet<>();\n\t\tfor (CtTypeReference<?> typeRef : Query.getReferences(this, new ReferenceTypeFilter<CtTypeReference<?>>(CtTypeReference.class))) {\n\t\t\tif (isValidTypeReference(typeRef) && shouldIncludeSamePackage(includeSamePackage, typeRef)) {\n\t\t\t\ttypeRefs.add(typeRef);\n\t\t\t}\n\t\t}\n\t\treturn typeRefs;\n\t}\n\n\tprivate boolean shouldIncludeSamePackage(boolean includeSamePackage, CtTypeReference<?> typeRef) {\n\t\treturn includeSamePackage || (getPackage() != null && !getPackageReference(typeRef).equals(getPackage().getReference()));\n\t}\n\n\tprivate boolean isValidTypeReference(CtTypeReference<?> typeRef) {\n\t\treturn !(isFromJavaLang(typeRef) || typeRef.isPrimitive() || typeRef instanceof CtArrayTypeReference || CtTypeReference.NULL_TYPE_NAME.equals(typeRef.toString()));\n\t}\n\n\tprivate boolean isFromJavaLang(CtTypeReference<?> typeRef) {\n\t\treturn typeRef.getPackage() != null && \"java.lang\".equals(typeRef.getPackage().toString());\n\t}\n\n\t/**\n\t * Return the package reference for the corresponding type reference. For\n\t * inner type, return the package reference of the top-most enclosing type.\n\t * This helper method is meant to deal with package references that are\n\t * <code>null</code> for inner types.\n\t *\n\t * @param tref the type reference\n\t * @return the corresponding package reference\n\t * @see CtTypeReference#getPackage()\n\t * @since 4.0\n\t */\n\tprivate static CtPackageReference getPackageReference(CtTypeReference<?> tref) {\n\t\tCtPackageReference pref = tref.getPackage();\n\t\twhile (pref == null) {\n\t\t\ttref = tref.getDeclaringType();\n\t\t\tpref = tref.getPackage();\n\t\t}\n\t\treturn pref;\n\t}\n\n\t@Override\n\tpublic Class<T> getActualClass() {\n\t\treturn getFactory().Type().createReference(this).getActualClass();\n\t}\n\n\t@Override\n\tpublic CtType<?> getDeclaringType() {\n\t\ttry {\n\t\t\treturn getParent(CtType.class);\n\t\t} catch (ParentNotInitializedException ex) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> CtType<T> getTopLevelType() {\n\t\tCtType<?> top = this;\n\n\t\twhile (true) {\n\t\t\tCtType<?> nextTop = top.getDeclaringType();\n\t\t\tif (nextTop == null) {\n\t\t\t\treturn (CtType<T>) top;\n\t\t\t}\n\t\t\ttop = nextTop;\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <N extends CtType<?>> N getNestedType(final String name) {\n\t\tclass NestedTypeScanner extends EarlyTerminatingScanner<CtType<?>> {\n\n\t\t\tprivate boolean checkType(CtType<?> type) {\n\t\t\t\tif (type.getSimpleName().equals(name) && CtTypeImpl.this.equals(type.getDeclaringType())) {\n\t\t\t\t\tsetResult(type);\n\t\t\t\t\tterminate();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <U> void visitCtClass(spoon.reflect.declaration.CtClass<U> ctClass) {\n\t\t\t\tif (!checkType(ctClass)) {\n\t\t\t\t\tfinal List<CtTypeMember> typeMembers = new ArrayList<>();\n\t\t\t\t\tfor (CtTypeMember typeMember : ctClass.getTypeMembers()) {\n\t\t\t\t\t\tif (typeMember instanceof CtType || typeMember instanceof CtConstructor || typeMember instanceof CtMethod) {\n\t\t\t\t\t\t\ttypeMembers.add(typeMember);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscan(typeMembers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <U> void visitCtInterface(spoon.reflect.declaration.CtInterface<U> intrface) {\n\t\t\t\tif (!checkType(intrface)) {\n\t\t\t\t\tfinal List<CtTypeMember> typeMembers = new ArrayList<>();\n\t\t\t\t\tfor (CtTypeMember typeMember : intrface.getTypeMembers()) {\n\t\t\t\t\t\tif (typeMember instanceof CtType || typeMember instanceof CtMethod) {\n\t\t\t\t\t\t\ttypeMembers.add(typeMember);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscan(typeMembers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <U extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<U> ctEnum) {\n\t\t\t\tif (!checkType(ctEnum)) {\n\t\t\t\t\tfinal List<CtTypeMember> typeMembers = new ArrayList<>();\n\t\t\t\t\tfor (CtTypeMember typeMember : ctEnum.getTypeMembers()) {\n\t\t\t\t\t\tif (typeMember instanceof CtType || typeMember instanceof CtConstructor || typeMember instanceof CtMethod) {\n\t\t\t\t\t\t\ttypeMembers.add(typeMember);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscan(typeMembers);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <A extends Annotation> void visitCtAnnotationType(CtAnnotationType<A> annotationType) {\n\t\t\t\tif (!checkType(annotationType)) {\n\t\t\t\t\tscan(annotationType.getNestedTypes());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tNestedTypeScanner scanner = new NestedTypeScanner();\n\t\tscanner.scan(this);\n\t\treturn (N) scanner.getResult();\n\t}\n\n\t@Override\n\tpublic Set<CtType<?>> getNestedTypes() {\n\t\tSet<CtType<?>> nestedTypes = new QualifiedNameBasedSortedSet<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtType) {\n\t\t\t\tnestedTypes.add((CtType<?>) typeMember);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableSet(nestedTypes);\n\t}\n\n\t@Override\n\tpublic CtPackage getPackage() {\n\t\tif (parent instanceof CtPackage) {\n\t\t\treturn (CtPackage) getParent();\n\t\t} else if (parent instanceof CtType) {\n\t\t\treturn ((CtType<?>) parent).getPackage();\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getReference() {\n\t\treturn getFactory().Type().createReference(this);\n\t}\n\n\t@Override\n\tpublic boolean isTopLevel() {\n\t\treturn (getDeclaringType() == null) && (getPackage() != null);\n\t}\n\n\t@Override\n\tpublic void compileAndReplaceSnippets() {\n\t\tSnippetCompilationHelper.compileAndReplaceSnippetsIn(this);\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\treturn modifierHandler.getVisibility();\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <T extends CtModifiable> T setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean isPrimitive() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isAnonymous() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isLocalType() {\n\t\treturn isParentInitialized() && getParent() instanceof CtBlock;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic CtTypeReference<?> getSuperclass() {\n\t\t// overridden in subclasses.\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isClass() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isInterface() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isAnnotationType() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isEnum() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isGenerics() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<CtFieldReference<?>> getAllFields() {\n\t\tfinal List<CtFieldReference<?>> fields = new ArrayList<>();\n\t\tmap(new AllTypeMembersFunction(CtField.class)).forEach(new CtConsumer<CtField<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtField<?> field) {\n\t\t\t\tfields.add(field.getReference());\n\t\t\t}\n\t\t});\n\t\treturn fields;\n\t}\n\n\t@Override\n\tpublic List<CtFieldReference<?>> getDeclaredFields() {\n\t\tif (typeMembers.isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tfinal List<CtFieldReference<?>> fields = new ArrayList<>(typeMembers.size());\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\tfields.add(((CtField) typeMember).getReference());\n\t\t\t}\n\t\t}\n\t\treturn fields;\n\t}\n\n\t@Override\n\tpublic <M, C extends CtType<T>> C addMethod(CtMethod<M> method) {\n\t\tif (method != null) {\n\t\t\tfor (CtTypeMember typeMember : new ArrayList<>(typeMembers)) {\n\t\t\t\tif (!(typeMember instanceof CtMethod)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tCtMethod<?> m = (CtMethod<?>) typeMember;\n\t\t\t\tif (m.getSignature().equals(method.getSignature())) {\n\t\t\t\t\t// replace old method by new one (based on signature and not equality)\n\t\t\t\t\t// we have to do it by hand\n\t\t\t\t\tremoveTypeMember(m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn addTypeMember(method);\n\t}\n\n\t@Override\n\tpublic <M> boolean removeMethod(CtMethod<M> method) {\n\t\treturn removeTypeMember(method);\n\t}\n\n\t@Override\n\tpublic <S, C extends CtType<T>> C addSuperInterface(CtTypeReference<S> interfac) {\n\t\tif (interfac == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (interfaces == CtElementImpl.<CtTypeReference<?>>emptySet()) {\n\t\t\tinterfaces = new QualifiedNameBasedSortedSet<>();\n\t\t}\n\t\tinterfac.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(this, CtRole.INTERFACE, this.interfaces, interfac);\n\t\tinterfaces.add(interfac);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <S> boolean removeSuperInterface(CtTypeReference<S> interfac) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDelete(this, CtRole.INTERFACE, interfaces, interfac);\n\t\tif (interfaces == CtElementImpl.<CtTypeReference<?>>emptySet()) {\n\t\t\treturn false;\n\t\t} else if (interfaces.size() == 1) {\n\t\t\tif (interfaces.contains(interfac)) {\n\t\t\t\tinterfaces = CtElementImpl.<CtTypeReference<?>>emptySet();\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t// contains() not needed. see comment in removeMethod()\n\t\t\treturn interfaces.contains(interfac) && interfaces.remove(interfac);\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn formalCtTypeParameters;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.TYPE_PARAMETER, formalCtTypeParameters, new ArrayList<>(formalCtTypeParameters));\n\t\tif (formalTypeParameters == null || formalTypeParameters.isEmpty()) {\n\t\t\tthis.formalCtTypeParameters = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tthis.formalCtTypeParameters = new ArrayList<>(ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tthis.formalCtTypeParameters.clear();\n\t\tfor (CtTypeParameter formalTypeParameter : formalTypeParameters) {\n\t\t\taddFormalCtTypeParameter(formalTypeParameter);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C addFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (formalTypeParameter == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tformalCtTypeParameters = new ArrayList<>(ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tformalTypeParameter.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.TYPE_PARAMETER, this.formalCtTypeParameters, formalTypeParameter);\n\t\tformalCtTypeParameters.add(formalTypeParameter);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.TYPE_PARAMETER, formalCtTypeParameters, formalCtTypeParameters.indexOf(formalTypeParameter), formalTypeParameter);\n\t\treturn formalCtTypeParameters.remove(formalTypeParameter);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <R> CtMethod<R> getMethod(CtTypeReference<R> returnType, String name, CtTypeReference<?>... parameterTypes) {\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (!(typeMember instanceof CtMethod)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCtMethod<R> m = (CtMethod<R>) typeMember;\n\t\t\tif (m.getSimpleName().equals(name)) {\n\t\t\t\tif (!m.getType().equals(returnType)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean cont = m.getParameters().size() == parameterTypes.length;\n\t\t\t\tfor (int i = 0; cont && (i < m.getParameters().size()) && (i < parameterTypes.length); i++) {\n\t\t\t\t\tif (!m.getParameters().get(i).getType().getQualifiedName().equals(parameterTypes[i].getQualifiedName())) {\n\t\t\t\t\t\tcont = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cont) {\n\t\t\t\t\treturn m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <R> CtMethod<R> getMethod(String name, CtTypeReference<?>... parameterTypes) {\n\t\tif (name == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (CtMethod<?> candidate : getMethodsByName(name)) {\n\t\t\tif (hasSameParameters(candidate, parameterTypes)) {\n\t\t\t\treturn (CtMethod<R>) candidate;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected boolean hasSameParameters(CtExecutable<?> candidate, CtTypeReference<?>... parameterTypes) {\n\t\tif (candidate.getParameters().size() != parameterTypes.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; (i < candidate.getParameters().size()) && (i < parameterTypes.length); i++) {\n\t\t\tfinal CtTypeReference<?> ctParameterType = candidate.getParameters().get(i).getType();\n\t\t\tfinal CtTypeReference<?> parameterType = parameterTypes[i];\n\t\t\tif (parameterType instanceof CtArrayTypeReference) {\n\t\t\t\tif (ctParameterType instanceof CtArrayTypeReference) {\n\t\t\t\t\tif (!isSameParameter(candidate, ((CtArrayTypeReference) ctParameterType).getComponentType(), ((CtArrayTypeReference) parameterType).getComponentType())) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((CtArrayTypeReference) ctParameterType).getDimensionCount() != ((CtArrayTypeReference) parameterType).getDimensionCount()) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (!isSameParameter(candidate, ctParameterType, parameterType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean isSameParameter(CtExecutable<?> candidate, CtTypeReference<?> ctParameterType, CtTypeReference<?> expectedType) {\n\t\treturn ctParameterType.getTypeErasure().getQualifiedName().equals(expectedType.getTypeErasure().getQualifiedName());\n\t}\n\n\t@Override\n\tpublic Set<CtMethod<?>> getMethods() {\n\t\tSet<CtMethod<?>> methods = new SignatureBasedSortedSet<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (typeMember instanceof CtMethod) {\n\t\t\t\tmethods.add((CtMethod<?>) typeMember);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableSet(methods);\n\t}\n\n\t@Override\n\tpublic Set<CtMethod<?>> getMethodsAnnotatedWith(CtTypeReference<?>... annotationTypes) {\n\t\tSet<CtMethod<?>> result = new SignatureBasedSortedSet<>();\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (!(typeMember instanceof CtMethod)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCtMethod<?> m = (CtMethod<?>) typeMember;\n\t\t\tfor (CtAnnotation<?> a : m.getAnnotations()) {\n\t\t\t\tif (Arrays.asList(annotationTypes).contains(a.getAnnotationType())) {\n\t\t\t\t\tresult.add(m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic List<CtMethod<?>> getMethodsByName(String name) {\n\t\tList<CtMethod<?>> result = new ArrayList<>(1);\n\t\tfor (CtTypeMember typeMember : typeMembers) {\n\t\t\tif (!(typeMember instanceof CtMethod)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCtMethod<?> m = (CtMethod<?>) typeMember;\n\t\t\tif (name.equals(m.getSimpleName())) {\n\t\t\t\tresult.add(m);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean hasMethod(CtMethod<?> method) {\n\t\tif (method == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal String over = method.getSignature();\n\t\tfor (CtMethod<?> m : getMethods()) {\n\t\t\tif (m.getSignature().equals(over)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Checking whether a super class has the method.\n\t\tfinal CtTypeReference<?> superCl = getSuperclass();\n\t\ttry {\n\t\t\tif (superCl != null && superCl.getTypeDeclaration().hasMethod(method)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (SpoonException ex) {\n\t\t\t// No matter, trying something else.\n\t\t}\n\n\t\t// Finally, checking whether an interface has the method.\n\t\tfor (CtTypeReference<?> interf : getSuperInterfaces()) {\n\t\t\ttry {\n\t\t\t\tif (interf.getTypeDeclaration().hasMethod(method)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} catch (SpoonException ex) {\n\t\t\t\t// No matter, trying something else.\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\tif (isTopLevel()) {\n\t\t\tif (getPackage() != null && !getPackage().isUnnamedPackage()) {\n\t\t\t\treturn getPackage().getQualifiedName() + \".\" + getSimpleName();\n\t\t\t} else {\n\t\t\t\treturn getSimpleName();\n\t\t\t}\n\t\t} else if (getDeclaringType() != null) {\n\t\t\treturn getDeclaringType().getQualifiedName() + INNERTTYPE_SEPARATOR + getSimpleName();\n\t\t} else {\n\t\t\treturn getSimpleName();\n\t\t}\n\t}\n\n\t@Override\n\tpublic Set<CtTypeReference<?>> getSuperInterfaces() {\n\t\treturn interfaces;\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setMethods(Set<CtMethod<?>> methods) {\n\t\tSet<CtMethod<?>> allMethods = getMethods();\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.METHOD, this.typeMembers, new ArrayList(allMethods));\n\t\ttypeMembers.removeAll(allMethods);\n\t\tif (methods == null || methods.isEmpty()) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tfor (CtMethod<?> meth : methods) {\n\t\t\taddMethod(meth);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtType<T>> C setSuperclass(CtTypeReference<?> superClass) {\n\t\t// overridden in subclasses.\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtType<T>> C setSuperInterfaces(Set<CtTypeReference<?>> interfaces) {\n\t\tif (interfaces == null || interfaces.isEmpty()) {\n\t\t\tthis.interfaces = CtElementImpl.emptySet();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.interfaces == CtElementImpl.<CtTypeReference<?>>emptySet()) {\n\t\t\tthis.interfaces = new QualifiedNameBasedSortedSet<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDeleteAll(this, CtRole.INTERFACE, this.interfaces, new HashSet<>(this.interfaces));\n\t\tthis.interfaces.clear();\n\t\tfor (CtTypeReference<?> anInterface : interfaces) {\n\t\t\taddSuperInterface(anInterface);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getDeclaredExecutables() {\n\t\tif (getMethods().isEmpty()) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<CtExecutableReference<?>> l = new ArrayList<>(getMethods().size());\n\t\tfor (CtExecutable<?> m : getMethods()) {\n\t\t\tl.add(m.getReference());\n\t\t}\n\t\treturn Collections.unmodifiableList(l);\n\t}\n\n\t@Override\n\tpublic Collection<CtExecutableReference<?>> getAllExecutables() {\n\t\tSet<CtExecutableReference<?>> l = new SignatureBasedSortedSet();\n\t\tfor (CtMethod<?> m : getAllMethods()) {\n\t\t\tl.add(m.getReference());\n\t\t}\n\t\treturn l;\n\t}\n\n\t@Override\n\tpublic Set<CtMethod<?>> getAllMethods() {\n\t\tfinal Set<CtMethod<?>> l = new HashSet<>();\n\t\tfinal ClassTypingContext ctc = new ClassTypingContext(this);\n\t\tmap(new AllTypeMembersFunction(CtMethod.class)).forEach(new CtConsumer<CtMethod<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtMethod<?> currentMethod) {\n\t\t\t\tfor (CtMethod<?> alreadyVisitedMethod : l) {\n\t\t\t\t\tif (ctc.isSameSignature(currentMethod, alreadyVisitedMethod)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tl.add(currentMethod);\n\t\t\t}\n\t\t});\n\t\treturn Collections.unmodifiableSet(l);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> getTypeErasure() {\n\t\treturn getReference();\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtType<T> clone() {\n\t\treturn (CtType<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n\n\t@Override\n\tpublic CtType<?> copyType() {\n\t\treturn Refactoring.copyType(this);\n\t}\n\n\t@Override\n\tpublic boolean isArray() {\n\t\treturn getSimpleName().contains(\"[\");\n\t}\n\n\t@Override\n\tpublic String toStringWithImports() {\n\t\tDefaultJavaPrettyPrinter printer = new DefaultJavaPrettyPrinter(getFactory().getEnvironment());\n\t\tprinter.getImportsContext().computeImports(this);\n\t\tprinter.writeHeader(Arrays.asList(new CtType[] {this}), printer.getImportsContext().getAllImports());\n\t\tthis.accept(printer);\n\t\treturn printer.toString();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtProvidedServiceImpl.java",
      "weight" : 71.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtProvidedService;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CtProvidedServiceImpl extends CtElementImpl implements CtProvidedService {\n\t@MetamodelPropertyField(role = CtRole.SERVICE_TYPE)\n\tprivate CtTypeReference serviceType;\n\n\t@MetamodelPropertyField(role = CtRole.IMPLEMENTATION_TYPE)\n\tprivate List<CtTypeReference> implementationTypes = CtElementImpl.emptyList();\n\n\tpublic CtProvidedServiceImpl() {\n\t}\n\n\t@Override\n\tpublic CtTypeReference getServiceType() {\n\t\treturn this.serviceType;\n\t}\n\n\t@Override\n\tpublic <T extends CtProvidedService> T setServiceType(CtTypeReference providingType) {\n\t\tif (providingType != null) {\n\t\t\tprovidingType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.SERVICE_TYPE, providingType, this.serviceType);\n\t\tthis.serviceType = providingType;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtTypeReference> getImplementationTypes() {\n\t\treturn Collections.unmodifiableList(this.implementationTypes);\n\t}\n\n\t@Override\n\tpublic <T extends CtProvidedService> T setImplementationTypes(List<CtTypeReference> usedTypes) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.IMPLEMENTATION_TYPE, this.implementationTypes, new ArrayList<>(this.implementationTypes));\n\t\tif (usedTypes == null || usedTypes.isEmpty()) {\n\t\t\tthis.implementationTypes = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tif (this.implementationTypes == CtElementImpl.<CtTypeReference>emptyList()) {\n\t\t\tthis.implementationTypes = new ArrayList<>();\n\t\t}\n\t\tthis.implementationTypes.clear();\n\t\tfor (CtTypeReference usedType : usedTypes) {\n\t\t\tthis.addImplementationType(usedType);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtProvidedService> T addImplementationType(CtTypeReference usedType) {\n\t\tif (usedType == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.implementationTypes == CtElementImpl.<CtTypeReference>emptyList()) {\n\t\t\tthis.implementationTypes = new ArrayList<>();\n\t\t}\n\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.IMPLEMENTATION_TYPE, this.implementationTypes, usedType);\n\t\tusedType.setParent(this);\n\t\tthis.implementationTypes.add(usedType);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtProvidedService(this);\n\t}\n\n\t@Override\n\tpublic CtProvidedService clone() {\n\t\treturn (CtProvidedService) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtAnnotationImpl.java",
      "weight" : 391.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.SpoonException;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtTypeAccess;\nimport spoon.reflect.declaration.CtAnnotatedElementType;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.DerivedProperty;\nimport spoon.support.UnsettableProperty;\nimport spoon.support.comparator.CtLineElementComparator;\nimport spoon.support.reflect.code.CtExpressionImpl;\nimport spoon.support.reflect.eval.EvalHelper;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtAnnotation}.\n *\n * @author Renaud Pawlak\n */\npublic class CtAnnotationImpl<A extends Annotation> extends CtExpressionImpl<A> implements CtAnnotation<A> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.ANNOTATION_TYPE)\n\tCtTypeReference<A> annotationType;\n\n\t@MetamodelPropertyField(role = CtRole.VALUE)\n\tprivate Map<String, CtExpression> elementValues = new TreeMap() {\n\t\t@Override\n\t\tpublic Set<Entry<String, CtExpression>> entrySet() {\n\t\t\tSet<Entry<String, CtExpression>> result = new TreeSet<>(new Comparator<Entry<String, CtExpression>>() {\n\t\t\t\tfinal CtLineElementComparator comp = new CtLineElementComparator();\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Entry<String, CtExpression> o1, Entry<String, CtExpression> o2) {\n\t\t\t\t\treturn comp.compare(o1.getValue(), o2.getValue());\n\t\t\t\t}\n\t\t\t}\n\t\t\t);\n\t\t\tresult.addAll(super.entrySet());\n\t\t\treturn result;\n\t\t}\n\t};\n\n\tpublic CtAnnotationImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtAnnotation(this);\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T addValue(String elementName, Object value) {\n\t\tif (value instanceof CtExpression) {\n\t\t\treturn addValueExpression(elementName, (CtExpression<?>) value);\n\t\t}\n\t\treturn this.addValueExpression(elementName, convertValueToExpression(value));\n\t}\n\n\tprivate CtExpression convertValueToExpression(Object value) {\n\t\tCtExpression res;\n\t\tif (value.getClass().isArray()) {\n\t\t\t// Value should be converted to a CtNewArray.\n\t\t\tres = getFactory().Core().createNewArray();\n\t\t\tObject[] values = (Object[]) value;\n\n\t\t\tres.setType(getFactory().Type().createArrayReference(getFactory().Type().createReference(value.getClass().getComponentType())));\n\t\t\tfor (Object o : values) {\n\t\t\t\t((CtNewArray) res).addElement(convertValueToExpression(o));\n\t\t\t}\n\t\t} else if (value instanceof Collection) {\n\t\t\t// Value should be converted to a CtNewArray.\n\t\t\tres = getFactory().Core().createNewArray();\n\t\t\tCollection values = (Collection) value;\n\t\t\tres.setType(getFactory().Type().createArrayReference(getFactory().Type().createReference(values.toArray()[0].getClass())));\n\t\t\tfor (Object o : values) {\n\t\t\t\t((CtNewArray) res).addElement(convertValueToExpression(o));\n\t\t\t}\n\t\t} else if (value instanceof Class) {\n\t\t\t// Value should be a field access to a .class.\n\t\t\tres = getFactory().Code().createClassAccess(getFactory().Type().createReference((Class) value));\n\t\t} else if (value instanceof Field) {\n\t\t\t// Value should be a field access to a field.\n\t\t\tCtFieldReference<Object> variable = getFactory().Field().createReference((Field) value);\n\t\t\tvariable.setStatic(true);\n\t\t\tCtTypeAccess target = getFactory().Code().createTypeAccess(getFactory().Type().createReference(((Field) value).getDeclaringClass()));\n\t\t\tCtFieldRead fieldRead = getFactory().Core().createFieldRead();\n\t\t\tfieldRead.setVariable(variable);\n\t\t\tfieldRead.setTarget(target);\n\t\t\tfieldRead.setType(target.getAccessedType());\n\t\t\tres = fieldRead;\n\t\t} else if (isPrimitive(value.getClass()) || value instanceof String) {\n\t\t\t// Value should be a literal.\n\t\t\tres = getFactory().Code().createLiteral(value);\n\t\t} else if (value.getClass().isEnum()) {\n\t\t\tfinal CtTypeReference declaringClass = getFactory().Type().createReference(((Enum) value).getDeclaringClass());\n\t\t\tfinal CtFieldReference variableRef = getFactory().Field().createReference(declaringClass, declaringClass, ((Enum) value).name());\n\t\t\tCtTypeAccess target = getFactory().Code().createTypeAccess(declaringClass);\n\t\t\tCtFieldRead fieldRead = getFactory().Core().createFieldRead();\n\t\t\tfieldRead.setVariable(variableRef);\n\t\t\tfieldRead.setTarget(target);\n\t\t\tfieldRead.setType(declaringClass);\n\t\t\tres = fieldRead;\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Please, submit a valid value.\");\n\t\t}\n\t\treturn res;\n\t}\n\n\tprivate boolean isPrimitive(Class c) {\n\t\treturn c.isPrimitive() || c == Byte.class || c == Short.class || c == Integer.class || c == Long.class || c == Float.class || c == Double.class || c == Boolean.class || c == Character.class;\n\t}\n\n\tprivate <T extends CtAnnotation<A>> T addValueExpression(String elementName, CtExpression<?> expression) {\n\t\tif (elementValues.containsKey(elementName)) {\n\t\t\t// Update value of the existing one.\n\t\t\tfinal CtExpression ctExpression = elementValues.get(elementName);\n\t\t\tif (ctExpression instanceof CtNewArray) {\n\t\t\t\t// Already an array, add the value inside it.\n\t\t\t\tif (expression instanceof CtNewArray) {\n\t\t\t\t\tList<CtExpression<?>> elements = ((CtNewArray) expression).getElements();\n\t\t\t\t\tfor (CtExpression expInArray : elements) {\n\t\t\t\t\t\t((CtNewArray) ctExpression).addElement(expInArray);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t((CtNewArray) ctExpression).addElement(expression);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Switch the value to a CtNewArray.\n\t\t\t\tCtNewArray<Object> newArray = getFactory().Core().createNewArray();\n\t\t\t\tnewArray.setType(ctExpression.getType());\n\t\t\t\tnewArray.setParent(this);\n\t\t\t\tnewArray.addElement(ctExpression);\n\t\t\t\tnewArray.addElement(expression);\n\t\t\t\telementValues.put(elementName, newArray);\n\t\t\t}\n\t\t} else {\n\t\t\t// Add the new value.\n\t\t\texpression.setParent(this);\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onMapAdd(this, CtRole.VALUE, this.elementValues, elementName, expression);\n\t\t\telementValues.put(elementName, expression);\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T addValue(String elementName, CtLiteral<?> value) {\n\t\treturn addValueExpression(elementName, value);\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T addValue(String elementName, CtNewArray<? extends CtExpression> value) {\n\t\treturn addValueExpression(elementName, value);\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T addValue(String elementName, CtFieldAccess<?> value) {\n\t\treturn addValueExpression(elementName, value);\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T addValue(String elementName, CtAnnotation<?> value) {\n\t\treturn addValueExpression(elementName, value);\n\t}\n\n\tprivate Class<?> getElementType(String name) {\n\t\t// Try by CT reflection\n\t\tCtType<?> t = getAnnotationType().getDeclaration();\n\t\tif (t != null) {\n\t\t\tCtMethod<?> method = t.getMethod(name);\n\t\t\treturn method.getType().getActualClass();\n\t\t}\n\t\t// Try with RT reflection\n\t\tClass<?> c = getAnnotationType().getActualClass();\n\t\tfor (Method m : c.getMethods()) {\n\t\t\tif (m.getName().equals(name)) {\n\t\t\t\treturn m.getReturnType();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic CtTypeReference<A> getAnnotationType() {\n\t\treturn annotationType;\n\t}\n\n\tprivate CtExpression getDefaultExpression(String fieldName) {\n\t\tCtExpression ret = null;\n\t\tCtAnnotationType<?> at = (CtAnnotationType<?>) getAnnotationType().getDeclaration();\n\t\tif (at != null) {\n\t\t\tCtAnnotationMethod<?> f = (CtAnnotationMethod) at.getMethod(fieldName);\n\t\t\tret = f.getDefaultExpression();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends CtExpression> T getValue(String key) {\n\t\treturn (T) getValueAsExpression(key);\n\t}\n\n\t@Override\n\tpublic int getValueAsInt(String key) {\n\t\tObject val = getValueAsObject(key);\n\t\tif (val == null) {\n\t\t\tthrow new IllegalStateException(key + \" not in the annotation\");\n\t\t}\n\t\treturn (int) val;\n\t}\n\n\t@Override\n\tpublic String getValueAsString(String key) {\n\t\treturn (String) getValueAsObject(key);\n\t}\n\n\t@Override\n\tpublic Object getValueAsObject(String key) {\n\t\tCtExpression expr = getWrappedValue(key);\n\n\t\t// no such value, per the contract of the method\n\t\tif (expr == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tObject ret = EvalHelper.convertElementToRuntimeObject(expr);\n\t\tClass<?> type = getElementType(key);\n\t\treturn forceObjectToType(ret, type);\n\t}\n\n\tprivate Object forceObjectToType(Object ret, Class<?> type) {\n\t\tif (type.isPrimitive()) {\n\t\t\tif ((type == boolean.class) && (ret.getClass() != boolean.class)) {\n\t\t\t\treturn Boolean.parseBoolean(ret.toString());\n\t\t\t} else if ((type == byte.class) && (ret.getClass() != byte.class)) {\n\t\t\t\treturn Byte.parseByte(ret.toString());\n\t\t\t} else if ((type == char.class) && (ret.getClass() != char.class)) {\n\t\t\t\treturn ret.toString().charAt(0);\n\t\t\t} else if ((type == double.class) && (ret.getClass() != double.class)) {\n\t\t\t\treturn Double.parseDouble(ret.toString());\n\t\t\t} else if ((type == float.class) && (ret.getClass() != float.class)) {\n\t\t\t\treturn Float.parseFloat(ret.toString());\n\t\t\t} else if ((type == int.class) && (ret.getClass() != int.class)) {\n\t\t\t\treturn Integer.parseInt(ret.toString());\n\t\t\t} else if ((type == long.class) && (ret.getClass() != long.class)) {\n\t\t\t\treturn Long.parseLong(ret.toString());\n\t\t\t} else if (type == short.class && ret.getClass() != short.class) {\n\t\t\t\treturn Short.parseShort(ret.toString());\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\n\tprivate CtExpression getValueAsExpression(String key) {\n\n\t\t// get specified field in annotation directly\n\t\tCtExpression ret = this.elementValues.get(key);\n\t\tif (ret != null) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t// get default value in annotation declaration in source code\n\t\tret = getDefaultExpression(key);\n\t\tif (ret != null) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t// get default value in annotation declaration in classpath\n\t\tObject value = getReflectValue(key);\n\t\tif (value != null) {\n\t\t\treturn convertValueToExpression(value);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <T extends CtExpression> T getWrappedValue(String key) {\n\t\tCtExpression ctExpression = this.getValue(key);\n\n\t\t\tCtTypeReference typeReference = this.getAnnotationType();\n\t\t\tCtType type = typeReference.getTypeDeclaration();\n\t\t\tif (type != null) {\n\t\t\t\tCtMethod method = type.getMethod(key);\n\t\t\t\tif (method != null) {\n\t\t\t\t\tCtTypeReference returnType = method.getType();\n\t\t\t\t\tif (returnType instanceof CtArrayTypeReference && !(ctExpression instanceof CtNewArray)) {\n\t\t\t\t\t\tCtNewArray newArray = getFactory().Core().createNewArray();\n\t\t\t\t\t\tCtArrayTypeReference typeReference2 = this.getFactory().createArrayTypeReference();\n\t\t\t\t\t\ttypeReference2.setComponentType(ctExpression.getType().clone());\n\t\t\t\t\t\tnewArray.setType(typeReference2);\n\t\t\t\t\t\tnewArray.addElement(ctExpression.clone());\n\t\t\t\t\t\treturn (T) newArray;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn (T) ctExpression;\n\t}\n\n\tpublic Map<String, Object> getElementValues() {\n\t\tMap<String, Object> res = new TreeMap<>();\n\t\tfor (Entry<String, CtExpression> elementValue : elementValues.entrySet()) {\n\t\t\tres.put(elementValue.getKey(), elementValue.getValue());\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic Map<String, CtExpression> getValues() {\n\t\treturn Collections.unmodifiableMap(elementValues);\n\t}\n\n\t@Override\n\tpublic Map<String, CtExpression> getAllValues() {\n\t\tMap<String, CtExpression> values = new TreeMap();\n\t\t// first, we put the default values\n\t\tCtAnnotationType<?> annotationType = (CtAnnotationType) getAnnotationType().getTypeDeclaration();\n\t\tfor (CtAnnotationMethod m : annotationType.getAnnotationMethods()) {\n\t\t\tvalues.put(m.getSimpleName(), m.getDefaultExpression());\n\t\t}\n\n\t\t// we override the values with ones of this expression\n\t\tvalues.putAll(elementValues);\n\t\treturn Collections.unmodifiableMap(values);\n\t}\n\n\tprivate Object getReflectValue(String fieldname) {\n\t\ttry {\n\t\t\tClass<?> c = getAnnotationType().getActualClass();\n\t\t\tMethod m = c.getMethod(fieldname);\n\t\t\treturn m.getDefaultValue();\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends CtAnnotation<A>> T setAnnotationType(CtTypeReference<? extends Annotation> annotationType) {\n\t\tif (annotationType != null) {\n\t\t\tannotationType.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, annotationType, this.annotationType);\n\t\tthis.annotationType = (CtTypeReference<A>) annotationType;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T setElementValues(Map<String, Object> values) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onMapDeleteAll(this, CtRole.VALUE, this.elementValues, new HashMap<>(elementValues));\n\t\tthis.elementValues.clear();\n\t\tfor (Entry<String, Object> e : values.entrySet()) {\n\t\t\taddValue(e.getKey(), e.getValue());\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtAnnotation<A>> T setValues(Map<String, CtExpression> values) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onMapDeleteAll(this, CtRole.VALUE, this.elementValues, new HashMap<>(elementValues));\n\t\tthis.elementValues.clear();\n\t\tfor (Entry<String, CtExpression> e : values.entrySet()) {\n\t\t\taddValue(e.getKey(), e.getValue());\n\t\t}\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtElement getAnnotatedElement() {\n\t\treturn this.getParent();\n\t}\n\n\t@Override\n\tpublic CtAnnotatedElementType getAnnotatedElementType() {\n\t\tCtElement annotatedElement = this.getAnnotatedElement();\n\n\t\treturn CtAnnotation.getAnnotatedElementTypeForCtElement(annotatedElement);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic A getActualAnnotation() {\n\t\tclass AnnotationInvocationHandler implements InvocationHandler {\n\t\t\tCtAnnotation<? extends Annotation> annotation;\n\n\t\t\tAnnotationInvocationHandler(CtAnnotation<? extends Annotation> annotation) {\n\t\t\t\tthis.annotation = annotation;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) {\n\t\t\t\tString fieldname = method.getName();\n\t\t\t\tif (\"toString\".equals(fieldname)) {\n\t\t\t\t\treturn CtAnnotationImpl.this.toString();\n\t\t\t\t} else if (\"annotationType\".equals(fieldname)) {\n\t\t\t\t\treturn annotation.getAnnotationType().getActualClass();\n\t\t\t\t}\n\t\t\t\treturn getValueAsObject(fieldname);\n\t\t\t}\n\t\t}\n\t\treturn (A) Proxy.newProxyInstance(annotationType.getActualClass().getClassLoader(), new Class[] { annotationType.getActualClass() }, new AnnotationInvocationHandler(this));\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtAnnotation<A> clone() {\n\t\treturn (CtAnnotation<A>) super.clone();\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic List<CtTypeReference<?>> getTypeCasts() {\n\t\treturn emptyList();\n\t}\n\n\t@Override\n\t@UnsettableProperty\n\tpublic <C extends CtExpression<A>> C setTypeCasts(List<CtTypeReference<?>> casts) {\n\t\treturn (C) this;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtPackageImpl.java",
      "weight" : 197.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.cu.position.NoSourcePosition;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.support.comparator.QualifiedNameComparator;\nimport spoon.support.util.ModelSet;\n\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtPackage}.\n *\n * @author Renaud Pawlak\n */\npublic class CtPackageImpl extends CtNamedElementImpl implements CtPackage {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.SUB_PACKAGE)\n\tprotected ModelSet<CtPackage> packs = new ModelSet<CtPackage>(QualifiedNameComparator.INSTANCE) {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtPackageImpl.this;\n\t\t}\n\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.SUB_PACKAGE;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean add(CtPackage pack) {\n\t\t\tif (pack == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// they are the same\n\t\t\tif (CtPackageImpl.this.getQualifiedName().equals(pack.getQualifiedName())) {\n\t\t\t\taddAllTypes(pack, CtPackageImpl.this);\n\t\t\t\taddAllPackages(pack, CtPackageImpl.this);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// it already exists\n\t\t\tfor (CtPackage p1 : packs) {\n\t\t\t\tif (p1.getQualifiedName().equals(pack.getQualifiedName())) {\n\t\t\t\t\taddAllTypes(pack, p1);\n\t\t\t\t\taddAllPackages(pack, p1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn super.add(pack);\n\t\t}\n\t};\n\n\t@MetamodelPropertyField(role = CtRole.CONTAINED_TYPE)\n\tprivate ModelSet<CtType<?>> types = new ModelSet<CtType<?>>(QualifiedNameComparator.INSTANCE) {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t@Override\n\t\tprotected CtElement getOwner() {\n\t\t\treturn CtPackageImpl.this;\n\t\t}\n\t\t@Override\n\t\tprotected CtRole getRole() {\n\t\t\treturn CtRole.CONTAINED_TYPE;\n\t\t}\n\t};\n\n\tpublic CtPackageImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtPackage(this);\n\t}\n\n\t@Override\n\tpublic <T extends CtPackage> T addPackage(CtPackage pack) {\n\t\tthis.packs.add(pack);\n\t\treturn (T) this;\n\t}\n\n\t/** add all types of \"from\" in \"to\" */\n\tprivate void addAllTypes(CtPackage from, CtPackage to) {\n\t\tfor (CtType t : from.getTypes()) {\n\t\t\tfor (CtType t2: to.getTypes()) {\n\t\t\t\tif (t2.getQualifiedName().equals(t.getQualifiedName()) && !t2.equals(t)) {\n\t\t\t\t\tthrow new IllegalStateException(\"types with same qualified names and different code cannot be merged\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tto.addType(t);\n\t\t}\n\t}\n\n\t/** add all packages of \"from\" in \"to\" */\n\tprivate void addAllPackages(CtPackage from, CtPackage to) {\n\t\tfor (CtPackage p : from.getPackages()) {\n\t\t\tto.addPackage(p);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean removePackage(CtPackage pack) {\n\t\treturn packs.remove(pack);\n\t}\n\n\t@Override\n\tpublic CtModule getDeclaringModule() {\n\t\ttry {\n\t\t\treturn getParent(CtModule.class);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtPackage getDeclaringPackage() {\n\t\ttry {\n\t\t\treturn getParent(CtPackage.class);\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtPackage getPackage(String name) {\n\t\tfor (CtPackage p : packs) {\n\t\t\tif (p.getSimpleName().equals(name)) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtPackage> getPackages() {\n\t\treturn packs;\n\t}\n\n\t@Override\n\tpublic String getQualifiedName() {\n\t\tif (getDeclaringPackage() == null || getDeclaringPackage().isUnnamedPackage()) {\n\t\t\treturn getSimpleName();\n\t\t} else {\n\t\t\treturn getDeclaringPackage().getQualifiedName() + \".\" + getSimpleName();\n\t\t}\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T extends CtType<?>> T getType(String simpleName) {\n\t\tfor (CtType<?> t : types) {\n\t\t\tif (t.getSimpleName().equals(simpleName)) {\n\t\t\t\treturn (T) t;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Set<CtType<?>> getTypes() {\n\t\treturn types;\n\t}\n\n\t@Override\n\tpublic <T extends CtPackage> T setPackages(Set<CtPackage> packs) {\n\t\tthis.packs.set(packs);\n\t\t\treturn (T) this;\n\t\t}\n\n\t@Override\n\tpublic <T extends CtPackage> T setTypes(Set<CtType<?>> types) {\n\t\tthis.types.set(types);\n\t\t\treturn (T) this;\n\t\t}\n\n\t@Override\n\tpublic CtPackageReference getReference() {\n\t\treturn getFactory().Package().createReference(this);\n\t}\n\n\t@Override\n\tpublic <T extends CtPackage> T addType(CtType<?> type) {\n\t\ttypes.add(type);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void removeType(CtType<?> type) {\n\t\ttypes.remove(type);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getQualifiedName();\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtPackage clone() {\n\t\treturn (CtPackage) super.clone();\n\t}\n\n\t@Override\n\tpublic boolean isUnnamedPackage() {\n\t\treturn TOP_LEVEL_PACKAGE_NAME.equals(getSimpleName());\n\t}\n\n\t@Override\n\tpublic boolean hasPackageInfo() {\n\t\treturn !(getPosition() instanceof NoSourcePosition);\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn getPackages().isEmpty() && getTypes().isEmpty();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtPackageExportImpl.java",
      "weight" : 84.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtPackageExport;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CtPackageExportImpl extends CtElementImpl implements CtPackageExport {\n\t@MetamodelPropertyField(role = CtRole.PACKAGE_REF)\n\tprivate CtPackageReference packageReference;\n\n\t@MetamodelPropertyField(role = CtRole.MODULE_REF)\n\tprivate List<CtModuleReference> targets = CtElementImpl.emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.OPENED_PACKAGE)\n\tprivate boolean isOpen;\n\n\tpublic CtPackageExportImpl() {\n\t}\n\n\t@Override\n\tpublic <T extends CtPackageExport> T setOpenedPackage(boolean openedPackage) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.OPENED_PACKAGE, openedPackage, this.isOpen);\n\t\tthis.isOpen = openedPackage;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic boolean isOpenedPackage() {\n\t\treturn this.isOpen;\n\t}\n\n\t@Override\n\tpublic CtPackageReference getPackageReference() {\n\t\treturn this.packageReference;\n\t}\n\n\t@Override\n\tpublic <T extends CtPackageExport> T setPackageReference(CtPackageReference packageReference) {\n\t\tif (packageReference != null) {\n\t\t\tpackageReference.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.PACKAGE_REF, packageReference, this.packageReference);\n\t\tthis.packageReference = packageReference;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic List<CtModuleReference> getTargetExport() {\n\t\treturn Collections.unmodifiableList(targets);\n\t}\n\n\t@Override\n\tpublic <T extends CtPackageExport> T setTargetExport(List<CtModuleReference> targetExports) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.MODULE_REF, this.targets, new ArrayList<>(this.targets));\n\t\tif (targetExports == null || targetExports.isEmpty()) {\n\t\t\tthis.targets = CtElementImpl.emptyList();\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tif (this.targets == CtElementImpl.<CtModuleReference>emptyList()) {\n\t\t\tthis.targets = new ArrayList<>();\n\t\t}\n\t\tthis.targets.clear();\n\t\tfor (CtModuleReference targetExport : targetExports) {\n\t\t\tthis.addTargetExport(targetExport);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic <T extends CtPackageExport> T addTargetExport(CtModuleReference targetExport) {\n\t\tif (targetExport == null) {\n\t\t\treturn (T) this;\n\t\t}\n\t\tif (this.targets == CtElementImpl.<CtModuleReference>emptyList()) {\n\t\t\tthis.targets = new ArrayList<>();\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.MODULE_REF, this.targets, targetExport);\n\t\ttargetExport.setParent(this);\n\t\tthis.targets.add(targetExport);\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtPackageExport(this);\n\t}\n\n\t@Override\n\tpublic CtPackageExport clone() {\n\t\treturn (CtPackageExport) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtModuleRequirementImpl.java",
      "weight" : 58.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtModuleRequirement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtModuleReference;\nimport spoon.reflect.visitor.CtVisitor;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class CtModuleRequirementImpl extends CtElementImpl implements CtModuleRequirement {\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate Set<RequiresModifier> requiresModifiers = CtElementImpl.emptySet();\n\n\t@MetamodelPropertyField(role = CtRole.MODULE_REF)\n\tprivate CtModuleReference moduleReference;\n\n\tpublic CtModuleRequirementImpl() {\n\t}\n\n\t@Override\n\tpublic Set<RequiresModifier> getRequiresModifiers() {\n\t\treturn this.requiresModifiers;\n\t}\n\n\t@Override\n\tpublic <T extends CtModuleRequirement> T setRequiresModifiers(Set<RequiresModifier> requiresModifiers) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onSetDeleteAll(this, CtRole.MODIFIER, this.requiresModifiers, new HashSet<>(requiresModifiers));\n\t\tif (requiresModifiers == null || requiresModifiers.isEmpty()) {\n\t\t\tthis.requiresModifiers = CtElementImpl.emptySet();\n\t\t\treturn (T) this;\n\t\t}\n\n\t\tif (this.requiresModifiers == CtElementImpl.<RequiresModifier>emptySet()) {\n\t\t\tthis.requiresModifiers = new HashSet<>();\n\t\t}\n\t\tthis.requiresModifiers.clear();\n\t\tfor (RequiresModifier requiresModifier : requiresModifiers) {\n\t\t\tgetFactory().getEnvironment().getModelChangeListener().onSetAdd(this, CtRole.MODIFIER, this.requiresModifiers, requiresModifier);\n\t\t\tthis.requiresModifiers.add(requiresModifier);\n\t\t}\n\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic CtModuleReference getModuleReference() {\n\t\treturn this.moduleReference;\n\t}\n\n\t@Override\n\tpublic <T extends CtModuleRequirement> T setModuleReference(CtModuleReference moduleReference) {\n\t\tif (moduleReference != null) {\n\t\t\tmoduleReference.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.MODULE_REF, moduleReference, this.moduleReference);\n\t\tthis.moduleReference = moduleReference;\n\t\treturn (T) this;\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor visitor) {\n\t\tvisitor.visitCtModuleRequirement(this);\n\t}\n\n\t@Override\n\tpublic CtModuleRequirement clone() {\n\t\treturn (CtModuleRequirement) super.clone();\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtElementImpl.java",
      "weight" : 528.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport org.apache.log4j.Logger;\nimport spoon.Launcher;\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.cu.SourcePosition;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.ParentNotInitializedException;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.reflect.meta.RoleHandler;\nimport spoon.reflect.meta.impl.RoleHandlerHelper;\nimport spoon.reflect.path.CtElementPathBuilder;\nimport spoon.reflect.path.CtPath;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtIterator;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.reflect.visitor.DefaultJavaPrettyPrinter;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.ModelConsistencyChecker;\nimport spoon.reflect.visitor.Query;\nimport spoon.reflect.visitor.chain.CtConsumableFunction;\nimport spoon.reflect.visitor.chain.CtFunction;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.filter.AnnotationFilter;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.DerivedProperty;\nimport spoon.support.StandardEnvironment;\nimport spoon.support.sniper.internal.ElementSourceFragment;\nimport spoon.support.util.EmptyClearableList;\nimport spoon.support.util.EmptyClearableSet;\nimport spoon.support.visitor.HashcodeVisitor;\nimport spoon.support.visitor.TypeReferenceScanner;\nimport spoon.support.visitor.equals.CloneHelper;\nimport spoon.support.visitor.equals.EqualsVisitor;\nimport spoon.support.visitor.replace.ReplacementVisitor;\n\nimport java.io.Serializable;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static spoon.reflect.visitor.CommentHelper.printComment;\n\n/**\n * Contains the default implementation of most CtElement methods.\n *\n */\npublic abstract class CtElementImpl implements CtElement, Serializable {\n\tprivate static final long serialVersionUID = 1L;\n\tprotected static final Logger LOGGER = Logger.getLogger(CtElementImpl.class);\n\tpublic static final String ERROR_MESSAGE_TO_STRING = \"Error in printing the node. One parent isn't initialized!\";\n\tprivate static final Factory DEFAULT_FACTORY = new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\n\n\n\tpublic static <T> List<T> emptyList() {\n\t\treturn EmptyClearableList.instance();\n\t}\n\n\tpublic static <T> Set<T> emptySet() {\n\t\treturn EmptyClearableSet.instance();\n\t}\n\n\tpublic static <T> List<T> unmodifiableList(List<T> list) {\n\t\treturn list.isEmpty() ? Collections.<T>emptyList() : Collections.unmodifiableList(list);\n\t}\n\n\tFactory factory;\n\n\tprotected CtElement parent;\n\n\t@MetamodelPropertyField(role = CtRole.ANNOTATION)\n\tList<CtAnnotation<? extends Annotation>> annotations = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.COMMENT)\n\tprivate List<CtComment> comments = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.POSITION)\n\tSourcePosition position = SourcePosition.NOPOSITION;\n\n\tMap<String, Object> metadata;\n\n\tpublic CtElementImpl() {\n\t}\n\n\t@Override\n\tpublic String getShortRepresentation() {\n\t\treturn super.toString();\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (!(o instanceof CtElementImpl)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tboolean ret = EqualsVisitor.equals(this, (CtElement) o);\n\t\t// neat online testing of core Java contract\n\t\tif (ret && !factory.getEnvironment().checksAreSkipped() && this.hashCode() != o.hashCode()) {\n\t\t\tthrow new IllegalStateException(\"violation of equal/hashcode contract between \\n\" + this.toString() + \"\\nand\\n\" + o.toString() + \"\\n\");\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n\t\tCtType annot = getFactory().Annotation().get(annotationType);\n\t\tfor (CtAnnotation<? extends Annotation> a : getAnnotations()) {\n\t\t\tif (a.getAnnotationType().getQualifiedName().equals(annot.getQualifiedName())) {\n\t\t\t\treturn ((CtAnnotation<A>) a).getActualAnnotation(); // warning, here we do heavy and costly work with proxy\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> boolean hasAnnotation(Class<A> annotationType) {\n\t\tCtType annot = getFactory().Annotation().get(annotationType);\n\t\tfor (CtAnnotation<? extends Annotation> a : getAnnotations()) {\n\t\t\tif (a.getAnnotationType().getQualifiedName().equals(annot.getQualifiedName())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <A extends Annotation> CtAnnotation<A> getAnnotation(CtTypeReference<A> annotationType) {\n\t\tfor (CtAnnotation<? extends Annotation> a : getAnnotations()) {\n\t\t\tif (a.getAnnotationType().equals(annotationType)) {\n\t\t\t\treturn (CtAnnotation<A>) a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<CtAnnotation<? extends Annotation>> getAnnotations() {\n\t\tif (this instanceof CtShadowable) {\n\t\t\tCtShadowable shadowable = (CtShadowable) this;\n\t\t\tif (shadowable.isShadow()) {\n\t\t\t\tLauncher.LOGGER.debug(\"Some annotations might be unreachable from the shadow element: \" + this.getShortRepresentation());\n\t\t\t}\n\t\t}\n\t\treturn unmodifiableList(annotations);\n\t}\n\n\t@Override\n\tpublic String getDocComment() {\n\t\tfor (CtComment ctComment : comments) {\n\t\t\tif (ctComment.getCommentType() == CtComment.CommentType.JAVADOC) {\n\t\t\t\treturn printComment(ctComment);\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\t@Override\n\tpublic SourcePosition getPosition() {\n\t\tif (position != null) {\n\t\t\treturn position;\n\t\t}\n\t\treturn SourcePosition.NOPOSITION;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tHashcodeVisitor pr = new HashcodeVisitor();\n\t\tpr.scan(this);\n\t\treturn pr.getHasCode();\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setAnnotations(List<CtAnnotation<? extends Annotation>> annotations) {\n\t\tif (annotations == null || annotations.isEmpty()) {\n\t\t\tthis.annotations = emptyList();\n\t\t\treturn (E) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.ANNOTATION, this.annotations, new ArrayList<>(this.annotations));\n\t\tthis.annotations.clear();\n\t\tfor (CtAnnotation<? extends Annotation> annot : annotations) {\n\t\t\taddAnnotation(annot);\n\t\t}\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic void delete() {\n\t\t//delete is implemented as replace by no element (empty list of elements)\n\t\treplace(Collections.<CtElement>emptyList());\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E addAnnotation(CtAnnotation<? extends Annotation> annotation) {\n\t\tif (annotation == null) {\n\t\t\treturn (E) this;\n\t\t}\n\t\tif (this.annotations == CtElementImpl.<CtAnnotation<? extends Annotation>>emptyList()) {\n\t\t\tthis.annotations = new ArrayList<>(ModelElementContainerDefaultCapacities.ANNOTATIONS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tannotation.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.ANNOTATION, this.annotations, annotation);\n\t\tthis.annotations.add(annotation);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic boolean removeAnnotation(CtAnnotation<? extends Annotation> annotation) {\n\t\tif (this.annotations == CtElementImpl.<CtAnnotation<? extends Annotation>>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.ANNOTATION, annotations, annotations.indexOf(annotation), annotation);\n\t\treturn this.annotations.remove(annotation);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setDocComment(String docComment) {\n\t\tfor (CtComment ctComment : comments) {\n\t\t\tif (ctComment.getCommentType() == CtComment.CommentType.JAVADOC) {\n\t\t\t\tctComment.setContent(docComment);\n\t\t\t\treturn (E) this;\n\t\t\t}\n\t\t}\n\t\tthis.addComment(factory.Code().createComment(docComment, CtComment.CommentType.JAVADOC));\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setPosition(SourcePosition position) {\n\t\tif (position == null) {\n\t\t\tposition = SourcePosition.NOPOSITION;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.POSITION, position, this.position);\n\t\tthis.position = position;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setPositions(final SourcePosition position) {\n\t\taccept(new CtScanner() {\n\t\t\t@Override\n\t\t\tpublic void enter(CtElement e) {\n\t\t\t\te.setPosition(position);\n\t\t\t}\n\t\t});\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tDefaultJavaPrettyPrinter printer = new DefaultJavaPrettyPrinter(getFactory().getEnvironment());\n\t\tString errorMessage = \"\";\n\t\ttry {\n\t\t\t// we do not want to compute imports of for CtImport and CtReference\n\t\t\t// as it may change the print of a reference\n\t\t\tif (!(this instanceof CtImport) && !(this instanceof CtReference)) {\n\t\t\t\tprinter.getImportsContext().computeImports(this);\n\t\t\t}\n\t\t\tprinter.scan(this);\n\t\t} catch (ParentNotInitializedException ignore) {\n\t\t\tLOGGER.error(ERROR_MESSAGE_TO_STRING, ignore);\n\t\t\terrorMessage = ERROR_MESSAGE_TO_STRING;\n\t\t}\n\t\t// in line-preservation mode, newlines are added at the beginning to matches the lines\n\t\t// removing them from the toString() representation\n\t\treturn printer.toString().replaceFirst(\"^\\\\s+\", \"\") + errorMessage;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <E extends CtElement> List<E> getAnnotatedChildren(Class<? extends Annotation> annotationType) {\n\t\treturn (List<E>) Query.getElements(this, new AnnotationFilter<>(CtElement.class, annotationType));\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_IMPLICIT)\n\tboolean implicit = false;\n\n\t@Override\n\tpublic boolean isImplicit() {\n\t\treturn implicit;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setImplicit(boolean implicit) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_IMPLICIT, implicit, this.implicit);\n\t\tthis.implicit = implicit;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\t@DerivedProperty\n\tpublic Set<CtTypeReference<?>> getReferencedTypes() {\n\t\tTypeReferenceScanner s = new TypeReferenceScanner();\n\t\ts.scan(this);\n\t\treturn s.getReferences();\n\t}\n\n\t@Override\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tpublic <E extends CtElement> List<E> getElements(Filter<E> filter) {\n\t\treturn filterChildren(filter).list();\n\t}\n\n\t@Override\n\tpublic <I> CtQuery map(CtConsumableFunction<I> queryStep) {\n\t\treturn factory.Query().createQuery(this).map(queryStep);\n\t}\n\n\t@Override\n\tpublic <I, R> CtQuery map(CtFunction<I, R> function) {\n\t\treturn factory.Query().createQuery(this).map(function);\n\t}\n\n\t@Override\n\tpublic <P extends CtElement> CtQuery filterChildren(Filter<P> predicate) {\n\t\treturn factory.Query().createQuery(this).filterChildren(predicate);\n\t}\n\n\t@Override\n\tpublic CtElement getParent() throws ParentNotInitializedException {\n\t\tif (parent == null) {\n\t\t\tString exceptionMsg;\n\t\t\tif (this instanceof CtReference) {\n\t\t\t\texceptionMsg = \"parent not initialized for \" + ((CtReference) this).getSimpleName() + \"(\" + this.getClass() + \")\";\n\t\t\t} else {\n\t\t\t\tSourcePosition pos = getPosition();\n\t\t\t\tif (this instanceof CtNamedElement) {\n\t\t\t\t\texceptionMsg = (\"parent not initialized for \" + ((CtNamedElement) this).getSimpleName() + \"(\" + this.getClass() + \")\" + (pos != null ? \" \" + pos : \" (?)\"));\n\t\t\t\t} else {\n\t\t\t\t\texceptionMsg = (\"parent not initialized for \" + this.getClass() + (pos != null ? \" \" + pos : \" (?)\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new ParentNotInitializedException(exceptionMsg);\n\t\t}\n\t\treturn parent;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setParent(E parent) {\n\t\tthis.parent = parent;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic boolean isParentInitialized() {\n\t\treturn parent != null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <P extends CtElement> P getParent(Class<P> parentType) throws ParentNotInitializedException {\n\t\tif (parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (parentType.isAssignableFrom(getParent().getClass())) {\n\t\t\treturn (P) getParent();\n\t\t}\n\t\treturn getParent().getParent(parentType);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <E extends CtElement> E getParent(Filter<E> filter) throws ParentNotInitializedException {\n\t\tE current = (E) getParent();\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\twhile (current != null && !filter.matches(current)) {\n\t\t\t\t\tcurrent = (E) current.getParent();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\t// expected, some elements are not of type\n\t\t\t\tcurrent = (E) current.getParent();\n\t\t\t}\n\t\t}\n\n\t\tif (current != null && filter.matches(current)) {\n\t\t\treturn current;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasParent(CtElement candidate) {\n\t\ttry {\n\t\t\treturn this != getFactory().getModel().getUnnamedModule() && (getParent() == candidate || getParent().hasParent(candidate));\n\t\t} catch (ParentNotInitializedException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic CtRole getRoleInParent() {\n\t\tif (isParentInitialized()) {\n\t\t\tEarlyTerminatingScanner<CtRole> ets = new EarlyTerminatingScanner<CtRole>() {\n\t\t\t\t@Override\n\t\t\t\tpublic void scan(CtRole role, CtElement element) {\n\t\t\t\t\tif (element == CtElementImpl.this) {\n\t\t\t\t\t\tsetResult(role);\n\t\t\t\t\t\tterminate();\n\t\t\t\t\t}\n\t\t\t\t\t//do not call super.scan, because we do not want scan children\n\t\t\t\t}\n\t\t\t};\n\t\t\tgetParent().accept(ets);\n\t\t\treturn ets.getResult();\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void updateAllParentsBelow() {\n\t\tnew ModelConsistencyChecker(getFactory().getEnvironment(), true, true).scan(this);\n\t}\n\n\t@Override\n\tpublic Factory getFactory() {\n\t\tif (this.factory == null) {\n\t\t\treturn DEFAULT_FACTORY;\n\t\t}\n\t\treturn factory;\n\t}\n\n\t@Override\n\tpublic void setFactory(Factory factory) {\n\t\tthis.factory = factory;\n\t\tLOGGER.setLevel(factory.getEnvironment().getLevel());\n\t}\n\n\t@Override\n\tpublic void replace(CtElement element) {\n\t\tReplacementVisitor.replace(this, element);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> void replace(Collection<E> elements) {\n\t\tReplacementVisitor.replace(this, elements);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setAllMetadata(Map<String, Object> metadata) {\n\t\tif (metadata == null || metadata.isEmpty()) {\n\t\t\tthis.metadata = null;\n\t\t\treturn (E) this;\n\t\t}\n\t\tif (this.metadata == null) {\n\t\t\tthis.metadata = new HashMap<>();\n\t\t} else {\n\t\t\tthis.metadata.clear();\n\t\t}\n\t\tthis.metadata.putAll(metadata);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E putMetadata(String key, Object val) {\n\t\tif (metadata == null) {\n\t\t\tmetadata = new HashMap<>();\n\t\t}\n\t\tmetadata.put(key, val);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic Object getMetadata(String key) {\n\t\tif (metadata == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn metadata.get(key);\n\t}\n\n\t@Override\n\tpublic Map<String, Object> getAllMetadata() {\n\t\tif (this.metadata == null) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\t\treturn Collections.unmodifiableMap(this.metadata);\n\t}\n\n\t@Override\n\tpublic Set<String> getMetadataKeys() {\n\t\tif (metadata == null) {\n\t\t\treturn Collections.EMPTY_SET;\n\t\t}\n\t\treturn metadata.keySet();\n\t}\n\n\t@Override\n\tpublic List<CtComment> getComments() {\n\t\treturn unmodifiableList(comments);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E addComment(CtComment comment) {\n\t\tif (comment == null) {\n\t\t\treturn (E) this;\n\t\t}\n\t\tif (this.comments == CtElementImpl.<CtComment>emptyList()) {\n\t\t\tcomments = new ArrayList<>(ModelElementContainerDefaultCapacities.COMMENT_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tcomment.setParent(this);\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.COMMENT, this.comments, comment);\n\t\tcomments.add(comment);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E removeComment(CtComment comment) {\n\t\tif (this.comments == CtElementImpl.<CtComment>emptyList()) {\n\t\t\treturn (E) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.COMMENT, comments, comments.indexOf(comment), comment);\n\t\tthis.comments.remove(comment);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic <E extends CtElement> E setComments(List<CtComment> comments) {\n\t\tif (comments == null || comments.isEmpty()) {\n\t\t\tthis.comments = emptyList();\n\t\t\treturn (E) this;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.COMMENT, this.comments, new ArrayList<>(this.comments));\n\t\tthis.comments.clear();\n\t\tfor (CtComment comment : comments) {\n\t\t\taddComment(comment);\n\t\t}\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtElement clone() {\n\t\treturn CloneHelper.INSTANCE.clone(this);\n\t}\n\n\t@Override\n\tpublic <T> T getValueByRole(CtRole role) {\n\t\tRoleHandler rh = RoleHandlerHelper.getRoleHandler(this.getClass(), role);\n\t\treturn rh.getValue(this);\n\t}\n\n\t@Override\n\tpublic <E extends CtElement, T> E setValueByRole(CtRole role, T value) {\n\t\tRoleHandler rh = RoleHandlerHelper.getRoleHandler(this.getClass(), role);\n\t\trh.setValue(this, value);\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtPath getPath() {\n\t\treturn new CtElementPathBuilder().fromElement(this);\n\t}\n\n\t@Override\n\tpublic Iterator<CtElement> descendantIterator() {\n\t\treturn new CtIterator(this);\n\t}\n\n\t@Override\n\tpublic Iterable<CtElement> asIterable() {\n\t\treturn this::descendantIterator;\n\t}\n\n\t@Override\n\tpublic ElementSourceFragment getOriginalSourceFragment() {\n\t\tSourcePosition sp = this.getPosition();\n\t\tCompilationUnit compilationUnit = sp.getCompilationUnit();\n\t\tif (compilationUnit != null) {\n\t\t\tElementSourceFragment rootFragment = compilationUnit.getOriginalSourceFragment();\n\t\t\treturn rootFragment.getSourceFragmentOf(this, sp.getSourceStart(), sp.getSourceEnd() + 1);\n\t\t} else {\n\t\t\treturn ElementSourceFragment.NO_SOURCE_FRAGMENT;\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<CtElement> getDirectChildren() {\n\t\tList<CtElement> directChildren = new ArrayList<>();\n\t\tCtScanner scanner = new CtScanner() {\n\t\t\t@Override\n\t\t\tpublic void scan(CtElement element) {\n\t\t\t\t// since we don't call super.scan, this does not further descend in the tree\n\t\t\t\tif (element != null) {\n\t\t\t\t\tdirectChildren.add(element);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.accept(scanner);\n\t\treturn directChildren;\n\t}\n}\n"
    }, {
      "name" : "support/reflect/declaration/CtMethodImpl.java",
      "weight" : 215.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.declaration;\n\nimport spoon.refactoring.Refactoring;\nimport spoon.reflect.ModelElementContainerDefaultCapacities;\nimport spoon.reflect.annotations.MetamodelPropertyField;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.CtTypedElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtVisitor;\nimport spoon.reflect.visitor.filter.AllTypeMembersFunction;\nimport spoon.support.reflect.CtExtendedModifier;\nimport spoon.support.reflect.CtModifierHandler;\nimport spoon.support.visitor.ClassTypingContext;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * The implementation for {@link spoon.reflect.declaration.CtMethod}.\n *\n * @author Renaud Pawlak\n */\npublic class CtMethodImpl<T> extends CtExecutableImpl<T> implements CtMethod<T> {\n\tprivate static final long serialVersionUID = 1L;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE)\n\tCtTypeReference<T> returnType;\n\n\t@MetamodelPropertyField(role = CtRole.IS_DEFAULT)\n\tboolean defaultMethod = false;\n\n\t@MetamodelPropertyField(role = CtRole.TYPE_PARAMETER)\n\tList<CtTypeParameter> formalCtTypeParameters = emptyList();\n\n\t@MetamodelPropertyField(role = CtRole.MODIFIER)\n\tprivate CtModifierHandler modifierHandler = new CtModifierHandler(this);\n\n\tpublic CtMethodImpl() {\n\t}\n\n\t@Override\n\tpublic void accept(CtVisitor v) {\n\t\tv.visitCtMethod(this);\n\t}\n\n\t@Override\n\tpublic CtTypeReference<T> getType() {\n\t\treturn returnType;\n\t}\n\n\t@Override\n\tpublic <C extends CtTypedElement> C setType(CtTypeReference<T> type) {\n\t\tif (type != null) {\n\t\t\ttype.setParent(this);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.TYPE, type, this.returnType);\n\t\tthis.returnType = type;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isDefaultMethod() {\n\t\treturn defaultMethod;\n\t}\n\n\t@Override\n\tpublic <C extends CtMethod<T>> C setDefaultMethod(boolean defaultMethod) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_DEFAULT, defaultMethod, this.defaultMethod);\n\t\tthis.defaultMethod = defaultMethod;\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic List<CtTypeParameter> getFormalCtTypeParameters() {\n\t\treturn formalCtTypeParameters;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C setFormalCtTypeParameters(List<CtTypeParameter> formalTypeParameters) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDeleteAll(this, CtRole.TYPE_PARAMETER, this.formalCtTypeParameters, new ArrayList<>(this.formalCtTypeParameters));\n\t\tif (formalTypeParameters == null || formalTypeParameters.isEmpty()) {\n\t\t\tthis.formalCtTypeParameters = CtElementImpl.emptyList();\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (this.formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tthis.formalCtTypeParameters = new ArrayList<>(ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tthis.formalCtTypeParameters.clear();\n\t\tfor (CtTypeParameter formalTypeParameter : formalTypeParameters) {\n\t\t\taddFormalCtTypeParameter(formalTypeParameter);\n\t\t}\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtFormalTypeDeclarer> C addFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (formalTypeParameter == null) {\n\t\t\treturn (C) this;\n\t\t}\n\t\tif (formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\tformalCtTypeParameters = new ArrayList<>(ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListAdd(this, CtRole.TYPE_PARAMETER, this.formalCtTypeParameters, formalTypeParameter);\n\t\tformalTypeParameter.setParent(this);\n\t\tformalCtTypeParameters.add(formalTypeParameter);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic boolean removeFormalCtTypeParameter(CtTypeParameter formalTypeParameter) {\n\t\tif (formalCtTypeParameters == CtElementImpl.<CtTypeParameter>emptyList()) {\n\t\t\treturn false;\n\t\t}\n\t\tgetFactory().getEnvironment().getModelChangeListener().onListDelete(this, CtRole.TYPE_PARAMETER, formalCtTypeParameters, formalCtTypeParameters.indexOf(formalTypeParameter), formalTypeParameter);\n\t\treturn formalCtTypeParameters.remove(formalTypeParameter);\n\t}\n\n\t@Override\n\tpublic Set<ModifierKind> getModifiers() {\n\t\treturn modifierHandler.getModifiers();\n\t}\n\n\t@Override\n\tpublic boolean hasModifier(ModifierKind modifier) {\n\t\treturn getModifiers().contains(modifier);\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setModifiers(Set<ModifierKind> modifiers) {\n\t\tmodifierHandler.setModifiers(modifiers);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C addModifier(ModifierKind modifier) {\n\t\tmodifierHandler.addModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C removeModifier(ModifierKind modifier) {\n\t\tmodifierHandler.removeModifier(modifier);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setVisibility(ModifierKind visibility) {\n\t\tmodifierHandler.setVisibility(visibility);\n\t\treturn (C) this;\n\t}\n\n\t@Override\n\tpublic ModifierKind getVisibility() {\n\t\treturn modifierHandler.getVisibility();\n\t}\n\n\t@Override\n\tpublic Set<CtExtendedModifier> getExtendedModifiers() {\n\t\treturn this.modifierHandler.getExtendedModifiers();\n\t}\n\n\t@Override\n\tpublic <C extends CtModifiable> C setExtendedModifiers(Set<CtExtendedModifier> extendedModifiers) {\n\t\tthis.modifierHandler.setExtendedModifiers(extendedModifiers);\n\t\treturn  (C) this;\n\t}\n\n\t@Override\n\tpublic boolean isOverriding(CtMethod<?> superMethod) {\n\t\treturn new ClassTypingContext(getDeclaringType()).isOverriding(this, superMethod);\n\t}\n\n\t@MetamodelPropertyField(role = CtRole.IS_SHADOW)\n\tboolean isShadow;\n\n\t@Override\n\tpublic boolean isShadow() {\n\t\treturn isShadow;\n\t}\n\n\t@Override\n\tpublic <E extends CtShadowable> E setShadow(boolean isShadow) {\n\t\tgetFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, CtRole.IS_SHADOW, isShadow, this.isShadow);\n\t\tthis.isShadow = isShadow;\n\t\treturn (E) this;\n\t}\n\n\t@Override\n\tpublic CtMethod<T> clone() {\n\t\treturn (CtMethod<T>) super.clone();\n\t}\n\n\t@Override\n\tpublic Collection<CtMethod<?>> getTopDefinitions() {\n\t\tList<CtMethod<?>> s = new ArrayList<>();\n\n\t\t// first collect potential declarations of this method in the type hierarchy\n\t\tClassTypingContext context = new ClassTypingContext(this.getDeclaringType());\n\t\tgetDeclaringType().map(new AllTypeMembersFunction(CtMethod.class)).forEach((CtMethod<?> m) -> {\n\t\t\tif (m != this && context.isOverriding(this, m)) {\n\t\t\t\ts.add(m);\n\t\t\t}\n\t\t});\n\n\t\t// now removing the intermediate methods for which there exists a definition upper in the hierarchy\n\t\tList<CtMethod<?>> finalMeths = new ArrayList<>(s);\n\t\tfor (CtMethod m1 : s) {\n\t\t\tboolean m1IsIntermediate = false;\n\t\t\tfor (CtMethod m2 : s) {\n\t\t\t\tif (context.isOverriding(m1, m2)) {\n\t\t\t\t\tm1IsIntermediate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!m1IsIntermediate) {\n\t\t\t\tfinalMeths.add(m1);\n\t\t\t}\n\t\t}\n\t\treturn finalMeths;\n\t}\n\n\t@Override\n\tpublic boolean isPublic() {\n\t\treturn this.modifierHandler.isPublic();\n\t}\n\n\t@Override\n\tpublic boolean isPrivate() {\n\t\treturn this.modifierHandler.isPrivate();\n\t}\n\n\t@Override\n\tpublic boolean isProtected() {\n\t\treturn this.modifierHandler.isProtected();\n\t}\n\n\t@Override\n\tpublic boolean isFinal() {\n\t\treturn this.modifierHandler.isFinal();\n\t}\n\n\t@Override\n\tpublic boolean isStatic() {\n\t\treturn this.modifierHandler.isStatic();\n\t}\n\n\t@Override\n\tpublic boolean isAbstract() {\n\t\treturn this.modifierHandler.isAbstract();\n\t}\n\n\t@Override\n\tpublic CtMethod<?> copyMethod() {\n\t\treturn Refactoring.copyMethod(this);\n\t}\n}\n"
    }, {
      "name" : "support/reflect/eval/EvalHelper.java",
      "weight" : 63.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.eval;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.reference.CtFieldReference;\n\nimport java.lang.reflect.Array;\nimport java.util.List;\n\npublic class EvalHelper {\n\n\t// this class contains only static methods\n\tprivate EvalHelper() {\n\t}\n\n\t/**\n\t * Evaluates and converts CtExpression to their equivalent runtime objects\n\t * eg \"CtLiteral(3) + CtLiteral(4)\" -&gt; 7\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Object convertElementToRuntimeObject(CtElement value) {\n\t\tif (value instanceof CtExpression) {\n\t\t\tCtExpression evaled = ((CtExpression) value).partiallyEvaluate();\n\t\t\treturn getCorrespondingRuntimeObject(evaled);\n\t\t}\n\t\tthrow new SpoonException(\"not possible to convert to runtime object \" + value);\n\t}\n\n\t/**\n\t * Returns the runtime object corresponding to the expression\n\t * eg CtLiteral(3) -&gt; 3\n\t */\n\tpublic static Object getCorrespondingRuntimeObject(CtExpression<?> value) {\n\t\tif (value instanceof CtNewArray) {\n\t\t\treturn toArray((CtNewArray) value);\n\t\t} else if (value instanceof CtAnnotation) {\n\t\t\t// Get proxy\n\t\t\treturn ((CtAnnotation<?>) value).getActualAnnotation();\n\t\t} else if (value instanceof CtLiteral) {\n\t\t\t// Replace literal by his value\n\t\t\treturn ((CtLiteral<?>) value).getValue();\n\t\t} else if (value instanceof CtFieldRead) {\n\t\t\t// replace enum value by actual enum value\n\t\t\tCtFieldReference<?> fieldRef = ((CtFieldRead<?>) value).getVariable();\n\t\t\tClass<?> c = fieldRef.getDeclaringType().getActualClass();\n\t\t\tCtField<?> field = fieldRef.getFieldDeclaration();\n\t\t\tif (Enum.class.isAssignableFrom(c)) {\n\t\t\t\t// Value references a Enum field\n\t\t\t\treturn Enum.valueOf((Class<? extends Enum>) c, fieldRef.getSimpleName());\n\t\t\t}\n\t\t\t// handling primitive types\n\t\t\tif (field.getDefaultExpression() instanceof CtLiteral) {\n\t\t\t\treturn ((CtLiteral) field.getDefaultExpression()).getValue();\n\t\t\t}\n\t\t}\n\n\t\tthrow new SpoonException(\"not possible to transform to expression \\\"\" + value + \"\\\" (\" + value.getClass().getName() + \")\");\n\t}\n\n\t/** creating a real low level Java array from a CtNewArray */\n\tprivate static Object toArray(CtNewArray value) {\n\t\tCtNewArray<?> arrayExpression = (CtNewArray<?>) value;\n\n\t\tClass<?> componentType = arrayExpression.getType().getActualClass().getComponentType();\n\t\tList<CtExpression<?>> elements = arrayExpression.getElements();\n\n\t\tObject array = Array.newInstance(componentType, elements.size());\n\t\tfor (int i = 0; i < elements.size(); i++) {\n\t\t\tArray.set(array, i, convertElementToRuntimeObject(elements.get(i)));\n\t\t}\n\n\t\treturn array;\n\t}\n\n\t/** returns true if the expression is known at compile time\n\t * Bonus method for @oscarlvp :-)\n\t */\n\tpublic static boolean isKnownAtCompileTime(CtExpression<?> exp) {\n\t\ttry {\n\t\t\tCtExpression evaled = exp.partiallyEvaluate();\n\t\t\tgetCorrespondingRuntimeObject(evaled);\n\t\t\t// no exception, it is known\n\t\t\treturn true;\n\t\t} catch (SpoonException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n}\n\n\n"
    }, {
      "name" : "support/reflect/eval/InlinePartialEvaluator.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.eval;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.eval.PartialEvaluator;\nimport spoon.reflect.visitor.CtScanner;\n\n/**\n * Simplifies an AST inline based on {@link VisitorPartialEvaluator} (wanring: the nodes are changed).\n */\npublic class InlinePartialEvaluator extends CtScanner {\n\tprivate final PartialEvaluator eval;\n\n\tpublic InlinePartialEvaluator(PartialEvaluator eval) {\n\t\tthis.eval = eval;\n\t}\n\t@Override\n\tprotected void exit(CtElement e) {\n\t\tCtElement simplified = eval.evaluate(e);\n\t\tif (simplified != null) {\n\t\t\te.replace(simplified);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/reflect/eval/VisitorPartialEvaluator.java",
      "weight" : 524.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.reflect.eval;\n\nimport spoon.reflect.code.CtAnnotationFieldAccess;\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtCatch;\nimport spoon.reflect.code.CtCatchVariable;\nimport spoon.reflect.code.CtComment;\nimport spoon.reflect.code.CtConditional;\nimport spoon.reflect.code.CtDo;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtFieldAccess;\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.code.CtFor;\nimport spoon.reflect.code.CtIf;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtLocalVariable;\nimport spoon.reflect.code.CtNewArray;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtSynchronized;\nimport spoon.reflect.code.CtThrow;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.code.CtVariableAccess;\nimport spoon.reflect.code.CtVariableRead;\nimport spoon.reflect.code.CtVariableWrite;\nimport spoon.reflect.code.CtWhile;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.eval.PartialEvaluator;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.support.util.RtHelper;\n\nimport java.util.List;\n\n/**\n *\n * Simplifies an AST by performing all operations that are statically known and changes the AST accordingly (eg \"0+1\" -&gt; \"1\")\n * This visitor implements a simple partial evaluator for the program\n * compile-time metamodel.\n */\npublic class VisitorPartialEvaluator extends CtScanner implements PartialEvaluator {\n\n\tboolean flowEnded = false;\n\n\tCtElement result;\n\n\tNumber convert(CtTypeReference<?> type, Number n) {\n\t\tif ((type.getActualClass() == int.class) || (type.getActualClass() == Integer.class)) {\n\t\t\treturn n.intValue();\n\t\t}\n\t\tif ((type.getActualClass() == byte.class) || (type.getActualClass() == Byte.class)) {\n\t\t\treturn n.byteValue();\n\t\t}\n\t\tif ((type.getActualClass() == long.class) || (type.getActualClass() == Long.class)) {\n\t\t\treturn n.longValue();\n\t\t}\n\t\tif ((type.getActualClass() == float.class) || (type.getActualClass() == Float.class)) {\n\t\t\treturn n.floatValue();\n\t\t}\n\t\tif ((type.getActualClass() == short.class) || (type.getActualClass() == Short.class)) {\n\t\t\treturn n.shortValue();\n\t\t}\n\t\treturn n;\n\t}\n\n\t@Override\n\tprotected void exit(CtElement e) {\n\t\t// if we go back to CtScanner, we discard the temp result\n\t\tresult = null;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <R extends CtElement> R evaluate(R element) {\n\t\tif (element == null) {\n\t\t\treturn null;\n\t\t}\n\t\telement.accept(this);\n\t\tif (result != null) {\n\t\t\tCtElement r = result;\n\t\t\t//reset result, to not influence another evaluation.\n\t\t\tresult = null;\n\t\t\tif (element.isParentInitialized()) {\n\t\t\t\tr.setParent(element.getParent());\n\t\t\t}\n\t\t\treturn (R) r;\n\t\t}\n\n\t\t// otherwise nothing has been changed\n\t\treturn (R) element.clone();\n\t}\n\n\tvoid setResult(CtElement element) {\n\t\tresult = element;\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> operator) {\n\t\tCtExpression<?> left = evaluate(operator.getLeftHandOperand());\n\t\tCtExpression<?> right = evaluate(operator.getRightHandOperand());\n\t\tif ((left instanceof CtLiteral) && (right instanceof CtLiteral)) {\n\t\t\tObject leftObject = ((CtLiteral<?>) left).getValue();\n\t\t\tObject rightObject = ((CtLiteral<?>) right).getValue();\n\t\t\tCtLiteral<Object> res = operator.getFactory().Core().createLiteral();\n\t\t\tswitch (operator.getKind()) {\n\t\t\tcase AND:\n\t\t\t\tres.setValue((Boolean) leftObject && (Boolean) rightObject);\n\t\t\t\tbreak;\n\t\t\tcase OR:\n\t\t\t\tres.setValue((Boolean) leftObject || (Boolean) rightObject);\n\t\t\t\tbreak;\n\t\t\tcase EQ:\n\t\t\t\tif (leftObject == null) {\n\t\t\t\t\tres.setValue(leftObject == rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(leftObject.equals(rightObject));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase NE:\n\t\t\t\tif (leftObject == null) {\n\t\t\t\t\tres.setValue(leftObject != rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(!leftObject.equals(rightObject));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GE:\n\t\t\t\tres.setValue(((Number) leftObject).doubleValue() >= ((Number) rightObject).doubleValue());\n\t\t\t\tbreak;\n\t\t\tcase LE:\n\t\t\t\tres.setValue(((Number) leftObject).doubleValue() <= ((Number) rightObject).doubleValue());\n\t\t\t\tbreak;\n\t\t\tcase GT:\n\t\t\t\tres.setValue(((Number) leftObject).doubleValue() > ((Number) rightObject).doubleValue());\n\t\t\t\tbreak;\n\t\t\tcase LT:\n\t\t\t\tres.setValue(((Number) leftObject).doubleValue() < ((Number) rightObject).doubleValue());\n\t\t\t\tbreak;\n\t\t\tcase MINUS:\n\t\t\t\tres.setValue(convert(operator.getType(),\n\t\t\t\t\t\t\t\t((Number) leftObject).doubleValue() - ((Number) rightObject).doubleValue()));\n\t\t\t\tbreak;\n\t\t\tcase MUL:\n\t\t\t\tres.setValue(convert(operator.getType(),\n\t\t\t\t\t\t\t\t((Number) leftObject).doubleValue() * ((Number) rightObject).doubleValue()));\n\t\t\t\tbreak;\n\t\t\tcase DIV:\n\t\t\t\tres.setValue(convert(operator.getType(),\n\t\t\t\t\t\t\t\t((Number) leftObject).doubleValue() / ((Number) rightObject).doubleValue()));\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\tif ((leftObject instanceof String) || (rightObject instanceof String)) {\n\t\t\t\t\tres.setValue(\"\" + leftObject + rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(convert(operator.getType(),\n\t\t\t\t\t\t\t\t\t((Number) leftObject).doubleValue() + ((Number) rightObject).doubleValue()));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BITAND:\n\t\t\t\tif (leftObject instanceof Boolean) {\n\t\t\t\t\tres.setValue((Boolean) leftObject & (Boolean) rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(((Number) leftObject).intValue() & ((Number) rightObject).intValue());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BITOR:\n\t\t\t\tif (leftObject instanceof Boolean) {\n\t\t\t\t\tres.setValue((Boolean) leftObject | (Boolean) rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(((Number) leftObject).intValue() | ((Number) rightObject).intValue());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BITXOR:\n\t\t\t\tif (leftObject instanceof Boolean) {\n\t\t\t\t\tres.setValue((Boolean) leftObject ^ (Boolean) rightObject);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(((Number) leftObject).intValue() ^ ((Number) rightObject).intValue());\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"unsupported operator \" + operator.getKind());\n\t\t\t}\n\t\t\tsetResult(res);\n\t\t} else if ((left instanceof CtLiteral) || (right instanceof CtLiteral)) {\n\t\t\tCtLiteral<?> literal;\n\t\t\tCtExpression<?> expr;\n\t\t\tif (left instanceof CtLiteral) {\n\t\t\t\tliteral = (CtLiteral<?>) left;\n\t\t\t\texpr = right;\n\t\t\t} else {\n\t\t\t\tliteral = (CtLiteral<?>) right;\n\t\t\t\texpr = left;\n\t\t\t}\n\t\t\tObject o = literal.getValue();\n\t\t\tCtLiteral<Object> res = operator.getFactory().Core().createLiteral();\n\t\t\tswitch (operator.getKind()) {\n\t\t\tcase AND:\n\t\t\t\tif ((Boolean) o) {\n\t\t\t\t\tsetResult(expr);\n\t\t\t\t} else {\n\t\t\t\t\tres.setValue(false);\n\t\t\t\t\tsetResult(res);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tcase OR:\n\t\t\t\tif ((Boolean) o) {\n\t\t\t\t\tres.setValue(true);\n\t\t\t\t\tsetResult(res);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(expr);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tcase BITOR:\n\t\t\t\tif ((o instanceof Boolean) && (Boolean) o) {\n\t\t\t\t\tres.setValue(true);\n\t\t\t\t\tsetResult(res);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\t// TODO: other cases?\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <R> void visitCtBlock(CtBlock<R> block) {\n\t\tCtBlock<?> b = block.getFactory().Core().createBlock();\n\t\tfor (CtStatement s : block.getStatements()) {\n\t\t\tCtElement res = evaluate(s);\n\t\t\tif (res != null) {\n\t\t\t\tif (res instanceof CtStatement) {\n\t\t\t\t\tb.addStatement((CtStatement) res);\n\t\t\t\t} else {\n\t\t\t\t\t//the context expects statement. We cannot simplify in this case\n\t\t\t\t\tb.addStatement(s.clone());\n\t\t\t\t}\n\t\t\t}\n\t\t\t// do not copy unreachable statements\n\t\t\tif (flowEnded) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsetResult(b);\n\t}\n\n\t@Override\n\tpublic void visitCtDo(CtDo doLoop) {\n\t\tCtDo w = doLoop.clone();\n\t\tw.setLoopingExpression(evaluate(doLoop.getLoopingExpression()));\n\t\tw.setBody(evaluate(doLoop.getBody()));\n\t\tsetResult(w);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\tvisitFieldAccess(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {\n\t\tvisitFieldAccess(fieldWrite);\n\t}\n\n\tprivate <T> void visitFieldAccess(CtFieldAccess<T> fieldAccess) {\n\t\tif (\"class\".equals(fieldAccess.getVariable().getSimpleName())) {\n\t\t\tClass<?> actualClass = fieldAccess.getVariable().getDeclaringType().getActualClass();\n\t\t\tif (actualClass != null) {\n\t\t\t\tCtLiteral<Class<?>> literal = fieldAccess.getFactory().Core().createLiteral();\n\t\t\t\tliteral.setValue(actualClass);\n\t\t\t\tsetResult(literal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (\"length\".equals(fieldAccess.getVariable().getSimpleName())) {\n\t\t\tCtExpression<?> target = fieldAccess.getTarget();\n\t\t\tif (target instanceof CtNewArray<?>) {\n\t\t\t\tCtNewArray<?> newArr = (CtNewArray<?>) target;\n\t\t\t\tCtLiteral<Number> literal = fieldAccess.getFactory().createLiteral(newArr.getElements().size());\n\t\t\t\tsetResult(literal);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tString fieldName = fieldAccess.getVariable().getSimpleName();\n\n\t\t// accessing the field, even for shadow classes\n\t\tCtType<?> typeDeclaration = fieldAccess.getVariable()\n\t\t\t\t.getDeclaringType()\n\t\t\t\t.getTypeDeclaration();\n\n\t\tCtField<?> f;\n\t\tif (typeDeclaration != null) {\n\t\t\tf = typeDeclaration.getField(fieldName); // works for shadow fields also\n\t\t} else {\n\t\t\tf = fieldAccess.getVariable().getFieldDeclaration();\n\t\t}\n\n\t\tif ((f != null) && f.getModifiers().contains(ModifierKind.FINAL)\n\t\t\t\t// enum values have no meaningful default expression to be evaluated\n\t\t\t\t&& !fieldAccess.getVariable().getDeclaringType().isSubtypeOf(fieldAccess.getFactory().Type().ENUM)\n\t\t\t\t) {\n\t\t\tsetResult(evaluate(f.getDefaultExpression()));\n\t\t\treturn;\n\t\t}\n\t\tsetResult(fieldAccess.clone());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationFieldAccess(CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\tCtField<?> f = annotationFieldAccess.getVariable().getDeclaration();\n\t\tsetResult(evaluate(f.getDefaultExpression()));\n\t}\n\n\t@Override\n\tpublic void visitCtFor(CtFor forLoop) {\n\n\t\t// Evaluate forInit\n\t\tList<CtStatement> lst = forLoop.getForInit();\n\t\tfor (CtStatement s : lst) {\n\t\t\tCtStatement evaluateStatement = evaluate(s);\n\t\t\tif (evaluateStatement != null) {\n\t\t\t\tforLoop.addForInit(evaluateStatement);\n\t\t\t}\n\t\t}\n\n\t\t// Evaluate Expression\n\t\tforLoop.setExpression(evaluate(forLoop.getExpression()));\n\n\t\t// Evaluate forUpdate\n\t\tlst = forLoop.getForUpdate();\n\t\tfor (CtStatement s : lst) {\n\t\t\tCtStatement evaluateStatement = evaluate(s);\n\t\t\tif (evaluateStatement != null) {\n\t\t\t\tforLoop.addForUpdate(evaluateStatement);\n\t\t\t}\n\t\t}\n\n\t\tsetResult(forLoop.clone());\n\t}\n\n\t@Override\n\tpublic void visitCtIf(CtIf ifElement) {\n\t\tCtExpression<Boolean> r = evaluate(ifElement.getCondition());\n\t\tif (r instanceof CtLiteral) {\n\t\t\tCtLiteral<Boolean> l = (CtLiteral<Boolean>) r;\n\t\t\tif (l.getValue()) {\n\t\t\t\tsetResult(evaluate(ifElement.getThenStatement()));\n\t\t\t} else {\n\t\t\t\tif (ifElement.getElseStatement() != null) {\n\t\t\t\t\tsetResult(evaluate(ifElement.getElseStatement()));\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(ifElement.getFactory().Code().createComment(\"if removed\", CtComment.CommentType.INLINE));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tCtIf ifRes = ifElement.getFactory().Core().createIf();\n\t\t\tifRes.setCondition(r);\n\t\t\tboolean thenEnded = false;\n\t\t\tboolean elseEnded = false;\n\t\t\tifRes.setThenStatement((CtStatement) evaluate(ifElement.getThenStatement()));\n\t\t\tif (flowEnded) {\n\t\t\t\tthenEnded = true;\n\t\t\t\tflowEnded = false;\n\t\t\t}\n\t\t\tif (ifElement.getElseStatement() != null) {\n\t\t\t\tifRes.setElseStatement((CtStatement) evaluate(ifElement.getElseStatement()));\n\t\t\t}\n\t\t\tif (flowEnded) {\n\t\t\t\telseEnded = true;\n\t\t\t\tflowEnded = false;\n\t\t\t}\n\t\t\tsetResult(ifRes);\n\t\t\tif (thenEnded && elseEnded) {\n\t\t\t\tflowEnded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInvocation(CtInvocation<T> invocation) {\n\t\tCtInvocation<T> i = invocation.getFactory().Core().createInvocation();\n\t\ti.setExecutable(invocation.getExecutable());\n\t\ti.setTypeCasts(invocation.getTypeCasts());\n\t\tboolean constant = true;\n\t\ti.setTarget(evaluate(invocation.getTarget()));\n\t\tif ((i.getTarget() != null) && !(i.getTarget() instanceof CtLiteral)) {\n\t\t\tconstant = false;\n\t\t}\n\t\tfor (CtExpression<?> e : invocation.getArguments()) {\n\t\t\tCtExpression<?> re = evaluate(e);\n\t\t\tif (!(re instanceof CtLiteral)) {\n\t\t\t\tconstant = false;\n\t\t\t}\n\t\t\ti.addArgument(re);\n\t\t}\n\t\t// do not partially evaluate super(...)\n\t\tif (i.getExecutable().getSimpleName().equals(CtExecutableReference.CONSTRUCTOR_NAME)) {\n\t\t\tsetResult(i);\n\t\t\treturn;\n\t\t}\n\t\tif (constant) {\n\t\t\tCtExecutable<?> executable = invocation.getExecutable().getDeclaration();\n\t\t\tCtType<?> aType = invocation.getParent(CtType.class);\n\t\t\tCtTypeReference<?> execDeclaringType = invocation.getExecutable().getDeclaringType();\n\t\t\t// try to inline partial evaluation results for local calls\n\t\t\t// (including superclasses)\n\t\t\tif (executable != null && aType != null && invocation.getType() != null && execDeclaringType != null\n\t\t\t\t\t&& execDeclaringType.isSubtypeOf(aType.getReference())) {\n\t\t\t\tCtBlock<?> b = evaluate(executable.getBody());\n\t\t\t\tflowEnded = false;\n\t\t\t\tCtStatement last = b.getStatements().get(b.getStatements().size() - 1);\n\t\t\t\tif ((last instanceof CtReturn)) {\n\t\t\t\t\tif (((CtReturn<?>) last).getReturnedExpression() instanceof CtLiteral) {\n\t\t\t\t\t\tsetResult(((CtReturn<?>) last).getReturnedExpression());\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// try to completely evaluate\n\t\t\t\tT r;\n\t\t\t\ttry {\n\t\t\t\t\tr = RtHelper.invoke(i);\n\t\t\t\t\tif (isLiteralType(r)) {\n\t\t\t\t\t\tCtLiteral<T> l = invocation.getFactory().Core().createLiteral();\n\t\t\t\t\t\tl.setValue(r);\n\t\t\t\t\t\tsetResult(l);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetResult(i);\n\t}\n\n\tprivate boolean isLiteralType(Object object) {\n\t\tif (object == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (object instanceof String) {\n\t\t\treturn true;\n\t\t}\n\t\tif (object instanceof Number) {\n\t\t\treturn true;\n\t\t}\n\t\tif (object instanceof Character) {\n\t\t\treturn true;\n\t\t}\n\t\treturn object instanceof Class;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtField(CtField<T> f) {\n\t\tCtField<T> r = f.clone();\n\t\tr.setDefaultExpression(evaluate(f.getDefaultExpression()));\n\t\tsetResult(r);\n\t}\n\n\n\t@Override\n\tpublic <T> void visitCtLocalVariable(final CtLocalVariable<T> localVariable) {\n\t\tCtLocalVariable<T> r = localVariable.clone();\n\t\tr.setDefaultExpression(evaluate(localVariable.getDefaultExpression()));\n\t\tsetResult(r);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtCatchVariable(CtCatchVariable<T> catchVariable) {\n\t\tCtCatchVariable<T> r = catchVariable.clone();\n\t\tr.setDefaultExpression(evaluate(catchVariable.getDefaultExpression()));\n\t\tsetResult(r);\n\t}\n\t@Override\n\tpublic <R> void visitCtReturn(CtReturn<R> returnStatement) {\n\t\tCtReturn<R> r = returnStatement.getFactory().Core().createReturn();\n\t\tr.setReturnedExpression(evaluate(returnStatement.getReturnedExpression()));\n\t\tsetResult(r);\n\t\tflowEnded = true;\n\t}\n\n\t@Override\n\tpublic void visitCtSynchronized(CtSynchronized synchro) {\n\t\tCtSynchronized s = synchro.clone();\n\t\ts.setBlock(evaluate(synchro.getBlock()));\n\t\tsetResult(s);\n\t}\n\n\t@Override\n\tpublic void visitCtThrow(CtThrow throwStatement) {\n\t\tCtThrow r = throwStatement.getFactory().Core().createThrow();\n\t\tr.setThrownExpression(evaluate(throwStatement.getThrownExpression()));\n\t\tsetResult(r);\n\t\tflowEnded = true;\n\t}\n\n\t@Override\n\tpublic void visitCtCatch(CtCatch catchBlock) {\n\t\tsuper.visitCtCatch(catchBlock);\n\t\t//the flowEnded = true set by throw in catch block does not stops flow of parent\n\t\tflowEnded = false;\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {\n\t\tCtExpression<?> operand = evaluate(operator.getOperand());\n\t\tif (operand instanceof CtLiteral) {\n\t\t\tObject object = ((CtLiteral<?>) operand).getValue();\n\t\t\tCtLiteral<Object> res = operator.getFactory().Core().createLiteral();\n\t\t\tswitch (operator.getKind()) {\n\t\t\tcase NOT:\n\t\t\t\tres.setValue(!(Boolean) object);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"unsupported operator \" + operator.getKind());\n\t\t\t}\n\t\t\tsetResult(res);\n\t\t\treturn;\n\t\t}\n\t\tsetResult(operator.clone());\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableRead(CtVariableRead<T> variableRead) {\n\t\tvisitVariableAccess(variableRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtVariableWrite(CtVariableWrite<T> variableWrite) {\n\t\tvisitVariableAccess(variableWrite);\n\t}\n\n\tprivate <T> void visitVariableAccess(CtVariableAccess<T> variableAccess) {\n\t\tCtVariable<?> v = variableAccess.getVariable().getDeclaration();\n\t\tif (v != null && v.hasModifier(ModifierKind.FINAL) && v.getDefaultExpression() != null) {\n\t\t\tsetResult(evaluate(v.getDefaultExpression()));\n\t\t} else {\n\t\t\tsetResult(variableAccess.clone());\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtAssignment(CtAssignment<T, A> variableAssignment) {\n\t\tCtAssignment<T, A> a = variableAssignment.clone();\n\t\ta.setAssignment(evaluate(a.getAssignment()));\n\t\tsetResult(a);\n\t}\n\n\t@Override\n\tpublic void visitCtWhile(CtWhile whileLoop) {\n\t\tCtWhile w = whileLoop.clone();\n\t\tw.setLoopingExpression(evaluate(whileLoop.getLoopingExpression()));\n\t\t// If lopping Expression always false\n\t\tif ((whileLoop.getLoopingExpression() instanceof CtLiteral) && !((CtLiteral<Boolean>) whileLoop\n\t\t\t\t.getLoopingExpression()).getValue()) {\n\t\t\tsetResult(null);\n\t\t\treturn;\n\t\t}\n\t\tw.setBody(evaluate(whileLoop.getBody()));\n\t\tsetResult(w);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConditional(CtConditional<T> conditional) {\n\t\tCtExpression<Boolean> r = evaluate(conditional.getCondition());\n\t\tif (r instanceof CtLiteral) {\n\t\t\tCtLiteral<Boolean> l = (CtLiteral<Boolean>) r;\n\t\t\tif (l.getValue()) {\n\t\t\t\tsetResult(evaluate(conditional.getThenExpression()));\n\t\t\t} else {\n\t\t\t\tsetResult(evaluate(conditional.getElseExpression()));\n\t\t\t}\n\t\t} else {\n\t\t\tCtConditional<T> ifRes = conditional.getFactory().Core().createConditional();\n\t\t\tifRes.setCondition(r);\n\t\t\tifRes.setThenExpression(evaluate(conditional.getThenExpression()));\n\t\t\tifRes.setElseExpression(evaluate(conditional.getElseExpression()));\n\t\t\tsetResult(ifRes);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/ActionBasedChangeListenerImpl.java",
      "weight" : 114.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport spoon.support.modelobs.action.Action;\nimport spoon.support.modelobs.action.AddAction;\nimport spoon.support.modelobs.action.DeleteAction;\nimport spoon.support.modelobs.action.DeleteAllAction;\nimport spoon.support.modelobs.action.UpdateAction;\nimport spoon.support.modelobs.context.ListContext;\nimport spoon.support.modelobs.context.MapContext;\nimport spoon.support.modelobs.context.ObjectContext;\nimport spoon.support.modelobs.context.SetContext;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This listener will propagate the change to the listener\n */\npublic abstract class ActionBasedChangeListenerImpl implements ActionBasedChangeListener, FineModelChangeListener {\n\n\tprivate void propagateModelChange(final Action action) {\n\t\tthis.onAction(action);\n\t\tif (action instanceof DeleteAllAction) {\n\t\t\tthis.onDeleteAll((DeleteAllAction) action);\n\t\t} else if (action instanceof DeleteAction) {\n\t\t\tthis.onDelete((DeleteAction) action);\n\t\t} else if (action instanceof AddAction) {\n\t\t\tthis.onAdd((AddAction) action);\n\t\t} else if (action instanceof UpdateAction) {\n\t\t\tthis.onUpdate((UpdateAction) action);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onObjectUpdate(CtElement currentElement, CtRole role, CtElement newValue, CtElement oldValue) {\n\t\tpropagateModelChange(new UpdateAction<>(new ObjectContext(currentElement, role), newValue, oldValue));\n\t}\n\n\t@Override\n\tpublic void onObjectUpdate(CtElement currentElement, CtRole role, Object newValue, Object oldValue) {\n\t\tpropagateModelChange(new UpdateAction<>(new ObjectContext(currentElement, role), newValue, oldValue));\n\t}\n\n\t@Override\n\tpublic void onObjectDelete(CtElement currentElement, CtRole role, CtElement oldValue) {\n\t\tpropagateModelChange(new DeleteAction<>(new ObjectContext(currentElement, role), oldValue));\n\t}\n\n\t@Override\n\tpublic void onListAdd(CtElement currentElement, CtRole role, List field, CtElement newValue) {\n\t\tpropagateModelChange(new AddAction<>(new ListContext(currentElement, role, field), newValue));\n\t}\n\n\t@Override\n\tpublic void onListAdd(CtElement currentElement, CtRole role, List field, int index, CtElement newValue) {\n\t\tpropagateModelChange(new AddAction<>(new ListContext(currentElement, role, field, index), newValue));\n\t}\n\n\t@Override\n\tpublic void onListDelete(CtElement currentElement, CtRole role, List field, Collection<? extends CtElement> oldValue) {\n\t\tfor (CtElement ctElement : oldValue) {\n\t\t\tonListDelete(currentElement, role, field, field.indexOf(ctElement), ctElement);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onListDelete(CtElement currentElement, CtRole role, List field, int index, CtElement oldValue) {\n\t\tpropagateModelChange(new DeleteAction<>(new ListContext(currentElement, role, field, index), oldValue));\n\t}\n\n\t@Override\n\tpublic void onListDeleteAll(CtElement currentElement, CtRole role, List field, List oldValue) {\n\t\tpropagateModelChange(new DeleteAllAction(new ListContext(currentElement, role, field), oldValue));\n\t}\n\n\t@Override\n\tpublic <K, V> void onMapAdd(CtElement currentElement, CtRole role, Map<K, V> field, K key, CtElement newValue) {\n\t\tpropagateModelChange(new AddAction<>(new MapContext<>(currentElement, role, field, key), newValue));\n\t}\n\n\t@Override\n\tpublic <K, V> void onMapDeleteAll(CtElement currentElement, CtRole role, Map<K, V> field, Map<K, V> oldValue) {\n\t\tpropagateModelChange(new DeleteAllAction(new MapContext<>(currentElement, role, field), oldValue));\n\t}\n\n\t@Override\n\tpublic void onSetAdd(CtElement currentElement, CtRole role, Set field, CtElement newValue) {\n\t\tpropagateModelChange(new AddAction<>(new SetContext(currentElement, role, field), newValue));\n\t}\n\n\t@Override\n\tpublic  <T extends Enum> void onSetAdd(CtElement currentElement, CtRole role, Set field, T newValue) {\n\t\tpropagateModelChange(new AddAction<>(new SetContext(currentElement, role, field), newValue));\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, CtElement oldValue) {\n\t\tpropagateModelChange(new DeleteAction<>(new SetContext(currentElement, role, field), oldValue));\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, Collection<ModifierKind> oldValue) {\n\t\tfor (ModifierKind modifierKind : oldValue) {\n\t\t\tonSetDelete(currentElement, role, field, modifierKind);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, ModifierKind oldValue) {\n\t\tpropagateModelChange(new DeleteAction<>(new SetContext(currentElement, role, field), oldValue));\n\t}\n\n\t@Override\n\tpublic void onSetDeleteAll(CtElement currentElement, CtRole role, Set field, Set oldValue) {\n\t\tpropagateModelChange(new DeleteAllAction(new SetContext(currentElement, role, field), oldValue));\n\t}\n\n\t@Override\n\tpublic void onDelete(DeleteAction action) {\n\t}\n\n\t@Override\n\tpublic void onDeleteAll(DeleteAllAction action) {\n\t}\n\n\t@Override\n\tpublic void onAdd(AddAction action) {\n\t}\n\n\t@Override\n\tpublic void onUpdate(UpdateAction action) {\n\t}\n\n\t@Override\n\tpublic void onAction(Action action) {\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/SourceFragmentCreator.java",
      "weight" : 18.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.sniper.internal.ElementSourceFragment;\n\n/**\n * A {@link ChangeCollector}, which builds a tree of {@link ElementSourceFragment}s of {@link CompilationUnit} of the modified element\n * lazily just before the element is changed\n */\npublic class SourceFragmentCreator extends ChangeCollector {\n\t@Override\n\tprotected void onChange(CtElement currentElement, CtRole role) {\n\t\tif (!currentElement.isParentInitialized()) {\n\t\t\t//parent is not initialized. It is just creation of a temporary element\n\t\t\t//ignore such \"change\"\n\t\t\treturn;\n\t\t}\n\t\tCompilationUnit cu = currentElement.getPosition().getCompilationUnit();\n\t\tif (cu != null) {\n\t\t\t//getOriginalSourceFragment is not only a getter, it actually\n\t\t\t//builds a tree of SourceFragments of compilation unit of the modified element\n\t\t\tcu.getOriginalSourceFragment();\n\t\t}\n\t\tsuper.onChange(currentElement, role);\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/EmptyModelChangeListener.java",
      "weight" : 79.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * is the listener that creates the action on the model. This default listener does nothing.\n */\npublic class EmptyModelChangeListener implements FineModelChangeListener {\n\n\t@Override\n\tpublic void onObjectUpdate(CtElement currentElement, CtRole role,\n\t\t\tCtElement newValue, CtElement oldValue) {\n\t}\n\n\t@Override\n\tpublic void onObjectUpdate(CtElement currentElement, CtRole role,\n\t\t\tObject newValue, Object oldValue) {\n\t}\n\n\t@Override\n\tpublic void onObjectDelete(CtElement currentElement, CtRole role,\n\t\t\tCtElement oldValue) {\n\t}\n\n\t@Override\n\tpublic void onListAdd(CtElement currentElement, CtRole role, List field,\n\t\t\tCtElement newValue) {\n\t}\n\n\t@Override\n\tpublic void onListAdd(CtElement currentElement, CtRole role, List field,\n\t\t\tint index, CtElement newValue) {\n\t}\n\n\n\t@Override\n\tpublic void onListDelete(CtElement currentElement, CtRole role, List field,\n\t\t\tCollection<? extends CtElement> oldValue) {\n\t\tfor (CtElement ctElement : oldValue) {\n\t\t\tonListDelete(currentElement, role, field, field.indexOf(ctElement), ctElement);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onListDelete(CtElement currentElement, CtRole role, List field,\n\t\t\tint index, CtElement oldValue) {\n\t}\n\n\n\t@Override\n\tpublic void onListDeleteAll(CtElement currentElement, CtRole role,\n\t\t\tList field, List oldValue) {\n\t}\n\n\n\t@Override\n\tpublic <K, V> void onMapAdd(CtElement currentElement, CtRole role,\n\t\t\tMap<K, V> field, K key, CtElement newValue) {\n\t}\n\n\t@Override\n\tpublic <K, V> void onMapDeleteAll(CtElement currentElement, CtRole role,\n\t\t\tMap<K, V> field, Map<K, V> oldValue) {\n\t}\n\n\t@Override\n\tpublic void onSetAdd(CtElement currentElement, CtRole role, Set field,\n\t\t\tCtElement newValue) {\n\t}\n\n\t@Override\n\tpublic <T extends Enum> void onSetAdd(CtElement currentElement, CtRole role, Set field,\n\t\t\tT newValue) {\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field,\n\t\t\tCtElement oldValue) {\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, Collection<ModifierKind> oldValue) {\n\t\tfor (ModifierKind modifierKind : oldValue) {\n\t\t\tonSetDelete(currentElement, role, field, modifierKind);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field,\n\t\t\tModifierKind oldValue) {\n\t}\n\n\t@Override\n\tpublic void onSetDeleteAll(CtElement currentElement, CtRole role, Set field,\n\t\t\tSet oldValue) {\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/FineModelChangeListener.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/** Can be subclassed by clients who want to be notified on all changes in AST nodes */\npublic interface FineModelChangeListener {\n\t/** a field corresponding to the role is being set in the AST node */\n\tvoid onObjectUpdate(CtElement currentElement, CtRole role, CtElement newValue, CtElement oldValue);\n\n\t/** a field corresponding to the role is being set in the AST node */\n\tvoid onObjectUpdate(CtElement currentElement, CtRole role, Object newValue, Object oldValue);\n\n\t/** a field corresponding to the role is being set to null */\n\tvoid onObjectDelete(CtElement currentElement, CtRole role, CtElement oldValue);\n\n\t/** a newValue is appended to the list corresponding to the role in the AST node */\n\tvoid onListAdd(CtElement currentElement, CtRole role, List field, CtElement newValue);\n\n\t/** a newValue is appended to the list corresponding to the role in the AST node */\n\tvoid onListAdd(CtElement currentElement, CtRole role, List field, int index, CtElement newValue);\n\n\t/** an oldValue is deleted in the list corresponding to the role in the AST node */\n\tvoid onListDelete(CtElement currentElement, CtRole role, List field, Collection<? extends CtElement> oldValue);\n\n\t/** an oldValue is deleted in the list corresponding to the role in the AST node */\n\tvoid onListDelete(CtElement currentElement, CtRole role, List field, int index, CtElement oldValue);\n\n\t/** a list corresponding to the role in the AST node is emptied */\n\tvoid onListDeleteAll(CtElement currentElement, CtRole role, List field, List oldValue);\n\n\t/** a newValue is appended to the map corresponding to the role in the AST node */\n\t<K, V> void onMapAdd(CtElement currentElement, CtRole role, Map<K, V> field, K key, CtElement newValue);\n\n\t/** a map corresponding to the role in the AST node is emptied */\n\t<K, V> void onMapDeleteAll(CtElement currentElement, CtRole role, Map<K, V> field, Map<K, V> oldValue);\n\n\t/** a newValue is appended to the set corresponding to the role in the AST node */\n\tvoid onSetAdd(CtElement currentElement, CtRole role, Set field, CtElement newValue);\n\n\t/** a newValue is appended to the set corresponding to the role in the AST node */\n\t<T extends Enum> void onSetAdd(CtElement currentElement, CtRole role, Set field, T newValue);\n\n\t/** an oldValue is deleted in the set corresponding to the role in the AST node */\n\tvoid onSetDelete(CtElement currentElement, CtRole role, Set field, CtElement oldValue);\n\n\t/** an oldValue is deleted in the set corresponding to the role in the AST node */\n\tvoid onSetDelete(CtElement currentElement, CtRole role, Set field, Collection<ModifierKind> oldValue);\n\n\t/** an oldValue is deleted in the set corresponding to the role in the AST node */\n\tvoid onSetDelete(CtElement currentElement, CtRole role, Set field, ModifierKind oldValue);\n\n\t/** a set corresponding to the role in the AST node is emptied */\n\tvoid onSetDeleteAll(CtElement currentElement, CtRole role, Set field, Set oldValue);\n}\n"
    }, {
      "name" : "support/modelobs/context/MapContext.java",
      "weight" : 22.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Map;\n\n/**\n * defines the map context\n * @param <K>\n * @param <V>\n */\npublic class MapContext<K, V> extends Context {\n\tprivate final Map<K, V> map;\n\tprivate  K key;\n\n\tpublic MapContext(CtElement element, CtRole role, Map<K, V> map) {\n\t\tsuper(element, role);\n\t\tthis.map = map;\n\t}\n\n\tpublic MapContext(CtElement element, CtRole role, Map<K, V> map, K key) {\n\t\tthis(element, role, map);\n\t\tthis.key = key;\n\t}\n\n\t/**\n\t * get the changed key\n\t * @return the changed key\n\t */\n\tpublic K getKey() {\n\t\treturn key;\n\t}\n\n\t/**\n\t * the changed map\n\t * @return the changed map\n\t */\n\tpublic Map<K, V> getMap() {\n\t\treturn map;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/context/ObjectContext.java",
      "weight" : 8.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\npublic class ObjectContext extends Context {\n\n\tpublic ObjectContext(CtElement ctElement, CtRole role) {\n\t\tsuper(ctElement, role);\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/context/ListContext.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.List;\n\n/**\n * defines a list context\n */\npublic class ListContext extends CollectionContext<List<?>> {\n\tprivate final int position;\n\n\tpublic ListContext(CtElement element, CtRole role, List<?> original) {\n\t\tthis(element, role, original, -1);\n\t}\n\n\tpublic ListContext(CtElement element, CtRole role, List<?> original, int position) {\n\t\tsuper(element, role, original);\n\t\tthis.position = position;\n\t}\n\n\t/**\n\t * the position where the change has been made (returns -1 if no position is defined).\n\t *\n\t * @return the position of the change\n\t */\n\tpublic int getPosition() {\n\t\treturn position;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/context/Context.java",
      "weight" : 17.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\n/**\n * defines the context of an action\n */\npublic abstract class Context {\n\tprivate CtElement elementWhereChangeHappens;\n\tprivate CtRole changedProperty;\n\n\tpublic Context(CtElement element, CtRole changedProperty) {\n\t\tthis.elementWhereChangeHappens = element;\n\t\tthis.changedProperty = changedProperty;\n\t}\n\n\t/**\n\t * the changed parent\n\t * @return the changed parent\n\t */\n\tpublic CtElement getElementWhereChangeHappens() {\n\t\treturn elementWhereChangeHappens;\n\t}\n\n\t/**\n\t * the role that has been modified\n\t * @return the role that has been modified\n\t */\n\tpublic CtRole getChangedProperty() {\n\t\treturn changedProperty;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/context/CollectionContext.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Collection;\n\npublic abstract class CollectionContext<T extends Collection<?>> extends Context {\n\tprotected final T copyOfTheCollection;\n\n\tpublic CollectionContext(CtElement element, CtRole role, T copyOfTheCollection) {\n\t\tsuper(element, role);\n\t\tthis.copyOfTheCollection = copyOfTheCollection;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/context/SetContext.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.context;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\n\nimport java.util.Set;\n\npublic class SetContext extends CollectionContext<Set<?>> {\n\n\tpublic SetContext(CtElement element, CtRole role, Set<?> original) {\n\t\tsuper(element, role, original);\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/action/DeleteAllAction.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.action;\n\nimport spoon.support.modelobs.context.Context;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * defines the delete all action.\n * @param <T>\n */\npublic class DeleteAllAction<T> extends DeleteAction<T> {\n\n\tpublic DeleteAllAction(Context context, Collection oldValue) {\n\t\tsuper(context, (T) oldValue);\n\t}\n\n\tpublic DeleteAllAction(Context context, Map oldValue) {\n\t\tsuper(context, (T) oldValue);\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/action/Action.java",
      "weight" : 12.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.action;\n\nimport spoon.support.modelobs.context.Context;\n\n/**\n * defines an action change on the model\n */\npublic abstract class Action {\n\tprivate final Context context;\n\n\tAction(Context context) {\n\t\tthis.context = context;\n\t}\n\n\t/**\n\t * get the changed value of the model\n\t * @param <T> the type of the element\n\t * @return the changed value\n\t */\n\tpublic abstract <T> T getChangedValue();\n\n\t/**\n\t * get the context of the change\n\t * @return the context\n\t */\n\tpublic Context getContext() {\n\t\treturn context;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/action/UpdateAction.java",
      "weight" : 21.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.action;\n\nimport spoon.support.modelobs.context.Context;\n\n/**\n * defines the update action\n * @param <T>\n */\npublic class UpdateAction<T> extends Action {\n\tprivate final T oldValue;\n\tprivate final T newValue;\n\n\tpublic UpdateAction(Context context, T newValue, T oldValue) {\n\t\tsuper(context);\n\t\tthis.oldValue = oldValue;\n\t\tthis.newValue = newValue;\n\t}\n\n\t@Override\n\tpublic T getChangedValue() {\n\t\treturn getNewValue();\n\t}\n\n\t/**\n\t * the new value in the model\n\t * @return the new value\n\t */\n\tpublic T getNewValue() {\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * the old value in the model\n\t * @return the old value\n\t */\n\tpublic T getOldValue() {\n\t\treturn oldValue;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/action/AddAction.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.action;\n\nimport spoon.support.modelobs.context.Context;\n\npublic class AddAction<T>  extends Action {\n\tprivate T newValue;\n\n\tpublic AddAction(Context context, T newValue) {\n\t\tsuper(context);\n\t\tthis.newValue = newValue;\n\t}\n\n\t@Override\n\tpublic T getChangedValue() {\n\t\treturn getNewValue();\n\t}\n\n\t/**\n\t * Returns the added element\n\t * @return the new element\n\t */\n\tpublic T getNewValue() {\n\t\treturn newValue;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/action/DeleteAction.java",
      "weight" : 16.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs.action;\n\nimport spoon.support.modelobs.context.Context;\n\n/**\n * defines the delete action\n * @param <T>\n */\npublic class DeleteAction<T> extends Action {\n\tprivate T oldValue;\n\n\tpublic DeleteAction(Context context, T oldValue) {\n\t\tsuper(context);\n\t\tthis.oldValue = oldValue;\n\t}\n\n\t@Override\n\tpublic T getChangedValue() {\n\t\treturn getRemovedValue();\n\t}\n\n\t/**\n\t * Returns the removed element\n\t * @return the removed element\n\t */\n\tpublic T getRemovedValue() {\n\t\treturn oldValue;\n\t}\n}\n"
    }, {
      "name" : "support/modelobs/ActionBasedChangeListener.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport spoon.support.modelobs.action.Action;\nimport spoon.support.modelobs.action.AddAction;\nimport spoon.support.modelobs.action.DeleteAction;\nimport spoon.support.modelobs.action.DeleteAllAction;\nimport spoon.support.modelobs.action.UpdateAction;\n\n/**\n * notifies all change on the AST\n */\npublic interface ActionBasedChangeListener {\n\t/**\n\t * when an element is removed\n\t * @param action contains information of the change\n\t */\n\tvoid onDelete(DeleteAction action);\n\n\t/**\n\t * when all element are removed\n\t * @param action contains information of the change\n\t */\n\tvoid onDeleteAll(DeleteAllAction action);\n\n\t/**\n\t * when an element is added\n\t * @param action contains information of the change\n\t */\n\tvoid onAdd(AddAction action);\n\n\t/**\n\t * when an element is modified\n\t * @param action contains information of the change\n\t */\n\tvoid onUpdate(UpdateAction action);\n\n\t/**\n\t * when an element is changed\n\t * @param action contains information of the change\n\t */\n\tvoid onAction(Action action);\n}\n"
    }, {
      "name" : "support/modelobs/ChangeCollector.java",
      "weight" : 166.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.modelobs;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport spoon.compiler.Environment;\nimport spoon.reflect.CtModel;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.EarlyTerminatingScanner;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\n\n/**\n * Listens on changes  on the spoon model and remembers them\n */\npublic class ChangeCollector {\n\tprivate final Map<CtElement, Set<CtRole>> elementToChangeRole = new IdentityHashMap<>();\n\tprivate final ChangeListener changeListener = new ChangeListener();\n\n\t/**\n\t * @param env to be checked {@link Environment}\n\t * @return {@link ChangeCollector} attached to the `env` or null if there is none\n\t */\n\tpublic static ChangeCollector getChangeCollector(Environment env) {\n\t\tFineModelChangeListener mcl = env.getModelChangeListener();\n\t\tif (mcl instanceof ChangeListener) {\n\t\t\treturn ((ChangeListener) mcl).getChangeCollector();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Allows to run code using change collector switched off.\n\t * It means that any change of spoon model done by the `runnable` is ignored by the change collector.\n\t * Note: it is actually needed to wrap CtElement#toString() calls which sometime modifies spoon model.\n\t * See TestSniperPrinter#testPrintChangedReferenceBuilder()\n\t * @param env Spoon environment\n\t * @param runnable the code to be run\n\t */\n\tpublic static void runWithoutChangeListener(Environment env, Runnable runnable) {\n\t\tFineModelChangeListener mcl = env.getModelChangeListener();\n\t\tif (mcl instanceof ChangeListener) {\n\t\t\tenv.setModelChangeListener(new EmptyModelChangeListener());\n\t\t\ttry {\n\t\t\t\trunnable.run();\n\t\t\t} finally {\n\t\t\t\tenv.setModelChangeListener(mcl);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Attaches itself to {@link CtModel} to listen to all changes of it's child elements\n\t * TODO: it would be nicer if we might listen on changes on {@link CtElement}\n\t * @param env to be attached to {@link Environment}\n\t * @return this to support fluent API\n\t */\n\tpublic ChangeCollector attachTo(Environment env) {\n\t\tenv.setModelChangeListener(changeListener);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param currentElement the {@link CtElement} whose changes has to be checked\n\t * @return set of {@link CtRole}s whose attribute was directly changed on `currentElement` since this {@link ChangeCollector} was attached\n\t * The 'directly' means that value of attribute of `currentElement` was changed.\n\t * Use {@link #getChanges(CtElement)} to detect changes in child elements too\n\t */\n\tpublic Set<CtRole> getDirectChanges(CtElement currentElement) {\n\t\tSet<CtRole> changes = elementToChangeRole.get(currentElement);\n\t\tif (changes == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\treturn Collections.unmodifiableSet(changes);\n\t}\n\n\t/**\n\t * @param currentElement the {@link CtElement} whose changes has to be checked\n\t * @return set of {@link CtRole}s whose attribute was changed on `currentElement`\n\t * or any child of this attribute was changed\n\t * since this {@link ChangeCollector} was attached\n\t */\n\tpublic Set<CtRole> getChanges(CtElement currentElement) {\n\t\tfinal Set<CtRole> changes = new HashSet<>(getDirectChanges(currentElement));\n\t\tfinal Scanner scanner = new Scanner();\n\t\tscanner.setListener(new CtScannerListener() {\n\t\t\tint depth = 0;\n\t\t\tCtRole checkedRole;\n\t\t\t@Override\n\t\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\t\tif (depth == 0) {\n\t\t\t\t\t//we are checking children of role checkedRole\n\t\t\t\t\tcheckedRole = scanner.getScannedRole();\n\t\t\t\t}\n\t\t\t\tif (changes.contains(checkedRole)) {\n\t\t\t\t\t//we already know that some child of `checkedRole` attribute is modified. Skip others\n\t\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t\t}\n\t\t\t\tif (elementToChangeRole.containsKey(element)) {\n\t\t\t\t\t//we have found a modified element in children of `checkedRole`\n\t\t\t\t\tchanges.add(checkedRole);\n\t\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t\t}\n\t\t\t\tdepth++;\n\t\t\t\t//continue searching for an modification\n\t\t\t\treturn ScanningMode.NORMAL;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void exit(CtElement element) {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t});\n\t\tcurrentElement.accept(scanner);\n\t\treturn Collections.unmodifiableSet(changes);\n\t}\n\n\tprivate static class Scanner extends EarlyTerminatingScanner<Void> {\n\t\tScanner() {\n\t\t\tsetVisitCompilationUnitContent(true);\n\t\t}\n\t\tCtRole getScannedRole() {\n\t\t\treturn scannedRole;\n\t\t}\n\t}\n\n\t/**\n\t * Called whenever anything changes in the spoon model\n\t * @param currentElement the modified element\n\t * @param role the modified attribute of that element\n\t */\n\tprotected void onChange(CtElement currentElement, CtRole role) {\n\t\tSet<CtRole> roles = elementToChangeRole.get(currentElement);\n\t\tif (roles == null) {\n\t\t\troles = new HashSet<>();\n\t\t\telementToChangeRole.put(currentElement, roles);\n\t\t}\n\t\tif (role.getSuperRole() != null) {\n\t\t\trole = role.getSuperRole();\n\t\t}\n\t\troles.add(role);\n\t}\n\n\tprivate class ChangeListener implements FineModelChangeListener {\n\t\tprivate ChangeCollector getChangeCollector() {\n\t\t\treturn ChangeCollector.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onObjectUpdate(CtElement currentElement, CtRole role, CtElement newValue, CtElement oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onObjectUpdate(CtElement currentElement, CtRole role, Object newValue, Object oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onObjectDelete(CtElement currentElement, CtRole role, CtElement oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListAdd(CtElement currentElement, CtRole role, List field, CtElement newValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListAdd(CtElement currentElement, CtRole role, List field, int index, CtElement newValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListDelete(CtElement currentElement, CtRole role, List field, Collection<? extends CtElement> oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListDelete(CtElement currentElement, CtRole role, List field, int index, CtElement oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onListDeleteAll(CtElement currentElement, CtRole role, List field, List oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic <K, V> void onMapAdd(CtElement currentElement, CtRole role, Map<K, V> field, K key, CtElement newValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic <K, V> void onMapDeleteAll(CtElement currentElement, CtRole role, Map<K, V> field, Map<K, V> oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSetAdd(CtElement currentElement, CtRole role, Set field, CtElement newValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T extends Enum> void onSetAdd(CtElement currentElement, CtRole role, Set field, T newValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, CtElement oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, Collection<ModifierKind> oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSetDelete(CtElement currentElement, CtRole role, Set field, ModifierKind oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSetDeleteAll(CtElement currentElement, CtRole role, Set field, Set oldValue) {\n\t\t\tonChange(currentElement, role);\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/JavaOutputProcessor.java",
      "weight" : 158.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.compiler.Environment;\nimport spoon.processing.AbstractProcessor;\nimport spoon.processing.FileGenerator;\nimport spoon.processing.TraversalStrategy;\nimport spoon.reflect.cu.CompilationUnit;\nimport spoon.reflect.declaration.CtModule;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.visitor.PrettyPrinter;\nimport spoon.support.compiler.SpoonProgress;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A processor that generates compilable Java source files from the meta-model.\n */\npublic class JavaOutputProcessor extends AbstractProcessor<CtNamedElement> implements FileGenerator<CtNamedElement> {\n\tPrettyPrinter printer;\n\n\tList<File> printedFiles = new ArrayList<>();\n\n\t/**\n\t * @param printer  the PrettyPrinter to use for written the files\n\t */\n\tpublic JavaOutputProcessor(PrettyPrinter printer) {\n\t\tthis.printer = printer;\n\t}\n\n\t/**\n\t * Such processor will use printer created by {@link Environment#createPrettyPrinter()}\n\t */\n\tpublic JavaOutputProcessor() {\n\t}\n\n\t@Override\n\tpublic Environment getEnvironment() {\n\t\treturn this.getFactory().getEnvironment();\n\t}\n\n\tpublic PrettyPrinter getPrinter() {\n\t\tif (printer == null) {\n\t\t\t//create printer using CURRENT Environment settings\n\t\t\treturn getFactory().getEnvironment().createPrettyPrinter();\n\t\t}\n\t\treturn printer;\n\t}\n\n\t@Override\n\tpublic List<File> getCreatedFiles() {\n\t\treturn printedFiles;\n\t}\n\n\t@Override\n\tpublic File getOutputDirectory() {\n\t\treturn this.getEnvironment().getSourceOutputDirectory();\n\t}\n\n\t@Override\n\tpublic void init() {\n\t\t// Skip loading properties\n\t\t// super.init();\n\t\tFile directory = getOutputDirectory();\n\n\t\t// Check output directory\n\t\tif (directory == null) {\n\t\t\tthrow new SpoonException(\"You should set output directory before printing\");\n\t\t}\n\n\t\tif (!directory.exists()) {\n\t\t\tif (!directory.mkdirs()) {\n\t\t\t\tthrow new SpoonException(\"Error creating output directory\");\n\t\t\t}\n\t\t}\n\t}\n\n\tMap<String, Map<Integer, Integer>> lineNumberMappings = new HashMap<>();\n\n\t/**\n\t * Creates the Java file associated to the given element. Splits top-level\n\t * classes in different files (even if they are in the same file in the\n\t * original sources).\n\t */\n\tpublic void createJavaFile(CtType<?> element) {\n\t\tPath typePath = getElementPath(element);\n\n\t\t// we only create a file for top-level classes\n\t\tif (!element.isTopLevel()) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\tCompilationUnit cu = this.getFactory().CompilationUnit().getOrCreate(element);\n\t\tList<CtType<?>> toBePrinted = new ArrayList<>();\n\t\ttoBePrinted.add(element);\n\n\t\tPrettyPrinter printer = getPrinter();\n\t\tprinter.calculate(cu, toBePrinted);\n\n\n\t\ttry {\n\t\t\tFile file = typePath.toFile();\n\t\t\tfile.createNewFile();\n\t\t\tif (!printedFiles.contains(file)) {\n\t\t\t\tprintedFiles.add(file);\n\t\t\t}\n\t\t\t// print type\n\t\t\ttry (PrintStream stream = new PrintStream(file)) {\n\t\t\t\tstream.print(printer.getResult());\n\t\t\t\tfor (CtType<?> t : toBePrinted) {\n\t\t\t\t\tlineNumberMappings.put(t.getQualifiedName(), printer.getLineNumberMapping());\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t\tif (getEnvironment().getSpoonProgress() != null) {\n\t\t\tgetEnvironment().getSpoonProgress().step(SpoonProgress.Process.PRINT, element.getQualifiedName());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean isToBeProcessed(CtNamedElement candidate) {\n\t\treturn candidate instanceof CtType<?> || candidate instanceof CtModule || candidate instanceof CtPackage && (!candidate.getComments().isEmpty() || !candidate.getAnnotations().isEmpty());\n\t}\n\n\t/**\n\t * Creates a source file for each processed top-level type and pretty prints\n\t * its contents.\n\t */\n\t@Override\n\tpublic void process(CtNamedElement nameElement) {\n\t\tif (nameElement instanceof CtType && ((CtType) nameElement).isTopLevel()) {\n\t\t\tcreateJavaFile((CtType<?>) nameElement);\n\t\t} else if (nameElement instanceof CtPackage) {\n\t\t\tcreatePackageFile((CtPackage) nameElement);\n\t\t} else if (nameElement instanceof CtModule) {\n\t\t\tcreateModuleFile((CtModule) nameElement);\n\t\t}\n\t}\n\n\tprivate void createPackageFile(CtPackage pack) {\n\t\t// Create package annotation file\n\t\tFile packageAnnot = getElementPath(pack).toFile();\n\t\tif (!printedFiles.contains(packageAnnot)) {\n\t\t\tprintedFiles.add(packageAnnot);\n\t\t}\n\t\ttry (PrintStream stream = new PrintStream(packageAnnot)) {\n\t\t\tstream.println(getPrinter().printPackageInfo(pack));\n\t\t} catch (FileNotFoundException e) {\n\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t}\n\t}\n\n\tprivate void createModuleFile(CtModule module) {\n\t\tif (getEnvironment().getComplianceLevel() > 8 && module != getFactory().getModel().getUnnamedModule()) {\n\t\t\tFile moduleFile = getElementPath(module).toFile();\n\t\t\tif (!printedFiles.contains(moduleFile)) {\n\t\t\t\tprintedFiles.add(moduleFile);\n\t\t\t}\n\t\t\ttry (PrintStream stream = new PrintStream(moduleFile)) {\n\t\t\t\tstream.println(getPrinter().printModuleInfo(module));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tLauncher.LOGGER.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Path getElementPath(CtModule type) {\n\t\treturn createFolders(getEnvironment().getOutputDestinationHandler()\n\t\t\t\t.getOutputPath(type, null, null));\n\t}\n\n\tprivate Path getElementPath(CtPackage type) {\n\t\treturn createFolders(getEnvironment().getOutputDestinationHandler()\n\t\t\t\t.getOutputPath(type.getDeclaringModule(), type, null));\n\t}\n\n\tprivate Path getElementPath(CtType type) {\n\t\treturn createFolders(getEnvironment().getOutputDestinationHandler()\n\t\t\t\t.getOutputPath(type.getPackage().getDeclaringModule(),\n\t\t\t\t\t\ttype.getPackage(), type));\n\t}\n\n\tprivate Path createFolders(Path outputPath) {\n\t\tif (!outputPath.getParent().toFile().exists()) {\n\t\t\tif (!outputPath.getParent().toFile().mkdirs()) {\n\t\t\t\tthrow new RuntimeException(\"Error creating output directory\");\n\t\t\t}\n\t\t}\n\t\treturn outputPath;\n\t}\n\n\tpublic Map<String, Map<Integer, Integer>> getLineNumberMappings() {\n\t\treturn lineNumberMappings;\n\t}\n\n\t@Override\n\tpublic TraversalStrategy getTraversalStrategy() {\n\t\treturn TraversalStrategy.PRE_ORDER;\n\t}\n\n}\n"
    }, {
      "name" : "support/Experimental.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Tells that a type has recently been introduced and may be subject to non-backward compatible changes without deprecation.\n * The annotation is expected to be removed at the latest one year after its introduction (you can do a \"git blame\" to see when it appeared).\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.TYPE, ElementType.METHOD })\npublic @interface Experimental {\n}\n"
    }, {
      "name" : "support/visitor/clone/CloneVisitor.java",
      "weight" : 886.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.clone;\n\n\n/**\n * Used to clone a given element.\n *\n * This class is generated automatically by the processor spoon.generating.CloneVisitorGenerator.\n */\npublic class CloneVisitor extends spoon.reflect.visitor.CtScanner {\n\tprivate final spoon.support.visitor.equals.CloneHelper cloneHelper;\n\n\tprivate final spoon.support.visitor.clone.CloneBuilder builder = new spoon.support.visitor.clone.CloneBuilder();\n\n\tprivate spoon.reflect.declaration.CtElement other;\n\n\tpublic CloneVisitor(spoon.support.visitor.equals.CloneHelper cloneHelper) {\n\t\tthis.cloneHelper = cloneHelper;\n\t}\n\n\tpublic <T extends spoon.reflect.declaration.CtElement> T getClone() {\n\t\treturn ((T) (other));\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {\n\t\tspoon.reflect.declaration.CtAnnotation<A> aCtAnnotation = annotation.getFactory().Core().createAnnotation();\n\t\tthis.builder.copy(annotation, aCtAnnotation);\n\t\taCtAnnotation.setType(this.cloneHelper.clone(annotation.getType()));\n\t\taCtAnnotation.setComments(this.cloneHelper.clone(annotation.getComments()));\n\t\taCtAnnotation.setAnnotationType(this.cloneHelper.clone(annotation.getAnnotationType()));\n\t\taCtAnnotation.setAnnotations(this.cloneHelper.clone(annotation.getAnnotations()));\n\t\taCtAnnotation.setValues(this.cloneHelper.clone(annotation.getValues()));\n\t\tthis.cloneHelper.tailor(annotation, aCtAnnotation);\n\t\tthis.other = aCtAnnotation;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n\t\tspoon.reflect.declaration.CtAnnotationType<A> aCtAnnotationType = annotationType.getFactory().Core().createAnnotationType();\n\t\tthis.builder.copy(annotationType, aCtAnnotationType);\n\t\taCtAnnotationType.setAnnotations(this.cloneHelper.clone(annotationType.getAnnotations()));\n\t\taCtAnnotationType.setTypeMembers(this.cloneHelper.clone(annotationType.getTypeMembers()));\n\t\taCtAnnotationType.setComments(this.cloneHelper.clone(annotationType.getComments()));\n\t\tthis.cloneHelper.tailor(annotationType, aCtAnnotationType);\n\t\tthis.other = aCtAnnotationType;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtAnonymousExecutable(final spoon.reflect.declaration.CtAnonymousExecutable anonymousExec) {\n\t\tspoon.reflect.declaration.CtAnonymousExecutable aCtAnonymousExecutable = anonymousExec.getFactory().Core().createAnonymousExecutable();\n\t\tthis.builder.copy(anonymousExec, aCtAnonymousExecutable);\n\t\taCtAnonymousExecutable.setAnnotations(this.cloneHelper.clone(anonymousExec.getAnnotations()));\n\t\taCtAnonymousExecutable.setBody(this.cloneHelper.clone(anonymousExec.getBody()));\n\t\taCtAnonymousExecutable.setComments(this.cloneHelper.clone(anonymousExec.getComments()));\n\t\tthis.cloneHelper.tailor(anonymousExec, aCtAnonymousExecutable);\n\t\tthis.other = aCtAnonymousExecutable;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayRead(final spoon.reflect.code.CtArrayRead<T> arrayRead) {\n\t\tspoon.reflect.code.CtArrayRead<T> aCtArrayRead = arrayRead.getFactory().Core().createArrayRead();\n\t\tthis.builder.copy(arrayRead, aCtArrayRead);\n\t\taCtArrayRead.setAnnotations(this.cloneHelper.clone(arrayRead.getAnnotations()));\n\t\taCtArrayRead.setType(this.cloneHelper.clone(arrayRead.getType()));\n\t\taCtArrayRead.setTypeCasts(this.cloneHelper.clone(arrayRead.getTypeCasts()));\n\t\taCtArrayRead.setTarget(this.cloneHelper.clone(arrayRead.getTarget()));\n\t\taCtArrayRead.setIndexExpression(this.cloneHelper.clone(arrayRead.getIndexExpression()));\n\t\taCtArrayRead.setComments(this.cloneHelper.clone(arrayRead.getComments()));\n\t\tthis.cloneHelper.tailor(arrayRead, aCtArrayRead);\n\t\tthis.other = aCtArrayRead;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayWrite(final spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n\t\tspoon.reflect.code.CtArrayWrite<T> aCtArrayWrite = arrayWrite.getFactory().Core().createArrayWrite();\n\t\tthis.builder.copy(arrayWrite, aCtArrayWrite);\n\t\taCtArrayWrite.setAnnotations(this.cloneHelper.clone(arrayWrite.getAnnotations()));\n\t\taCtArrayWrite.setType(this.cloneHelper.clone(arrayWrite.getType()));\n\t\taCtArrayWrite.setTypeCasts(this.cloneHelper.clone(arrayWrite.getTypeCasts()));\n\t\taCtArrayWrite.setTarget(this.cloneHelper.clone(arrayWrite.getTarget()));\n\t\taCtArrayWrite.setIndexExpression(this.cloneHelper.clone(arrayWrite.getIndexExpression()));\n\t\taCtArrayWrite.setComments(this.cloneHelper.clone(arrayWrite.getComments()));\n\t\tthis.cloneHelper.tailor(arrayWrite, aCtArrayWrite);\n\t\tthis.other = aCtArrayWrite;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtArrayTypeReference(final spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtArrayTypeReference<T> aCtArrayTypeReference = reference.getFactory().Core().createArrayTypeReference();\n\t\tthis.builder.copy(reference, aCtArrayTypeReference);\n\t\taCtArrayTypeReference.setPackage(this.cloneHelper.clone(reference.getPackage()));\n\t\taCtArrayTypeReference.setDeclaringType(this.cloneHelper.clone(reference.getDeclaringType()));\n\t\taCtArrayTypeReference.setComponentType(this.cloneHelper.clone(reference.getComponentType()));\n\t\taCtArrayTypeReference.setActualTypeArguments(this.cloneHelper.clone(reference.getActualTypeArguments()));\n\t\taCtArrayTypeReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtArrayTypeReference);\n\t\tthis.other = aCtArrayTypeReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtAssert(final spoon.reflect.code.CtAssert<T> asserted) {\n\t\tspoon.reflect.code.CtAssert<T> aCtAssert = asserted.getFactory().Core().createAssert();\n\t\tthis.builder.copy(asserted, aCtAssert);\n\t\taCtAssert.setAnnotations(this.cloneHelper.clone(asserted.getAnnotations()));\n\t\taCtAssert.setAssertExpression(this.cloneHelper.clone(asserted.getAssertExpression()));\n\t\taCtAssert.setExpression(this.cloneHelper.clone(asserted.getExpression()));\n\t\taCtAssert.setComments(this.cloneHelper.clone(asserted.getComments()));\n\t\tthis.cloneHelper.tailor(asserted, aCtAssert);\n\t\tthis.other = aCtAssert;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T, A extends T> void visitCtAssignment(final spoon.reflect.code.CtAssignment<T, A> assignement) {\n\t\tspoon.reflect.code.CtAssignment<T, A> aCtAssignment = assignement.getFactory().Core().createAssignment();\n\t\tthis.builder.copy(assignement, aCtAssignment);\n\t\taCtAssignment.setAnnotations(this.cloneHelper.clone(assignement.getAnnotations()));\n\t\taCtAssignment.setType(this.cloneHelper.clone(assignement.getType()));\n\t\taCtAssignment.setTypeCasts(this.cloneHelper.clone(assignement.getTypeCasts()));\n\t\taCtAssignment.setAssigned(this.cloneHelper.clone(assignement.getAssigned()));\n\t\taCtAssignment.setAssignment(this.cloneHelper.clone(assignement.getAssignment()));\n\t\taCtAssignment.setComments(this.cloneHelper.clone(assignement.getComments()));\n\t\tthis.cloneHelper.tailor(assignement, aCtAssignment);\n\t\tthis.other = aCtAssignment;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtBinaryOperator(final spoon.reflect.code.CtBinaryOperator<T> operator) {\n\t\tspoon.reflect.code.CtBinaryOperator<T> aCtBinaryOperator = operator.getFactory().Core().createBinaryOperator();\n\t\tthis.builder.copy(operator, aCtBinaryOperator);\n\t\taCtBinaryOperator.setAnnotations(this.cloneHelper.clone(operator.getAnnotations()));\n\t\taCtBinaryOperator.setType(this.cloneHelper.clone(operator.getType()));\n\t\taCtBinaryOperator.setTypeCasts(this.cloneHelper.clone(operator.getTypeCasts()));\n\t\taCtBinaryOperator.setLeftHandOperand(this.cloneHelper.clone(operator.getLeftHandOperand()));\n\t\taCtBinaryOperator.setRightHandOperand(this.cloneHelper.clone(operator.getRightHandOperand()));\n\t\taCtBinaryOperator.setComments(this.cloneHelper.clone(operator.getComments()));\n\t\tthis.cloneHelper.tailor(operator, aCtBinaryOperator);\n\t\tthis.other = aCtBinaryOperator;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <R> void visitCtBlock(final spoon.reflect.code.CtBlock<R> block) {\n\t\tspoon.reflect.code.CtBlock<R> aCtBlock = block.getFactory().Core().createBlock();\n\t\tthis.builder.copy(block, aCtBlock);\n\t\taCtBlock.setAnnotations(this.cloneHelper.clone(block.getAnnotations()));\n\t\taCtBlock.setStatements(this.cloneHelper.clone(block.getStatements()));\n\t\taCtBlock.setComments(this.cloneHelper.clone(block.getComments()));\n\t\tthis.cloneHelper.tailor(block, aCtBlock);\n\t\tthis.other = aCtBlock;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtBreak(final spoon.reflect.code.CtBreak breakStatement) {\n\t\tspoon.reflect.code.CtBreak aCtBreak = breakStatement.getFactory().Core().createBreak();\n\t\tthis.builder.copy(breakStatement, aCtBreak);\n\t\taCtBreak.setAnnotations(this.cloneHelper.clone(breakStatement.getAnnotations()));\n\t\taCtBreak.setComments(this.cloneHelper.clone(breakStatement.getComments()));\n\t\tthis.cloneHelper.tailor(breakStatement, aCtBreak);\n\t\tthis.other = aCtBreak;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <S> void visitCtCase(final spoon.reflect.code.CtCase<S> caseStatement) {\n\t\tspoon.reflect.code.CtCase<S> aCtCase = caseStatement.getFactory().Core().createCase();\n\t\tthis.builder.copy(caseStatement, aCtCase);\n\t\taCtCase.setAnnotations(this.cloneHelper.clone(caseStatement.getAnnotations()));\n\t\taCtCase.setCaseExpression(this.cloneHelper.clone(caseStatement.getCaseExpression()));\n\t\taCtCase.setStatements(this.cloneHelper.clone(caseStatement.getStatements()));\n\t\taCtCase.setComments(this.cloneHelper.clone(caseStatement.getComments()));\n\t\tthis.cloneHelper.tailor(caseStatement, aCtCase);\n\t\tthis.other = aCtCase;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtCatch(final spoon.reflect.code.CtCatch catchBlock) {\n\t\tspoon.reflect.code.CtCatch aCtCatch = catchBlock.getFactory().Core().createCatch();\n\t\tthis.builder.copy(catchBlock, aCtCatch);\n\t\taCtCatch.setAnnotations(this.cloneHelper.clone(catchBlock.getAnnotations()));\n\t\taCtCatch.setParameter(this.cloneHelper.clone(catchBlock.getParameter()));\n\t\taCtCatch.setBody(this.cloneHelper.clone(catchBlock.getBody()));\n\t\taCtCatch.setComments(this.cloneHelper.clone(catchBlock.getComments()));\n\t\tthis.cloneHelper.tailor(catchBlock, aCtCatch);\n\t\tthis.other = aCtCatch;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtClass(final spoon.reflect.declaration.CtClass<T> ctClass) {\n\t\tspoon.reflect.declaration.CtClass<T> aCtClass = ctClass.getFactory().Core().createClass();\n\t\tthis.builder.copy(ctClass, aCtClass);\n\t\taCtClass.setAnnotations(this.cloneHelper.clone(ctClass.getAnnotations()));\n\t\taCtClass.setSuperclass(this.cloneHelper.clone(ctClass.getSuperclass()));\n\t\taCtClass.setSuperInterfaces(this.cloneHelper.clone(ctClass.getSuperInterfaces()));\n\t\taCtClass.setFormalCtTypeParameters(this.cloneHelper.clone(ctClass.getFormalCtTypeParameters()));\n\t\taCtClass.setTypeMembers(this.cloneHelper.clone(ctClass.getTypeMembers()));\n\t\taCtClass.setComments(this.cloneHelper.clone(ctClass.getComments()));\n\t\tthis.cloneHelper.tailor(ctClass, aCtClass);\n\t\tthis.other = aCtClass;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n\t\tspoon.reflect.declaration.CtTypeParameter aCtTypeParameter = typeParameter.getFactory().Core().createTypeParameter();\n\t\tthis.builder.copy(typeParameter, aCtTypeParameter);\n\t\taCtTypeParameter.setAnnotations(this.cloneHelper.clone(typeParameter.getAnnotations()));\n\t\taCtTypeParameter.setSuperclass(this.cloneHelper.clone(typeParameter.getSuperclass()));\n\t\taCtTypeParameter.setComments(this.cloneHelper.clone(typeParameter.getComments()));\n\t\tthis.cloneHelper.tailor(typeParameter, aCtTypeParameter);\n\t\tthis.other = aCtTypeParameter;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtConditional(final spoon.reflect.code.CtConditional<T> conditional) {\n\t\tspoon.reflect.code.CtConditional<T> aCtConditional = conditional.getFactory().Core().createConditional();\n\t\tthis.builder.copy(conditional, aCtConditional);\n\t\taCtConditional.setType(this.cloneHelper.clone(conditional.getType()));\n\t\taCtConditional.setAnnotations(this.cloneHelper.clone(conditional.getAnnotations()));\n\t\taCtConditional.setCondition(this.cloneHelper.clone(conditional.getCondition()));\n\t\taCtConditional.setThenExpression(this.cloneHelper.clone(conditional.getThenExpression()));\n\t\taCtConditional.setElseExpression(this.cloneHelper.clone(conditional.getElseExpression()));\n\t\taCtConditional.setComments(this.cloneHelper.clone(conditional.getComments()));\n\t\taCtConditional.setTypeCasts(this.cloneHelper.clone(conditional.getTypeCasts()));\n\t\tthis.cloneHelper.tailor(conditional, aCtConditional);\n\t\tthis.other = aCtConditional;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtConstructor(final spoon.reflect.declaration.CtConstructor<T> c) {\n\t\tspoon.reflect.declaration.CtConstructor<T> aCtConstructor = c.getFactory().Core().createConstructor();\n\t\tthis.builder.copy(c, aCtConstructor);\n\t\taCtConstructor.setAnnotations(this.cloneHelper.clone(c.getAnnotations()));\n\t\taCtConstructor.setParameters(this.cloneHelper.clone(c.getParameters()));\n\t\taCtConstructor.setThrownTypes(this.cloneHelper.clone(c.getThrownTypes()));\n\t\taCtConstructor.setFormalCtTypeParameters(this.cloneHelper.clone(c.getFormalCtTypeParameters()));\n\t\taCtConstructor.setBody(this.cloneHelper.clone(c.getBody()));\n\t\taCtConstructor.setComments(this.cloneHelper.clone(c.getComments()));\n\t\tthis.cloneHelper.tailor(c, aCtConstructor);\n\t\tthis.other = aCtConstructor;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtContinue(final spoon.reflect.code.CtContinue continueStatement) {\n\t\tspoon.reflect.code.CtContinue aCtContinue = continueStatement.getFactory().Core().createContinue();\n\t\tthis.builder.copy(continueStatement, aCtContinue);\n\t\taCtContinue.setAnnotations(this.cloneHelper.clone(continueStatement.getAnnotations()));\n\t\taCtContinue.setComments(this.cloneHelper.clone(continueStatement.getComments()));\n\t\tthis.cloneHelper.tailor(continueStatement, aCtContinue);\n\t\tthis.other = aCtContinue;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtDo(final spoon.reflect.code.CtDo doLoop) {\n\t\tspoon.reflect.code.CtDo aCtDo = doLoop.getFactory().Core().createDo();\n\t\tthis.builder.copy(doLoop, aCtDo);\n\t\taCtDo.setAnnotations(this.cloneHelper.clone(doLoop.getAnnotations()));\n\t\taCtDo.setLoopingExpression(this.cloneHelper.clone(doLoop.getLoopingExpression()));\n\t\taCtDo.setBody(this.cloneHelper.clone(doLoop.getBody()));\n\t\taCtDo.setComments(this.cloneHelper.clone(doLoop.getComments()));\n\t\tthis.cloneHelper.tailor(doLoop, aCtDo);\n\t\tthis.other = aCtDo;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T extends java.lang.Enum<?>> void visitCtEnum(final spoon.reflect.declaration.CtEnum<T> ctEnum) {\n\t\tspoon.reflect.declaration.CtEnum<T> aCtEnum = ctEnum.getFactory().Core().createEnum();\n\t\tthis.builder.copy(ctEnum, aCtEnum);\n\t\taCtEnum.setAnnotations(this.cloneHelper.clone(ctEnum.getAnnotations()));\n\t\taCtEnum.setSuperInterfaces(this.cloneHelper.clone(ctEnum.getSuperInterfaces()));\n\t\taCtEnum.setTypeMembers(this.cloneHelper.clone(ctEnum.getTypeMembers()));\n\t\taCtEnum.setEnumValues(this.cloneHelper.clone(ctEnum.getEnumValues()));\n\t\taCtEnum.setComments(this.cloneHelper.clone(ctEnum.getComments()));\n\t\tthis.cloneHelper.tailor(ctEnum, aCtEnum);\n\t\tthis.other = aCtEnum;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtExecutableReference(final spoon.reflect.reference.CtExecutableReference<T> reference) {\n\t\tspoon.reflect.reference.CtExecutableReference<T> aCtExecutableReference = reference.getFactory().Core().createExecutableReference();\n\t\tthis.builder.copy(reference, aCtExecutableReference);\n\t\taCtExecutableReference.setDeclaringType(this.cloneHelper.clone(reference.getDeclaringType()));\n\t\taCtExecutableReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\taCtExecutableReference.setParameters(this.cloneHelper.clone(reference.getParameters()));\n\t\taCtExecutableReference.setActualTypeArguments(this.cloneHelper.clone(reference.getActualTypeArguments()));\n\t\taCtExecutableReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\taCtExecutableReference.setComments(this.cloneHelper.clone(reference.getComments()));\n\t\tthis.cloneHelper.tailor(reference, aCtExecutableReference);\n\t\tthis.other = aCtExecutableReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtField(final spoon.reflect.declaration.CtField<T> f) {\n\t\tspoon.reflect.declaration.CtField<T> aCtField = f.getFactory().Core().createField();\n\t\tthis.builder.copy(f, aCtField);\n\t\taCtField.setAnnotations(this.cloneHelper.clone(f.getAnnotations()));\n\t\taCtField.setType(this.cloneHelper.clone(f.getType()));\n\t\taCtField.setDefaultExpression(this.cloneHelper.clone(f.getDefaultExpression()));\n\t\taCtField.setComments(this.cloneHelper.clone(f.getComments()));\n\t\tthis.cloneHelper.tailor(f, aCtField);\n\t\tthis.other = aCtField;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtEnumValue(final spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n\t\tspoon.reflect.declaration.CtEnumValue<T> aCtEnumValue = enumValue.getFactory().Core().createEnumValue();\n\t\tthis.builder.copy(enumValue, aCtEnumValue);\n\t\taCtEnumValue.setAnnotations(this.cloneHelper.clone(enumValue.getAnnotations()));\n\t\taCtEnumValue.setType(this.cloneHelper.clone(enumValue.getType()));\n\t\taCtEnumValue.setDefaultExpression(this.cloneHelper.clone(enumValue.getDefaultExpression()));\n\t\taCtEnumValue.setComments(this.cloneHelper.clone(enumValue.getComments()));\n\t\tthis.cloneHelper.tailor(enumValue, aCtEnumValue);\n\t\tthis.other = aCtEnumValue;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtThisAccess(final spoon.reflect.code.CtThisAccess<T> thisAccess) {\n\t\tspoon.reflect.code.CtThisAccess<T> aCtThisAccess = thisAccess.getFactory().Core().createThisAccess();\n\t\tthis.builder.copy(thisAccess, aCtThisAccess);\n\t\taCtThisAccess.setComments(this.cloneHelper.clone(thisAccess.getComments()));\n\t\taCtThisAccess.setAnnotations(this.cloneHelper.clone(thisAccess.getAnnotations()));\n\t\taCtThisAccess.setType(this.cloneHelper.clone(thisAccess.getType()));\n\t\taCtThisAccess.setTypeCasts(this.cloneHelper.clone(thisAccess.getTypeCasts()));\n\t\taCtThisAccess.setTarget(this.cloneHelper.clone(thisAccess.getTarget()));\n\t\tthis.cloneHelper.tailor(thisAccess, aCtThisAccess);\n\t\tthis.other = aCtThisAccess;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtAnnotationFieldAccess(final spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\tspoon.reflect.code.CtAnnotationFieldAccess<T> aCtAnnotationFieldAccess = annotationFieldAccess.getFactory().Core().createAnnotationFieldAccess();\n\t\tthis.builder.copy(annotationFieldAccess, aCtAnnotationFieldAccess);\n\t\taCtAnnotationFieldAccess.setComments(this.cloneHelper.clone(annotationFieldAccess.getComments()));\n\t\taCtAnnotationFieldAccess.setAnnotations(this.cloneHelper.clone(annotationFieldAccess.getAnnotations()));\n\t\taCtAnnotationFieldAccess.setTypeCasts(this.cloneHelper.clone(annotationFieldAccess.getTypeCasts()));\n\t\taCtAnnotationFieldAccess.setTarget(this.cloneHelper.clone(annotationFieldAccess.getTarget()));\n\t\taCtAnnotationFieldAccess.setVariable(this.cloneHelper.clone(annotationFieldAccess.getVariable()));\n\t\tthis.cloneHelper.tailor(annotationFieldAccess, aCtAnnotationFieldAccess);\n\t\tthis.other = aCtAnnotationFieldAccess;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtFieldReference(final spoon.reflect.reference.CtFieldReference<T> reference) {\n\t\tspoon.reflect.reference.CtFieldReference<T> aCtFieldReference = reference.getFactory().Core().createFieldReference();\n\t\tthis.builder.copy(reference, aCtFieldReference);\n\t\taCtFieldReference.setDeclaringType(this.cloneHelper.clone(reference.getDeclaringType()));\n\t\taCtFieldReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\taCtFieldReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtFieldReference);\n\t\tthis.other = aCtFieldReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtFor(final spoon.reflect.code.CtFor forLoop) {\n\t\tspoon.reflect.code.CtFor aCtFor = forLoop.getFactory().Core().createFor();\n\t\tthis.builder.copy(forLoop, aCtFor);\n\t\taCtFor.setAnnotations(this.cloneHelper.clone(forLoop.getAnnotations()));\n\t\taCtFor.setForInit(this.cloneHelper.clone(forLoop.getForInit()));\n\t\taCtFor.setExpression(this.cloneHelper.clone(forLoop.getExpression()));\n\t\taCtFor.setForUpdate(this.cloneHelper.clone(forLoop.getForUpdate()));\n\t\taCtFor.setBody(this.cloneHelper.clone(forLoop.getBody()));\n\t\taCtFor.setComments(this.cloneHelper.clone(forLoop.getComments()));\n\t\tthis.cloneHelper.tailor(forLoop, aCtFor);\n\t\tthis.other = aCtFor;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtForEach(final spoon.reflect.code.CtForEach foreach) {\n\t\tspoon.reflect.code.CtForEach aCtForEach = foreach.getFactory().Core().createForEach();\n\t\tthis.builder.copy(foreach, aCtForEach);\n\t\taCtForEach.setAnnotations(this.cloneHelper.clone(foreach.getAnnotations()));\n\t\taCtForEach.setVariable(this.cloneHelper.clone(foreach.getVariable()));\n\t\taCtForEach.setExpression(this.cloneHelper.clone(foreach.getExpression()));\n\t\taCtForEach.setBody(this.cloneHelper.clone(foreach.getBody()));\n\t\taCtForEach.setComments(this.cloneHelper.clone(foreach.getComments()));\n\t\tthis.cloneHelper.tailor(foreach, aCtForEach);\n\t\tthis.other = aCtForEach;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtIf(final spoon.reflect.code.CtIf ifElement) {\n\t\tspoon.reflect.code.CtIf aCtIf = ifElement.getFactory().Core().createIf();\n\t\tthis.builder.copy(ifElement, aCtIf);\n\t\taCtIf.setAnnotations(this.cloneHelper.clone(ifElement.getAnnotations()));\n\t\taCtIf.setCondition(this.cloneHelper.clone(ifElement.getCondition()));\n\t\taCtIf.setThenStatement(this.cloneHelper.clone(((spoon.reflect.code.CtStatement) (ifElement.getThenStatement()))));\n\t\taCtIf.setElseStatement(this.cloneHelper.clone(((spoon.reflect.code.CtStatement) (ifElement.getElseStatement()))));\n\t\taCtIf.setComments(this.cloneHelper.clone(ifElement.getComments()));\n\t\tthis.cloneHelper.tailor(ifElement, aCtIf);\n\t\tthis.other = aCtIf;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtInterface(final spoon.reflect.declaration.CtInterface<T> intrface) {\n\t\tspoon.reflect.declaration.CtInterface<T> aCtInterface = intrface.getFactory().Core().createInterface();\n\t\tthis.builder.copy(intrface, aCtInterface);\n\t\taCtInterface.setAnnotations(this.cloneHelper.clone(intrface.getAnnotations()));\n\t\taCtInterface.setSuperInterfaces(this.cloneHelper.clone(intrface.getSuperInterfaces()));\n\t\taCtInterface.setFormalCtTypeParameters(this.cloneHelper.clone(intrface.getFormalCtTypeParameters()));\n\t\taCtInterface.setTypeMembers(this.cloneHelper.clone(intrface.getTypeMembers()));\n\t\taCtInterface.setComments(this.cloneHelper.clone(intrface.getComments()));\n\t\tthis.cloneHelper.tailor(intrface, aCtInterface);\n\t\tthis.other = aCtInterface;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtInvocation(final spoon.reflect.code.CtInvocation<T> invocation) {\n\t\tspoon.reflect.code.CtInvocation<T> aCtInvocation = invocation.getFactory().Core().createInvocation();\n\t\tthis.builder.copy(invocation, aCtInvocation);\n\t\taCtInvocation.setAnnotations(this.cloneHelper.clone(invocation.getAnnotations()));\n\t\taCtInvocation.setTypeCasts(this.cloneHelper.clone(invocation.getTypeCasts()));\n\t\taCtInvocation.setTarget(this.cloneHelper.clone(invocation.getTarget()));\n\t\taCtInvocation.setExecutable(this.cloneHelper.clone(invocation.getExecutable()));\n\t\taCtInvocation.setArguments(this.cloneHelper.clone(invocation.getArguments()));\n\t\taCtInvocation.setComments(this.cloneHelper.clone(invocation.getComments()));\n\t\tthis.cloneHelper.tailor(invocation, aCtInvocation);\n\t\tthis.other = aCtInvocation;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtLiteral(final spoon.reflect.code.CtLiteral<T> literal) {\n\t\tspoon.reflect.code.CtLiteral<T> aCtLiteral = literal.getFactory().Core().createLiteral();\n\t\tthis.builder.copy(literal, aCtLiteral);\n\t\taCtLiteral.setAnnotations(this.cloneHelper.clone(literal.getAnnotations()));\n\t\taCtLiteral.setType(this.cloneHelper.clone(literal.getType()));\n\t\taCtLiteral.setTypeCasts(this.cloneHelper.clone(literal.getTypeCasts()));\n\t\taCtLiteral.setComments(this.cloneHelper.clone(literal.getComments()));\n\t\tthis.cloneHelper.tailor(literal, aCtLiteral);\n\t\tthis.other = aCtLiteral;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtLocalVariable(final spoon.reflect.code.CtLocalVariable<T> localVariable) {\n\t\tspoon.reflect.code.CtLocalVariable<T> aCtLocalVariable = localVariable.getFactory().Core().createLocalVariable();\n\t\tthis.builder.copy(localVariable, aCtLocalVariable);\n\t\taCtLocalVariable.setAnnotations(this.cloneHelper.clone(localVariable.getAnnotations()));\n\t\taCtLocalVariable.setType(this.cloneHelper.clone(localVariable.getType()));\n\t\taCtLocalVariable.setDefaultExpression(this.cloneHelper.clone(localVariable.getDefaultExpression()));\n\t\taCtLocalVariable.setComments(this.cloneHelper.clone(localVariable.getComments()));\n\t\tthis.cloneHelper.tailor(localVariable, aCtLocalVariable);\n\t\tthis.other = aCtLocalVariable;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtLocalVariableReference(final spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtLocalVariableReference<T> aCtLocalVariableReference = reference.getFactory().Core().createLocalVariableReference();\n\t\tthis.builder.copy(reference, aCtLocalVariableReference);\n\t\taCtLocalVariableReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\taCtLocalVariableReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtLocalVariableReference);\n\t\tthis.other = aCtLocalVariableReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtCatchVariable(final spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n\t\tspoon.reflect.code.CtCatchVariable<T> aCtCatchVariable = catchVariable.getFactory().Core().createCatchVariable();\n\t\tthis.builder.copy(catchVariable, aCtCatchVariable);\n\t\taCtCatchVariable.setComments(this.cloneHelper.clone(catchVariable.getComments()));\n\t\taCtCatchVariable.setAnnotations(this.cloneHelper.clone(catchVariable.getAnnotations()));\n\t\taCtCatchVariable.setMultiTypes(this.cloneHelper.clone(catchVariable.getMultiTypes()));\n\t\tthis.cloneHelper.tailor(catchVariable, aCtCatchVariable);\n\t\tthis.other = aCtCatchVariable;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtCatchVariableReference(final spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtCatchVariableReference<T> aCtCatchVariableReference = reference.getFactory().Core().createCatchVariableReference();\n\t\tthis.builder.copy(reference, aCtCatchVariableReference);\n\t\taCtCatchVariableReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\taCtCatchVariableReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtCatchVariableReference);\n\t\tthis.other = aCtCatchVariableReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtMethod(final spoon.reflect.declaration.CtMethod<T> m) {\n\t\tspoon.reflect.declaration.CtMethod<T> aCtMethod = m.getFactory().Core().createMethod();\n\t\tthis.builder.copy(m, aCtMethod);\n\t\taCtMethod.setAnnotations(this.cloneHelper.clone(m.getAnnotations()));\n\t\taCtMethod.setFormalCtTypeParameters(this.cloneHelper.clone(m.getFormalCtTypeParameters()));\n\t\taCtMethod.setType(this.cloneHelper.clone(m.getType()));\n\t\taCtMethod.setParameters(this.cloneHelper.clone(m.getParameters()));\n\t\taCtMethod.setThrownTypes(this.cloneHelper.clone(m.getThrownTypes()));\n\t\taCtMethod.setBody(this.cloneHelper.clone(m.getBody()));\n\t\taCtMethod.setComments(this.cloneHelper.clone(m.getComments()));\n\t\tthis.cloneHelper.tailor(m, aCtMethod);\n\t\tthis.other = aCtMethod;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n\t\tspoon.reflect.declaration.CtAnnotationMethod<T> aCtAnnotationMethod = annotationMethod.getFactory().Core().createAnnotationMethod();\n\t\tthis.builder.copy(annotationMethod, aCtAnnotationMethod);\n\t\taCtAnnotationMethod.setAnnotations(this.cloneHelper.clone(annotationMethod.getAnnotations()));\n\t\taCtAnnotationMethod.setType(this.cloneHelper.clone(annotationMethod.getType()));\n\t\taCtAnnotationMethod.setDefaultExpression(this.cloneHelper.clone(annotationMethod.getDefaultExpression()));\n\t\taCtAnnotationMethod.setComments(this.cloneHelper.clone(annotationMethod.getComments()));\n\t\tthis.cloneHelper.tailor(annotationMethod, aCtAnnotationMethod);\n\t\tthis.other = aCtAnnotationMethod;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {\n\t\tspoon.reflect.code.CtNewArray<T> aCtNewArray = newArray.getFactory().Core().createNewArray();\n\t\tthis.builder.copy(newArray, aCtNewArray);\n\t\taCtNewArray.setAnnotations(this.cloneHelper.clone(newArray.getAnnotations()));\n\t\taCtNewArray.setType(this.cloneHelper.clone(newArray.getType()));\n\t\taCtNewArray.setTypeCasts(this.cloneHelper.clone(newArray.getTypeCasts()));\n\t\taCtNewArray.setElements(this.cloneHelper.clone(newArray.getElements()));\n\t\taCtNewArray.setDimensionExpressions(this.cloneHelper.clone(newArray.getDimensionExpressions()));\n\t\taCtNewArray.setComments(this.cloneHelper.clone(newArray.getComments()));\n\t\tthis.cloneHelper.tailor(newArray, aCtNewArray);\n\t\tthis.other = aCtNewArray;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConstructorCall(final spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n\t\tspoon.reflect.code.CtConstructorCall<T> aCtConstructorCall = ctConstructorCall.getFactory().Core().createConstructorCall();\n\t\tthis.builder.copy(ctConstructorCall, aCtConstructorCall);\n\t\taCtConstructorCall.setAnnotations(this.cloneHelper.clone(ctConstructorCall.getAnnotations()));\n\t\taCtConstructorCall.setTypeCasts(this.cloneHelper.clone(ctConstructorCall.getTypeCasts()));\n\t\taCtConstructorCall.setExecutable(this.cloneHelper.clone(ctConstructorCall.getExecutable()));\n\t\taCtConstructorCall.setTarget(this.cloneHelper.clone(ctConstructorCall.getTarget()));\n\t\taCtConstructorCall.setArguments(this.cloneHelper.clone(ctConstructorCall.getArguments()));\n\t\taCtConstructorCall.setComments(this.cloneHelper.clone(ctConstructorCall.getComments()));\n\t\tthis.cloneHelper.tailor(ctConstructorCall, aCtConstructorCall);\n\t\tthis.other = aCtConstructorCall;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtNewClass(final spoon.reflect.code.CtNewClass<T> newClass) {\n\t\tspoon.reflect.code.CtNewClass<T> aCtNewClass = newClass.getFactory().Core().createNewClass();\n\t\tthis.builder.copy(newClass, aCtNewClass);\n\t\taCtNewClass.setAnnotations(this.cloneHelper.clone(newClass.getAnnotations()));\n\t\taCtNewClass.setTypeCasts(this.cloneHelper.clone(newClass.getTypeCasts()));\n\t\taCtNewClass.setExecutable(this.cloneHelper.clone(newClass.getExecutable()));\n\t\taCtNewClass.setTarget(this.cloneHelper.clone(newClass.getTarget()));\n\t\taCtNewClass.setArguments(this.cloneHelper.clone(newClass.getArguments()));\n\t\taCtNewClass.setAnonymousClass(this.cloneHelper.clone(newClass.getAnonymousClass()));\n\t\taCtNewClass.setComments(this.cloneHelper.clone(newClass.getComments()));\n\t\tthis.cloneHelper.tailor(newClass, aCtNewClass);\n\t\tthis.other = aCtNewClass;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLambda(final spoon.reflect.code.CtLambda<T> lambda) {\n\t\tspoon.reflect.code.CtLambda<T> aCtLambda = lambda.getFactory().Core().createLambda();\n\t\tthis.builder.copy(lambda, aCtLambda);\n\t\taCtLambda.setAnnotations(this.cloneHelper.clone(lambda.getAnnotations()));\n\t\taCtLambda.setType(this.cloneHelper.clone(lambda.getType()));\n\t\taCtLambda.setTypeCasts(this.cloneHelper.clone(lambda.getTypeCasts()));\n\t\taCtLambda.setParameters(this.cloneHelper.clone(lambda.getParameters()));\n\t\taCtLambda.setBody(this.cloneHelper.clone(lambda.getBody()));\n\t\taCtLambda.setExpression(this.cloneHelper.clone(lambda.getExpression()));\n\t\taCtLambda.setComments(this.cloneHelper.clone(lambda.getComments()));\n\t\tthis.cloneHelper.tailor(lambda, aCtLambda);\n\t\tthis.other = aCtLambda;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(final spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n\t\tspoon.reflect.code.CtExecutableReferenceExpression<T, E> aCtExecutableReferenceExpression = expression.getFactory().Core().createExecutableReferenceExpression();\n\t\tthis.builder.copy(expression, aCtExecutableReferenceExpression);\n\t\taCtExecutableReferenceExpression.setComments(this.cloneHelper.clone(expression.getComments()));\n\t\taCtExecutableReferenceExpression.setAnnotations(this.cloneHelper.clone(expression.getAnnotations()));\n\t\taCtExecutableReferenceExpression.setType(this.cloneHelper.clone(expression.getType()));\n\t\taCtExecutableReferenceExpression.setTypeCasts(this.cloneHelper.clone(expression.getTypeCasts()));\n\t\taCtExecutableReferenceExpression.setExecutable(this.cloneHelper.clone(expression.getExecutable()));\n\t\taCtExecutableReferenceExpression.setTarget(this.cloneHelper.clone(expression.getTarget()));\n\t\tthis.cloneHelper.tailor(expression, aCtExecutableReferenceExpression);\n\t\tthis.other = aCtExecutableReferenceExpression;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T, A extends T> void visitCtOperatorAssignment(final spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n\t\tspoon.reflect.code.CtOperatorAssignment<T, A> aCtOperatorAssignment = assignment.getFactory().Core().createOperatorAssignment();\n\t\tthis.builder.copy(assignment, aCtOperatorAssignment);\n\t\taCtOperatorAssignment.setAnnotations(this.cloneHelper.clone(assignment.getAnnotations()));\n\t\taCtOperatorAssignment.setType(this.cloneHelper.clone(assignment.getType()));\n\t\taCtOperatorAssignment.setTypeCasts(this.cloneHelper.clone(assignment.getTypeCasts()));\n\t\taCtOperatorAssignment.setAssigned(this.cloneHelper.clone(assignment.getAssigned()));\n\t\taCtOperatorAssignment.setAssignment(this.cloneHelper.clone(assignment.getAssignment()));\n\t\taCtOperatorAssignment.setComments(this.cloneHelper.clone(assignment.getComments()));\n\t\tthis.cloneHelper.tailor(assignment, aCtOperatorAssignment);\n\t\tthis.other = aCtOperatorAssignment;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtPackage(final spoon.reflect.declaration.CtPackage ctPackage) {\n\t\tspoon.reflect.declaration.CtPackage aCtPackage = ctPackage.getFactory().Core().createPackage();\n\t\tthis.builder.copy(ctPackage, aCtPackage);\n\t\taCtPackage.setAnnotations(this.cloneHelper.clone(ctPackage.getAnnotations()));\n\t\taCtPackage.setPackages(this.cloneHelper.clone(ctPackage.getPackages()));\n\t\taCtPackage.setTypes(this.cloneHelper.clone(ctPackage.getTypes()));\n\t\taCtPackage.setComments(this.cloneHelper.clone(ctPackage.getComments()));\n\t\tthis.cloneHelper.tailor(ctPackage, aCtPackage);\n\t\tthis.other = aCtPackage;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtPackageReference(final spoon.reflect.reference.CtPackageReference reference) {\n\t\tspoon.reflect.reference.CtPackageReference aCtPackageReference = reference.getFactory().Core().createPackageReference();\n\t\tthis.builder.copy(reference, aCtPackageReference);\n\t\taCtPackageReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtPackageReference);\n\t\tthis.other = aCtPackageReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtParameter(final spoon.reflect.declaration.CtParameter<T> parameter) {\n\t\tspoon.reflect.declaration.CtParameter<T> aCtParameter = parameter.getFactory().Core().createParameter();\n\t\tthis.builder.copy(parameter, aCtParameter);\n\t\taCtParameter.setAnnotations(this.cloneHelper.clone(parameter.getAnnotations()));\n\t\taCtParameter.setType(this.cloneHelper.clone(parameter.getType()));\n\t\taCtParameter.setComments(this.cloneHelper.clone(parameter.getComments()));\n\t\tthis.cloneHelper.tailor(parameter, aCtParameter);\n\t\tthis.other = aCtParameter;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtParameterReference(final spoon.reflect.reference.CtParameterReference<T> reference) {\n\t\tspoon.reflect.reference.CtParameterReference<T> aCtParameterReference = reference.getFactory().Core().createParameterReference();\n\t\tthis.builder.copy(reference, aCtParameterReference);\n\t\taCtParameterReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\taCtParameterReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(reference, aCtParameterReference);\n\t\tthis.other = aCtParameterReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <R> void visitCtReturn(final spoon.reflect.code.CtReturn<R> returnStatement) {\n\t\tspoon.reflect.code.CtReturn<R> aCtReturn = returnStatement.getFactory().Core().createReturn();\n\t\tthis.builder.copy(returnStatement, aCtReturn);\n\t\taCtReturn.setAnnotations(this.cloneHelper.clone(returnStatement.getAnnotations()));\n\t\taCtReturn.setReturnedExpression(this.cloneHelper.clone(returnStatement.getReturnedExpression()));\n\t\taCtReturn.setComments(this.cloneHelper.clone(returnStatement.getComments()));\n\t\tthis.cloneHelper.tailor(returnStatement, aCtReturn);\n\t\tthis.other = aCtReturn;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <R> void visitCtStatementList(final spoon.reflect.code.CtStatementList statements) {\n\t\tspoon.reflect.code.CtStatementList aCtStatementList = statements.getFactory().Core().createStatementList();\n\t\tthis.builder.copy(statements, aCtStatementList);\n\t\taCtStatementList.setAnnotations(this.cloneHelper.clone(statements.getAnnotations()));\n\t\taCtStatementList.setStatements(this.cloneHelper.clone(statements.getStatements()));\n\t\taCtStatementList.setComments(this.cloneHelper.clone(statements.getComments()));\n\t\tthis.cloneHelper.tailor(statements, aCtStatementList);\n\t\tthis.other = aCtStatementList;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <S> void visitCtSwitch(final spoon.reflect.code.CtSwitch<S> switchStatement) {\n\t\tspoon.reflect.code.CtSwitch<S> aCtSwitch = switchStatement.getFactory().Core().createSwitch();\n\t\tthis.builder.copy(switchStatement, aCtSwitch);\n\t\taCtSwitch.setAnnotations(this.cloneHelper.clone(switchStatement.getAnnotations()));\n\t\taCtSwitch.setSelector(this.cloneHelper.clone(switchStatement.getSelector()));\n\t\taCtSwitch.setCases(this.cloneHelper.clone(switchStatement.getCases()));\n\t\taCtSwitch.setComments(this.cloneHelper.clone(switchStatement.getComments()));\n\t\tthis.cloneHelper.tailor(switchStatement, aCtSwitch);\n\t\tthis.other = aCtSwitch;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtSynchronized(final spoon.reflect.code.CtSynchronized synchro) {\n\t\tspoon.reflect.code.CtSynchronized aCtSynchronized = synchro.getFactory().Core().createSynchronized();\n\t\tthis.builder.copy(synchro, aCtSynchronized);\n\t\taCtSynchronized.setAnnotations(this.cloneHelper.clone(synchro.getAnnotations()));\n\t\taCtSynchronized.setExpression(this.cloneHelper.clone(synchro.getExpression()));\n\t\taCtSynchronized.setBlock(this.cloneHelper.clone(synchro.getBlock()));\n\t\taCtSynchronized.setComments(this.cloneHelper.clone(synchro.getComments()));\n\t\tthis.cloneHelper.tailor(synchro, aCtSynchronized);\n\t\tthis.other = aCtSynchronized;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtThrow(final spoon.reflect.code.CtThrow throwStatement) {\n\t\tspoon.reflect.code.CtThrow aCtThrow = throwStatement.getFactory().Core().createThrow();\n\t\tthis.builder.copy(throwStatement, aCtThrow);\n\t\taCtThrow.setAnnotations(this.cloneHelper.clone(throwStatement.getAnnotations()));\n\t\taCtThrow.setThrownExpression(this.cloneHelper.clone(throwStatement.getThrownExpression()));\n\t\taCtThrow.setComments(this.cloneHelper.clone(throwStatement.getComments()));\n\t\tthis.cloneHelper.tailor(throwStatement, aCtThrow);\n\t\tthis.other = aCtThrow;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtTry(final spoon.reflect.code.CtTry tryBlock) {\n\t\tspoon.reflect.code.CtTry aCtTry = tryBlock.getFactory().Core().createTry();\n\t\tthis.builder.copy(tryBlock, aCtTry);\n\t\taCtTry.setAnnotations(this.cloneHelper.clone(tryBlock.getAnnotations()));\n\t\taCtTry.setBody(this.cloneHelper.clone(tryBlock.getBody()));\n\t\taCtTry.setCatchers(this.cloneHelper.clone(tryBlock.getCatchers()));\n\t\taCtTry.setFinalizer(this.cloneHelper.clone(tryBlock.getFinalizer()));\n\t\taCtTry.setComments(this.cloneHelper.clone(tryBlock.getComments()));\n\t\tthis.cloneHelper.tailor(tryBlock, aCtTry);\n\t\tthis.other = aCtTry;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTryWithResource(final spoon.reflect.code.CtTryWithResource tryWithResource) {\n\t\tspoon.reflect.code.CtTryWithResource aCtTryWithResource = tryWithResource.getFactory().Core().createTryWithResource();\n\t\tthis.builder.copy(tryWithResource, aCtTryWithResource);\n\t\taCtTryWithResource.setAnnotations(this.cloneHelper.clone(tryWithResource.getAnnotations()));\n\t\taCtTryWithResource.setResources(this.cloneHelper.clone(tryWithResource.getResources()));\n\t\taCtTryWithResource.setBody(this.cloneHelper.clone(tryWithResource.getBody()));\n\t\taCtTryWithResource.setCatchers(this.cloneHelper.clone(tryWithResource.getCatchers()));\n\t\taCtTryWithResource.setFinalizer(this.cloneHelper.clone(tryWithResource.getFinalizer()));\n\t\taCtTryWithResource.setComments(this.cloneHelper.clone(tryWithResource.getComments()));\n\t\tthis.cloneHelper.tailor(tryWithResource, aCtTryWithResource);\n\t\tthis.other = aCtTryWithResource;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtTypeParameterReference(final spoon.reflect.reference.CtTypeParameterReference ref) {\n\t\tspoon.reflect.reference.CtTypeParameterReference aCtTypeParameterReference = ref.getFactory().Core().createTypeParameterReference();\n\t\tthis.builder.copy(ref, aCtTypeParameterReference);\n\t\taCtTypeParameterReference.setPackage(this.cloneHelper.clone(ref.getPackage()));\n\t\taCtTypeParameterReference.setDeclaringType(this.cloneHelper.clone(ref.getDeclaringType()));\n\t\taCtTypeParameterReference.setAnnotations(this.cloneHelper.clone(ref.getAnnotations()));\n\t\tthis.cloneHelper.tailor(ref, aCtTypeParameterReference);\n\t\tthis.other = aCtTypeParameterReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n\t\tspoon.reflect.reference.CtWildcardReference aCtWildcardReference = wildcardReference.getFactory().Core().createWildcardReference();\n\t\tthis.builder.copy(wildcardReference, aCtWildcardReference);\n\t\taCtWildcardReference.setPackage(this.cloneHelper.clone(wildcardReference.getPackage()));\n\t\taCtWildcardReference.setDeclaringType(this.cloneHelper.clone(wildcardReference.getDeclaringType()));\n\t\taCtWildcardReference.setAnnotations(this.cloneHelper.clone(wildcardReference.getAnnotations()));\n\t\taCtWildcardReference.setBoundingType(this.cloneHelper.clone(wildcardReference.getBoundingType()));\n\t\tthis.cloneHelper.tailor(wildcardReference, aCtWildcardReference);\n\t\tthis.other = aCtWildcardReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtIntersectionTypeReference<T> aCtIntersectionTypeReference = reference.getFactory().Core().createIntersectionTypeReference();\n\t\tthis.builder.copy(reference, aCtIntersectionTypeReference);\n\t\taCtIntersectionTypeReference.setPackage(this.cloneHelper.clone(reference.getPackage()));\n\t\taCtIntersectionTypeReference.setDeclaringType(this.cloneHelper.clone(reference.getDeclaringType()));\n\t\taCtIntersectionTypeReference.setActualTypeArguments(this.cloneHelper.clone(reference.getActualTypeArguments()));\n\t\taCtIntersectionTypeReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\taCtIntersectionTypeReference.setBounds(this.cloneHelper.clone(reference.getBounds()));\n\t\tthis.cloneHelper.tailor(reference, aCtIntersectionTypeReference);\n\t\tthis.other = aCtIntersectionTypeReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtTypeReference(final spoon.reflect.reference.CtTypeReference<T> reference) {\n\t\tspoon.reflect.reference.CtTypeReference<T> aCtTypeReference = reference.getFactory().Core().createTypeReference();\n\t\tthis.builder.copy(reference, aCtTypeReference);\n\t\taCtTypeReference.setPackage(this.cloneHelper.clone(reference.getPackage()));\n\t\taCtTypeReference.setDeclaringType(this.cloneHelper.clone(reference.getDeclaringType()));\n\t\taCtTypeReference.setActualTypeArguments(this.cloneHelper.clone(reference.getActualTypeArguments()));\n\t\taCtTypeReference.setAnnotations(this.cloneHelper.clone(reference.getAnnotations()));\n\t\taCtTypeReference.setComments(this.cloneHelper.clone(reference.getComments()));\n\t\tthis.cloneHelper.tailor(reference, aCtTypeReference);\n\t\tthis.other = aCtTypeReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtTypeAccess(final spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n\t\tspoon.reflect.code.CtTypeAccess<T> aCtTypeAccess = typeAccess.getFactory().Core().createTypeAccess();\n\t\tthis.builder.copy(typeAccess, aCtTypeAccess);\n\t\taCtTypeAccess.setAnnotations(this.cloneHelper.clone(typeAccess.getAnnotations()));\n\t\taCtTypeAccess.setTypeCasts(this.cloneHelper.clone(typeAccess.getTypeCasts()));\n\t\taCtTypeAccess.setAccessedType(this.cloneHelper.clone(typeAccess.getAccessedType()));\n\t\taCtTypeAccess.setComments(this.cloneHelper.clone(typeAccess.getComments()));\n\t\tthis.cloneHelper.tailor(typeAccess, aCtTypeAccess);\n\t\tthis.other = aCtTypeAccess;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtUnaryOperator(final spoon.reflect.code.CtUnaryOperator<T> operator) {\n\t\tspoon.reflect.code.CtUnaryOperator<T> aCtUnaryOperator = operator.getFactory().Core().createUnaryOperator();\n\t\tthis.builder.copy(operator, aCtUnaryOperator);\n\t\taCtUnaryOperator.setAnnotations(this.cloneHelper.clone(operator.getAnnotations()));\n\t\taCtUnaryOperator.setType(this.cloneHelper.clone(operator.getType()));\n\t\taCtUnaryOperator.setTypeCasts(this.cloneHelper.clone(operator.getTypeCasts()));\n\t\taCtUnaryOperator.setOperand(this.cloneHelper.clone(operator.getOperand()));\n\t\taCtUnaryOperator.setComments(this.cloneHelper.clone(operator.getComments()));\n\t\tthis.cloneHelper.tailor(operator, aCtUnaryOperator);\n\t\tthis.other = aCtUnaryOperator;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableRead(final spoon.reflect.code.CtVariableRead<T> variableRead) {\n\t\tspoon.reflect.code.CtVariableRead<T> aCtVariableRead = variableRead.getFactory().Core().createVariableRead();\n\t\tthis.builder.copy(variableRead, aCtVariableRead);\n\t\taCtVariableRead.setAnnotations(this.cloneHelper.clone(variableRead.getAnnotations()));\n\t\taCtVariableRead.setTypeCasts(this.cloneHelper.clone(variableRead.getTypeCasts()));\n\t\taCtVariableRead.setVariable(this.cloneHelper.clone(variableRead.getVariable()));\n\t\taCtVariableRead.setComments(this.cloneHelper.clone(variableRead.getComments()));\n\t\tthis.cloneHelper.tailor(variableRead, aCtVariableRead);\n\t\tthis.other = aCtVariableRead;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableWrite(final spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n\t\tspoon.reflect.code.CtVariableWrite<T> aCtVariableWrite = variableWrite.getFactory().Core().createVariableWrite();\n\t\tthis.builder.copy(variableWrite, aCtVariableWrite);\n\t\taCtVariableWrite.setAnnotations(this.cloneHelper.clone(variableWrite.getAnnotations()));\n\t\taCtVariableWrite.setTypeCasts(this.cloneHelper.clone(variableWrite.getTypeCasts()));\n\t\taCtVariableWrite.setVariable(this.cloneHelper.clone(variableWrite.getVariable()));\n\t\taCtVariableWrite.setComments(this.cloneHelper.clone(variableWrite.getComments()));\n\t\tthis.cloneHelper.tailor(variableWrite, aCtVariableWrite);\n\t\tthis.other = aCtVariableWrite;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtWhile(final spoon.reflect.code.CtWhile whileLoop) {\n\t\tspoon.reflect.code.CtWhile aCtWhile = whileLoop.getFactory().Core().createWhile();\n\t\tthis.builder.copy(whileLoop, aCtWhile);\n\t\taCtWhile.setAnnotations(this.cloneHelper.clone(whileLoop.getAnnotations()));\n\t\taCtWhile.setLoopingExpression(this.cloneHelper.clone(whileLoop.getLoopingExpression()));\n\t\taCtWhile.setBody(this.cloneHelper.clone(whileLoop.getBody()));\n\t\taCtWhile.setComments(this.cloneHelper.clone(whileLoop.getComments()));\n\t\tthis.cloneHelper.tailor(whileLoop, aCtWhile);\n\t\tthis.other = aCtWhile;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtCodeSnippetExpression(final spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n\t\tspoon.reflect.code.CtCodeSnippetExpression<T> aCtCodeSnippetExpression = expression.getFactory().Core().createCodeSnippetExpression();\n\t\tthis.builder.copy(expression, aCtCodeSnippetExpression);\n\t\taCtCodeSnippetExpression.setType(this.cloneHelper.clone(expression.getType()));\n\t\taCtCodeSnippetExpression.setComments(this.cloneHelper.clone(expression.getComments()));\n\t\taCtCodeSnippetExpression.setAnnotations(this.cloneHelper.clone(expression.getAnnotations()));\n\t\taCtCodeSnippetExpression.setTypeCasts(this.cloneHelper.clone(expression.getTypeCasts()));\n\t\tthis.cloneHelper.tailor(expression, aCtCodeSnippetExpression);\n\t\tthis.other = aCtCodeSnippetExpression;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtCodeSnippetStatement(final spoon.reflect.code.CtCodeSnippetStatement statement) {\n\t\tspoon.reflect.code.CtCodeSnippetStatement aCtCodeSnippetStatement = statement.getFactory().Core().createCodeSnippetStatement();\n\t\tthis.builder.copy(statement, aCtCodeSnippetStatement);\n\t\taCtCodeSnippetStatement.setComments(this.cloneHelper.clone(statement.getComments()));\n\t\taCtCodeSnippetStatement.setAnnotations(this.cloneHelper.clone(statement.getAnnotations()));\n\t\tthis.cloneHelper.tailor(statement, aCtCodeSnippetStatement);\n\t\tthis.other = aCtCodeSnippetStatement;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtUnboundVariableReference(final spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n\t\tspoon.reflect.reference.CtUnboundVariableReference<T> aCtUnboundVariableReference = reference.getFactory().Core().createUnboundVariableReference();\n\t\tthis.builder.copy(reference, aCtUnboundVariableReference);\n\t\taCtUnboundVariableReference.setType(this.cloneHelper.clone(reference.getType()));\n\t\tthis.cloneHelper.tailor(reference, aCtUnboundVariableReference);\n\t\tthis.other = aCtUnboundVariableReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldRead(final spoon.reflect.code.CtFieldRead<T> fieldRead) {\n\t\tspoon.reflect.code.CtFieldRead<T> aCtFieldRead = fieldRead.getFactory().Core().createFieldRead();\n\t\tthis.builder.copy(fieldRead, aCtFieldRead);\n\t\taCtFieldRead.setAnnotations(this.cloneHelper.clone(fieldRead.getAnnotations()));\n\t\taCtFieldRead.setTypeCasts(this.cloneHelper.clone(fieldRead.getTypeCasts()));\n\t\taCtFieldRead.setTarget(this.cloneHelper.clone(fieldRead.getTarget()));\n\t\taCtFieldRead.setVariable(this.cloneHelper.clone(fieldRead.getVariable()));\n\t\taCtFieldRead.setComments(this.cloneHelper.clone(fieldRead.getComments()));\n\t\tthis.cloneHelper.tailor(fieldRead, aCtFieldRead);\n\t\tthis.other = aCtFieldRead;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldWrite(final spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n\t\tspoon.reflect.code.CtFieldWrite<T> aCtFieldWrite = fieldWrite.getFactory().Core().createFieldWrite();\n\t\tthis.builder.copy(fieldWrite, aCtFieldWrite);\n\t\taCtFieldWrite.setAnnotations(this.cloneHelper.clone(fieldWrite.getAnnotations()));\n\t\taCtFieldWrite.setTypeCasts(this.cloneHelper.clone(fieldWrite.getTypeCasts()));\n\t\taCtFieldWrite.setTarget(this.cloneHelper.clone(fieldWrite.getTarget()));\n\t\taCtFieldWrite.setVariable(this.cloneHelper.clone(fieldWrite.getVariable()));\n\t\taCtFieldWrite.setComments(this.cloneHelper.clone(fieldWrite.getComments()));\n\t\tthis.cloneHelper.tailor(fieldWrite, aCtFieldWrite);\n\t\tthis.other = aCtFieldWrite;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtSuperAccess(final spoon.reflect.code.CtSuperAccess<T> f) {\n\t\tspoon.reflect.code.CtSuperAccess<T> aCtSuperAccess = f.getFactory().Core().createSuperAccess();\n\t\tthis.builder.copy(f, aCtSuperAccess);\n\t\taCtSuperAccess.setComments(this.cloneHelper.clone(f.getComments()));\n\t\taCtSuperAccess.setAnnotations(this.cloneHelper.clone(f.getAnnotations()));\n\t\taCtSuperAccess.setTypeCasts(this.cloneHelper.clone(f.getTypeCasts()));\n\t\taCtSuperAccess.setTarget(this.cloneHelper.clone(f.getTarget()));\n\t\taCtSuperAccess.setVariable(this.cloneHelper.clone(f.getVariable()));\n\t\tthis.cloneHelper.tailor(f, aCtSuperAccess);\n\t\tthis.other = aCtSuperAccess;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtComment(final spoon.reflect.code.CtComment comment) {\n\t\tspoon.reflect.code.CtComment aCtComment = comment.getFactory().Core().createComment();\n\t\tthis.builder.copy(comment, aCtComment);\n\t\taCtComment.setComments(this.cloneHelper.clone(comment.getComments()));\n\t\taCtComment.setAnnotations(this.cloneHelper.clone(comment.getAnnotations()));\n\t\tthis.cloneHelper.tailor(comment, aCtComment);\n\t\tthis.other = aCtComment;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDoc(final spoon.reflect.code.CtJavaDoc javaDoc) {\n\t\tspoon.reflect.code.CtJavaDoc aCtJavaDoc = javaDoc.getFactory().Core().createJavaDoc();\n\t\tthis.builder.copy(javaDoc, aCtJavaDoc);\n\t\taCtJavaDoc.setComments(this.cloneHelper.clone(javaDoc.getComments()));\n\t\taCtJavaDoc.setAnnotations(this.cloneHelper.clone(javaDoc.getAnnotations()));\n\t\taCtJavaDoc.setTags(this.cloneHelper.clone(javaDoc.getTags()));\n\t\tthis.cloneHelper.tailor(javaDoc, aCtJavaDoc);\n\t\tthis.other = aCtJavaDoc;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDocTag(final spoon.reflect.code.CtJavaDocTag docTag) {\n\t\tspoon.reflect.code.CtJavaDocTag aCtJavaDocTag = docTag.getFactory().Core().createJavaDocTag();\n\t\tthis.builder.copy(docTag, aCtJavaDocTag);\n\t\taCtJavaDocTag.setComments(this.cloneHelper.clone(docTag.getComments()));\n\t\taCtJavaDocTag.setAnnotations(this.cloneHelper.clone(docTag.getAnnotations()));\n\t\tthis.cloneHelper.tailor(docTag, aCtJavaDocTag);\n\t\tthis.other = aCtJavaDocTag;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtImport(final spoon.reflect.declaration.CtImport ctImport) {\n\t\tspoon.reflect.declaration.CtImport aCtImport = ctImport.getFactory().Core().createImport();\n\t\tthis.builder.copy(ctImport, aCtImport);\n\t\taCtImport.setReference(this.cloneHelper.clone(ctImport.getReference()));\n\t\taCtImport.setAnnotations(this.cloneHelper.clone(ctImport.getAnnotations()));\n\t\taCtImport.setComments(this.cloneHelper.clone(ctImport.getComments()));\n\t\tthis.cloneHelper.tailor(ctImport, aCtImport);\n\t\tthis.other = aCtImport;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModule(spoon.reflect.declaration.CtModule module) {\n\t\tspoon.reflect.declaration.CtModule aCtModule = module.getFactory().Core().createModule();\n\t\tthis.builder.copy(module, aCtModule);\n\t\taCtModule.setComments(this.cloneHelper.clone(module.getComments()));\n\t\taCtModule.setAnnotations(this.cloneHelper.clone(module.getAnnotations()));\n\t\taCtModule.setModuleDirectives(this.cloneHelper.clone(module.getModuleDirectives()));\n\t\taCtModule.setRootPackage(this.cloneHelper.clone(module.getRootPackage()));\n\t\tthis.cloneHelper.tailor(module, aCtModule);\n\t\tthis.other = aCtModule;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {\n\t\tspoon.reflect.reference.CtModuleReference aCtModuleReference = moduleReference.getFactory().Core().createModuleReference();\n\t\tthis.builder.copy(moduleReference, aCtModuleReference);\n\t\taCtModuleReference.setAnnotations(this.cloneHelper.clone(moduleReference.getAnnotations()));\n\t\tthis.cloneHelper.tailor(moduleReference, aCtModuleReference);\n\t\tthis.other = aCtModuleReference;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n\t\tspoon.reflect.declaration.CtPackageExport aCtPackageExport = moduleExport.getFactory().Core().createPackageExport();\n\t\tthis.builder.copy(moduleExport, aCtPackageExport);\n\t\taCtPackageExport.setComments(this.cloneHelper.clone(moduleExport.getComments()));\n\t\taCtPackageExport.setPackageReference(this.cloneHelper.clone(moduleExport.getPackageReference()));\n\t\taCtPackageExport.setTargetExport(this.cloneHelper.clone(moduleExport.getTargetExport()));\n\t\taCtPackageExport.setAnnotations(this.cloneHelper.clone(moduleExport.getAnnotations()));\n\t\tthis.cloneHelper.tailor(moduleExport, aCtPackageExport);\n\t\tthis.other = aCtPackageExport;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n\t\tspoon.reflect.declaration.CtModuleRequirement aCtModuleRequirement = moduleRequirement.getFactory().Core().createModuleRequirement();\n\t\tthis.builder.copy(moduleRequirement, aCtModuleRequirement);\n\t\taCtModuleRequirement.setComments(this.cloneHelper.clone(moduleRequirement.getComments()));\n\t\taCtModuleRequirement.setModuleReference(this.cloneHelper.clone(moduleRequirement.getModuleReference()));\n\t\taCtModuleRequirement.setAnnotations(this.cloneHelper.clone(moduleRequirement.getAnnotations()));\n\t\tthis.cloneHelper.tailor(moduleRequirement, aCtModuleRequirement);\n\t\tthis.other = aCtModuleRequirement;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {\n\t\tspoon.reflect.declaration.CtProvidedService aCtProvidedService = moduleProvidedService.getFactory().Core().createProvidedService();\n\t\tthis.builder.copy(moduleProvidedService, aCtProvidedService);\n\t\taCtProvidedService.setComments(this.cloneHelper.clone(moduleProvidedService.getComments()));\n\t\taCtProvidedService.setServiceType(this.cloneHelper.clone(moduleProvidedService.getServiceType()));\n\t\taCtProvidedService.setImplementationTypes(this.cloneHelper.clone(moduleProvidedService.getImplementationTypes()));\n\t\taCtProvidedService.setAnnotations(this.cloneHelper.clone(moduleProvidedService.getAnnotations()));\n\t\tthis.cloneHelper.tailor(moduleProvidedService, aCtProvidedService);\n\t\tthis.other = aCtProvidedService;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {\n\t\tspoon.reflect.declaration.CtUsedService aCtUsedService = usedService.getFactory().Core().createUsedService();\n\t\tthis.builder.copy(usedService, aCtUsedService);\n\t\taCtUsedService.setComments(this.cloneHelper.clone(usedService.getComments()));\n\t\taCtUsedService.setServiceType(this.cloneHelper.clone(usedService.getServiceType()));\n\t\taCtUsedService.setAnnotations(this.cloneHelper.clone(usedService.getAnnotations()));\n\t\tthis.cloneHelper.tailor(usedService, aCtUsedService);\n\t\tthis.other = aCtUsedService;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtCompilationUnit(spoon.reflect.declaration.CtCompilationUnit compilationUnit) {\n\t\tspoon.reflect.declaration.CtCompilationUnit aCtCompilationUnit = compilationUnit.getFactory().Core().createCompilationUnit();\n\t\tthis.builder.copy(compilationUnit, aCtCompilationUnit);\n\t\taCtCompilationUnit.setComments(this.cloneHelper.clone(compilationUnit.getComments()));\n\t\taCtCompilationUnit.setAnnotations(this.cloneHelper.clone(compilationUnit.getAnnotations()));\n\t\taCtCompilationUnit.setPackageDeclaration(this.cloneHelper.clone(compilationUnit.getPackageDeclaration()));\n\t\taCtCompilationUnit.setImports(this.cloneHelper.clone(compilationUnit.getImports()));\n\t\taCtCompilationUnit.setDeclaredModuleReference(this.cloneHelper.clone(compilationUnit.getDeclaredModuleReference()));\n\t\taCtCompilationUnit.setDeclaredTypeReferences(this.cloneHelper.clone(compilationUnit.getDeclaredTypeReferences()));\n\t\tthis.cloneHelper.tailor(compilationUnit, aCtCompilationUnit);\n\t\tthis.other = aCtCompilationUnit;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageDeclaration(spoon.reflect.declaration.CtPackageDeclaration packageDeclaration) {\n\t\tspoon.reflect.declaration.CtPackageDeclaration aCtPackageDeclaration = packageDeclaration.getFactory().Core().createPackageDeclaration();\n\t\tthis.builder.copy(packageDeclaration, aCtPackageDeclaration);\n\t\taCtPackageDeclaration.setComments(this.cloneHelper.clone(packageDeclaration.getComments()));\n\t\taCtPackageDeclaration.setAnnotations(this.cloneHelper.clone(packageDeclaration.getAnnotations()));\n\t\taCtPackageDeclaration.setReference(this.cloneHelper.clone(packageDeclaration.getReference()));\n\t\tthis.cloneHelper.tailor(packageDeclaration, aCtPackageDeclaration);\n\t\tthis.other = aCtPackageDeclaration;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeMemberWildcardImportReference(spoon.reflect.reference.CtTypeMemberWildcardImportReference wildcardReference) {\n\t\tspoon.reflect.reference.CtTypeMemberWildcardImportReference aCtTypeMemberWildcardImportReference = wildcardReference.getFactory().Core().createTypeMemberWildcardImportReference();\n\t\tthis.builder.copy(wildcardReference, aCtTypeMemberWildcardImportReference);\n\t\taCtTypeMemberWildcardImportReference.setTypeReference(this.cloneHelper.clone(wildcardReference.getTypeReference()));\n\t\tthis.cloneHelper.tailor(wildcardReference, aCtTypeMemberWildcardImportReference);\n\t\tthis.other = aCtTypeMemberWildcardImportReference;\n\t}\n}\n\n"
    }, {
      "name" : "support/visitor/clone/CloneBuilder.java",
      "weight" : 187.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.clone;\n\n\n/**\n * Used to set all data in the cloned element.\n *\n * This class is generated automatically by the processor spoon.generating.CloneVisitorGenerator.\n */\npublic class CloneBuilder extends spoon.reflect.visitor.CtInheritanceScanner {\n\tpublic void copy(spoon.reflect.declaration.CtElement element, spoon.reflect.declaration.CtElement other) {\n\t\tthis.setOther(other);\n\t\tthis.scan(element);\n\t}\n\n\tpublic static <T extends spoon.reflect.declaration.CtElement> T build(spoon.support.visitor.clone.CloneBuilder builder, spoon.reflect.declaration.CtElement element, spoon.reflect.declaration.CtElement other) {\n\t\tbuilder.setOther(other);\n\t\tbuilder.scan(element);\n\t\treturn ((T) (builder.other));\n\t}\n\n\tprivate spoon.reflect.declaration.CtElement other;\n\n\tpublic void setOther(spoon.reflect.declaration.CtElement other) {\n\t\tthis.other = other;\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> e) {\n\t\t((spoon.reflect.code.CtCodeSnippetExpression<T>) (other)).setValue(e.getValue());\n\t\tsuper.visitCtCodeSnippetExpression(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement e) {\n\t\t((spoon.reflect.code.CtCodeSnippetStatement) (other)).setValue(e.getValue());\n\t\tsuper.visitCtCodeSnippetStatement(e);\n\t}\n\n\t/**\n\t * Scans an abstract element.\n\t */\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void scanCtElement(spoon.reflect.declaration.CtElement e) {\n\t\t((spoon.reflect.declaration.CtElement) (other)).setPosition(e.getPosition());\n\t\t((spoon.reflect.declaration.CtElement) (other)).setAllMetadata(e.getAllMetadata());\n\t\t((spoon.reflect.declaration.CtElement) (other)).setImplicit(e.isImplicit());\n\t\tsuper.scanCtElement(e);\n\t}\n\n\t/**\n\t * Scans an abstract named element.\n\t */\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void scanCtNamedElement(spoon.reflect.declaration.CtNamedElement e) {\n\t\t((spoon.reflect.declaration.CtNamedElement) (other)).setSimpleName(e.getSimpleName());\n\t\tsuper.scanCtNamedElement(e);\n\t}\n\n\t/**\n\t * Scans an abstract reference.\n\t */\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void scanCtReference(spoon.reflect.reference.CtReference reference) {\n\t\t((spoon.reflect.reference.CtReference) (other)).setSimpleName(reference.getSimpleName());\n\t\tsuper.scanCtReference(reference);\n\t}\n\n\t/**\n\t * Scans an abstract statement.\n\t */\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void scanCtStatement(spoon.reflect.code.CtStatement s) {\n\t\t((spoon.reflect.code.CtStatement) (other)).setLabel(s.getLabel());\n\t\tsuper.scanCtStatement(s);\n\t}\n\n\t/**\n\t * Scans an abstract type.\n\t */\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void scanCtType(spoon.reflect.declaration.CtType<T> type) {\n\t\t((spoon.reflect.declaration.CtType<T>) (other)).setModifiers(type.getModifiers());\n\t\t((spoon.reflect.declaration.CtType<T>) (other)).setShadow(type.isShadow());\n\t\tsuper.scanCtType(type);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> e) {\n\t\t((spoon.reflect.code.CtOperatorAssignment<T, A>) (other)).setKind(e.getKind());\n\t\tsuper.visitCtOperatorAssignment(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> e) {\n\t\t((spoon.reflect.declaration.CtAnnotation<A>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtAnnotation(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable e) {\n\t\t((spoon.reflect.declaration.CtAnonymousExecutable) (other)).setModifiers(e.getModifiers());\n\t\tsuper.visitCtAnonymousExecutable(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> e) {\n\t\t((spoon.reflect.code.CtBinaryOperator<T>) (other)).setKind(e.getKind());\n\t\tsuper.visitCtBinaryOperator(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtBreak(spoon.reflect.code.CtBreak e) {\n\t\t((spoon.reflect.code.CtBreak) (other)).setTargetLabel(e.getTargetLabel());\n\t\tsuper.visitCtBreak(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> e) {\n\t\t((spoon.reflect.declaration.CtConstructor<T>) (other)).setModifiers(e.getModifiers());\n\t\t((spoon.reflect.declaration.CtConstructor<T>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtConstructor(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtContinue(spoon.reflect.code.CtContinue e) {\n\t\t((spoon.reflect.code.CtContinue) (other)).setTargetLabel(e.getTargetLabel());\n\t\tsuper.visitCtContinue(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> e) {\n\t\t((spoon.reflect.reference.CtExecutableReference<T>) (other)).setStatic(e.isStatic());\n\t\tsuper.visitCtExecutableReference(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtField(spoon.reflect.declaration.CtField<T> e) {\n\t\t((spoon.reflect.declaration.CtField<T>) (other)).setModifiers(e.getModifiers());\n\t\t((spoon.reflect.declaration.CtField<T>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtField(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> e) {\n\t\t((spoon.reflect.reference.CtFieldReference<T>) (other)).setFinal(e.isFinal());\n\t\t((spoon.reflect.reference.CtFieldReference<T>) (other)).setStatic(e.isStatic());\n\t\tsuper.visitCtFieldReference(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> e) {\n\t\t((spoon.reflect.code.CtInvocation<T>) (other)).setLabel(e.getLabel());\n\t\tsuper.visitCtInvocation(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> e) {\n\t\t((spoon.reflect.code.CtLiteral<T>) (other)).setValue(e.getValue());\n\t\tsuper.visitCtLiteral(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> e) {\n\t\t((spoon.reflect.code.CtLocalVariable<T>) (other)).setSimpleName(e.getSimpleName());\n\t\t((spoon.reflect.code.CtLocalVariable<T>) (other)).setModifiers(e.getModifiers());\n\t\t((spoon.reflect.code.CtLocalVariable<T>) (other)).setInferred(e.isInferred());\n\t\tsuper.visitCtLocalVariable(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> e) {\n\t\t((spoon.reflect.code.CtCatchVariable<T>) (other)).setSimpleName(e.getSimpleName());\n\t\t((spoon.reflect.code.CtCatchVariable<T>) (other)).setModifiers(e.getModifiers());\n\t\tsuper.visitCtCatchVariable(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> e) {\n\t\t((spoon.reflect.declaration.CtMethod<T>) (other)).setDefaultMethod(e.isDefaultMethod());\n\t\t((spoon.reflect.declaration.CtMethod<T>) (other)).setModifiers(e.getModifiers());\n\t\t((spoon.reflect.declaration.CtMethod<T>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtMethod(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> e) {\n\t\t((spoon.reflect.code.CtConstructorCall<T>) (other)).setLabel(e.getLabel());\n\t\tsuper.visitCtConstructorCall(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> e) {\n\t\t((spoon.reflect.code.CtLambda<T>) (other)).setSimpleName(e.getSimpleName());\n\t\tsuper.visitCtLambda(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T, A extends T> void visitCtOperatorAssignement(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n\t\t((spoon.reflect.code.CtOperatorAssignment<T, A>) (other)).setKind(assignment.getKind());\n\t\tsuper.visitCtOperatorAssignement(assignment);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic void visitCtPackage(spoon.reflect.declaration.CtPackage e) {\n\t\t((spoon.reflect.declaration.CtPackage) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtPackage(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> e) {\n\t\t((spoon.reflect.declaration.CtParameter<T>) (other)).setVarArgs(e.isVarArgs());\n\t\t((spoon.reflect.declaration.CtParameter<T>) (other)).setModifiers(e.getModifiers());\n\t\t((spoon.reflect.declaration.CtParameter<T>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtParameter(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n\t\t((spoon.reflect.reference.CtWildcardReference) (other)).setUpper(wildcardReference.isUpper());\n\t\tsuper.visitCtWildcardReference(wildcardReference);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> e) {\n\t\t((spoon.reflect.reference.CtTypeReference<T>) (other)).setShadow(e.isShadow());\n\t\tsuper.visitCtTypeReference(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\tpublic <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> e) {\n\t\t((spoon.reflect.code.CtUnaryOperator<T>) (other)).setKind(e.getKind());\n\t\t((spoon.reflect.code.CtUnaryOperator<T>) (other)).setLabel(e.getLabel());\n\t\tsuper.visitCtUnaryOperator(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtComment(spoon.reflect.code.CtComment e) {\n\t\t((spoon.reflect.code.CtComment) (other)).setContent(e.getContent());\n\t\t((spoon.reflect.code.CtComment) (other)).setCommentType(e.getCommentType());\n\t\tsuper.visitCtComment(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag e) {\n\t\t((spoon.reflect.code.CtJavaDocTag) (other)).setType(e.getType());\n\t\t((spoon.reflect.code.CtJavaDocTag) (other)).setContent(e.getContent());\n\t\t((spoon.reflect.code.CtJavaDocTag) (other)).setParam(e.getParam());\n\t\tsuper.visitCtJavaDocTag(e);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModule(spoon.reflect.declaration.CtModule module) {\n\t\t((spoon.reflect.declaration.CtModule) (other)).setIsOpenModule(module.isOpenModule());\n\t\tsuper.visitCtModule(module);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n\t\t((spoon.reflect.declaration.CtPackageExport) (other)).setOpenedPackage(moduleExport.isOpenedPackage());\n\t\tsuper.visitCtPackageExport(moduleExport);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n\t\t((spoon.reflect.declaration.CtModuleRequirement) (other)).setRequiresModifiers(moduleRequirement.getRequiresModifiers());\n\t\tsuper.visitCtModuleRequirement(moduleRequirement);\n\t}\n\n\t// auto-generated, see spoon.generating.CloneVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtCompilationUnit(spoon.reflect.declaration.CtCompilationUnit compilationUnit) {\n\t\t((spoon.reflect.declaration.CtCompilationUnit) (other)).setFile(compilationUnit.getFile());\n\t\t((spoon.reflect.declaration.CtCompilationUnit) (other)).setLineSeparatorPositions(compilationUnit.getLineSeparatorPositions());\n\t\tsuper.visitCtCompilationUnit(compilationUnit);\n\t}\n}\n\n"
    }, {
      "name" : "support/visitor/replace/ReplaceListener.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport spoon.reflect.declaration.CtElement;\n\npublic interface ReplaceListener<T extends CtElement> {\n\tvoid set(T replace);\n}\n"
    }, {
      "name" : "support/visitor/replace/ReplaceListListener.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport java.util.Collection;\n\npublic interface ReplaceListListener<T extends Collection> {\n\tvoid set(T replace);\n}\n"
    }, {
      "name" : "support/visitor/replace/InvalidReplaceException.java",
      "weight" : 15.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport spoon.SpoonException;\n\n/**\n * Thrown when replacing of element by another element is not possible\n */\npublic class InvalidReplaceException extends SpoonException {\n\n\tpublic InvalidReplaceException() {\n\t}\n\n\tpublic InvalidReplaceException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\tpublic InvalidReplaceException(Throwable e) {\n\t\tsuper(e);\n\t}\n\n\tpublic InvalidReplaceException(String msg, Throwable e) {\n\t\tsuper(msg, e);\n\t}\n\n}\n"
    }, {
      "name" : "support/visitor/replace/ReplaceMapListener.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport java.util.Map;\n\npublic interface ReplaceMapListener<T extends Map> {\n\tvoid set(T replace);\n}\n"
    }, {
      "name" : "support/visitor/replace/ReplacementVisitor.java",
      "weight" : 1648.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n/**\n * Used to replace an element by another one.\n *\n * This class is generated automatically by the processor spoon.generating.ReplacementVisitorGenerator.\n */\npublic class ReplacementVisitor extends spoon.reflect.visitor.CtScanner {\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypedElementTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.declaration.CtTypedElement element;\n\n\t\tCtTypedElementTypeReplaceListener(spoon.reflect.declaration.CtTypedElement element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtElementCommentsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtElement element;\n\n\t\tCtElementCommentsReplaceListener(spoon.reflect.declaration.CtElement element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setComments(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAnnotationAnnotationTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.declaration.CtAnnotation element;\n\n\t\tCtAnnotationAnnotationTypeReplaceListener(spoon.reflect.declaration.CtAnnotation element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setAnnotationType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtElementAnnotationsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtElement element;\n\n\t\tCtElementAnnotationsReplaceListener(spoon.reflect.declaration.CtElement element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setAnnotations(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAnnotationValuesReplaceListener implements spoon.support.visitor.replace.ReplaceMapListener<java.util.Map> {\n\t\tprivate final spoon.reflect.declaration.CtAnnotation element;\n\n\t\tCtAnnotationValuesReplaceListener(spoon.reflect.declaration.CtAnnotation element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Map replace) {\n\t\t\tthis.element.setValues(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeTypeMembersReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtType element;\n\n\t\tCtTypeTypeMembersReplaceListener(spoon.reflect.declaration.CtType element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setTypeMembers(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableBodyReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtBlock> {\n\t\tprivate final spoon.reflect.code.CtBodyHolder element;\n\n\t\tCtExecutableBodyReplaceListener(spoon.reflect.code.CtBodyHolder element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtBlock replace) {\n\t\t\tthis.element.setBody(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExpressionTypeCastsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtExpression element;\n\n\t\tCtExpressionTypeCastsReplaceListener(spoon.reflect.code.CtExpression element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setTypeCasts(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTargetedExpressionTargetReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtTargetedExpression element;\n\n\t\tCtTargetedExpressionTargetReplaceListener(spoon.reflect.code.CtTargetedExpression element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setTarget(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtArrayAccessIndexExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtArrayAccess element;\n\n\t\tCtArrayAccessIndexExpressionReplaceListener(spoon.reflect.code.CtArrayAccess element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setIndexExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeReferencePackageReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtPackageReference> {\n\t\tprivate final spoon.reflect.reference.CtTypeReference element;\n\n\t\tCtTypeReferencePackageReplaceListener(spoon.reflect.reference.CtTypeReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtPackageReference replace) {\n\t\t\tthis.element.setPackage(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeReferenceDeclaringTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtTypeReference element;\n\n\t\tCtTypeReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtTypeReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setDeclaringType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtArrayTypeReferenceComponentTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtArrayTypeReference element;\n\n\t\tCtArrayTypeReferenceComponentTypeReplaceListener(spoon.reflect.reference.CtArrayTypeReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setComponentType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtActualTypeContainerActualTypeArgumentsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.reference.CtActualTypeContainer element;\n\n\t\tCtActualTypeContainerActualTypeArgumentsReplaceListener(spoon.reflect.reference.CtActualTypeContainer element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setActualTypeArguments(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAssertAssertExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtAssert element;\n\n\t\tCtAssertAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setAssertExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAssertExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtAssert element;\n\n\t\tCtAssertExpressionReplaceListener(spoon.reflect.code.CtAssert element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAssignmentAssignedReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtAssignment element;\n\n\t\tCtAssignmentAssignedReplaceListener(spoon.reflect.code.CtAssignment element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setAssigned(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtRHSReceiverAssignmentReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtRHSReceiver element;\n\n\t\tCtRHSReceiverAssignmentReplaceListener(spoon.reflect.code.CtRHSReceiver element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setAssignment(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtBinaryOperatorLeftHandOperandReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtBinaryOperator element;\n\n\t\tCtBinaryOperatorLeftHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setLeftHandOperand(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtBinaryOperatorRightHandOperandReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtBinaryOperator element;\n\n\t\tCtBinaryOperatorRightHandOperandReplaceListener(spoon.reflect.code.CtBinaryOperator element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setRightHandOperand(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtStatementListStatementsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtStatementList element;\n\n\t\tCtStatementListStatementsReplaceListener(spoon.reflect.code.CtStatementList element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setStatements(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCaseCaseExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtCase element;\n\n\t\tCtCaseCaseExpressionReplaceListener(spoon.reflect.code.CtCase element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setCaseExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCatchParameterReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtCatchVariable> {\n\t\tprivate final spoon.reflect.code.CtCatch element;\n\n\t\tCtCatchParameterReplaceListener(spoon.reflect.code.CtCatch element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtCatchVariable replace) {\n\t\t\tthis.element.setParameter(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCatchBodyReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtBlock> {\n\t\tprivate final spoon.reflect.code.CtBodyHolder element;\n\n\t\tCtCatchBodyReplaceListener(spoon.reflect.code.CtBodyHolder element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtBlock replace) {\n\t\t\tthis.element.setBody(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeInformationSuperclassReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.declaration.CtType element;\n\n\t\tCtTypeInformationSuperclassReplaceListener(spoon.reflect.declaration.CtType element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setSuperclass(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeInformationSuperInterfacesReplaceListener implements spoon.support.visitor.replace.ReplaceSetListener<java.util.Set> {\n\t\tprivate final spoon.reflect.declaration.CtType element;\n\n\t\tCtTypeInformationSuperInterfacesReplaceListener(spoon.reflect.declaration.CtType element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Set replace) {\n\t\t\tthis.element.setSuperInterfaces(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtFormalTypeDeclarer element;\n\n\t\tCtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(spoon.reflect.declaration.CtFormalTypeDeclarer element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setFormalCtTypeParameters(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtConditionalConditionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtConditional element;\n\n\t\tCtConditionalConditionReplaceListener(spoon.reflect.code.CtConditional element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setCondition(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtConditionalThenExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtConditional element;\n\n\t\tCtConditionalThenExpressionReplaceListener(spoon.reflect.code.CtConditional element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setThenExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtConditionalElseExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtConditional element;\n\n\t\tCtConditionalElseExpressionReplaceListener(spoon.reflect.code.CtConditional element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setElseExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableParametersReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtExecutable element;\n\n\t\tCtExecutableParametersReplaceListener(spoon.reflect.declaration.CtExecutable element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setParameters(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableThrownTypesReplaceListener implements spoon.support.visitor.replace.ReplaceSetListener<java.util.Set> {\n\t\tprivate final spoon.reflect.declaration.CtExecutable element;\n\n\t\tCtExecutableThrownTypesReplaceListener(spoon.reflect.declaration.CtExecutable element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Set replace) {\n\t\t\tthis.element.setThrownTypes(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtDoLoopingExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtDo element;\n\n\t\tCtDoLoopingExpressionReplaceListener(spoon.reflect.code.CtDo element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setLoopingExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtLoopBodyReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtStatement> {\n\t\tprivate final spoon.reflect.code.CtBodyHolder element;\n\n\t\tCtLoopBodyReplaceListener(spoon.reflect.code.CtBodyHolder element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtStatement replace) {\n\t\t\tthis.element.setBody(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtEnumEnumValuesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtEnum element;\n\n\t\tCtEnumEnumValuesReplaceListener(spoon.reflect.declaration.CtEnum element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setEnumValues(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableReferenceDeclaringTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtExecutableReference element;\n\n\t\tCtExecutableReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setDeclaringType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableReferenceTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtExecutableReference element;\n\n\t\tCtExecutableReferenceTypeReplaceListener(spoon.reflect.reference.CtExecutableReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableReferenceParametersReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.reference.CtExecutableReference element;\n\n\t\tCtExecutableReferenceParametersReplaceListener(spoon.reflect.reference.CtExecutableReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setParameters(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtVariableDefaultExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.declaration.CtVariable element;\n\n\t\tCtVariableDefaultExpressionReplaceListener(spoon.reflect.declaration.CtVariable element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setDefaultExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAnnotationFieldAccessVariableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {\n\t\tprivate final spoon.reflect.code.CtVariableAccess element;\n\n\t\tCtAnnotationFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtFieldReference replace) {\n\t\t\tthis.element.setVariable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtFieldReferenceDeclaringTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtFieldReference element;\n\n\t\tCtFieldReferenceDeclaringTypeReplaceListener(spoon.reflect.reference.CtFieldReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setDeclaringType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtVariableReferenceTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtVariableReference element;\n\n\t\tCtVariableReferenceTypeReplaceListener(spoon.reflect.reference.CtVariableReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtForForInitReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtFor element;\n\n\t\tCtForForInitReplaceListener(spoon.reflect.code.CtFor element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setForInit(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtForExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtFor element;\n\n\t\tCtForExpressionReplaceListener(spoon.reflect.code.CtFor element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtForForUpdateReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtFor element;\n\n\t\tCtForForUpdateReplaceListener(spoon.reflect.code.CtFor element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setForUpdate(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtForEachVariableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtLocalVariable> {\n\t\tprivate final spoon.reflect.code.CtForEach element;\n\n\t\tCtForEachVariableReplaceListener(spoon.reflect.code.CtForEach element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtLocalVariable replace) {\n\t\t\tthis.element.setVariable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtForEachExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtForEach element;\n\n\t\tCtForEachExpressionReplaceListener(spoon.reflect.code.CtForEach element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtIfConditionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtIf element;\n\n\t\tCtIfConditionReplaceListener(spoon.reflect.code.CtIf element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setCondition(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtIfThenStatementReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtStatement> {\n\t\tprivate final spoon.reflect.code.CtIf element;\n\n\t\tCtIfThenStatementReplaceListener(spoon.reflect.code.CtIf element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtStatement replace) {\n\t\t\tthis.element.setThenStatement(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtIfElseStatementReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtStatement> {\n\t\tprivate final spoon.reflect.code.CtIf element;\n\n\t\tCtIfElseStatementReplaceListener(spoon.reflect.code.CtIf element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtStatement replace) {\n\t\t\tthis.element.setElseStatement(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAbstractInvocationExecutableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {\n\t\tprivate final spoon.reflect.code.CtAbstractInvocation element;\n\n\t\tCtAbstractInvocationExecutableReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtExecutableReference replace) {\n\t\t\tthis.element.setExecutable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAbstractInvocationArgumentsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtAbstractInvocation element;\n\n\t\tCtAbstractInvocationArgumentsReplaceListener(spoon.reflect.code.CtAbstractInvocation element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setArguments(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtMultiTypedElementMultiTypesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtMultiTypedElement element;\n\n\t\tCtMultiTypedElementMultiTypesReplaceListener(spoon.reflect.declaration.CtMultiTypedElement element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setMultiTypes(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtAnnotationMethodDefaultExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.declaration.CtAnnotationMethod element;\n\n\t\tCtAnnotationMethodDefaultExpressionReplaceListener(spoon.reflect.declaration.CtAnnotationMethod element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setDefaultExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtNewArrayElementsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtNewArray element;\n\n\t\tCtNewArrayElementsReplaceListener(spoon.reflect.code.CtNewArray element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setElements(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtNewArrayDimensionExpressionsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtNewArray element;\n\n\t\tCtNewArrayDimensionExpressionsReplaceListener(spoon.reflect.code.CtNewArray element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setDimensionExpressions(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtNewClassAnonymousClassReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.declaration.CtClass> {\n\t\tprivate final spoon.reflect.code.CtNewClass element;\n\n\t\tCtNewClassAnonymousClassReplaceListener(spoon.reflect.code.CtNewClass element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.declaration.CtClass replace) {\n\t\t\tthis.element.setAnonymousClass(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtLambdaExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtLambda element;\n\n\t\tCtLambdaExpressionReplaceListener(spoon.reflect.code.CtLambda element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtExecutableReferenceExpressionExecutableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtExecutableReference> {\n\t\tprivate final spoon.reflect.code.CtExecutableReferenceExpression element;\n\n\t\tCtExecutableReferenceExpressionExecutableReplaceListener(spoon.reflect.code.CtExecutableReferenceExpression element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtExecutableReference replace) {\n\t\t\tthis.element.setExecutable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtPackagePackagesReplaceListener implements spoon.support.visitor.replace.ReplaceSetListener<java.util.Set> {\n\t\tprivate final spoon.reflect.declaration.CtPackage element;\n\n\t\tCtPackagePackagesReplaceListener(spoon.reflect.declaration.CtPackage element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Set replace) {\n\t\t\tthis.element.setPackages(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtPackageTypesReplaceListener implements spoon.support.visitor.replace.ReplaceSetListener<java.util.Set> {\n\t\tprivate final spoon.reflect.declaration.CtPackage element;\n\n\t\tCtPackageTypesReplaceListener(spoon.reflect.declaration.CtPackage element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Set replace) {\n\t\t\tthis.element.setTypes(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtReturnReturnedExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtReturn element;\n\n\t\tCtReturnReturnedExpressionReplaceListener(spoon.reflect.code.CtReturn element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setReturnedExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtSwitchSelectorReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtSwitch element;\n\n\t\tCtSwitchSelectorReplaceListener(spoon.reflect.code.CtSwitch element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setSelector(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtSwitchCasesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtSwitch element;\n\n\t\tCtSwitchCasesReplaceListener(spoon.reflect.code.CtSwitch element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setCases(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtSynchronizedExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtSynchronized element;\n\n\t\tCtSynchronizedExpressionReplaceListener(spoon.reflect.code.CtSynchronized element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtSynchronizedBlockReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtBlock> {\n\t\tprivate final spoon.reflect.code.CtSynchronized element;\n\n\t\tCtSynchronizedBlockReplaceListener(spoon.reflect.code.CtSynchronized element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtBlock replace) {\n\t\t\tthis.element.setBlock(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtThrowThrownExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtThrow element;\n\n\t\tCtThrowThrownExpressionReplaceListener(spoon.reflect.code.CtThrow element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setThrownExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTryBodyReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtBlock> {\n\t\tprivate final spoon.reflect.code.CtBodyHolder element;\n\n\t\tCtTryBodyReplaceListener(spoon.reflect.code.CtBodyHolder element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtBlock replace) {\n\t\t\tthis.element.setBody(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTryCatchersReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtTry element;\n\n\t\tCtTryCatchersReplaceListener(spoon.reflect.code.CtTry element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setCatchers(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTryFinalizerReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtBlock> {\n\t\tprivate final spoon.reflect.code.CtTry element;\n\n\t\tCtTryFinalizerReplaceListener(spoon.reflect.code.CtTry element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtBlock replace) {\n\t\t\tthis.element.setFinalizer(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTryWithResourceResourcesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtTryWithResource element;\n\n\t\tCtTryWithResourceResourcesReplaceListener(spoon.reflect.code.CtTryWithResource element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setResources(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtWildcardReferenceBoundingTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtWildcardReference element;\n\n\t\tCtWildcardReferenceBoundingTypeReplaceListener(spoon.reflect.reference.CtWildcardReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setBoundingType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtIntersectionTypeReferenceBoundsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.reference.CtIntersectionTypeReference element;\n\n\t\tCtIntersectionTypeReferenceBoundsReplaceListener(spoon.reflect.reference.CtIntersectionTypeReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setBounds(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeAccessAccessedTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.code.CtTypeAccess element;\n\n\t\tCtTypeAccessAccessedTypeReplaceListener(spoon.reflect.code.CtTypeAccess element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setAccessedType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtUnaryOperatorOperandReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtUnaryOperator element;\n\n\t\tCtUnaryOperatorOperandReplaceListener(spoon.reflect.code.CtUnaryOperator element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setOperand(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtVariableAccessVariableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtVariableReference> {\n\t\tprivate final spoon.reflect.code.CtVariableAccess element;\n\n\t\tCtVariableAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtVariableReference replace) {\n\t\t\tthis.element.setVariable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtWhileLoopingExpressionReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.code.CtExpression> {\n\t\tprivate final spoon.reflect.code.CtWhile element;\n\n\t\tCtWhileLoopingExpressionReplaceListener(spoon.reflect.code.CtWhile element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.code.CtExpression replace) {\n\t\t\tthis.element.setLoopingExpression(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtFieldAccessVariableReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtFieldReference> {\n\t\tprivate final spoon.reflect.code.CtVariableAccess element;\n\n\t\tCtFieldAccessVariableReplaceListener(spoon.reflect.code.CtVariableAccess element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtFieldReference replace) {\n\t\t\tthis.element.setVariable(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtJavaDocTagsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.code.CtJavaDoc element;\n\n\t\tCtJavaDocTagsReplaceListener(spoon.reflect.code.CtJavaDoc element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setTags(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtImportReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtReference> {\n\t\tprivate final spoon.reflect.declaration.CtImport element;\n\n\t\tCtImportReferenceReplaceListener(spoon.reflect.declaration.CtImport element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtReference replace) {\n\t\t\tthis.element.setReference(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtModuleModuleDirectivesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtModule element;\n\n\t\tCtModuleModuleDirectivesReplaceListener(spoon.reflect.declaration.CtModule element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setModuleDirectives(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtModuleRootPackageReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.declaration.CtPackage> {\n\t\tprivate final spoon.reflect.declaration.CtModule element;\n\n\t\tCtModuleRootPackageReplaceListener(spoon.reflect.declaration.CtModule element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.declaration.CtPackage replace) {\n\t\t\tthis.element.setRootPackage(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtPackageExportPackageReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtPackageReference> {\n\t\tprivate final spoon.reflect.declaration.CtPackageExport element;\n\n\t\tCtPackageExportPackageReferenceReplaceListener(spoon.reflect.declaration.CtPackageExport element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtPackageReference replace) {\n\t\t\tthis.element.setPackageReference(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtPackageExportTargetExportReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtPackageExport element;\n\n\t\tCtPackageExportTargetExportReplaceListener(spoon.reflect.declaration.CtPackageExport element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setTargetExport(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtModuleRequirementModuleReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtModuleReference> {\n\t\tprivate final spoon.reflect.declaration.CtModuleRequirement element;\n\n\t\tCtModuleRequirementModuleReferenceReplaceListener(spoon.reflect.declaration.CtModuleRequirement element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtModuleReference replace) {\n\t\t\tthis.element.setModuleReference(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtProvidedServiceServiceTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.declaration.CtProvidedService element;\n\n\t\tCtProvidedServiceServiceTypeReplaceListener(spoon.reflect.declaration.CtProvidedService element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setServiceType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtProvidedServiceImplementationTypesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtProvidedService element;\n\n\t\tCtProvidedServiceImplementationTypesReplaceListener(spoon.reflect.declaration.CtProvidedService element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setImplementationTypes(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtUsedServiceServiceTypeReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.declaration.CtUsedService element;\n\n\t\tCtUsedServiceServiceTypeReplaceListener(spoon.reflect.declaration.CtUsedService element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setServiceType(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCompilationUnitPackageDeclarationReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.declaration.CtPackageDeclaration> {\n\t\tprivate final spoon.reflect.declaration.CtCompilationUnit element;\n\n\t\tCtCompilationUnitPackageDeclarationReplaceListener(spoon.reflect.declaration.CtCompilationUnit element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.declaration.CtPackageDeclaration replace) {\n\t\t\tthis.element.setPackageDeclaration(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCompilationUnitImportsReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.Collection> {\n\t\tprivate final spoon.reflect.declaration.CtCompilationUnit element;\n\n\t\tCtCompilationUnitImportsReplaceListener(spoon.reflect.declaration.CtCompilationUnit element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.Collection replace) {\n\t\t\tthis.element.setImports(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCompilationUnitDeclaredModuleReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtModuleReference> {\n\t\tprivate final spoon.reflect.declaration.CtCompilationUnit element;\n\n\t\tCtCompilationUnitDeclaredModuleReferenceReplaceListener(spoon.reflect.declaration.CtCompilationUnit element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtModuleReference replace) {\n\t\t\tthis.element.setDeclaredModuleReference(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtCompilationUnitDeclaredTypeReferencesReplaceListener implements spoon.support.visitor.replace.ReplaceListListener<java.util.List> {\n\t\tprivate final spoon.reflect.declaration.CtCompilationUnit element;\n\n\t\tCtCompilationUnitDeclaredTypeReferencesReplaceListener(spoon.reflect.declaration.CtCompilationUnit element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(java.util.List replace) {\n\t\t\tthis.element.setDeclaredTypeReferences(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtPackageDeclarationReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtPackageReference> {\n\t\tprivate final spoon.reflect.declaration.CtPackageDeclaration element;\n\n\t\tCtPackageDeclarationReferenceReplaceListener(spoon.reflect.declaration.CtPackageDeclaration element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtPackageReference replace) {\n\t\t\tthis.element.setReference(replace);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\tclass CtTypeMemberWildcardImportReferenceTypeReferenceReplaceListener implements spoon.support.visitor.replace.ReplaceListener<spoon.reflect.reference.CtTypeReference> {\n\t\tprivate final spoon.reflect.reference.CtTypeMemberWildcardImportReference element;\n\n\t\tCtTypeMemberWildcardImportReferenceTypeReferenceReplaceListener(spoon.reflect.reference.CtTypeMemberWildcardImportReference element) {\n\t\t\tthis.element = element;\n\t\t}\n\n\t\t@java.lang.Override\n\t\tpublic void set(spoon.reflect.reference.CtTypeReference replace) {\n\t\t\tthis.element.setTypeReference(replace);\n\t\t}\n\t}\n\n\tpublic static void replace(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement replace) {\n\t\ttry {\n\t\t\tnew spoon.support.visitor.replace.ReplacementVisitor(original, (replace == null ? EMPTY : new spoon.reflect.declaration.CtElement[]{ replace })).scan(original.getParent());\n\t\t} catch (spoon.support.visitor.replace.InvalidReplaceException e) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tpublic static <E extends spoon.reflect.declaration.CtElement> void replace(spoon.reflect.declaration.CtElement original, java.util.Collection<E> replaces) {\n\t\ttry {\n\t\t\tnew spoon.support.visitor.replace.ReplacementVisitor(original, replaces.toArray(new spoon.reflect.declaration.CtElement[replaces.size()])).scan(original.getParent());\n\t\t} catch (spoon.support.visitor.replace.InvalidReplaceException e) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tprivate spoon.reflect.declaration.CtElement original;\n\n\tprivate spoon.reflect.declaration.CtElement[] replace;\n\n\tprivate static final spoon.reflect.declaration.CtElement[] EMPTY = new spoon.reflect.declaration.CtElement[0];\n\n\tprivate ReplacementVisitor(spoon.reflect.declaration.CtElement original, spoon.reflect.declaration.CtElement... replace) {\n\t\tthis.original = original;\n\t\tthis.replace = (replace == null) ? EMPTY : replace;\n\t}\n\n\tprivate <K, V extends spoon.reflect.declaration.CtElement> void replaceInMapIfExist(java.util.Map<K, V> mapProtected, spoon.support.visitor.replace.ReplaceMapListener listener) {\n\t\tjava.util.Map<K, V> map = new java.util.HashMap<>(mapProtected);\n\t\tV shouldBeDeleted = null;\n\t\tK key = null;\n\t\tfor (java.util.Map.Entry<K, V> entry : map.entrySet()) {\n\t\t\tif ((entry.getValue()) == (original)) {\n\t\t\t\tshouldBeDeleted = entry.getValue();\n\t\t\t\tkey = entry.getKey();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (shouldBeDeleted != null) {\n\t\t\tif ((replace.length) > 0) {\n\t\t\t\tif ((replace.length) > 1) {\n\t\t\t\t\tthrow new spoon.support.visitor.replace.InvalidReplaceException((\"Cannot replace single value by multiple values in \" + (listener.getClass().getSimpleName())));\n\t\t\t\t}\n\t\t\t\tV val = ((V) (replace[0]));\n\t\t\t\tif (val != null) {\n\t\t\t\t\tmap.put(key, val);\n\t\t\t\t\tval.setParent(shouldBeDeleted.getParent());\n\t\t\t\t} else {\n\t\t\t\t\tmap.remove(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmap.remove(key);\n\t\t\t}\n\t\t\tlistener.set(map);\n\t\t}\n\t}\n\n\tprivate <T extends spoon.reflect.declaration.CtElement> void replaceInSetIfExist(java.util.Set<T> setProtected, spoon.support.visitor.replace.ReplaceSetListener listener) {\n\t\tjava.util.Set<T> set = new java.util.HashSet<>(setProtected);\n\t\tT shouldBeDeleted = null;\n\t\tfor (T element : set) {\n\t\t\tif (element == (original)) {\n\t\t\t\tshouldBeDeleted = element;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (shouldBeDeleted != null) {\n\t\t\tset.remove(shouldBeDeleted);\n\t\t\tfor (spoon.reflect.declaration.CtElement ele : replace) {\n\t\t\t\tif (ele != null) {\n\t\t\t\t\tset.add(((T) (ele)));\n\t\t\t\t\tele.setParent(shouldBeDeleted.getParent());\n\t\t\t\t}\n\t\t\t}\n\t\t\tlistener.set(set);\n\t\t}\n\t}\n\n\tprivate <T extends spoon.reflect.declaration.CtElement> void replaceInListIfExist(java.util.List<T> listProtected, spoon.support.visitor.replace.ReplaceListListener listener) {\n\t\tjava.util.List<T> list = new java.util.ArrayList<>(listProtected);\n\t\tT shouldBeDeleted = null;\n\t\tint index = 0;\n\t\tfor (int i = 0; i < (list.size()); i++) {\n\t\t\tif ((list.get(i)) == (original)) {\n\t\t\t\tindex = i;\n\t\t\t\tshouldBeDeleted = list.get(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (shouldBeDeleted != null) {\n\t\t\tlist.remove(index);\n\t\t\tif ((replace.length) > 0) {\n\t\t\t\tfor (spoon.reflect.declaration.CtElement aReplace : replace) {\n\t\t\t\t\tT ele = ((T) (aReplace));\n\t\t\t\t\tif (ele != null) {\n\t\t\t\t\t\tlist.add(index, ele);\n\t\t\t\t\t\tele.setParent(shouldBeDeleted.getParent());\n\t\t\t\t\t\tindex = index + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlistener.set(list);\n\t\t}\n\t}\n\n\tprivate void replaceElementIfExist(spoon.reflect.declaration.CtElement candidate, spoon.support.visitor.replace.ReplaceListener listener) {\n\t\tif (candidate == (original)) {\n\t\t\tspoon.reflect.declaration.CtElement val = null;\n\t\t\tif ((replace.length) > 0) {\n\t\t\t\tif ((replace.length) > 1) {\n\t\t\t\t\tthrow new spoon.support.visitor.replace.InvalidReplaceException((\"Cannot replace single value by multiple values in \" + (listener.getClass().getSimpleName())));\n\t\t\t\t}\n\t\t\t\tval = replace[0];\n\t\t\t}\n\t\t\tif (val != null) {\n\t\t\t\tval.setParent(candidate.getParent());\n\t\t\t}\n\t\t\tlistener.set(val);\n\t\t}\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotation(final spoon.reflect.declaration.CtAnnotation<A> annotation) {\n\t\treplaceElementIfExist(annotation.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(annotation));\n\t\treplaceInListIfExist(annotation.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotation));\n\t\treplaceElementIfExist(annotation.getAnnotationType(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationAnnotationTypeReplaceListener(annotation));\n\t\treplaceInListIfExist(annotation.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotation));\n\t\treplaceInMapIfExist(annotation.getValues(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationValuesReplaceListener(annotation));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(final spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n\t\treplaceInListIfExist(annotationType.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationType));\n\t\treplaceInListIfExist(annotationType.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(annotationType));\n\t\treplaceInListIfExist(annotationType.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationType));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtAnonymousExecutable(final spoon.reflect.declaration.CtAnonymousExecutable anonymousExec) {\n\t\treplaceInListIfExist(anonymousExec.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(anonymousExec));\n\t\treplaceElementIfExist(anonymousExec.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(anonymousExec));\n\t\treplaceInListIfExist(anonymousExec.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(anonymousExec));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayRead(final spoon.reflect.code.CtArrayRead<T> arrayRead) {\n\t\treplaceInListIfExist(arrayRead.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayRead));\n\t\treplaceElementIfExist(arrayRead.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayRead));\n\t\treplaceInListIfExist(arrayRead.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayRead));\n\t\treplaceElementIfExist(arrayRead.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayRead));\n\t\treplaceElementIfExist(arrayRead.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayRead));\n\t\treplaceInListIfExist(arrayRead.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayRead));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayWrite(final spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n\t\treplaceInListIfExist(arrayWrite.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(arrayWrite));\n\t\treplaceElementIfExist(arrayWrite.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(arrayWrite));\n\t\treplaceInListIfExist(arrayWrite.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(arrayWrite));\n\t\treplaceElementIfExist(arrayWrite.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(arrayWrite));\n\t\treplaceElementIfExist(arrayWrite.getIndexExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayAccessIndexExpressionReplaceListener(arrayWrite));\n\t\treplaceInListIfExist(arrayWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(arrayWrite));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtArrayTypeReference(final spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n\t\treplaceElementIfExist(reference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getComponentType(), new spoon.support.visitor.replace.ReplacementVisitor.CtArrayTypeReferenceComponentTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtAssert(final spoon.reflect.code.CtAssert<T> asserted) {\n\t\treplaceInListIfExist(asserted.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(asserted));\n\t\treplaceElementIfExist(asserted.getAssertExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertAssertExpressionReplaceListener(asserted));\n\t\treplaceElementIfExist(asserted.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssertExpressionReplaceListener(asserted));\n\t\treplaceInListIfExist(asserted.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(asserted));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T, A extends T> void visitCtAssignment(final spoon.reflect.code.CtAssignment<T, A> assignement) {\n\t\treplaceInListIfExist(assignement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(assignement));\n\t\treplaceElementIfExist(assignement.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(assignement));\n\t\treplaceInListIfExist(assignement.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(assignement));\n\t\treplaceElementIfExist(assignement.getAssigned(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssignmentAssignedReplaceListener(assignement));\n\t\treplaceElementIfExist(assignement.getAssignment(), new spoon.support.visitor.replace.ReplacementVisitor.CtRHSReceiverAssignmentReplaceListener(assignement));\n\t\treplaceInListIfExist(assignement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(assignement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtBinaryOperator(final spoon.reflect.code.CtBinaryOperator<T> operator) {\n\t\treplaceInListIfExist(operator.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(operator));\n\t\treplaceElementIfExist(operator.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(operator));\n\t\treplaceInListIfExist(operator.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(operator));\n\t\treplaceElementIfExist(operator.getLeftHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorLeftHandOperandReplaceListener(operator));\n\t\treplaceElementIfExist(operator.getRightHandOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtBinaryOperatorRightHandOperandReplaceListener(operator));\n\t\treplaceInListIfExist(operator.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(operator));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <R> void visitCtBlock(final spoon.reflect.code.CtBlock<R> block) {\n\t\treplaceInListIfExist(block.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(block));\n\t\treplaceInListIfExist(block.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(block));\n\t\treplaceInListIfExist(block.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(block));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtBreak(final spoon.reflect.code.CtBreak breakStatement) {\n\t\treplaceInListIfExist(breakStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(breakStatement));\n\t\treplaceInListIfExist(breakStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(breakStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <S> void visitCtCase(final spoon.reflect.code.CtCase<S> caseStatement) {\n\t\treplaceInListIfExist(caseStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(caseStatement));\n\t\treplaceElementIfExist(caseStatement.getCaseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtCaseCaseExpressionReplaceListener(caseStatement));\n\t\treplaceInListIfExist(caseStatement.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(caseStatement));\n\t\treplaceInListIfExist(caseStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(caseStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtCatch(final spoon.reflect.code.CtCatch catchBlock) {\n\t\treplaceInListIfExist(catchBlock.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(catchBlock));\n\t\treplaceElementIfExist(catchBlock.getParameter(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchParameterReplaceListener(catchBlock));\n\t\treplaceElementIfExist(catchBlock.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtCatchBodyReplaceListener(catchBlock));\n\t\treplaceInListIfExist(catchBlock.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(catchBlock));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtClass(final spoon.reflect.declaration.CtClass<T> ctClass) {\n\t\treplaceInListIfExist(ctClass.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctClass));\n\t\treplaceElementIfExist(ctClass.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(ctClass));\n\t\treplaceInSetIfExist(ctClass.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctClass));\n\t\treplaceInListIfExist(ctClass.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(ctClass));\n\t\treplaceInListIfExist(ctClass.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(ctClass));\n\t\treplaceInListIfExist(ctClass.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctClass));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n\t\treplaceInListIfExist(typeParameter.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(typeParameter));\n\t\treplaceElementIfExist(typeParameter.getSuperclass(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperclassReplaceListener(typeParameter));\n\t\treplaceInListIfExist(typeParameter.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(typeParameter));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConditional(final spoon.reflect.code.CtConditional<T> conditional) {\n\t\treplaceElementIfExist(conditional.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(conditional));\n\t\treplaceInListIfExist(conditional.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(conditional));\n\t\treplaceElementIfExist(conditional.getCondition(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalConditionReplaceListener(conditional));\n\t\treplaceElementIfExist(conditional.getThenExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalThenExpressionReplaceListener(conditional));\n\t\treplaceElementIfExist(conditional.getElseExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtConditionalElseExpressionReplaceListener(conditional));\n\t\treplaceInListIfExist(conditional.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(conditional));\n\t\treplaceInListIfExist(conditional.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(conditional));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConstructor(final spoon.reflect.declaration.CtConstructor<T> c) {\n\t\treplaceInListIfExist(c.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(c));\n\t\treplaceInListIfExist(c.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableParametersReplaceListener(c));\n\t\treplaceInSetIfExist(c.getThrownTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableThrownTypesReplaceListener(c));\n\t\treplaceInListIfExist(c.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(c));\n\t\treplaceElementIfExist(c.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(c));\n\t\treplaceInListIfExist(c.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(c));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtContinue(final spoon.reflect.code.CtContinue continueStatement) {\n\t\treplaceInListIfExist(continueStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(continueStatement));\n\t\treplaceInListIfExist(continueStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(continueStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtDo(final spoon.reflect.code.CtDo doLoop) {\n\t\treplaceInListIfExist(doLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(doLoop));\n\t\treplaceElementIfExist(doLoop.getLoopingExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtDoLoopingExpressionReplaceListener(doLoop));\n\t\treplaceElementIfExist(doLoop.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(doLoop));\n\t\treplaceInListIfExist(doLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(doLoop));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T extends java.lang.Enum<?>> void visitCtEnum(final spoon.reflect.declaration.CtEnum<T> ctEnum) {\n\t\treplaceInListIfExist(ctEnum.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctEnum));\n\t\treplaceInSetIfExist(ctEnum.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(ctEnum));\n\t\treplaceInListIfExist(ctEnum.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(ctEnum));\n\t\treplaceInListIfExist(ctEnum.getEnumValues(), new spoon.support.visitor.replace.ReplacementVisitor.CtEnumEnumValuesReplaceListener(ctEnum));\n\t\treplaceInListIfExist(ctEnum.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctEnum));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtExecutableReference(final spoon.reflect.reference.CtExecutableReference<T> reference) {\n\t\treplaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceDeclaringTypeReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceParametersReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtField(final spoon.reflect.declaration.CtField<T> f) {\n\t\treplaceInListIfExist(f.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(f));\n\t\treplaceElementIfExist(f.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(f));\n\t\treplaceElementIfExist(f.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(f));\n\t\treplaceInListIfExist(f.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(f));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtEnumValue(final spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n\t\treplaceInListIfExist(enumValue.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(enumValue));\n\t\treplaceElementIfExist(enumValue.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(enumValue));\n\t\treplaceElementIfExist(enumValue.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(enumValue));\n\t\treplaceInListIfExist(enumValue.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(enumValue));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtThisAccess(final spoon.reflect.code.CtThisAccess<T> thisAccess) {\n\t\treplaceInListIfExist(thisAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(thisAccess));\n\t\treplaceInListIfExist(thisAccess.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(thisAccess));\n\t\treplaceElementIfExist(thisAccess.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(thisAccess));\n\t\treplaceInListIfExist(thisAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(thisAccess));\n\t\treplaceElementIfExist(thisAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(thisAccess));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtAnnotationFieldAccess(final spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n\t\treplaceInListIfExist(annotationFieldAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationFieldAccess));\n\t\treplaceInListIfExist(annotationFieldAccess.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationFieldAccess));\n\t\treplaceInListIfExist(annotationFieldAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(annotationFieldAccess));\n\t\treplaceElementIfExist(annotationFieldAccess.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(annotationFieldAccess));\n\t\treplaceElementIfExist(annotationFieldAccess.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationFieldAccessVariableReplaceListener(annotationFieldAccess));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldReference(final spoon.reflect.reference.CtFieldReference<T> reference) {\n\t\treplaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtFieldReferenceDeclaringTypeReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtFor(final spoon.reflect.code.CtFor forLoop) {\n\t\treplaceInListIfExist(forLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(forLoop));\n\t\treplaceInListIfExist(forLoop.getForInit(), new spoon.support.visitor.replace.ReplacementVisitor.CtForForInitReplaceListener(forLoop));\n\t\treplaceElementIfExist(forLoop.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtForExpressionReplaceListener(forLoop));\n\t\treplaceInListIfExist(forLoop.getForUpdate(), new spoon.support.visitor.replace.ReplacementVisitor.CtForForUpdateReplaceListener(forLoop));\n\t\treplaceElementIfExist(forLoop.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(forLoop));\n\t\treplaceInListIfExist(forLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(forLoop));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtForEach(final spoon.reflect.code.CtForEach foreach) {\n\t\treplaceInListIfExist(foreach.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(foreach));\n\t\treplaceElementIfExist(foreach.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtForEachVariableReplaceListener(foreach));\n\t\treplaceElementIfExist(foreach.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtForEachExpressionReplaceListener(foreach));\n\t\treplaceElementIfExist(foreach.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(foreach));\n\t\treplaceInListIfExist(foreach.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(foreach));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtIf(final spoon.reflect.code.CtIf ifElement) {\n\t\treplaceInListIfExist(ifElement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ifElement));\n\t\treplaceElementIfExist(ifElement.getCondition(), new spoon.support.visitor.replace.ReplacementVisitor.CtIfConditionReplaceListener(ifElement));\n\t\treplaceElementIfExist(((spoon.reflect.code.CtStatement) (ifElement.getThenStatement())), new spoon.support.visitor.replace.ReplacementVisitor.CtIfThenStatementReplaceListener(ifElement));\n\t\treplaceElementIfExist(((spoon.reflect.code.CtStatement) (ifElement.getElseStatement())), new spoon.support.visitor.replace.ReplacementVisitor.CtIfElseStatementReplaceListener(ifElement));\n\t\treplaceInListIfExist(ifElement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ifElement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtInterface(final spoon.reflect.declaration.CtInterface<T> intrface) {\n\t\treplaceInListIfExist(intrface.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(intrface));\n\t\treplaceInSetIfExist(intrface.getSuperInterfaces(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeInformationSuperInterfacesReplaceListener(intrface));\n\t\treplaceInListIfExist(intrface.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(intrface));\n\t\treplaceInListIfExist(intrface.getTypeMembers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeTypeMembersReplaceListener(intrface));\n\t\treplaceInListIfExist(intrface.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(intrface));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtInvocation(final spoon.reflect.code.CtInvocation<T> invocation) {\n\t\treplaceInListIfExist(invocation.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(invocation));\n\t\treplaceInListIfExist(invocation.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(invocation));\n\t\treplaceElementIfExist(invocation.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(invocation));\n\t\treplaceElementIfExist(invocation.getExecutable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationExecutableReplaceListener(invocation));\n\t\treplaceInListIfExist(invocation.getArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationArgumentsReplaceListener(invocation));\n\t\treplaceInListIfExist(invocation.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(invocation));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLiteral(final spoon.reflect.code.CtLiteral<T> literal) {\n\t\treplaceInListIfExist(literal.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(literal));\n\t\treplaceElementIfExist(literal.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(literal));\n\t\treplaceInListIfExist(literal.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(literal));\n\t\treplaceInListIfExist(literal.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(literal));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLocalVariable(final spoon.reflect.code.CtLocalVariable<T> localVariable) {\n\t\treplaceInListIfExist(localVariable.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(localVariable));\n\t\treplaceElementIfExist(localVariable.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(localVariable));\n\t\treplaceElementIfExist(localVariable.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableDefaultExpressionReplaceListener(localVariable));\n\t\treplaceInListIfExist(localVariable.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(localVariable));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLocalVariableReference(final spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtCatchVariable(final spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n\t\treplaceInListIfExist(catchVariable.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(catchVariable));\n\t\treplaceInListIfExist(catchVariable.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(catchVariable));\n\t\treplaceInListIfExist(catchVariable.getMultiTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtMultiTypedElementMultiTypesReplaceListener(catchVariable));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtCatchVariableReference(final spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtMethod(final spoon.reflect.declaration.CtMethod<T> m) {\n\t\treplaceInListIfExist(m.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(m));\n\t\treplaceInListIfExist(m.getFormalCtTypeParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtFormalTypeDeclarerFormalCtTypeParametersReplaceListener(m));\n\t\treplaceElementIfExist(m.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(m));\n\t\treplaceInListIfExist(m.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableParametersReplaceListener(m));\n\t\treplaceInSetIfExist(m.getThrownTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableThrownTypesReplaceListener(m));\n\t\treplaceElementIfExist(m.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(m));\n\t\treplaceInListIfExist(m.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(m));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n\t\treplaceInListIfExist(annotationMethod.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(annotationMethod));\n\t\treplaceElementIfExist(annotationMethod.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(annotationMethod));\n\t\treplaceElementIfExist(annotationMethod.getDefaultExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtAnnotationMethodDefaultExpressionReplaceListener(annotationMethod));\n\t\treplaceInListIfExist(annotationMethod.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(annotationMethod));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtNewArray(final spoon.reflect.code.CtNewArray<T> newArray) {\n\t\treplaceInListIfExist(newArray.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(newArray));\n\t\treplaceElementIfExist(newArray.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(newArray));\n\t\treplaceInListIfExist(newArray.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(newArray));\n\t\treplaceInListIfExist(newArray.getElements(), new spoon.support.visitor.replace.ReplacementVisitor.CtNewArrayElementsReplaceListener(newArray));\n\t\treplaceInListIfExist(newArray.getDimensionExpressions(), new spoon.support.visitor.replace.ReplacementVisitor.CtNewArrayDimensionExpressionsReplaceListener(newArray));\n\t\treplaceInListIfExist(newArray.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(newArray));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtConstructorCall(final spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n\t\treplaceInListIfExist(ctConstructorCall.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctConstructorCall));\n\t\treplaceInListIfExist(ctConstructorCall.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(ctConstructorCall));\n\t\treplaceElementIfExist(ctConstructorCall.getExecutable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationExecutableReplaceListener(ctConstructorCall));\n\t\treplaceElementIfExist(ctConstructorCall.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(ctConstructorCall));\n\t\treplaceInListIfExist(ctConstructorCall.getArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationArgumentsReplaceListener(ctConstructorCall));\n\t\treplaceInListIfExist(ctConstructorCall.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctConstructorCall));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtNewClass(final spoon.reflect.code.CtNewClass<T> newClass) {\n\t\treplaceInListIfExist(newClass.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(newClass));\n\t\treplaceInListIfExist(newClass.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(newClass));\n\t\treplaceElementIfExist(newClass.getExecutable(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationExecutableReplaceListener(newClass));\n\t\treplaceElementIfExist(newClass.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(newClass));\n\t\treplaceInListIfExist(newClass.getArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtAbstractInvocationArgumentsReplaceListener(newClass));\n\t\treplaceElementIfExist(newClass.getAnonymousClass(), new spoon.support.visitor.replace.ReplacementVisitor.CtNewClassAnonymousClassReplaceListener(newClass));\n\t\treplaceInListIfExist(newClass.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(newClass));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtLambda(final spoon.reflect.code.CtLambda<T> lambda) {\n\t\treplaceInListIfExist(lambda.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(lambda));\n\t\treplaceElementIfExist(lambda.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(lambda));\n\t\treplaceInListIfExist(lambda.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(lambda));\n\t\treplaceInListIfExist(lambda.getParameters(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableParametersReplaceListener(lambda));\n\t\treplaceElementIfExist(lambda.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableBodyReplaceListener(lambda));\n\t\treplaceElementIfExist(lambda.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtLambdaExpressionReplaceListener(lambda));\n\t\treplaceInListIfExist(lambda.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(lambda));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(final spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n\t\treplaceInListIfExist(expression.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(expression));\n\t\treplaceInListIfExist(expression.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(expression));\n\t\treplaceElementIfExist(expression.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(expression));\n\t\treplaceInListIfExist(expression.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(expression));\n\t\treplaceElementIfExist(expression.getExecutable(), new spoon.support.visitor.replace.ReplacementVisitor.CtExecutableReferenceExpressionExecutableReplaceListener(expression));\n\t\treplaceElementIfExist(expression.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(expression));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T, A extends T> void visitCtOperatorAssignment(final spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n\t\treplaceInListIfExist(assignment.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(assignment));\n\t\treplaceElementIfExist(assignment.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(assignment));\n\t\treplaceInListIfExist(assignment.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(assignment));\n\t\treplaceElementIfExist(assignment.getAssigned(), new spoon.support.visitor.replace.ReplacementVisitor.CtAssignmentAssignedReplaceListener(assignment));\n\t\treplaceElementIfExist(assignment.getAssignment(), new spoon.support.visitor.replace.ReplacementVisitor.CtRHSReceiverAssignmentReplaceListener(assignment));\n\t\treplaceInListIfExist(assignment.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(assignment));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackage(final spoon.reflect.declaration.CtPackage ctPackage) {\n\t\treplaceInListIfExist(ctPackage.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctPackage));\n\t\treplaceInSetIfExist(ctPackage.getPackages(), new spoon.support.visitor.replace.ReplacementVisitor.CtPackagePackagesReplaceListener(ctPackage));\n\t\treplaceInSetIfExist(ctPackage.getTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtPackageTypesReplaceListener(ctPackage));\n\t\treplaceInListIfExist(ctPackage.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctPackage));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageReference(final spoon.reflect.reference.CtPackageReference reference) {\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtParameter(final spoon.reflect.declaration.CtParameter<T> parameter) {\n\t\treplaceInListIfExist(parameter.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(parameter));\n\t\treplaceElementIfExist(parameter.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(parameter));\n\t\treplaceInListIfExist(parameter.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(parameter));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtParameterReference(final spoon.reflect.reference.CtParameterReference<T> reference) {\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <R> void visitCtReturn(final spoon.reflect.code.CtReturn<R> returnStatement) {\n\t\treplaceInListIfExist(returnStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(returnStatement));\n\t\treplaceElementIfExist(returnStatement.getReturnedExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtReturnReturnedExpressionReplaceListener(returnStatement));\n\t\treplaceInListIfExist(returnStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(returnStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <R> void visitCtStatementList(final spoon.reflect.code.CtStatementList statements) {\n\t\treplaceInListIfExist(statements.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(statements));\n\t\treplaceInListIfExist(statements.getStatements(), new spoon.support.visitor.replace.ReplacementVisitor.CtStatementListStatementsReplaceListener(statements));\n\t\treplaceInListIfExist(statements.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(statements));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <S> void visitCtSwitch(final spoon.reflect.code.CtSwitch<S> switchStatement) {\n\t\treplaceInListIfExist(switchStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(switchStatement));\n\t\treplaceElementIfExist(switchStatement.getSelector(), new spoon.support.visitor.replace.ReplacementVisitor.CtSwitchSelectorReplaceListener(switchStatement));\n\t\treplaceInListIfExist(switchStatement.getCases(), new spoon.support.visitor.replace.ReplacementVisitor.CtSwitchCasesReplaceListener(switchStatement));\n\t\treplaceInListIfExist(switchStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(switchStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtSynchronized(final spoon.reflect.code.CtSynchronized synchro) {\n\t\treplaceInListIfExist(synchro.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(synchro));\n\t\treplaceElementIfExist(synchro.getExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtSynchronizedExpressionReplaceListener(synchro));\n\t\treplaceElementIfExist(synchro.getBlock(), new spoon.support.visitor.replace.ReplacementVisitor.CtSynchronizedBlockReplaceListener(synchro));\n\t\treplaceInListIfExist(synchro.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(synchro));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtThrow(final spoon.reflect.code.CtThrow throwStatement) {\n\t\treplaceInListIfExist(throwStatement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(throwStatement));\n\t\treplaceElementIfExist(throwStatement.getThrownExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtThrowThrownExpressionReplaceListener(throwStatement));\n\t\treplaceInListIfExist(throwStatement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(throwStatement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTry(final spoon.reflect.code.CtTry tryBlock) {\n\t\treplaceInListIfExist(tryBlock.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(tryBlock));\n\t\treplaceElementIfExist(tryBlock.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryBodyReplaceListener(tryBlock));\n\t\treplaceInListIfExist(tryBlock.getCatchers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryCatchersReplaceListener(tryBlock));\n\t\treplaceElementIfExist(tryBlock.getFinalizer(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryFinalizerReplaceListener(tryBlock));\n\t\treplaceInListIfExist(tryBlock.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(tryBlock));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTryWithResource(final spoon.reflect.code.CtTryWithResource tryWithResource) {\n\t\treplaceInListIfExist(tryWithResource.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(tryWithResource));\n\t\treplaceInListIfExist(tryWithResource.getResources(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryWithResourceResourcesReplaceListener(tryWithResource));\n\t\treplaceElementIfExist(tryWithResource.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryBodyReplaceListener(tryWithResource));\n\t\treplaceInListIfExist(tryWithResource.getCatchers(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryCatchersReplaceListener(tryWithResource));\n\t\treplaceElementIfExist(tryWithResource.getFinalizer(), new spoon.support.visitor.replace.ReplacementVisitor.CtTryFinalizerReplaceListener(tryWithResource));\n\t\treplaceInListIfExist(tryWithResource.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(tryWithResource));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeParameterReference(final spoon.reflect.reference.CtTypeParameterReference ref) {\n\t\treplaceElementIfExist(ref.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(ref));\n\t\treplaceElementIfExist(ref.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(ref));\n\t\treplaceInListIfExist(ref.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ref));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n\t\treplaceElementIfExist(wildcardReference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(wildcardReference));\n\t\treplaceElementIfExist(wildcardReference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(wildcardReference));\n\t\treplaceInListIfExist(wildcardReference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(wildcardReference));\n\t\treplaceElementIfExist(wildcardReference.getBoundingType(), new spoon.support.visitor.replace.ReplacementVisitor.CtWildcardReferenceBoundingTypeReplaceListener(wildcardReference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtIntersectionTypeReference(final spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n\t\treplaceElementIfExist(reference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getBounds(), new spoon.support.visitor.replace.ReplacementVisitor.CtIntersectionTypeReferenceBoundsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtTypeReference(final spoon.reflect.reference.CtTypeReference<T> reference) {\n\t\treplaceElementIfExist(reference.getPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferencePackageReplaceListener(reference));\n\t\treplaceElementIfExist(reference.getDeclaringType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeReferenceDeclaringTypeReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getActualTypeArguments(), new spoon.support.visitor.replace.ReplacementVisitor.CtActualTypeContainerActualTypeArgumentsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(reference));\n\t\treplaceInListIfExist(reference.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtTypeAccess(final spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n\t\treplaceInListIfExist(typeAccess.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(typeAccess));\n\t\treplaceInListIfExist(typeAccess.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(typeAccess));\n\t\treplaceElementIfExist(typeAccess.getAccessedType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeAccessAccessedTypeReplaceListener(typeAccess));\n\t\treplaceInListIfExist(typeAccess.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(typeAccess));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtUnaryOperator(final spoon.reflect.code.CtUnaryOperator<T> operator) {\n\t\treplaceInListIfExist(operator.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(operator));\n\t\treplaceElementIfExist(operator.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(operator));\n\t\treplaceInListIfExist(operator.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(operator));\n\t\treplaceElementIfExist(operator.getOperand(), new spoon.support.visitor.replace.ReplacementVisitor.CtUnaryOperatorOperandReplaceListener(operator));\n\t\treplaceInListIfExist(operator.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(operator));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableRead(final spoon.reflect.code.CtVariableRead<T> variableRead) {\n\t\treplaceInListIfExist(variableRead.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(variableRead));\n\t\treplaceInListIfExist(variableRead.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(variableRead));\n\t\treplaceElementIfExist(variableRead.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableAccessVariableReplaceListener(variableRead));\n\t\treplaceInListIfExist(variableRead.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(variableRead));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtVariableWrite(final spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n\t\treplaceInListIfExist(variableWrite.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(variableWrite));\n\t\treplaceInListIfExist(variableWrite.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(variableWrite));\n\t\treplaceElementIfExist(variableWrite.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableAccessVariableReplaceListener(variableWrite));\n\t\treplaceInListIfExist(variableWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(variableWrite));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtWhile(final spoon.reflect.code.CtWhile whileLoop) {\n\t\treplaceInListIfExist(whileLoop.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(whileLoop));\n\t\treplaceElementIfExist(whileLoop.getLoopingExpression(), new spoon.support.visitor.replace.ReplacementVisitor.CtWhileLoopingExpressionReplaceListener(whileLoop));\n\t\treplaceElementIfExist(whileLoop.getBody(), new spoon.support.visitor.replace.ReplacementVisitor.CtLoopBodyReplaceListener(whileLoop));\n\t\treplaceInListIfExist(whileLoop.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(whileLoop));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtCodeSnippetExpression(final spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n\t\treplaceElementIfExist(expression.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypedElementTypeReplaceListener(expression));\n\t\treplaceInListIfExist(expression.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(expression));\n\t\treplaceInListIfExist(expression.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(expression));\n\t\treplaceInListIfExist(expression.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(expression));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtCodeSnippetStatement(final spoon.reflect.code.CtCodeSnippetStatement statement) {\n\t\treplaceInListIfExist(statement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(statement));\n\t\treplaceInListIfExist(statement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(statement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtUnboundVariableReference(final spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n\t\treplaceElementIfExist(reference.getType(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableReferenceTypeReplaceListener(reference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldRead(final spoon.reflect.code.CtFieldRead<T> fieldRead) {\n\t\treplaceInListIfExist(fieldRead.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(fieldRead));\n\t\treplaceInListIfExist(fieldRead.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(fieldRead));\n\t\treplaceElementIfExist(fieldRead.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(fieldRead));\n\t\treplaceElementIfExist(fieldRead.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtFieldAccessVariableReplaceListener(fieldRead));\n\t\treplaceInListIfExist(fieldRead.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(fieldRead));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtFieldWrite(final spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n\t\treplaceInListIfExist(fieldWrite.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(fieldWrite));\n\t\treplaceInListIfExist(fieldWrite.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(fieldWrite));\n\t\treplaceElementIfExist(fieldWrite.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(fieldWrite));\n\t\treplaceElementIfExist(fieldWrite.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtFieldAccessVariableReplaceListener(fieldWrite));\n\t\treplaceInListIfExist(fieldWrite.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(fieldWrite));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic <T> void visitCtSuperAccess(final spoon.reflect.code.CtSuperAccess<T> f) {\n\t\treplaceInListIfExist(f.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(f));\n\t\treplaceInListIfExist(f.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(f));\n\t\treplaceInListIfExist(f.getTypeCasts(), new spoon.support.visitor.replace.ReplacementVisitor.CtExpressionTypeCastsReplaceListener(f));\n\t\treplaceElementIfExist(f.getTarget(), new spoon.support.visitor.replace.ReplacementVisitor.CtTargetedExpressionTargetReplaceListener(f));\n\t\treplaceElementIfExist(f.getVariable(), new spoon.support.visitor.replace.ReplacementVisitor.CtVariableAccessVariableReplaceListener(f));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtComment(final spoon.reflect.code.CtComment comment) {\n\t\treplaceInListIfExist(comment.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(comment));\n\t\treplaceInListIfExist(comment.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(comment));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDoc(final spoon.reflect.code.CtJavaDoc javaDoc) {\n\t\treplaceInListIfExist(javaDoc.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(javaDoc));\n\t\treplaceInListIfExist(javaDoc.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(javaDoc));\n\t\treplaceInListIfExist(javaDoc.getTags(), new spoon.support.visitor.replace.ReplacementVisitor.CtJavaDocTagsReplaceListener(javaDoc));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtJavaDocTag(final spoon.reflect.code.CtJavaDocTag docTag) {\n\t\treplaceInListIfExist(docTag.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(docTag));\n\t\treplaceInListIfExist(docTag.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(docTag));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtImport(final spoon.reflect.declaration.CtImport ctImport) {\n\t\treplaceElementIfExist(ctImport.getReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtImportReferenceReplaceListener(ctImport));\n\t\treplaceInListIfExist(ctImport.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(ctImport));\n\t\treplaceInListIfExist(ctImport.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(ctImport));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModule(spoon.reflect.declaration.CtModule module) {\n\t\treplaceInListIfExist(module.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(module));\n\t\treplaceInListIfExist(module.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(module));\n\t\treplaceInListIfExist(module.getModuleDirectives(), new spoon.support.visitor.replace.ReplacementVisitor.CtModuleModuleDirectivesReplaceListener(module));\n\t\treplaceElementIfExist(module.getRootPackage(), new spoon.support.visitor.replace.ReplacementVisitor.CtModuleRootPackageReplaceListener(module));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleReference(spoon.reflect.reference.CtModuleReference moduleReference) {\n\t\treplaceInListIfExist(moduleReference.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(moduleReference));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageExport(spoon.reflect.declaration.CtPackageExport moduleExport) {\n\t\treplaceInListIfExist(moduleExport.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(moduleExport));\n\t\treplaceElementIfExist(moduleExport.getPackageReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtPackageExportPackageReferenceReplaceListener(moduleExport));\n\t\treplaceInListIfExist(moduleExport.getTargetExport(), new spoon.support.visitor.replace.ReplacementVisitor.CtPackageExportTargetExportReplaceListener(moduleExport));\n\t\treplaceInListIfExist(moduleExport.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(moduleExport));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtModuleRequirement(spoon.reflect.declaration.CtModuleRequirement moduleRequirement) {\n\t\treplaceInListIfExist(moduleRequirement.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(moduleRequirement));\n\t\treplaceElementIfExist(moduleRequirement.getModuleReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtModuleRequirementModuleReferenceReplaceListener(moduleRequirement));\n\t\treplaceInListIfExist(moduleRequirement.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(moduleRequirement));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtProvidedService(spoon.reflect.declaration.CtProvidedService moduleProvidedService) {\n\t\treplaceInListIfExist(moduleProvidedService.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(moduleProvidedService));\n\t\treplaceElementIfExist(moduleProvidedService.getServiceType(), new spoon.support.visitor.replace.ReplacementVisitor.CtProvidedServiceServiceTypeReplaceListener(moduleProvidedService));\n\t\treplaceInListIfExist(moduleProvidedService.getImplementationTypes(), new spoon.support.visitor.replace.ReplacementVisitor.CtProvidedServiceImplementationTypesReplaceListener(moduleProvidedService));\n\t\treplaceInListIfExist(moduleProvidedService.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(moduleProvidedService));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtUsedService(spoon.reflect.declaration.CtUsedService usedService) {\n\t\treplaceInListIfExist(usedService.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(usedService));\n\t\treplaceElementIfExist(usedService.getServiceType(), new spoon.support.visitor.replace.ReplacementVisitor.CtUsedServiceServiceTypeReplaceListener(usedService));\n\t\treplaceInListIfExist(usedService.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(usedService));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtCompilationUnit(spoon.reflect.declaration.CtCompilationUnit compilationUnit) {\n\t\treplaceInListIfExist(compilationUnit.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(compilationUnit));\n\t\treplaceInListIfExist(compilationUnit.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(compilationUnit));\n\t\treplaceElementIfExist(compilationUnit.getPackageDeclaration(), new spoon.support.visitor.replace.ReplacementVisitor.CtCompilationUnitPackageDeclarationReplaceListener(compilationUnit));\n\t\treplaceInListIfExist(compilationUnit.getImports(), new spoon.support.visitor.replace.ReplacementVisitor.CtCompilationUnitImportsReplaceListener(compilationUnit));\n\t\treplaceElementIfExist(compilationUnit.getDeclaredModuleReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtCompilationUnitDeclaredModuleReferenceReplaceListener(compilationUnit));\n\t\treplaceInListIfExist(compilationUnit.getDeclaredTypeReferences(), new spoon.support.visitor.replace.ReplacementVisitor.CtCompilationUnitDeclaredTypeReferencesReplaceListener(compilationUnit));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtPackageDeclaration(spoon.reflect.declaration.CtPackageDeclaration packageDeclaration) {\n\t\treplaceInListIfExist(packageDeclaration.getComments(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementCommentsReplaceListener(packageDeclaration));\n\t\treplaceInListIfExist(packageDeclaration.getAnnotations(), new spoon.support.visitor.replace.ReplacementVisitor.CtElementAnnotationsReplaceListener(packageDeclaration));\n\t\treplaceElementIfExist(packageDeclaration.getReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtPackageDeclarationReferenceReplaceListener(packageDeclaration));\n\t}\n\n\t// auto-generated, see spoon.generating.ReplacementVisitorGenerator\n\t@java.lang.Override\n\tpublic void visitCtTypeMemberWildcardImportReference(spoon.reflect.reference.CtTypeMemberWildcardImportReference wildcardReference) {\n\t\treplaceElementIfExist(wildcardReference.getTypeReference(), new spoon.support.visitor.replace.ReplacementVisitor.CtTypeMemberWildcardImportReferenceTypeReferenceReplaceListener(wildcardReference));\n\t}\n}\n"
    }, {
      "name" : "support/visitor/replace/ReplaceSetListener.java",
      "weight" : 5.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport java.util.Set;\n\npublic interface ReplaceSetListener<T extends Set> {\n\tvoid set(T replace);\n}\n"
    }, {
      "name" : "support/visitor/replace/CtListener.java",
      "weight" : 11.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.replace;\n\nimport spoon.reflect.declaration.CtElement;\n\nclass CtListener implements ReplaceListener<CtElement> {\n\tprivate final CtElement element;\n\n\tCtListener(CtElement element) {\n\t\tthis.element = element;\n\t}\n\n\t@Override\n\tpublic void set(CtElement replace) {\n\t}\n}\n"
    }, {
      "name" : "support/visitor/MethodTypingContext.java",
      "weight" : 231.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport static spoon.support.visitor.ClassTypingContext.getTypeReferences;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Set;\n\nimport spoon.SpoonException;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtInvocation;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * For the scope method or constructor and super type hierarchy of it's declaring type,\n * it is able to adapt type parameters.\n *\n * https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.4\n * Where two methods or constructors M and N have the same type parameters {@link #hasSameMethodFormalTypeParameters(CtFormalTypeDeclarer)},\n * a type mentioned in N can be adapted to the type parameters of M\n */\npublic class MethodTypingContext extends AbstractTypingContext {\n\n\tprivate CtFormalTypeDeclarer scopeMethod;\n\tprivate List<CtTypeReference<?>> actualTypeArguments;\n\tprivate ClassTypingContext classTypingContext;\n\n\tpublic MethodTypingContext() {\n\t}\n\n\t@Override\n\tpublic CtFormalTypeDeclarer getAdaptationScope() {\n\t\treturn scopeMethod;\n\t}\n\n\tpublic MethodTypingContext setMethod(CtMethod<?> method) {\n\t\tactualTypeArguments = getTypeReferences(method.getFormalCtTypeParameters());\n\t\tif (classTypingContext != null) {\n\t\t\tCtType<?> declType = method.getDeclaringType();\n\t\t\tif (declType == null) {\n\t\t\t\tthrow new SpoonException(\"Cannot use method without declaring type as scope of method typing context\");\n\t\t\t}\n\t\t\tif (classTypingContext.getAdaptationScope() != declType) {\n\t\t\t\t//the method is declared in different type. We have to adapt it to required classTypingContext\n\t\t\t\tif (classTypingContext.isSubtypeOf(declType.getReference()) == false) {\n\t\t\t\t\tthrow new SpoonException(\"Cannot create MethodTypingContext for method declared in different ClassTypingContext\");\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * The method is declared in an supertype of classTypingContext.\n\t\t\t\t * Create virtual scope method by adapting generic types of supertype method to required scope\n\t\t\t\t */\n\t\t\t\tFactory factory = method.getFactory();\n\t\t\t\t//create new scopeMethod, which is directly used during adaptation of it's parameters\n\t\t\t\tCtMethod<?> adaptedMethod = factory.Core().createMethod();\n\t\t\t\tadaptedMethod.setParent(classTypingContext.getAdaptationScope());\n\t\t\t\tadaptedMethod.setModifiers(method.getModifiers());\n\t\t\t\tadaptedMethod.setSimpleName(method.getSimpleName());\n\n\t\t\t\tfor (CtTypeParameter typeParam : method.getFormalCtTypeParameters()) {\n\t\t\t\t\tCtTypeParameter newTypeParam = typeParam.clone();\n\t\t\t\t\tnewTypeParam.setSuperclass(adaptTypeForNewMethod(typeParam.getSuperclass()));\n\t\t\t\t\tadaptedMethod.addFormalCtTypeParameter(newTypeParam);\n\t\t\t\t}\n\t\t\t\t//now the formal type parameters of the scopeMethod are defined, so we can use adaptType of this MethodTypingContext\n\t\t\t\tscopeMethod = adaptedMethod;\n\t\t\t\tfor (CtTypeReference<? extends Throwable> thrownType : method.getThrownTypes()) {\n\t\t\t\t\tadaptedMethod.addThrownType((CtTypeReference<Throwable>) adaptType(thrownType.clone()));\n\t\t\t\t}\n\t\t\t\t//adapt return type\n\t\t\t\tadaptedMethod.setType((CtTypeReference) adaptType(method.getType()));\n\t\t\t\t//adapt parameters\n\t\t\t\tList<CtParameter<?>> adaptedParams = new ArrayList<>(method.getParameters().size());\n\t\t\t\tfor (CtParameter<?> parameter : method.getParameters()) {\n\t\t\t\t\tadaptedParams.add(factory.Executable().createParameter(null,\n\t\t\t\t\t\t\tadaptType(parameter.getType()),\n\t\t\t\t\t\t\tparameter.getSimpleName()));\n\t\t\t\t}\n\t\t\t\tadaptedMethod.setParameters(adaptedParams);\n\t\t\t\tmethod = adaptedMethod;\n\t\t\t}\n\t\t}\n\t\tscopeMethod = method;\n\t\treturn this;\n\t}\n\n\tpublic MethodTypingContext setConstructor(CtConstructor<?> constructor) {\n\t\tactualTypeArguments = getTypeReferences(constructor.getFormalCtTypeParameters());\n\t\t//TODO may be the constructors have to be adapted too, same like in setScopeMethod??\n\t\tcheckSameTypingContext(classTypingContext, constructor);\n\t\tscopeMethod = constructor;\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic ClassTypingContext getEnclosingGenericTypeAdapter() {\n\t\tif (classTypingContext == null && scopeMethod != null) {\n\t\t\tclassTypingContext = new ClassTypingContext(getScopeMethodDeclaringType());\n\t\t}\n\t\treturn classTypingContext;\n\t}\n\n\tpublic MethodTypingContext setClassTypingContext(ClassTypingContext classTypingContext) {\n\t\tcheckSameTypingContext(classTypingContext, scopeMethod);\n\t\tthis.classTypingContext = classTypingContext;\n\t\treturn this;\n\t}\n\n\tpublic MethodTypingContext setInvocation(CtInvocation<?> invocation) {\n\t\tif (classTypingContext == null) {\n\t\t\tCtExpression<?> target = invocation.getTarget();\n\t\t\tif (target != null) {\n\t\t\t\tCtTypeReference<?> targetTypeRef = target.getType();\n\t\t\t\tif (targetTypeRef != null) {\n\t\t\t\t\tclassTypingContext = new ClassTypingContext(targetTypeRef);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetExecutableReference(invocation.getExecutable());\n\t\treturn this;\n\t}\n\n\tpublic MethodTypingContext setExecutableReference(CtExecutableReference<?> execRef) {\n\t\tif (classTypingContext == null) {\n\t\t\tCtTypeReference<?> declaringTypeRef = execRef.getDeclaringType();\n\t\t\tif (declaringTypeRef != null) {\n\t\t\t\tclassTypingContext = new ClassTypingContext(declaringTypeRef);\n\t\t\t}\n\t\t}\n\t\tCtExecutable<?> exec = execRef.getExecutableDeclaration();\n\t\tif (exec == null) {\n\t\t\tthrow new SpoonException(\"Cannot create MethodTypingContext from CtExecutable of CtExecutableReference is null\");\n\t\t}\n\t\tif (exec instanceof CtMethod<?>) {\n\t\t\tsetMethod((CtMethod<?>) exec);\n\t\t} else if (exec instanceof CtConstructor<?>) {\n\t\t\tsetConstructor((CtConstructor<?>) exec);\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Cannot create MethodTypingContext from \" + exec.getClass().getName());\n\t\t}\n\t\tthis.actualTypeArguments = execRef.getActualTypeArguments();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adapts `typeParam` to the {@link CtTypeReference}\n\t * of scope of this {@link MethodTypingContext}\n\t * In can be {@link CtTypeParameterReference} again - depending actual type arguments of this {@link MethodTypingContext}.\n\t *\n\t * @param typeParam to be resolved {@link CtTypeParameter}\n\t * @return {@link CtTypeReference} or {@link CtTypeParameterReference} adapted to scope of this {@link MethodTypingContext}\n\t *  or null if `typeParam` cannot be adapted to target `scope`\n\t */\n\t@Override\n\tprotected CtTypeReference<?> adaptTypeParameter(CtTypeParameter typeParam) {\n\t\tCtFormalTypeDeclarer typeParamDeclarer = typeParam.getTypeParameterDeclarer();\n\t\tif (typeParamDeclarer instanceof CtType<?>) {\n\t\t\treturn getEnclosingGenericTypeAdapter().adaptType(typeParam);\n\t\t}\n\t\t//only method to method or constructor to constructor can be adapted\n\t\tif (typeParamDeclarer instanceof CtMethod<?>) {\n\t\t\tif ((scopeMethod instanceof CtMethod<?>) == false) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (typeParamDeclarer instanceof CtConstructor<?>) {\n\t\t\tif ((scopeMethod instanceof CtConstructor<?>) == false) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Unexpected type parameter declarer\");\n\t\t}\n\t\t//the typeParamDeclarer is method or constructor\n\t\t/*\n\t\t *\n\t\t * Two methods or constructors M and N have the same type parameters if both of the following are true:\n\t\t * 1) M and N have same number of type parameters (possibly zero).\n\t\t * 2) Where A1, ..., An are the type parameters of M and B1, ..., Bn are the type parameters of N, let T=[B1:=A1, ..., Bn:=An].\n\t\t * Then, for all i (1 ≤ i ≤ n), the bound of Ai is the same type as T applied to the bound of Bi.\n\t\t */\n\t\tif (hasSameMethodFormalTypeParameters(typeParamDeclarer) == false) {\n\t\t\t//the methods formal type parameters are different. We cannot adapt such parameters\n\t\t\treturn null;\n\t\t}\n\t\tint typeParamPosition = typeParamDeclarer.getFormalCtTypeParameters().indexOf(typeParam);\n\t\treturn actualTypeArguments.get(typeParamPosition);\n\t}\n\n\tprivate Set<CtFormalTypeDeclarer> checkingFormalTypeParamsOf = Collections.newSetFromMap(new IdentityHashMap<>(1));\n\n\t/**\n\t * https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.4\n\t *\n\t * Formal type parameters of method are same if\n\t * 1) both methods have same number of formal type parameters\n\t * 2) bounds of Formal type parameters are after adapting same types\n\t *\n\t * @return true if formal type parameters of method are same\n\t */\n\tpublic boolean hasSameMethodFormalTypeParameters(CtFormalTypeDeclarer typeParamDeclarer) {\n\t\tList<CtTypeParameter> thisTypeParameters = scopeMethod.getFormalCtTypeParameters();\n\t\tList<CtTypeParameter> thatTypeParameters = typeParamDeclarer.getFormalCtTypeParameters();\n\t\tif (thisTypeParameters.size() != thatTypeParameters.size()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (checkingFormalTypeParamsOf.contains(typeParamDeclarer)) {\n\t\t\t//do not check isSameMethodFormalTypeParameter recursively\n\t\t\treturn true;\n\t\t}\n\t\ttry {\n\t\t\tcheckingFormalTypeParamsOf.add(typeParamDeclarer);\n\t\t\t//the methods has same count of formal parameters\n\t\t\t//check that bounds of formal type parameters are same after adapting\n\t\t\tfor (int i = 0; i < thisTypeParameters.size(); i++) {\n\t\t\t\tif (isSameMethodFormalTypeParameter(thisTypeParameters.get(i), thatTypeParameters.get(i)) == false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tcheckingFormalTypeParamsOf.remove(typeParamDeclarer);\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean isSameMethodFormalTypeParameter(CtTypeParameter scopeParam, CtTypeParameter superParam) {\n\t\tCtTypeReference<?> scopeBound = getBound(scopeParam);\n\t\tCtTypeReference<?> superBound = getBound(superParam);\n\t\tif (scopeBound.getActualTypeArguments().size() != superBound.getActualTypeArguments().size()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tCtTypeReference<?> superBoundAdapted = adaptType(superBound);\n\t\tif (superBoundAdapted == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn scopeBound.getQualifiedName().equals(superBoundAdapted.getQualifiedName());\n\t}\n\n\t/*\n\t * @param declared\n\t * @param typeRef\n\t * @return index of type parameter in formal type parameters of `declarer` if typeRef is reference refers type parameter of that declarer.\n\t *  Returns -1 if it is not.\n\t */\n\tprivate int getIndexOfTypeParam(CtFormalTypeDeclarer declarer, CtTypeReference<?> typeRef) {\n\t\tif (typeRef instanceof CtTypeParameterReference) {\n\t\t\tCtTypeParameter typeParam = ((CtTypeParameterReference) typeRef).getDeclaration();\n\t\t\tif (typeParam != null) {\n\t\t\t\tif (declarer == typeParam.getTypeParameterDeclarer()) {\n\t\t\t\t\treturn declarer.getFormalCtTypeParameters().indexOf(typeParam);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static CtTypeReference<?> getBound(CtTypeParameter typeParam) {\n\t\tCtTypeReference<?> bound = typeParam.getSuperclass();\n\t\tif (bound == null) {\n\t\t\tbound = typeParam.getFactory().Type().OBJECT;\n\t\t}\n\t\treturn bound;\n\t}\n\n\tprivate CtType<?> getScopeMethodDeclaringType() {\n\t\tif (scopeMethod != null) {\n\t\t\treturn scopeMethod.getDeclaringType();\n\t\t}\n\t\tthrow new SpoonException(\"scopeMethod is not assigned\");\n\t}\n\n\tprivate CtTypeReference<?> adaptTypeForNewMethod(CtTypeReference<?> typeRef) {\n\t\tif (typeRef == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (typeRef instanceof CtTypeParameterReference) {\n\t\t\tCtTypeParameterReference typeParamRef = (CtTypeParameterReference) typeRef;\n\t\t\tCtTypeParameter typeParam = typeParamRef.getDeclaration();\n\t\t\tif (typeParam == null) {\n\t\t\t\tthrow new SpoonException(\"Declaration of the CtTypeParameter should not be null.\");\n\t\t\t}\n\n\t\t\tif (typeParam.getTypeParameterDeclarer() instanceof CtExecutable) {\n\t\t\t\t//the parameter is declared in scope of Method or Constructor\n\t\t\t\treturn typeRef.clone();\n\t\t\t}\n\t\t}\n\t\t//it is not type reference of scopeMethod. Adapt it using classTypingContext\n\t\treturn classTypingContext.adaptType(typeRef);\n\t}\n\n\tprivate void checkSameTypingContext(ClassTypingContext ctc, CtFormalTypeDeclarer executable) {\n\t\tif (ctc != null && executable != null) {\n\t\t\tCtType<?> scope = executable.getDeclaringType();\n\t\t\tif (scope == null) {\n\t\t\t\tthrow new SpoonException(\"Cannot use executable without declaring type as scope of method typing context\");\n\t\t\t}\n\t\t\tif (scope != ctc.getAdaptationScope()) {\n\t\t\t\tthrow new SpoonException(\"Declaring type of executable is not same like scope of classTypingContext provided for method typing context\");\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/visitor/equals/CloneHelper.java",
      "weight" : 82.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.equals;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.visitor.CtScanner;\nimport spoon.support.util.EmptyClearableList;\nimport spoon.support.util.EmptyClearableSet;\nimport spoon.support.visitor.clone.CloneVisitor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * {@link CloneHelper} is responsible for creating clones of {@link CtElement} AST nodes including the whole subtree.\n *\n * By default, the same instance of {@link CloneHelper} is used for whole clonning process.\n *\n * However, by subclassing this class and overriding method {@link #clone(CtElement)},\n * one can extend and/or modify the cloning behavior.\n *\n * For instance, one can listen to each call to clone and get each pair of `clone source` and `clone target`.\n */\npublic class CloneHelper {\n\tpublic static final CloneHelper INSTANCE = new CloneHelper();\n\n\tpublic <T extends CtElement> T clone(T element) {\n\t\tfinal CloneVisitor cloneVisitor = new CloneVisitor(this);\n\t\tcloneVisitor.scan(element);\n\t\treturn cloneVisitor.getClone();\n\t}\n\n\tpublic <T extends CtElement> Collection<T> clone(Collection<T> elements) {\n\t\tif (elements == null || elements.isEmpty()) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tCollection<T> others = new ArrayList<>();\n\t\tfor (T element : elements) {\n\t\t\taddClone(others, element);\n\t\t}\n\t\treturn others;\n\t}\n\n\tpublic <T extends CtElement> List<T> clone(List<T> elements) {\n\t\tif (elements instanceof EmptyClearableList) {\n\t\t\treturn elements;\n\t\t}\n\t\tif (elements == null || elements.isEmpty()) {\n\t\t\treturn new ArrayList<>();\n\t\t}\n\t\tList<T> others = new ArrayList<>();\n\t\tfor (T element : elements) {\n\t\t\taddClone(others, element);\n\t\t}\n\t\treturn others;\n\t}\n\n\tpublic <T extends CtElement> Set<T> clone(Set<T> elements) {\n\t\tif (elements instanceof EmptyClearableSet) {\n\t\t\treturn elements;\n\t\t}\n\t\tif (elements == null || elements.isEmpty()) {\n\t\t\treturn EmptyClearableSet.instance();\n\t\t}\n\t\tSet<T> others = new HashSet<>(elements.size());\n\t\tfor (T element : elements) {\n\t\t\taddClone(others, element);\n\t\t}\n\t\treturn others;\n\t}\n\n\tpublic <T extends CtElement> Map<String, T> clone(Map<String, T> elements) {\n\t\tif (elements == null || elements.isEmpty()) {\n\t\t\treturn new HashMap<>();\n\t\t}\n\t\tMap<String, T> others = new HashMap<>();\n\t\tfor (Map.Entry<String, T> tEntry : elements.entrySet()) {\n\t\t\taddClone(others, tEntry.getKey(), tEntry.getValue());\n\t\t}\n\t\treturn others;\n\t}\n\n\t/**\n\t * clones a element and adds it's clone as value into targetCollection\n\t * @param targetCollection - the collection which will receive a clone of element\n\t * @param element to be cloned element\n\t */\n\tprotected <T extends CtElement> void addClone(Collection<T> targetCollection, T element) {\n\t\ttargetCollection.add(clone(element));\n\t}\n\n\t/**\n\t * clones a value and adds it's clone as value into targetMap under key\n\t * @param targetMap - the Map which will receive a clone of value\n\t * @param key the target key, which has to be used to add cloned value into targetMap\n\t * @param value to be cloned element\n\t */\n\tprotected <T extends CtElement> void addClone(Map<String, T> targetMap, String key, T value) {\n\t\ttargetMap.put(key, clone(value));\n\t}\n\n\n\t/** Is called by {@link CloneVisitor} at the end of the cloning for each element. */\n\tpublic void tailor(final spoon.reflect.declaration.CtElement topLevelElement, final spoon.reflect.declaration.CtElement topLevelClone) {\n\t\t// this scanner visit certain nodes to done some additional work after cloning\n\t\tnew CtScanner() {\n\t\t\t@Override\n\t\t\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> clone) {\n\t\t\t\t// for instance, here we can do additional things\n\t\t\t\t// after cloning an executable reference\n\t\t\t\t// we have access here to \"topLevelElement\" and \"topLevelClone\"\n\t\t\t\t// if we want to analyze them as well.\n\n\t\t\t\t// super must be called to visit the subelements\n\t\t\t\tsuper.visitCtExecutableReference(clone);\n\t\t\t}\n\t\t}.scan(topLevelClone);\n\t}\n\n}\n"
    }, {
      "name" : "support/visitor/equals/EqualsVisitor.java",
      "weight" : 107.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.equals;\n\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.visitor.CtBiScannerDefault;\n\nimport java.util.Collection;\n\n/**\n * Used to check equality between an element and another one.\n *\n */\npublic class EqualsVisitor extends CtBiScannerDefault {\n\tpublic static boolean equals(CtElement element, CtElement other) {\n\t\treturn new EqualsVisitor().checkEquals(element, other);\n\t}\n\n\tprotected final EqualsChecker checker;\n\n\tprivate CtRole lastRole = null;\n\n\tpublic EqualsVisitor() {\n\t\tthis(new EqualsChecker());\n\t}\n\n\tpublic EqualsVisitor(EqualsChecker checker) {\n\t\tthis.checker = checker;\n\t}\n\n\t@Override\n\tprotected void enter(CtElement e) {\n\t\tsuper.enter(e);\n\t\tCtElement other = stack.peek();\n\t\tchecker.setOther(other);\n\t\ttry {\n\t\t\tchecker.scan(e);\n\t\t} catch (NotEqualException ex) {\n\t\t\tfail(checker.getNotEqualRole() == null ? lastRole : checker.getNotEqualRole(), e, other);\n\t\t}\n\t}\n\tprotected boolean isNotEqual = false;\n\tprotected CtRole notEqualRole;\n\tprotected Object notEqualElement;\n\tprotected Object notEqualOther;\n\n\t@Override\n\tprotected void biScan(CtRole role, Collection<? extends CtElement> elements, Collection<? extends CtElement> others) {\n\n\t\tif (isNotEqual) {\n\t\t\treturn;\n\t\t}\n\t\tif (elements == null) {\n\t\t\tif (others != null) {\n\t\t\t\tfail(role, elements, others);\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (others == null) {\n\t\t\tfail(role, elements, others);\n\t\t\treturn;\n\t\t}\n\t\tif ((elements.size()) != (others.size())) {\n\t\t\tfail(role, elements, others);\n\t\t\treturn;\n\t\t}\n\t\tsuper.biScan(role, elements, others);\n\t}\n\n\t@Override\n\tpublic void biScan(CtElement element, CtElement other) {\n\t\tbiScan(null, element, other);\n\t}\n\n\t@Override\n\tpublic void biScan(CtRole role, CtElement element, CtElement other) {\n\t\tif (isNotEqual) {\n\t\t\treturn;\n\t\t}\n\t\tif (element == null) {\n\t\t\tif (other != null) {\n\t\t\t\tfail(role, element, other);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn;\n\t\t} else if (other == null) {\n\t\t\tfail(role, element, other);\n\t\t\treturn;\n\t\t}\n\t\tif (element == other) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlastRole = role;\n\t\t\tsuper.biScan(element, other);\n\t\t} catch (java.lang.ClassCastException e) {\n\t\t\tfail(role, element, other);\n\t\t} finally {\n\t\t\tlastRole = null;\n\t\t}\n\t}\n\n\tprotected boolean fail(CtRole role, Object element, Object other) {\n\t\tisNotEqual = true;\n\t\tnotEqualRole = role;\n\t\tnotEqualElement = element;\n\t\tnotEqualOther = other;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param element first to be compared element\n\t * @param other second to be compared element\n\t * @return true if `element` and `other` are equal. If false then see\n\t * {@link #getNotEqualElement()}, {@link #getNotEqualOther()} and {@link #getNotEqualRole()} for details\n\t */\n\tpublic boolean checkEquals(CtElement element, CtElement other) {\n\t\tbiScan(element, other);\n\t\treturn !isNotEqual;\n\t}\n\n\t/**\n\t * @return true if {@link #checkEquals(CtElement, CtElement)} are equal. If false then see\n\t * {@link #getNotEqualElement()}, {@link #getNotEqualOther()} and {@link #getNotEqualRole()} for details\n\t */\n\tpublic boolean isEqual() {\n\t\treturn !isNotEqual;\n\t}\n\n\t/**\n\t * @return role on which the element and other element were not equal\n\t */\n\tpublic CtRole getNotEqualRole() {\n\t\treturn notEqualRole;\n\t}\n\n\t/**\n\t * @return element or collection which was not equal\n\t */\n\tpublic Object getNotEqualElement() {\n\t\treturn notEqualElement;\n\t}\n\n\t/**\n\t * @return other element or collection which was not equal\n\t */\n\tpublic Object getNotEqualOther() {\n\t\treturn notEqualOther;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/equals/NotEqualException.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.equals;\n\nimport spoon.SpoonException;\n\nclass NotEqualException extends SpoonException {\n\tstatic final NotEqualException INSTANCE = new NotEqualException();\n\n\tprivate NotEqualException() {\n\t}\n}\n"
    }, {
      "name" : "support/visitor/equals/EqualsChecker.java",
      "weight" : 227.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.equals;\n\nimport spoon.reflect.code.CtAssignment;\nimport spoon.reflect.code.CtBinaryOperator;\nimport spoon.reflect.code.CtBreak;\nimport spoon.reflect.code.CtContinue;\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.code.CtOperatorAssignment;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.code.CtUnaryOperator;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\n\npublic class EqualsChecker extends CtInheritanceScanner {\n\tprotected CtElement other;\n\tprivate boolean isNotEqual;\n\tprivate CtRole notEqualRole;\n\n\tpublic void setOther(CtElement other) {\n\t\tthis.other = other;\n\t\tisNotEqual = false;\n\t}\n\n\tpublic boolean isNotEqual() {\n\t\treturn isNotEqual;\n\t}\n\n\tpublic CtRole getNotEqualRole() {\n\t\treturn notEqualRole;\n\t}\n\n\t/**\n\t * @param role the role of the not equal attribute, or null if there is no such role\n\t */\n\tprotected void setNotEqual(CtRole role) {\n\t\tnotEqualRole = role;\n\t\tisNotEqual = true;\n\t\tthrow NotEqualException.INSTANCE;\n\t}\n\n\t@Override\n\tpublic void scanCtNamedElement(CtNamedElement e) {\n\t\tfinal CtNamedElement peek = (CtNamedElement) this.other;\n\t\tif (!e.getSimpleName().equals(peek.getSimpleName())) {\n\t\t\tsetNotEqual(CtRole.NAME);\n\t\t}\n\t\tsuper.scanCtNamedElement(e);\n\t}\n\n\t@Override\n\tpublic void scanCtReference(CtReference reference) {\n\t\tfinal CtReference peek = (CtReference) this.other;\n\t\tif (!reference.getSimpleName().equals(peek.getSimpleName())) {\n\t\t\tsetNotEqual(CtRole.NAME);\n\t\t}\n\t\tsuper.scanCtReference(reference);\n\t}\n\n\t@Override\n\tpublic void scanCtStatement(CtStatement s) {\n\t\tfinal CtStatement peek = (CtStatement) this.other;\n\t\tfinal String leftLabel = s.getLabel();\n\t\tfinal String rightLabel = peek.getLabel();\n\t\tif (leftLabel == null && rightLabel == null) {\n\t\t\tsuper.scanCtStatement(s);\n\t\t\treturn;\n\t\t}\n\t\tif (leftLabel == null || !leftLabel.equals(rightLabel)) {\n\t\t\tsetNotEqual(CtRole.LABEL);\n\t\t}\n\t\tsuper.scanCtStatement(s);\n\t}\n\n\t@Override\n\tpublic void scanCtModifiable(CtModifiable m) {\n\t\tfinal CtModifiable peek = (CtModifiable) this.other;\n\t\tif (m.getVisibility() == null) {\n\t\t\tif (peek.getVisibility() != null) {\n\t\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t\t}\n\t\t} else if (peek.getVisibility() == null) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t} else  if (!m.getVisibility().equals(peek.getVisibility())) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t}\n\t\tif (m.getModifiers().size() != peek.getModifiers().size()) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t}\n\t\tif (!m.getModifiers().containsAll(peek.getModifiers())) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t}\n\t\tsuper.scanCtModifiable(m);\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtAssignment(CtAssignment<T, A> assignment) {\n\t\tif (!(assignment instanceof CtOperatorAssignment) && this.other instanceof CtOperatorAssignment) {\n\t\t\tsetNotEqual(null);\n\t\t}\n\t\tsuper.visitCtAssignment(assignment);\n\t}\n\n\t@Override\n\tpublic <T, A extends T> void visitCtOperatorAssignment(CtOperatorAssignment<T, A> assignment) {\n\t\tfinal CtOperatorAssignment peek = (CtOperatorAssignment) this.other;\n\t\tif (assignment.getKind() == null) {\n\t\t\tif (peek.getKind() != null) {\n\t\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t\t}\n\t\t} else if (peek.getKind() == null) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t} else if (!assignment.getKind().equals(peek.getKind())) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t}\n\t\tsuper.visitCtOperatorAssignment(assignment);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtBinaryOperator(CtBinaryOperator<T> e) {\n\t\tfinal CtBinaryOperator peek = (CtBinaryOperator) this.other;\n\t\tif (e.getKind() == null) {\n\t\t\tif (peek.getKind() != null) {\n\t\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t\t}\n\t\t} else if (peek.getKind() == null) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t} else if (!e.getKind().equals(peek.getKind())) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t}\n\t\tsuper.visitCtBinaryOperator(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtUnaryOperator(CtUnaryOperator<T> e) {\n\t\tfinal CtUnaryOperator peek = (CtUnaryOperator) this.other;\n\t\tif (e.getKind() == null) {\n\t\t\tif (peek.getKind() != null) {\n\t\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t\t}\n\t\t} else if (peek.getKind() == null) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t} else if (!e.getKind().equals(peek.getKind())) {\n\t\t\tsetNotEqual(CtRole.OPERATOR_KIND);\n\t\t}\n\t\tsuper.visitCtUnaryOperator(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayTypeReference(CtArrayTypeReference<T> e) {\n\t\tfinal CtArrayTypeReference peek = (CtArrayTypeReference) this.other;\n\t\tif (e.getDimensionCount() != peek.getDimensionCount()) {\n\t\t\tsetNotEqual(CtRole.TYPE);\n\t\t}\n\t\tsuper.visitCtArrayTypeReference(e);\n\t}\n\n\t@Override\n\tpublic void visitCtBreak(CtBreak e) {\n\t\tfinal CtBreak peek = (CtBreak) this.other;\n\t\tif (e.getTargetLabel() == null) {\n\t\t\tif (peek.getTargetLabel() != null) {\n\t\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t\t}\n\t\t} else if (peek.getTargetLabel() == null) {\n\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t} else if (!e.getTargetLabel().equals(peek.getTargetLabel())) {\n\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t}\n\t\tsuper.visitCtBreak(e);\n\t}\n\n\t@Override\n\tpublic void visitCtContinue(CtContinue e) {\n\t\tfinal CtContinue peek = (CtContinue) this.other;\n\t\tif (e.getTargetLabel() == null) {\n\t\t\tif (peek.getTargetLabel() != null) {\n\t\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t\t}\n\t\t} else if (peek.getTargetLabel() == null) {\n\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t} else if (!e.getTargetLabel().equals(peek.getTargetLabel())) {\n\t\t\tsetNotEqual(CtRole.TARGET_LABEL);\n\t\t}\n\t\tsuper.visitCtContinue(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> e) {\n\t\tfinal CtExecutableReference peek = (CtExecutableReference) this.other;\n\t\tif (e.isConstructor() != peek.isConstructor()) {\n\t\t\tsetNotEqual(null);\n\t\t}\n\t\tsuper.visitCtExecutableReference(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtMethod(CtMethod<T> e) {\n\t\tfinal CtMethod peek = (CtMethod) this.other;\n\t\tif (e.isDefaultMethod() != peek.isDefaultMethod()) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t}\n\t\tsuper.visitCtMethod(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtParameter(CtParameter<T> e) {\n\t\tfinal CtParameter peek = (CtParameter) this.other;\n\t\tif (e.isVarArgs() != peek.isVarArgs()) {\n\t\t\tsetNotEqual(CtRole.MODIFIER);\n\t\t}\n\t\tsuper.visitCtParameter(e);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtLiteral(CtLiteral<T> e) {\n\t\tfinal CtLiteral peek = (CtLiteral) this.other;\n\t\tif (e.getValue() == null) {\n\t\t\tif (peek.getValue() != null) {\n\t\t\t\tsetNotEqual(CtRole.VALUE);\n\t\t\t}\n\t\t} else if (peek.getValue() == null) {\n\t\t\tsetNotEqual(CtRole.VALUE);\n\t\t} else if (!e.getValue().equals(peek.getValue())) {\n\t\t\tsetNotEqual(CtRole.VALUE);\n\t\t}\n\t\tsuper.visitCtLiteral(e);\n\t}\n\n\t@Override\n\tpublic void visitCtImport(CtImport ctImport) {\n\t\tfinal CtImport peek = (CtImport) this.other;\n\n\t\tif (ctImport.getImportKind() == null) {\n\t\t\tif (peek.getImportKind() != null) {\n\t\t\t\tsetNotEqual(null);\n\t\t\t}\n\t\t} else if (peek.getImportKind() == null) {\n\t\t\tsetNotEqual(null);\n\t\t} else if (!ctImport.getImportKind().equals(peek.getImportKind())) {\n\t\t\tsetNotEqual(null);\n\t\t}\n\n\t\tsuper.visitCtImport(ctImport);\n\t}\n\n}\n"
    }, {
      "name" : "support/visitor/GenericTypeAdapter.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * Provides adapting of generic types from one scope to another scope.\n */\npublic interface GenericTypeAdapter {\n\t/**\n\t * @return the scope of this type adapter\n\t */\n\tCtFormalTypeDeclarer getAdaptationScope();\n\t/**\n\t * adapts `type` to the {@link CtTypeReference}\n\t * of the scope of this {@link GenericTypeAdapter}\n\t *\n\t * This mapping function is able to resolve {@link CtTypeParameter} of:<br>\n\t * A) input type or any super class or any enclosing class of input type or it's super class<br>\n\t * B) super interfaces of input type or super interfaces of it's super classes.<br>\n\t *\n\t * The type reference is adapted recursive including all it's actual type arguments and bounds.\n\t *\n\t * @param type to be adapted type\n\t * @return {@link CtTypeReference} adapted to scope of this {@link ClassTypingContext}\n\t * or null if type cannot be adapted to this `scope`.\n\t */\n\tCtTypeReference<?> adaptType(CtTypeInformation type);\n\n\t/**\n\t * @return the {@link GenericTypeAdapter}, which adapts generic types of enclosing type\n\t */\n\tGenericTypeAdapter getEnclosingGenericTypeAdapter();\n\n}\n"
    }, {
      "name" : "support/visitor/HashcodeVisitor.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtImport;\nimport spoon.reflect.declaration.CtNamedElement;\nimport spoon.reflect.reference.CtReference;\nimport spoon.reflect.visitor.CtInheritanceScanner;\n\n/** Responsible for computing CtElement.hashCode().\n * Version that is fast and compatible with EqualVisitor\n */\npublic class HashcodeVisitor extends CtInheritanceScanner {\n\n\tprivate int hashCode = 0;\n\n\t@Override\n\tpublic void scanCtNamedElement(CtNamedElement e) {\n\t\tif (e.getSimpleName() != null) {\n\t\t\thashCode += e.getSimpleName().hashCode();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scanCtReference(CtReference e) {\n\t\thashCode += e.getSimpleName().hashCode();\n\t}\n\n\t@Override\n\tpublic void visitCtImport(CtImport e) {\n\t\tif (e.getReference() != null) {\n\t\t\tscanCtReference(e.getReference());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void scan(CtElement element) {\n\t\thashCode += 1;\n\t\tsuper.scan(element);\n\t}\n\n\tpublic int getHasCode() {\n\t\treturn hashCode;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/SubInheritanceHierarchyResolver.java",
      "weight" : 105.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.CtQuery;\nimport spoon.reflect.visitor.chain.CtScannerListener;\nimport spoon.reflect.visitor.chain.ScanningMode;\nimport spoon.reflect.visitor.filter.CtScannerFunction;\nimport spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction;\nimport spoon.reflect.visitor.filter.TypeFilter;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Expects a {@link CtPackage} as input\n * and  upon calls to forEachSubTypeInPackage produces all sub classes and sub interfaces,\n * which extends or implements super type(s) provided by call(s) of {@link #addSuperType(CtTypeInformation)}\n * and stored as `targetSuperTypes`.<br>\n *\n * The repeated processing of this mapping function on the same input returns only newly found sub types.\n * The instance of {@link SubInheritanceHierarchyResolver} returns found sub types only once.\n * So repeated call with same input package returns nothing.\n * Create and use new instance of {@link SubInheritanceHierarchyResolver} if you need to scan the subtype hierarchy again.\n */\npublic class SubInheritanceHierarchyResolver {\n\n\t/** where the subtypes will be looked for */\n\tprivate CtPackage inputPackage;\n\n\t/** whether interfaces are included in the result */\n\tprivate boolean includingInterfaces = true;\n\t/**\n\t * Set of qualified names of all super types whose sub types we are searching for.\n\t * Each found sub type is added to this set too\n\t */\n\tprivate Set<String> targetSuperTypes = new HashSet<>();\n\t/**\n\t * if true then we have to check if type is a subtype of superClass or superInterfaces too\n\t * if false then it is enough to search in superClass hierarchy only (faster)\n\t */\n\tprivate boolean hasSuperInterface = false;\n\n\tprivate boolean failOnClassNotFound = false;\n\n\tpublic SubInheritanceHierarchyResolver(CtPackage input) {\n\t\tinputPackage = input;\n\t}\n\n\t/**\n\t * Add another super type to this mapping function.\n\t * Using this function you can search parallel in more sub type hierarchies.\n\t *\n\t * @param superType - the type whose sub types will be returned by this mapping function too.\n\t */\n\tpublic SubInheritanceHierarchyResolver addSuperType(CtTypeInformation superType) {\n\t\ttargetSuperTypes.add(superType.getQualifiedName());\n\t\tif (hasSuperInterface == false) {\n\t\t\thasSuperInterface = superType.isInterface();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param includingInterfaces if false then interfaces are not visited - only super classes. By default it is true.\n\t */\n\tpublic SubInheritanceHierarchyResolver includingInterfaces(boolean includingInterfaces) {\n\t\tthis.includingInterfaces = includingInterfaces;\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param failOnClassNotFound sets whether processing should throw an exception if class is missing in noClassPath mode\n\t */\n\tpublic SubInheritanceHierarchyResolver failOnClassNotFound(boolean failOnClassNotFound) {\n\t\tthis.failOnClassNotFound = failOnClassNotFound;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls `outputConsumer.apply(subType)` for each sub type of the targetSuperTypes that are found in `inputPackage`.\n\t * Each sub type is returned only once.\n\t * It makes sense to call this method again for example after new super types are added\n\t * by {@link #addSuperType(CtTypeInformation)}.\n\t *\n\t * \tIf this method is called again with same input and configuration, nothing in sent to outputConsumer\n\t * @param outputConsumer the consumer for found sub types\n\t */\n\tpublic <T extends CtType<?>> void forEachSubTypeInPackage(final CtConsumer<T> outputConsumer) {\n\t\t/*\n\t\t * Set of qualified names of all visited types, independent on whether they are sub types or not.\n\t\t */\n\t\tfinal Set<String> allVisitedTypeNames = new HashSet<>();\n\t\t/*\n\t\t * the queue of types whose super inheritance hierarchy we are just visiting.\n\t\t * They are potential sub types of an `targetSuperTypes`\n\t\t */\n\t\tfinal Deque<CtTypeReference<?>> currentSubTypes = new ArrayDeque<>();\n\t\t//algorithm\n\t\t//1) query step: scan input package for sub classes and sub interfaces\n\t\tfinal CtQuery q = inputPackage.map(new CtScannerFunction());\n\t\t//2) query step: visit only required CtTypes\n\t\tif (includingInterfaces) {\n\t\t\t//the client is interested in sub inheritance hierarchy of interfaces too. Check interfaces, classes, enums, Annotations, but not CtTypeParameters.\n\t\t\tq.select(typeFilter);\n\t\t} else {\n\t\t\t//the client is not interested in sub inheritance hierarchy of interfaces. Check only classes and enums.\n\t\t\tq.select(classFilter);\n\t\t}\n\t\t/*\n\t\t * 3) query step: for each found CtType, visit it's super inheritance hierarchy and search there for a type which is equal to one of targetSuperTypes.\n\t\t * If found then all sub types in hierarchy (variable `currentSubTypes`) are sub types of targetSuperTypes. So return them\n\t\t */\n\t\tq.map(new SuperInheritanceHierarchyFunction()\n\t\t\t//if there is any interface between `targetSuperTypes`, then we have to check superInterfaces too\n\t\t\t.includingInterfaces(hasSuperInterface)\n\t\t\t.failOnClassNotFound(failOnClassNotFound)\n\t\t\t/*\n\t\t\t * listen for types in super inheritance hierarchy\n\t\t\t * 1) to collect `currentSubTypes`\n\t\t\t * 2) to check if we have already found a targetSuperType\n\t\t\t * 3) if found then send `currentSubTypes` to `outputConsumer` and skip visiting of further super types\n\t\t\t */\n\t\t\t.setListener(new CtScannerListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic ScanningMode enter(CtElement element) {\n\t\t\t\t\tfinal CtTypeReference<?> typeRef = (CtTypeReference<?>) element;\n\t\t\t\t\tString qName = typeRef.getQualifiedName();\n\t\t\t\t\tif (targetSuperTypes.contains(qName)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * FOUND! we are in super inheritance hierarchy, which extends from an searched super type(s).\n\t\t\t\t\t\t * All `currentSubTypes` are sub types of searched super type\n\t\t\t\t\t\t */\n\t\t\t\t\t\twhile (!currentSubTypes.isEmpty()) {\n\t\t\t\t\t\t\tfinal CtTypeReference<?> currentTypeRef  = currentSubTypes.pop();\n\t\t\t\t\t\t\tString currentQName = currentTypeRef.getQualifiedName();\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Send them to outputConsumer and add then as targetSuperTypes too, to perform faster with detection of next sub types.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (!targetSuperTypes.contains(currentQName)) {\n\t\t\t\t\t\t\t\ttargetSuperTypes.add(currentQName);\n\t\t\t\t\t\t\t\toutputConsumer.accept((T) currentTypeRef.getTypeDeclaration());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//we do not have to go deeper into super inheritance hierarchy. Skip visiting of further super types\n\t\t\t\t\t\t//but continue visiting of siblings (do not terminate query)\n\t\t\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t\t\t}\n\t\t\t\t\tif (allVisitedTypeNames.add(qName) == false) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * this type was already visited, by another way. So it is not sub type of `targetSuperTypes`.\n\t\t\t\t\t\t * Stop visiting it's inheritance hierarchy.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * This type was not visited yet.\n\t\t\t\t\t * We still do not know whether this type is a sub type of any target super type(s)\n\t\t\t\t\t * continue searching in super inheritance hierarchy\n\t\t\t\t\t */\n\t\t\t\t\tcurrentSubTypes.push(typeRef);\n\t\t\t\t\treturn ScanningMode.NORMAL;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void exit(CtElement element) {\n\t\t\t\t\tCtTypeInformation type = (CtTypeInformation) element;\n\t\t\t\t\tif (currentSubTypes.isEmpty() == false) {\n\t\t\t\t\t\t//remove current type, which is not a sub type of targetSuperTypes from the currentSubTypes\n\t\t\t\t\t\tCtTypeInformation stackType = currentSubTypes.pop();\n\t\t\t\t\t\tif (stackType != type) {\n\t\t\t\t\t\t\t//the enter/exit was not called consistently. There is a bug in SuperInheritanceHierarchyFunction\n\t\t\t\t\t\t\tthrow new SpoonException(\"CtScannerListener#exit was not called after enter.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t).forEach(new CtConsumer<CtType<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtType<?> type) {\n\t\t\t\t//we do not care about types visited by query `q`.\n\t\t\t\t//the result of whole mapping function was already produced by `sendResult` call\n\t\t\t\t//but we have to consume all these results to let query running\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * accept all {@link CtType} excluding {@link CtTypeParameter}\n\t */\n\tprivate static final Filter<CtType<?>> typeFilter = new Filter<CtType<?>>() {\n\t\t@Override\n\t\tpublic boolean matches(CtType<?> type) {\n\t\t\treturn !(type instanceof CtTypeParameter);\n\t\t}\n\t};\n\n\t/**\n\t * Accept all {@link CtClass}, {@link CtEnum}\n\t */\n\tprivate static final Filter<CtClass<?>> classFilter = new TypeFilter<>(CtClass.class);\n}\n"
    }, {
      "name" : "support/visitor/ProcessingVisitor.java",
      "weight" : 52.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.processing.Processor;\nimport spoon.processing.TraversalStrategy;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.visitor.CtScanner;\n\n/**\n * This visitor implements the code processing engine.\n */\npublic class ProcessingVisitor extends CtScanner {\n\n\tFactory factory;\n\n\tProcessor<?> processor;\n\n\t/**\n\t * The constructor.\n\t */\n\tpublic ProcessingVisitor(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\tprivate boolean canBeProcessed(CtElement e) {\n\t\tif (!factory.getEnvironment().isProcessingStopped()\n\t\t\t\t&& processor.getProcessedElementTypes() != null) {\n\t\t\tfor (Object o : processor.getProcessedElementTypes()) {\n\t\t\t\tif (!((Class<?>) o).isAssignableFrom(e.getClass())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic Processor<?> getProcessor() {\n\t\treturn processor;\n\t}\n\n\t/**\n\t * Applies the processing to the given element. To apply the processing,\n\t * this method upcalls, for all the registered processor in, the\n\t * {@link Processor#process(CtElement)} method if\n\t * {@link Processor#isToBeProcessed(CtElement)} returns true.\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void scan(CtElement e) {\n\t\tif (e == null) {\n\t\t\treturn;\n\t\t}\n\t\tProcessor<CtElement> p = (Processor<CtElement>) processor;\n\t\tif (p.getTraversalStrategy() == TraversalStrategy.PRE_ORDER\n\t\t\t\t&& canBeProcessed(e)) {\n\t\t\tif (p.isToBeProcessed(e)) {\n\t\t\t\tp.process(e);\n\t\t\t}\n\t\t}\n\t\tsuper.scan(e);\n\t\tif (p.getTraversalStrategy() == TraversalStrategy.POST_ORDER\n\t\t\t\t&& canBeProcessed(e)) {\n\t\t\tif (p.isToBeProcessed(e)) {\n\t\t\t\tp.process(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setProcessor(Processor<?> processor) {\n\t\tthis.processor = processor;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/TypeReferenceScanner.java",
      "weight" : 105.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.reflect.code.CtFieldRead;\nimport spoon.reflect.code.CtFieldWrite;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.CtScanner;\n\nimport java.lang.annotation.Annotation;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A scanner that calculates the imports for a given model.\n */\npublic class TypeReferenceScanner extends CtScanner {\n\n\tSet<CtTypeReference<?>> references;\n\n\t/**\n\t * Constructor.\n\t */\n\tpublic TypeReferenceScanner() {\n\t\treferences = new HashSet<>();\n\t}\n\n\t/**\n\t * Constructor.\n\t *\n\t * @param references\n\t * \t\ta set to fill with the references\n\t */\n\tpublic TypeReferenceScanner(HashSet<CtTypeReference<?>> references) {\n\t\tthis.references = references;\n\t}\n\n\t/**\n\t * Returns the set of calculated references.\n\t */\n\tpublic Set<CtTypeReference<?>> getReferences() {\n\t\treturn references;\n\t}\n\n\t/**\n\t * Adds a reference.\n\t */\n\tprivate <T> boolean addReference(CtTypeReference<T> ref) {\n\t\treturn references.add(ref);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldRead(CtFieldRead<T> fieldRead) {\n\t\tsuper.visitCtFieldRead(fieldRead);\n\t\tenter(fieldRead);\n\t\tscan(fieldRead.getVariable());\n\t\tscan(fieldRead.getAnnotations());\n\t\tscan(fieldRead.getTypeCasts());\n\t\tscan(fieldRead.getVariable());\n\t\tscan(fieldRead.getTarget());\n\t\texit(fieldRead);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldWrite(CtFieldWrite<T> fieldWrite) {\n\t\tenter(fieldWrite);\n\t\tscan(fieldWrite.getVariable());\n\t\tscan(fieldWrite.getAnnotations());\n\t\tscan(fieldWrite.getTypeCasts());\n\t\tscan(fieldWrite.getVariable());\n\t\tscan(fieldWrite.getTarget());\n\t\texit(fieldWrite);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtFieldReference(CtFieldReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(reference.getDeclaringType());\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(\n\t\t\tCtExecutableReference<T> reference) {\n\t\tenter(reference);\n\t\tscan(reference.getDeclaringType());\n\t\tscan(reference.getActualTypeArguments());\n\t\texit(reference);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\t\tif (!(reference instanceof CtArrayTypeReference)) {\n\t\t\taddReference(reference);\n\t\t}\n\t\tsuper.visitCtTypeReference(reference);\n\n\t}\n\n\t@Override\n\tpublic <A extends Annotation> void visitCtAnnotationType(\n\t\t\tCtAnnotationType<A> annotationType) {\n\t\taddReference(annotationType.getReference());\n\t\tsuper.visitCtAnnotationType(annotationType);\n\t}\n\n\t@Override\n\tpublic <T extends Enum<?>> void visitCtEnum(CtEnum<T> ctEnum) {\n\t\taddReference(ctEnum.getReference());\n\t\tsuper.visitCtEnum(ctEnum);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtInterface(CtInterface<T> intrface) {\n\t\taddReference(intrface.getReference());\n\t\tfor (CtTypeMember typeMember : intrface.getTypeMembers()) {\n\t\t\tif (typeMember instanceof CtType) {\n\t\t\t\taddReference(((CtType) typeMember).getReference());\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtInterface(intrface);\n\t}\n\n\t@Override\n\tpublic <T> void visitCtClass(CtClass<T> ctClass) {\n\t\taddReference(ctClass.getReference());\n\t\tfor (CtTypeMember typeMember : ctClass.getTypeMembers()) {\n\t\t\tif (typeMember instanceof CtType) {\n\t\t\t\taddReference(((CtType) typeMember).getReference());\n\t\t\t}\n\t\t}\n\t\tsuper.visitCtClass(ctClass);\n\t}\n}\n\n"
    }, {
      "name" : "support/visitor/SignaturePrinter.java",
      "weight" : 118.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtIntersectionTypeReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.visitor.CtScanner;\n\n/**\n * Responsible for computing signatures for elements where a signature exists\n * (CtType, CtMethod and CtPackage). Otherwise returns the empty string.\n *\n */\npublic class SignaturePrinter extends CtScanner {\n\n\tprivate final StringBuilder signature = new StringBuilder();\n\n\tpublic SignaturePrinter() { }\n\n\tpublic String getSignature() {\n\t\treturn signature.toString();\n\t}\n\n\t@Override\n\tpublic <T> void visitCtArrayTypeReference(CtArrayTypeReference<T> reference) {\n\t\tscan(reference.getComponentType());\n\t\twrite(\"[]\");\n\t}\n\n\t@Override\n\tpublic <T> void visitCtExecutableReference(CtExecutableReference<T> reference) {\n\t\twriteNameAndParameters(reference);\n\t}\n\n\t/** writes only the name and parameters' types */\n\tpublic <T> void writeNameAndParameters(CtExecutableReference<T> reference) {\n\t\tif (reference.isConstructor()) {\n\t\t\twrite(reference.getDeclaringType().getQualifiedName());\n\t\t} else {\n\t\t\twrite(reference.getSimpleName());\n\t\t}\n\t\twrite(\"(\");\n\t\tif (!reference.getParameters().isEmpty()) {\n\t\t\tfor (CtTypeReference<?> param : reference.getParameters()) {\n\t\t\t\tif (param != null && !\"null\".equals(param.getSimpleName())) {\n\t\t\t\t\tscan(param);\n\t\t\t\t} else {\n\t\t\t\t\twrite(CtExecutableReference.UNKNOWN_TYPE);\n\t\t\t\t}\n\t\t\t\twrite(\",\");\n\t\t\t}\n\t\t\tif (!reference.getParameters().isEmpty()) {\n\t\t\t\tclearLast(); // \",\"\n\t\t\t}\n\t\t}\n\t\twrite(\")\");\n\t}\n\n\t@Override\n\tpublic <T> void visitCtTypeReference(CtTypeReference<T> reference) {\n\t\twrite(reference.getQualifiedName());\n\t}\n\n\t@Override\n\tpublic void visitCtTypeParameterReference(CtTypeParameterReference ref) {\n\t\t/*\n\t\t * signature doesn't contain name of type parameter reference,\n\t\t * because these three methods declarations:\n\t\t * \t<T extends String> void m(T a);\n\t\t * \t<S extends String> void m(S b);\n\t\t * \tvoid m(String c)\n\t\t * Should have the same signature.\n\t\t */\n\t\tscan(ref.getBoundingType());\n\t}\n\n\t@Override\n\tpublic void visitCtWildcardReference(CtWildcardReference ref) {\n\t\twrite(ref.getSimpleName());\n\t\tif (!ref.isDefaultBoundingType() || !ref.getBoundingType().isImplicit()) {\n\t\t\tif (ref.isUpper()) {\n\t\t\t\twrite(\" extends \");\n\t\t\t} else {\n\t\t\t\twrite(\" super \");\n\t\t\t}\n\t\t\tscan(ref.getBoundingType());\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitCtIntersectionTypeReference(CtIntersectionTypeReference<T> reference) {\n\t\tfor (CtTypeReference<?> bound : reference.getBounds()) {\n\t\t\tscan(bound);\n\t\t\twrite(\",\");\n\t\t}\n\t\tclearLast();\n\t}\n\n\t@Override\n\tpublic <T> void visitCtConstructor(CtConstructor<T> c) {\n\t\tif (c.getDeclaringType() != null) {\n\t\t\twrite(c.getDeclaringType().getQualifiedName());\n\t\t}\n\t\twrite(\"(\");\n\t\tfor (CtParameter<?> p : c.getParameters()) {\n\t\t\tscan(p.getType());\n\t\t\twrite(\",\");\n\t\t}\n\t\tif (!c.getParameters().isEmpty()) {\n\t\t\tclearLast();\n\t\t}\n\t\twrite(\")\");\n\t}\n\n\t@Override\n\tpublic <T> void visitCtAnnotationMethod(CtAnnotationMethod<T> annotationMethod) {\n\t\tvisitCtMethod(annotationMethod);\n\t}\n\n\t/**\n\t* For methods, this implementation of signature contains the return type, which corresponds\n\t* to what the Java compile and virtual machine call a \"descriptor\".\n\t*\n\t* See chapter \"8.4.2 Method Signature\" of the Java specification\n\t*/\n\t@Override\n\tpublic <T> void visitCtMethod(CtMethod<T> m) {\n\t\twrite(m.getSimpleName());\n\t\twrite(\"(\");\n\t\tfor (CtParameter<?> p : m.getParameters()) {\n\t\t\tscan(p.getType());\n\t\t\twrite(\",\");\n\t\t}\n\t\tif (!m.getParameters().isEmpty()) {\n\t\t\tclearLast();\n\t\t}\n\t\twrite(\")\");\n\t}\n\n\tprivate SignaturePrinter clearLast() {\n\t\tsignature.deleteCharAt(signature.length() - 1);\n\t\treturn this;\n\t}\n\n\tprotected SignaturePrinter write(String value) {\n\t\tsignature.append(value);\n\t\treturn this;\n\t}\n\n}\n"
    }, {
      "name" : "support/visitor/java/internal/AnnotationRuntimeBuilderContext.java",
      "weight" : 29.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\n\npublic class AnnotationRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprivate CtAnnotation<Annotation> ctAnnotation;\n\n\tpublic AnnotationRuntimeBuilderContext(CtAnnotation<Annotation> ctAnnotation) {\n\t\tsuper(ctAnnotation);\n\t\tthis.ctAnnotation = ctAnnotation;\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\tthis.ctAnnotation.addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\tswitch (role) {\n\t\tcase ANNOTATION_TYPE:\n\t\t\tctAnnotation.setAnnotationType((CtTypeReference<? extends Annotation>) typeReference);\n\t\t\tctAnnotation.setType((CtTypeReference<Annotation>) typeReference);\n\t\t\treturn;\n\t\t}\n\t\tsuper.addTypeReference(role, typeReference);\n\t}\n\n\tpublic CtAnnotation<Annotation> getCtAnnotation() {\n\t\treturn this.ctAnnotation;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/TypeRuntimeBuilderContext.java",
      "weight" : 68.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class TypeRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprotected CtType type;\n\tprotected Type rtType;\n\tprivate Map<String, CtTypeParameter> mapTypeParameters;\n\n\tpublic TypeRuntimeBuilderContext(Type rtType, CtType type) {\n\t\tsuper(type);\n\t\tthis.type = type;\n\t\tthis.rtType = rtType;\n\t\tthis.mapTypeParameters = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic void addPackage(CtPackage ctPackage) {\n\t\tctPackage.addType(type);\n\t}\n\n\t@Override\n\tpublic void addType(CtType<?> aType) {\n\t\ttype.addNestedType(aType);\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\ttype.addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic void addMethod(CtMethod<?> ctMethod) {\n\t\ttype.addMethod(ctMethod);\n\t}\n\n\t@Override\n\tpublic void addField(CtField<?> ctField) {\n\t\ttype.addField(ctField);\n\t}\n\n\t@Override\n\tpublic void addFormalType(CtTypeParameter parameterRef) {\n\t\tthis.type.addFormalCtTypeParameter(parameterRef);\n\t\tthis.mapTypeParameters.put(parameterRef.getSimpleName(), parameterRef);\n\t}\n\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\tswitch (role) {\n\t\t\tcase INTERFACE:\n\t\t\t\ttype.addSuperInterface(typeReference);\n\t\t\t\treturn;\n\t\t\tcase SUPER_TYPE:\n\t\t\t\tif (type instanceof CtTypeParameter) {\n\t\t\t\t\t((CtTypeParameter) this.type).setSuperclass(typeReference);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string) {\n\t\treturn rtType == genericDeclaration ? this.mapTypeParameters.get(string) : null;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/TypeReferenceRuntimeBuilderContext.java",
      "weight" : 76.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class TypeReferenceRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprivate CtTypeReference<?> typeReference;\n\tprivate Type type;\n\tprivate Map<String, CtTypeParameter> mapTypeParameters;\n\n\tpublic TypeReferenceRuntimeBuilderContext(Type type, CtTypeReference<?> typeReference) {\n\t\tsuper(typeReference);\n\t\tthis.typeReference = typeReference;\n\t\tthis.type = type;\n\t\tthis.mapTypeParameters = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic void addPackage(CtPackage ctPackage) {\n\t\ttypeReference.setPackage(ctPackage.getReference());\n\t}\n\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> ctTypeReference) {\n\t\tswitch (role) {\n\t\tcase DECLARING_TYPE:\n\t\t\tthis.typeReference.setDeclaringType(ctTypeReference);\n\t\t\treturn;\n\t\tcase BOUNDING_TYPE:\n\t\tcase SUPER_TYPE:\n\t\t\tif (typeReference instanceof CtWildcardReference) {\n\t\t\t\t((CtWildcardReference) typeReference).setBoundingType(ctTypeReference);\n\t\t\t} else {\n\t\t\t\t//Strange case?\n\t\t\t\tthis.getClass();\n\t\t\t}\n\t\t\treturn;\n\t\tcase TYPE_ARGUMENT:\n\t\t\ttypeReference.addActualTypeArgument(ctTypeReference);\n\t\t\treturn;\n\t\t}\n\t\tsuper.addTypeReference(role, ctTypeReference);\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\ttypeReference.addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic void addFormalType(CtTypeParameter parameterRef) {\n\t\ttypeReference.addActualTypeArgument(parameterRef.getReference());\n\t\tthis.mapTypeParameters.put(parameterRef.getSimpleName(), parameterRef);\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string) {\n\t\treturn type == genericDeclaration ? this.mapTypeParameters.get(string) : null;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal TypeReferenceRuntimeBuilderContext that = (TypeReferenceRuntimeBuilderContext) o;\n\t\treturn type == that.type;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn Objects.hash(typeReference);\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/AbstractRuntimeBuilderContext.java",
      "weight" : 64.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtShadowable;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.GenericDeclaration;\n\nabstract class AbstractRuntimeBuilderContext implements RuntimeBuilderContext {\n\n\tprotected AbstractRuntimeBuilderContext(CtShadowable element) {\n\t\telement.setShadow(true);\n\t}\n\n\t@Override\n\tpublic void addPackage(CtPackage ctPackage) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addType(CtType<?> aType) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addConstructor(CtConstructor<?> ctConstructor) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addMethod(CtMethod<?> ctMethod) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addField(CtField<?> ctField) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addEnumValue(CtEnumValue<?> ctEnumValue) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addParameter(CtParameter ctParameter) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addFormalType(CtTypeParameter parameterRef) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> ctTypeReference) {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string) {\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/VariableRuntimeBuilderContext.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtVariable;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\n\npublic class VariableRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprivate CtVariable ctVariable;\n\n\tpublic VariableRuntimeBuilderContext(CtField<?> ctField) {\n\t\tsuper(ctField);\n\t\tthis.ctVariable = ctField;\n\t}\n\n\tpublic VariableRuntimeBuilderContext(CtParameter<?> ctParameter) {\n\t\tsuper(ctParameter);\n\t\tthis.ctVariable = ctParameter;\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\tctVariable.addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> ctTypeReference) {\n\t\tswitch (role) {\n\t\tcase TYPE:\n\t\t\tctVariable.setType(ctTypeReference);\n\t\t\treturn;\n\t\t}\n\t\tsuper.addTypeReference(role, ctTypeReference);\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/RuntimeBuilderContext.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.GenericDeclaration;\n\npublic interface RuntimeBuilderContext {\n\tvoid addPackage(CtPackage ctPackage);\n\n\tvoid addType(CtType<?> aType);\n\n\tvoid addAnnotation(CtAnnotation<Annotation> ctAnnotation);\n\n\tvoid addConstructor(CtConstructor<?> ctConstructor);\n\n\tvoid addMethod(CtMethod<?> ctMethod);\n\n\tvoid addField(CtField<?> ctField);\n\n\tvoid addEnumValue(CtEnumValue<?> ctEnumValue);\n\n\tvoid addParameter(CtParameter ctParameter);\n\n\tvoid addTypeReference(CtRole role, CtTypeReference<?> ctTypeReference);\n\n\tvoid addFormalType(CtTypeParameter parameterRef);\n\n\n\tCtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string);\n}\n"
    }, {
      "name" : "support/visitor/java/internal/PackageRuntimeBuilderContext.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\nimport java.lang.annotation.Annotation;\n\npublic class PackageRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprivate CtPackage ctPackage;\n\n\tpublic PackageRuntimeBuilderContext(CtPackage ctPackage) {\n\t\tsuper(ctPackage);\n\t\tthis.ctPackage = ctPackage;\n\t}\n\n\t@Override\n\tpublic void addType(CtType<?> aType) {\n\t\tctPackage.addType(aType);\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\tctPackage.addAnnotation(ctAnnotation);\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/internal/ExecutableRuntimeBuilderContext.java",
      "weight" : 66.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.internal;\n\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtTypeReference;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.GenericDeclaration;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ExecutableRuntimeBuilderContext extends AbstractRuntimeBuilderContext {\n\tprivate CtExecutable<?> ctExecutable;\n\tprivate Executable executable;\n\tprivate Map<String, CtTypeParameter> mapTypeParameters;\n\n\tpublic ExecutableRuntimeBuilderContext(Executable executable, CtMethod<?> ctMethod) {\n\t\tsuper(ctMethod);\n\t\tthis.ctExecutable = ctMethod;\n\t\tthis.executable = executable;\n\t\tthis.mapTypeParameters = new HashMap<>();\n\t}\n\n\tpublic ExecutableRuntimeBuilderContext(Executable executable, CtConstructor<?> ctConstructor) {\n\t\tsuper(ctConstructor);\n\t\tthis.ctExecutable = ctConstructor;\n\t\tthis.executable = executable;\n\t\tthis.mapTypeParameters = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic void addAnnotation(CtAnnotation<Annotation> ctAnnotation) {\n\t\tctExecutable.addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic void addParameter(CtParameter ctParameter) {\n\t\tctExecutable.addParameter(ctParameter);\n\t}\n\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t@Override\n\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\tswitch (role) {\n\t\tcase THROWN:\n\t\t\tctExecutable.addThrownType((CtTypeReference) typeReference);\n\t\t\treturn;\n\t\tcase TYPE:\n\t\t\tctExecutable.setType((CtTypeReference) typeReference);\n\t\t\treturn;\n\t\t}\n\t\tsuper.addTypeReference(role, typeReference);\n\t}\n\n\t@Override\n\tpublic void addFormalType(CtTypeParameter parameterRef) {\n\t\tif (ctExecutable instanceof CtFormalTypeDeclarer) {\n\t\t\t((CtFormalTypeDeclarer) ctExecutable).addFormalCtTypeParameter(parameterRef);\n\t\t\tthis.mapTypeParameters.put(parameterRef.getSimpleName(), parameterRef);\n\t\t\treturn;\n\t\t}\n\t\tsuper.addFormalType(parameterRef);\n\t}\n\n\t@Override\n\tpublic CtTypeParameter getTypeParameter(GenericDeclaration genericDeclaration, String string) {\n\t\treturn executable == genericDeclaration ? this.mapTypeParameters.get(string) : null;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/JavaReflectionVisitorImpl.java",
      "weight" : 434.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java;\n\nimport spoon.SpoonException;\nimport spoon.reflect.path.CtRole;\nimport spoon.support.visitor.java.reflect.RtMethod;\nimport spoon.support.visitor.java.reflect.RtParameter;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass JavaReflectionVisitorImpl implements JavaReflectionVisitor {\n\t@Override\n\tpublic void visitPackage(Package aPackage) {\n\t}\n\n\t@Override\n\tpublic <T> void visitClass(Class<T> clazz) {\n\t\tif (clazz.getPackage() != null) {\n\t\t\tclazz.getPackage();\n\t\t}\n\t\ttry {\n\t\t\tfor (TypeVariable<Class<T>> generic : clazz.getTypeParameters()) {\n\t\t\t\tvisitTypeParameter(generic);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null && clazz.getGenericSuperclass() != Object.class) {\n\t\t\t\tvisitTypeReference(CtRole.SUPER_TYPE, clazz.getGenericSuperclass());\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Type anInterface : clazz.getGenericInterfaces()) {\n\t\t\t\tvisitTypeReference(CtRole.INTERFACE, anInterface);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Annotation annotation : clazz.getDeclaredAnnotations()) {\n\t\t\t\tvisitAnnotation(annotation);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n\t\t\t\tif (constructor.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitConstructor(constructor);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (RtMethod method : getDeclaredMethods(clazz)) {\n\t\t\t\tif (method.getMethod().isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitMethod(method);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\t\tif (field.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitField(field);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Class<?> aClass : clazz.getDeclaredClasses()) {\n\t\t\t\tvisitType(aClass);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t}\n\n\tprotected final <T> void visitType(Class<T> aClass) {\n\t\tif (aClass.isAnnotation()) {\n\t\t\tvisitAnnotationClass((Class<Annotation>) aClass);\n\t\t} else if (aClass.isInterface()) {\n\t\t\tvisitInterface(aClass);\n\t\t} else if (aClass.isEnum()) {\n\t\t\tvisitEnum(aClass);\n\t\t} else {\n\t\t\tvisitClass(aClass);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitInterface(Class<T> clazz) {\n\t\tassert clazz.isInterface();\n\t\tif (clazz.getPackage() != null) {\n\t\t\tclazz.getPackage();\n\t\t}\n\t\ttry {\n\t\t\tfor (Type anInterface : clazz.getGenericInterfaces()) {\n\t\t\t\tvisitTypeReference(CtRole.INTERFACE, anInterface);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\n\t\ttry {\n\t\t\tfor (Annotation annotation : clazz.getDeclaredAnnotations()) {\n\t\t\t\tvisitAnnotation(annotation);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (RtMethod method : getDeclaredMethods(clazz)) {\n\t\t\t\tif (method.getMethod().isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitMethod(method);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\t\tif (field.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitField(field);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Class<?> aClass : clazz.getDeclaredClasses()) {\n\t\t\t\tvisitType(aClass);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (TypeVariable<Class<T>> generic : clazz.getTypeParameters()) {\n\t\t\t\tvisitTypeParameter(generic);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitEnum(Class<T> clazz) {\n\t\tassert clazz.isEnum();\n\t\tif (clazz.getPackage() != null) {\n\t\t\tclazz.getPackage();\n\t\t}\n\t\ttry {\n\t\t\tfor (Type anInterface : clazz.getGenericInterfaces()) {\n\t\t\t\tvisitTypeReference(CtRole.INTERFACE, anInterface);\n\t\t\t}\n\t\t}  catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Annotation annotation : clazz.getDeclaredAnnotations()) {\n\t\t\t\tvisitAnnotation(annotation);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Constructor<?> constructor : clazz.getDeclaredConstructors()) {\n\t\t\t\tif (Modifier.isPrivate(constructor.getModifiers())) {\n\t\t\t\t\tClass<?>[] paramTypes = constructor.getParameterTypes();\n\t\t\t\t\tif (paramTypes.length == 2 && paramTypes[0] == String.class && paramTypes[1] == int.class) {\n\t\t\t\t\t\t//ignore implicit enum constructor\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (constructor.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitConstructor(constructor);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (RtMethod method : getDeclaredMethods(clazz)) {\n\t\t\t\tif ((\"valueOf\".equals(method.getName()) && method.getParameterTypes().length == 1 && String.class.equals(method.getParameterTypes()[0])) || \"values\".equals(method.getName())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (method.getMethod().isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitMethod(method);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\t\tif (field.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field.isEnumConstant()) {\n\t\t\t\t\tvisitEnumValue(field);\n\t\t\t\t} else {\n\t\t\t\t\tvisitField(field);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Class<?> aClass : clazz.getDeclaredClasses()) {\n\t\t\t\tvisitType(aClass);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends Annotation> void visitAnnotationClass(Class<T> clazz) {\n\t\tassert clazz.isAnnotation();\n\t\tif (clazz.getPackage() != null) {\n\t\t\tclazz.getPackage();\n\t\t}\n\t\ttry {\n\t\t\tfor (Annotation annotation : clazz.getDeclaredAnnotations()) {\n\t\t\t\tvisitAnnotation(annotation);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (RtMethod method : getDeclaredMethods(clazz)) {\n\t\t\t\tif (method.getMethod().isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitMethod(method);\n\t\t\t}\n\t\t}  catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\t\tif (field.isSynthetic()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisitField(field);\n\t\t\t}\n\t\t}  catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t\ttry {\n\t\t\tfor (Class<?> aClass : clazz.getDeclaredClasses()) {\n\t\t\t\tvisitType(aClass);\n\t\t\t}\n\t\t} catch (NoClassDefFoundError ignore) {\n\t\t\t// partial classpath\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitAnnotation(Annotation annotation) {\n\t\tif (annotation.annotationType() != null) {\n\t\t\tvisitTypeReference(CtRole.ANNOTATION_TYPE, annotation.annotationType());\n\t\t\tList<RtMethod> methods = getDeclaredMethods(annotation.annotationType());\n\t\t\tfor (RtMethod method : methods) {\n\t\t\t\tvisitMethod(method, annotation);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitConstructor(Constructor<T> constructor) {\n\t\tfor (Annotation annotation : constructor.getDeclaredAnnotations()) {\n\t\t\tvisitAnnotation(annotation);\n\t\t}\n\t\tint nrEnclosingClasses = getNumberOfEnclosingClasses(constructor.getDeclaringClass());\n\t\tfor (RtParameter parameter : RtParameter.parametersOf(constructor)) {\n\t\t\t//ignore implicit parameters of enclosing classes\n\t\t\tif (nrEnclosingClasses > 0) {\n\t\t\t\tnrEnclosingClasses--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisitParameter(parameter);\n\t\t}\n\t\tfor (TypeVariable<Constructor<T>> aTypeParameter : constructor.getTypeParameters()) {\n\t\t\tvisitTypeParameter(aTypeParameter);\n\t\t}\n\t\tfor (Class<?> exceptionType : constructor.getExceptionTypes()) {\n\t\t\tvisitTypeReference(CtRole.THROWN, exceptionType);\n\t\t}\n\t}\n\n\tprivate int getNumberOfEnclosingClasses(Class<?> clazz) {\n\t\tint depth = 0;\n\t\twhile (Modifier.isStatic(clazz.getModifiers()) == false && (clazz = clazz.getEnclosingClass()) != null) {\n\t\t\tdepth++;\n\t\t}\n\t\treturn depth;\n\t}\n\n\t@Override\n\tpublic final void visitMethod(RtMethod method) {\n\t\tthis.visitMethod(method, null);\n\t}\n\n\tprotected void visitMethod(RtMethod method, Annotation parent) {\n\t\tfor (Annotation annotation : method.getDeclaredAnnotations()) {\n\t\t\tif (parent == null || !annotation.annotationType().equals(parent.annotationType())) {\n\t\t\t\tvisitAnnotation(annotation);\n\t\t\t}\n\t\t}\n\t\tfor (TypeVariable<Method> aTypeParameter : method.getTypeParameters()) {\n\t\t\tvisitTypeParameter(aTypeParameter);\n\t\t}\n\t\tfor (RtParameter parameter : RtParameter.parametersOf(method)) {\n\t\t\tvisitParameter(parameter);\n\t\t}\n\t\tif (method.getReturnType() != null) {\n\t\t\tvisitTypeReference(CtRole.TYPE, method.getGenericReturnType());\n\t\t}\n\t\tfor (Class<?> exceptionType : method.getExceptionTypes()) {\n\t\t\tvisitTypeReference(CtRole.THROWN, exceptionType);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitField(Field field) {\n\t\tfor (Annotation annotation : field.getDeclaredAnnotations()) {\n\n\t\t\tvisitAnnotation(annotation);\n\t\t}\n\t\tif (field.getGenericType() != null) {\n\t\t\tvisitTypeReference(CtRole.TYPE, field.getGenericType());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitEnumValue(Field field) {\n\t\tfor (Annotation annotation : field.getDeclaredAnnotations()) {\n\t\t\tvisitAnnotation(annotation);\n\t\t}\n\t\tif (field.getType() != null) {\n\t\t\tvisitTypeReference(CtRole.TYPE, field.getType());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitParameter(RtParameter parameter) {\n\t\tfor (Annotation annotation : parameter.getDeclaredAnnotations()) {\n\t\t\tvisitAnnotation(annotation);\n\t\t}\n\t\tif (parameter.getGenericType() != null) {\n\t\t\tvisitTypeReference(CtRole.TYPE, parameter.getGenericType());\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends GenericDeclaration> void visitTypeParameter(TypeVariable<T> parameter) {\n\t\tfor (Type type : parameter.getBounds()) {\n\t\t\tif (type == Object.class) {\n\t\t\t\t// we want to ignore Object to avoid <T extends Object>\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisitTypeReference(CtRole.SUPER_TYPE, type);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T extends GenericDeclaration> void visitTypeParameterReference(CtRole role, TypeVariable<T> parameter) {\n\t\tfor (Type type : parameter.getBounds()) {\n\t\t\tif (type == Object.class) {\n\t\t\t\t// we bypass Object.class: if a generic type extends Object we don't put it in the model, it's implicit\n\t\t\t\t// we do the same thing in ReferenceBuilder\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisitTypeReference(CtRole.SUPER_TYPE, type);\n\t\t}\n\t}\n\n\t@Override\n\tpublic final void visitTypeReference(CtRole role, Type type) {\n\t\tif (type instanceof TypeVariable) {\n\t\t\tthis.visitTypeParameterReference(role, (TypeVariable<?>) type);\n\t\t\treturn;\n\t\t}\n\t\tif (type instanceof ParameterizedType) {\n\t\t\tthis.visitTypeReference(role, (ParameterizedType) type);\n\t\t\treturn;\n\t\t}\n\t\tif (type instanceof WildcardType) {\n\t\t\tthis.visitTypeReference(role, (WildcardType) type);\n\t\t\treturn;\n\t\t}\n\t\tif (type instanceof GenericArrayType) {\n\t\t\tvisitArrayReference(role, ((GenericArrayType) type).getGenericComponentType());\n\t\t\treturn;\n\t\t}\n\t\tif (type instanceof Class) {\n\t\t\tClass<?> clazz = (Class<?>) type;\n\t\t\tif (clazz.isArray()) {\n\t\t\t\tvisitArrayReference(role, clazz.getComponentType());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.visitTypeReference(role, clazz);\n\t\t\treturn;\n\t\t}\n\t\tthrow new SpoonException(\"Unexpected java reflection type: \" + type.getClass().getName());\n\t}\n\n\t@Override\n\tpublic void visitTypeReference(CtRole role, ParameterizedType type) {\n\t\tType rawType = type.getRawType();\n\n\t\tif (!(rawType instanceof Class)) {\n\t\t\tthrow new UnsupportedOperationException(\"Rawtype of the parameterized type should be a class.\");\n\t\t}\n\n\t\tClass<?> classRaw = (Class<?>) rawType;\n\n\t\tif (classRaw.getPackage() != null) {\n\t\t\tvisitPackage(classRaw.getPackage());\n\t\t}\n\t\tif (classRaw.getEnclosingClass() != null) {\n\t\t\tvisitTypeReference(CtRole.DECLARING_TYPE, classRaw.getEnclosingClass());\n\t\t}\n\n\t\tfor (Type generic : type.getActualTypeArguments()) {\n\t\t\tvisitTypeReference(CtRole.TYPE_ARGUMENT, generic);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitTypeReference(CtRole role, WildcardType type) {\n\t\tif (type.getUpperBounds() != null && type.getUpperBounds().length > 0 && !type.getUpperBounds()[0].equals(Object.class)) {\n\t\t\tfor (Type upper : type.getUpperBounds()) {\n\t\t\t\tvisitTypeReference(CtRole.BOUNDING_TYPE, upper);\n\t\t\t}\n\t\t}\n\t\tfor (Type lower : type.getLowerBounds()) {\n\t\t\tvisitTypeReference(CtRole.BOUNDING_TYPE, lower);\n\t\t}\n\t}\n\n\t@Override\n\tpublic <T> void visitArrayReference(CtRole role, Type typeArray) {\n\t\tvisitTypeReference(role, typeArray);\n\t}\n\n\t@Override\n\tpublic <T> void visitTypeReference(CtRole role, Class<T> clazz) {\n\t\tif (clazz.getPackage() != null && clazz.getEnclosingClass() == null) {\n\t\t\tvisitPackage(clazz.getPackage());\n\t\t}\n\t\tif (clazz.getEnclosingClass() != null) {\n\t\t\tvisitTypeReference(CtRole.DECLARING_TYPE, clazz.getEnclosingClass());\n\t\t}\n// TODO in case of interfaces this was used!! But not in case of class?\n//\t\tif (clazz.isInterface()) {\n//\t\t\tfor (TypeVariable<Class<T>> generic : clazz.getTypeParameters()) {\n//\t\t\t\tvisitTypeParameter(generic);\n//\t\t\t}\n//\t\t}\n\t}\n\n\tprivate <T> List<RtMethod> getDeclaredMethods(Class<T> clazz) {\n\t\tMethod[] javaMethods = clazz.getDeclaredMethods();\n\t\tList<RtMethod> rtMethods = new ArrayList<>();\n\t\tfor (Method method : javaMethods) {\n\t\t\tif (method.isSynthetic()) {\n\t\t\t\t//ignore synthetic methods.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trtMethods.add(RtMethod.create(method));\n\t\t}\n\t\treturn rtMethods;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/JavaReflectionTreeBuilder.java",
      "weight" : 455.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java;\n\nimport spoon.reflect.code.CtLiteral;\nimport spoon.reflect.declaration.CtAnnotation;\nimport spoon.reflect.declaration.CtAnnotationMethod;\nimport spoon.reflect.declaration.CtAnnotationType;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtEnum;\nimport spoon.reflect.declaration.CtEnumValue;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtModifiable;\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.path.CtRole;\nimport spoon.reflect.reference.CtArrayTypeReference;\nimport spoon.reflect.reference.CtExecutableReference;\nimport spoon.reflect.reference.CtFieldReference;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.support.util.RtHelper;\nimport spoon.support.visitor.java.internal.AnnotationRuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.ExecutableRuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.PackageRuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.RuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.TypeReferenceRuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.TypeRuntimeBuilderContext;\nimport spoon.support.visitor.java.internal.VariableRuntimeBuilderContext;\nimport spoon.support.visitor.java.reflect.RtMethod;\nimport spoon.support.visitor.java.reflect.RtParameter;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Set;\n\n/**\n * Builds Spoon model from class file using the reflection api. The Spoon model\n * contains only the declaration part (type, field, method, etc.). Everything\n * that isn't available with the reflection api is absent from the model. Those\n * models are available when {@link CtTypeReference#getTypeDeclaration()},\n * {@link CtExecutableReference#getExecutableDeclaration()} and\n * {@link CtFieldReference#getFieldDeclaration()} are called. To know when an\n * element comes from the reflection api, use {@link spoon.reflect.declaration.CtShadowable#isShadow()}.\n */\npublic class JavaReflectionTreeBuilder extends JavaReflectionVisitorImpl {\n\tprivate Deque<RuntimeBuilderContext> contexts = new ArrayDeque<>();\n\tprivate Factory factory;\n\n\tpublic JavaReflectionTreeBuilder(Factory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\tprivate void enter(RuntimeBuilderContext context) {\n\t\tcontexts.push(context);\n\t}\n\n\tprivate RuntimeBuilderContext exit() {\n\t\treturn contexts.pop();\n\t}\n\n\t/** transforms a java.lang.Class into a CtType (ie a shadow type in Spoon's parlance) */\n\tpublic <T, R extends CtType<T>> R scan(Class<T> clazz) {\n\t\tCtPackage ctPackage;\n\t\tCtType<?> ctEnclosingClass;\n\t\tif (clazz.getEnclosingClass() != null) {\n\t\t\tctEnclosingClass = scan(clazz.getEnclosingClass());\n\t\t\treturn ctEnclosingClass.getNestedType(clazz.getSimpleName());\n\t\t} else {\n\t\t\tif (clazz.getPackage() == null) {\n\t\t\t\tctPackage = factory.Package().getRootPackage();\n\t\t\t} else {\n\t\t\t\tctPackage = factory.Package().getOrCreate(clazz.getPackage().getName());\n\t\t\t}\n\t\t\tif (contexts.isEmpty()) {\n\t\t\t\tenter(new PackageRuntimeBuilderContext(ctPackage));\n\t\t\t}\n\t\t\tif (clazz.isAnnotation()) {\n\t\t\t\tvisitAnnotationClass((Class<Annotation>) clazz);\n\t\t\t} else if (clazz.isInterface()) {\n\t\t\t\tvisitInterface(clazz);\n\t\t\t} else if (clazz.isEnum()) {\n\t\t\t\tvisitEnum(clazz);\n\t\t\t} else {\n\t\t\t\tvisitClass(clazz);\n\t\t\t}\n\t\t\texit();\n\t\t\tfinal R type = ctPackage.getType(clazz.getSimpleName());\n\t\t\tif (clazz.isPrimitive() && type.getParent() instanceof CtPackage) {\n\t\t\t\ttype.setParent(null); // primitive type isn't in a package.\n\t\t\t}\n\t\t\treturn type;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitPackage(Package aPackage) {\n\t\tfinal CtPackage ctPackage = factory.Package().getOrCreate(aPackage.getName());\n\n\t\tenter(new PackageRuntimeBuilderContext(ctPackage));\n\t\tsuper.visitPackage(aPackage);\n\t\texit();\n\n\t\tcontexts.peek().addPackage(ctPackage);\n\t}\n\n\t@Override\n\tpublic <T> void visitClass(Class<T> clazz) {\n\t\tfinal CtClass ctClass = factory.Core().createClass();\n\t\tctClass.setSimpleName(clazz.getSimpleName());\n\t\tsetModifier(ctClass, clazz.getModifiers(), clazz.getDeclaringClass());\n\n\t\tenter(new TypeRuntimeBuilderContext(clazz, ctClass) {\n\t\t\t@Override\n\t\t\tpublic void addConstructor(CtConstructor<?> ctConstructor) {\n\t\t\t\tctClass.addConstructor(ctConstructor);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\t\t\tswitch (role) {\n\t\t\t\tcase SUPER_TYPE:\n\t\t\t\t\tctClass.setSuperclass(typeReference);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsuper.addTypeReference(role, typeReference);\n\t\t\t}\n\t\t});\n\t\tsuper.visitClass(clazz);\n\t\texit();\n\n\t\tcontexts.peek().addType(ctClass);\n\t}\n\n\t@Override\n\tpublic <T> void visitInterface(Class<T> clazz) {\n\t\tfinal CtInterface<Object> ctInterface = factory.Core().createInterface();\n\t\tctInterface.setSimpleName(clazz.getSimpleName());\n\t\tsetModifier(ctInterface, clazz.getModifiers(), clazz.getDeclaringClass());\n\n\t\tenter(new TypeRuntimeBuilderContext(clazz, ctInterface));\n\t\tsuper.visitInterface(clazz);\n\t\texit();\n\n\t\tcontexts.peek().addType(ctInterface);\n\t}\n\n\t@Override\n\tpublic <T> void visitEnum(Class<T> clazz) {\n\t\tfinal CtEnum ctEnum = factory.Core().createEnum();\n\t\tctEnum.setSimpleName(clazz.getSimpleName());\n\t\tsetModifier(ctEnum, clazz.getModifiers(), clazz.getDeclaringClass());\n\n\t\tenter(new TypeRuntimeBuilderContext(clazz, ctEnum) {\n\t\t\t@Override\n\t\t\tpublic void addConstructor(CtConstructor<?> ctConstructor) {\n\t\t\t\tctEnum.addConstructor(ctConstructor);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void addEnumValue(CtEnumValue<?> ctEnumValue) {\n\t\t\t\tctEnum.addEnumValue(ctEnumValue);\n\t\t\t}\n\t\t});\n\t\tsuper.visitEnum(clazz);\n\t\texit();\n\n\t\tcontexts.peek().addType(ctEnum);\n\t}\n\n\t@Override\n\tpublic <T extends Annotation> void visitAnnotationClass(Class<T> clazz) {\n\t\tfinal CtAnnotationType<?> ctAnnotationType = factory.Core().createAnnotationType();\n\t\tctAnnotationType.setSimpleName(clazz.getSimpleName());\n\t\tsetModifier(ctAnnotationType, clazz.getModifiers(), clazz.getDeclaringClass());\n\n\t\tenter(new TypeRuntimeBuilderContext(clazz, ctAnnotationType) {\n\t\t\t@Override\n\t\t\tpublic void addMethod(CtMethod ctMethod) {\n\t\t\t\tfinal CtAnnotationMethod<Object> field = factory.Core().createAnnotationMethod();\n\t\t\t\tfield.setSimpleName(ctMethod.getSimpleName());\n\t\t\t\tfield.setModifiers(ctMethod.getModifiers());\n\t\t\t\tfield.setType(ctMethod.getType());\n\t\t\t\tfield.setShadow(true);\n\t\t\t\tctAnnotationType.addMethod(field);\n\t\t\t}\n\t\t});\n\t\tsuper.visitAnnotationClass(clazz);\n\t\texit();\n\n\t\tcontexts.peek().addType(ctAnnotationType);\n\t}\n\n\t@Override\n\tpublic void visitAnnotation(final Annotation annotation) {\n\t\tfinal CtAnnotation<Annotation> ctAnnotation = factory.Core().createAnnotation();\n\n\t\tenter(new AnnotationRuntimeBuilderContext(ctAnnotation) {\n\t\t\t@Override\n\t\t\tpublic void addMethod(CtMethod ctMethod) {\n\t\t\t\ttry {\n\t\t\t\t\tObject value = annotation.annotationType().getMethod(ctMethod.getSimpleName()).invoke(annotation);\n\n\t\t\t\t\t// if there's only one element in annotation,\n\t\t\t\t\t// then we only put that element's value.\n\t\t\t\t\t// this intends to keep the same behaviour than when spooning a model\n\t\t\t\t\t// with @MyAnnotation(values = \"myval\") -> Spoon creates only a CtLiteral for \"values\"\n\t\t\t\t\t// even if the return type should be a String[]\n\t\t\t\t\tif (value instanceof Object[]) {\n\t\t\t\t\t\tObject[] values = (Object[]) value;\n\t\t\t\t\t\tif (values.length == 1) {\n\t\t\t\t\t\t\tvalue = values[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctAnnotation.addValue(ctMethod.getSimpleName(), value);\n\t\t\t\t} catch (Exception ignore) {\n\t\t\t\t\tctAnnotation.addValue(ctMethod.getSimpleName(), \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tsuper.visitAnnotation(annotation);\n\t\texit();\n\n\t\tcontexts.peek().addAnnotation(ctAnnotation);\n\t}\n\n\t@Override\n\tpublic <T> void visitConstructor(Constructor<T> constructor) {\n\t\tfinal CtConstructor<Object> ctConstructor = factory.Core().createConstructor();\n\t\tctConstructor.setBody(factory.Core().createBlock());\n\t\tsetModifier(ctConstructor, constructor.getModifiers(), constructor.getDeclaringClass());\n\n\t\tenter(new ExecutableRuntimeBuilderContext(constructor, ctConstructor));\n\t\tsuper.visitConstructor(constructor);\n\t\texit();\n\n\t\tcontexts.peek().addConstructor(ctConstructor);\n\t}\n\n\t@Override\n\tpublic void visitMethod(RtMethod method, Annotation parent) {\n\t\tfinal CtMethod<Object> ctMethod = factory.Core().createMethod();\n\t\tctMethod.setSimpleName(method.getName());\n\t\t/**\n\t\t * java 8 static interface methods are marked as abstract but has body\n\t\t */\n\t\tif (Modifier.isAbstract(method.getModifiers()) == false) {\n\t\t\tctMethod.setBody(factory.Core().createBlock());\n\t\t}\n\t\tsetModifier(ctMethod, method.getModifiers(), method.getDeclaringClass());\n\t\tctMethod.setDefaultMethod(method.isDefault());\n\n\t\tenter(new ExecutableRuntimeBuilderContext(method.getMethod(), ctMethod));\n\t\tsuper.visitMethod(method, parent);\n\t\texit();\n\n\t\tcontexts.peek().addMethod(ctMethod);\n\t}\n\n\t@Override\n\tpublic void visitField(Field field) {\n\t\tfinal CtField<Object> ctField = factory.Core().createField();\n\t\tctField.setSimpleName(field.getName());\n\t\tsetModifier(ctField, field.getModifiers(), field.getDeclaringClass());\n\n\t\t// we set the value of the shadow field if it is a public and static primitive value\n\t\ttry {\n\t\t\tSet<ModifierKind> modifiers = RtHelper.getModifiers(field.getModifiers());\n\t\t\tif (modifiers.contains(ModifierKind.STATIC)\n\t\t\t\t\t&& modifiers.contains(ModifierKind.PUBLIC)\n\t\t\t\t\t&& (field.getType().isPrimitive() || String.class.isAssignableFrom(field.getType()))\n\t\t\t\t) {\n\t\t\t\tCtLiteral<Object> defaultExpression = factory.createLiteral(field.get(null));\n\t\t\t\tctField.setDefaultExpression(defaultExpression);\n\t\t\t}\n\t\t} catch (IllegalAccessException e) {\n\t\t\t// ignore\n\t\t}\n\n\t\tenter(new VariableRuntimeBuilderContext(ctField));\n\t\tsuper.visitField(field);\n\t\texit();\n\n\t\tcontexts.peek().addField(ctField);\n\t}\n\n\t@Override\n\tpublic void visitEnumValue(Field field) {\n\t\tfinal CtEnumValue<Object> ctEnumValue = factory.Core().createEnumValue();\n\t\tctEnumValue.setSimpleName(field.getName());\n\t\tsetModifier(ctEnumValue, field.getDeclaringClass().getModifiers(), field.getDeclaringClass().getDeclaringClass());\n\n\t\tenter(new VariableRuntimeBuilderContext(ctEnumValue));\n\t\tsuper.visitEnumValue(field);\n\t\texit();\n\n\t\tcontexts.peek().addEnumValue(ctEnumValue);\n\t}\n\n\t@Override\n\tpublic void visitParameter(RtParameter parameter) {\n\t\tfinal CtParameter ctParameter = factory.Core().createParameter();\n\t\tctParameter.setSimpleName(parameter.getName());\n\t\tctParameter.setVarArgs(parameter.isVarArgs());\n\t\t//it is not possible to detect whether parameter is final in runtime\n//\t\tif (parameter.isFinal()) {\n//\t\t\tctParameter.addModifier(ModifierKind.FINAL);\n//\t\t}\n\n\t\tenter(new VariableRuntimeBuilderContext(ctParameter));\n\t\tsuper.visitParameter(parameter);\n\t\texit();\n\n\t\tcontexts.peek().addParameter(ctParameter);\n\t}\n\n\t@Override\n\tpublic <T extends GenericDeclaration> void visitTypeParameter(TypeVariable<T> parameter) {\n\t\tGenericDeclaration genericDeclaration = parameter.getGenericDeclaration();\n\t\tfor (RuntimeBuilderContext context : contexts) {\n\t\t\tCtTypeParameter typeParameter = context.getTypeParameter(genericDeclaration, parameter.getName());\n\t\t\tif (typeParameter != null) {\n\t\t\t\tcontexts.peek().addFormalType(typeParameter.clone());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfinal CtTypeParameter typeParameter = factory.Core().createTypeParameter();\n\t\ttypeParameter.setSimpleName(parameter.getName());\n\n\t\tenter(new TypeRuntimeBuilderContext(parameter, typeParameter) {\n\t\t\t@SuppressWarnings(\"incomplete-switch\")\n\t\t\t@Override\n\t\t\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\t\t\tswitch (role) {\n\t\t\t\tcase SUPER_TYPE:\n\t\t\t\t\tif (typeParameter.getSuperclass() != null) {\n\t\t\t\t\t\ttypeParameter.setSuperclass(typeParameter.getFactory().createIntersectionTypeReferenceWithBounds(Arrays.asList(typeParameter.getSuperclass(), typeReference)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttypeParameter.setSuperclass(typeReference);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsuper.addTypeReference(role, typeReference);\n\t\t\t}\n\t\t});\n\t\tsuper.visitTypeParameter(parameter);\n\t\texit();\n\n\t\tcontexts.peek().addFormalType(typeParameter);\n\t}\n\n\t@Override\n\tpublic <T extends GenericDeclaration> void visitTypeParameterReference(CtRole role, TypeVariable<T> parameter) {\n\t\tfinal CtTypeParameterReference typeParameterReference = factory.Core().createTypeParameterReference();\n\t\ttypeParameterReference.setSimpleName(parameter.getName());\n\n\t\tRuntimeBuilderContext runtimeBuilderContext = new TypeReferenceRuntimeBuilderContext(parameter, typeParameterReference);\n\t\tif (contexts.contains(runtimeBuilderContext)) {\n\t\t\t// we are in the case of a loop\n\t\t\texit();\n\t\t\tenter(new TypeReferenceRuntimeBuilderContext(Object.class, factory.Type().OBJECT));\n\t\t\treturn;\n\t\t}\n\n\t\tGenericDeclaration genericDeclaration = parameter.getGenericDeclaration();\n\t\tfor (RuntimeBuilderContext context : contexts) {\n\t\t\tCtTypeParameter typeParameter = context.getTypeParameter(genericDeclaration, parameter.getName());\n\t\t\tif (typeParameter != null) {\n\t\t\t\tcontexts.peek().addTypeReference(role, typeParameter.getReference());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tenter(runtimeBuilderContext);\n\t\tsuper.visitTypeParameterReference(role, parameter);\n\t\texit();\n\n\t\tcontexts.peek().addTypeReference(role, typeParameterReference);\n\t}\n\n\t@Override\n\tpublic void visitTypeReference(CtRole role, ParameterizedType type) {\n\t\tfinal CtTypeReference<?> ctTypeReference = factory.Core().createTypeReference();\n\t\tctTypeReference.setSimpleName(((Class) type.getRawType()).getSimpleName());\n\n\t\tRuntimeBuilderContext context = new TypeReferenceRuntimeBuilderContext(type, ctTypeReference) {\n\n\t\t\t@Override\n\t\t\tpublic void addType(CtType<?> aType) {\n\t\t\t\t//TODO check if it is needed\n\t\t\t\tthis.getClass();\n\t\t\t}\n\t\t};\n\n\t\tenter(context);\n\t\tsuper.visitTypeReference(role, type);\n\n\t\t// in case of a loop we have replaced a context:\n\t\t// we do not want to addTypeName then\n\t\t// and we have to rely on the instance reference to check that\n\t\tboolean contextStillExisting = false;\n\t\tfor (RuntimeBuilderContext context1 : contexts) {\n\t\t\tcontextStillExisting = contextStillExisting || (context1 == context);\n\t\t}\n\t\texit();\n\n\t\tif (contextStillExisting) {\n\t\t\tcontexts.peek().addTypeReference(role, ctTypeReference);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void visitTypeReference(CtRole role, WildcardType type) {\n\t\tfinal CtWildcardReference wildcard = factory.Core().createWildcardReference();\n\t\t//looks like type.getUpperBounds() always returns single value array with Object.class\n\t\t//so we cannot distinguish between <? extends Object> and <?>, which must be upper==true too!\n\t\twildcard.setUpper((type.getLowerBounds() != null && type.getLowerBounds().length > 0) == false);\n\n\t\tenter(new TypeReferenceRuntimeBuilderContext(type, wildcard));\n\t\tsuper.visitTypeReference(role, type);\n\t\texit();\n\n\t\tcontexts.peek().addTypeReference(role, wildcard);\n\t}\n\n\n\tprivate String getTypeName(Type type) {\n\t\tif (type instanceof Class) {\n\t\t\tClass clazz = (Class) type;\n\t\t\tif (clazz.isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tClass<?> cl = clazz;\n\t\t\t\t\tint dimensions = 0;\n\t\t\t\t\twhile (cl.isArray()) {\n\t\t\t\t\t\tdimensions++;\n\t\t\t\t\t\tcl = cl.getComponentType();\n\t\t\t\t\t}\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\tsb.append(cl.getName());\n\t\t\t\t\tfor (int i = 0; i < dimensions; i++) {\n\t\t\t\t\t\tsb.append(\"[]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn sb.toString();\n\t\t\t\t} catch (Throwable e) { /*FALLTHRU*/ }\n\t\t\t} else {\n\t\t\t\tvisitPackage(clazz.getPackage());\n\t\t\t}\n\t\t\treturn clazz.getSimpleName();\n\t\t}\n\t\treturn type.toString();\n\t}\n\n\t@Override\n\tpublic <T> void visitArrayReference(CtRole role, final Type typeArray) {\n\t\tfinal CtArrayTypeReference<?> arrayTypeReference = factory.Core().createArrayTypeReference();\n\n\t\tenter(new TypeReferenceRuntimeBuilderContext(typeArray, arrayTypeReference) {\n\t\t\t@Override\n\t\t\tpublic void addTypeReference(CtRole role, CtTypeReference<?> typeReference) {\n\t\t\t\tswitch (role) {\n\t\t\t\tcase DECLARING_TYPE:\n\t\t\t\t\tarrayTypeReference.setDeclaringType(typeReference);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tarrayTypeReference.setComponentType(typeReference);\n\t\t\t}\n\t\t});\n\t\tsuper.visitArrayReference(role, typeArray);\n\t\texit();\n\n\t\tcontexts.peek().addTypeReference(role, arrayTypeReference);\n\t}\n\n\n\t@Override\n\tpublic <T> void visitTypeReference(CtRole role, Class<T> clazz) {\n\t\tfinal CtTypeReference<Object> typeReference = factory.Core().createTypeReference();\n\t\ttypeReference.setSimpleName(clazz.getSimpleName());\n\n\t\tenter(new TypeReferenceRuntimeBuilderContext(clazz, typeReference));\n\t\tsuper.visitTypeReference(role, clazz);\n\t\texit();\n\n\t\tcontexts.peek().addTypeReference(role, typeReference);\n\t}\n\n\n\tprivate void setModifier(CtModifiable ctModifiable, int modifiers, Class<?> declaringClass) {\n\t\t// an interface is implicitly abstract\n\t\tif (Modifier.isAbstract(modifiers) && !(ctModifiable instanceof CtInterface)) {\n\t\t\tif (ctModifiable instanceof CtEnum) {\n\t\t\t\t//enum must not be declared abstract (even if it can be made abstract see CtStatementImpl.InsertType)\n\t\t\t\t//as stated in java lang spec https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.9\n\t\t\t} else if (isInterface(declaringClass)) {\n\t\t\t\t//do not set implicit abstract for interface type members\n\t\t\t} else {\n\t\t\t\tctModifiable.addModifier(ModifierKind.ABSTRACT);\n\t\t\t}\n\t\t}\n\t\tif (Modifier.isFinal(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.FINAL);\n\t\t}\n\t\tif (Modifier.isNative(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.NATIVE);\n\t\t}\n\t\tif (Modifier.isPrivate(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.PRIVATE);\n\t\t}\n\t\tif (Modifier.isProtected(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.PROTECTED);\n\t\t}\n\t\tif (Modifier.isPublic(modifiers)) {\n\t\t\tif (isInterface(declaringClass)) {\n\t\t\t\t//do not set implicit abstract for interface type members\n\t\t\t} else {\n\t\t\t\tctModifiable.addModifier(ModifierKind.PUBLIC);\n\t\t\t}\n\t\t}\n\t\tif (Modifier.isStatic(modifiers)) {\n\t\t\tif (ctModifiable instanceof CtEnum) {\n\t\t\t\t//enum is implicitly static, so do not add static explicitly\n\t\t\t} else {\n\t\t\t\tctModifiable.addModifier(ModifierKind.STATIC);\n\t\t\t}\n\t\t}\n\t\tif (Modifier.isStrict(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.STRICTFP);\n\t\t}\n\t\tif (Modifier.isSynchronized(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.SYNCHRONIZED);\n\t\t}\n\t\tif (Modifier.isTransient(modifiers)) {\n\t\t\tif (ctModifiable instanceof CtField) {\n\t\t\t\tctModifiable.addModifier(ModifierKind.TRANSIENT);\n\t\t\t} else if (ctModifiable instanceof CtExecutable) {\n\t\t\t\t//it happens when executable has a vararg parameter. But that is not handled by modifiers in Spoon model\n//\t\t\t\tctModifiable.addModifier(ModifierKind.VARARG);\n\t\t\t} else {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\t\tif (Modifier.isVolatile(modifiers)) {\n\t\t\tctModifiable.addModifier(ModifierKind.VOLATILE);\n\t\t}\n\t}\n\n\tprivate boolean isInterface(Class<?> clazz) {\n\t\treturn clazz != null && clazz.isInterface();\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/reflect/RtMethod.java",
      "weight" : 169.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.reflect;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\nimport spoon.SpoonException;\n\npublic class RtMethod {\n\tprivate final Class<?> clazz;\n\tprivate final Method method;\n\tprivate final String name;\n\tprivate final Class<?> returnType;\n\tprivate final Type genericReturnType;\n\tprivate final TypeVariable<Method>[] typeParameters;\n\tprivate final Class<?>[] parameterTypes;\n\tprivate final Type[] genericParameterTypes;\n\tprivate final Class<?>[] exceptionTypes;\n\tprivate final int modifiers;\n\tprivate final Annotation[] annotations;\n\tprivate final Annotation[][] parameterAnnotations;\n\tprivate final boolean isVarArgs;\n\tprivate final boolean isDefault;\n\n\tpublic RtMethod(Class<?> clazz, Method method, String name, Class<?> returnType, Type genericReturnType, TypeVariable<Method>[] typeParameters, Class<?>[] parameterTypes, Type[] genericParameterTypes, Class<?>[] exceptionTypes, int modifiers,\n\t\t\tAnnotation[] annotations, Annotation[][] parameterAnnotations, boolean isVarArgs, boolean isDefault) {\n\t\tthis.clazz = clazz;\n\t\tthis.method = method;\n\t\tthis.name = name;\n\t\tthis.returnType = returnType;\n\t\tthis.genericReturnType = genericReturnType;\n\t\tthis.typeParameters = typeParameters;\n\t\tthis.parameterTypes = parameterTypes;\n\t\tthis.genericParameterTypes = genericParameterTypes;\n\t\tthis.exceptionTypes = exceptionTypes;\n\t\tthis.modifiers = modifiers;\n\t\tthis.annotations = annotations;\n\t\tthis.parameterAnnotations = parameterAnnotations;\n\t\tthis.isVarArgs = isVarArgs;\n\t\tthis.isDefault = isDefault;\n\t}\n\n\tpublic Class<?> getDeclaringClass() {\n\t\treturn clazz;\n\t}\n\n\tpublic Method getMethod() {\n\t\treturn method;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic Class<?> getReturnType() {\n\t\treturn returnType;\n\t}\n\n\tpublic TypeVariable<Method>[] getTypeParameters() {\n\t\treturn typeParameters;\n\t}\n\n\tpublic Class<?>[] getParameterTypes() {\n\t\treturn parameterTypes;\n\t}\n\n\tpublic Class<?>[] getExceptionTypes() {\n\t\treturn exceptionTypes;\n\t}\n\n\tpublic int getModifiers() {\n\t\treturn modifiers;\n\t}\n\n\tpublic Annotation[] getDeclaredAnnotations() {\n\t\treturn annotations;\n\t}\n\n\tpublic Annotation[][] getParameterAnnotations() {\n\t\treturn parameterAnnotations;\n\t}\n\n\tpublic boolean isVarArgs() {\n\t\treturn isVarArgs;\n\t}\n\n\tpublic boolean isDefault() {\n\t\treturn isDefault;\n\t}\n\n\tpublic Type getGenericReturnType() {\n\t\treturn genericReturnType;\n\t}\n\n\tpublic Type[] getGenericParameterTypes() {\n\t\treturn genericParameterTypes;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tRtMethod rtMethod = (RtMethod) o;\n\n\t\tif (!Objects.equals(name, rtMethod.name)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Objects.equals(returnType, rtMethod.returnType)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!Arrays.equals(parameterTypes, rtMethod.parameterTypes)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Arrays.equals(exceptionTypes, rtMethod.exceptionTypes);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n\t}\n\n\tpublic static RtMethod create(Method method) {\n\t\treturn new RtMethod(method.getDeclaringClass(), method, method.getName(), method.getReturnType(),\n\t\t\t\tmethod.getGenericReturnType(), method.getTypeParameters(), method.getParameterTypes(), method.getGenericParameterTypes(), method.getExceptionTypes(),\n\t\t\t\tmethod.getModifiers(), method.getDeclaredAnnotations(), method.getParameterAnnotations(),\n\t\t\t\tmethod.isVarArgs(), //spoon is compatible with Java 7, so compilation fails here\n\t\t\t\t//method.isDefault());\n\t\t\t\t_java8_isDefault(method));\n\t}\n\n\tprivate static Method _method_isDefault;\n\tstatic {\n\t\ttry {\n\t\t\t_method_isDefault = Method.class.getMethod(\"isDefault\");\n\t\t} catch (NoSuchMethodException | SecurityException e) {\n\t\t\t//spoon is running with java 7 JDK\n\t\t\t_method_isDefault = null;\n\t\t}\n\t}\n\n\tprivate static boolean _java8_isDefault(Method method) {\n\t\tif (_method_isDefault == null) {\n\t\t\t//spoon is running with java 7 JDK, all methods are not default, because java 7 does not have default methods\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\treturn (Boolean) _method_isDefault.invoke(method);\n\t\t} catch (IllegalAccessException | IllegalArgumentException e) {\n\t\t\tthrow new SpoonException(\"Calling of Java8 Method#isDefault() failed\", e);\n\t\t} catch (InvocationTargetException e) {\n\t\t\tthrow new SpoonException(\"Calling of Java8 Method#isDefault() failed\", e.getTargetException());\n\t\t}\n\t}\n\n\tpublic static <T> RtMethod[] methodsOf(Class<T> clazz) {\n\t\tfinal RtMethod[] methods = new RtMethod[clazz.getDeclaredMethods().length];\n\t\tint i = 0;\n\t\tfor (Method method : clazz.getDeclaredMethods()) {\n\t\t\tmethods[i++] = create(method);\n\t\t}\n\t\treturn methods;\n\t}\n\n\t/** Returns the methods of `klass` that have the same signature (according to runtime reflection) but a different return type of at least one of the methods\n\t * in `comparedMethods` given as parameter.\n\t */\n\tpublic static <T> RtMethod[] sameMethodsWithDifferentTypeOf(Class<T> klass, List<RtMethod> comparedMethods) {\n\t\tfinal List<RtMethod> methods = new ArrayList<>();\n\t\tfor (Method method : klass.getDeclaredMethods()) {\n\t\t\tfinal RtMethod rtMethod = create(method);\n\t\t\tfor (RtMethod potential : comparedMethods) {\n\t\t\t\tif (potential.isLightEquals(rtMethod) && !rtMethod.returnType.equals(potential.returnType)) {\n\t\t\t\t\tmethods.add(rtMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn methods.toArray(new RtMethod[0]);\n\t}\n\n\tprivate boolean isLightEquals(RtMethod rtMethod) {\n\t\tif (this == rtMethod) {\n\t\t\treturn true;\n\t\t}\n\t\tif (rtMethod == null || getClass() != rtMethod.getClass()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!Objects.equals(name, rtMethod.name)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn Arrays.equals(parameterTypes, rtMethod.parameterTypes);\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/reflect/RtParameter.java",
      "weight" : 92.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java.reflect;\n\nimport spoon.SpoonException;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Type;\n\n/**\n * To be compatible with Java 6, RtParameter has been created from\n * the Parameter class in Java 8.\n */\npublic class RtParameter {\n\tprivate final String name;\n\tprivate final Class<?> type;\n\tprivate final Type genericType;\n\tprivate final RtMethod method;\n\tprivate final Constructor constructor;\n\tprivate final int index;\n\n\tpublic RtParameter(String name, Class<?> type, Type genericType, RtMethod method, Constructor constructor, int index) {\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.genericType = genericType;\n\t\tthis.method = method;\n\t\tthis.constructor = constructor;\n\t\tthis.index = index;\n\t}\n\n\t/**\n\t * Returns the name of the parameter.\n\t *\n\t * @return The name of the parameter, either provided by the class\n\t * file or synthesized if the class file does not provide\n\t * a name.\n\t */\n\tpublic String getName() {\n\t\t// Note: empty strings as parameter names are now outlawed.\n\t\t// The .equals(\"\") is for compatibility with current JVM\n\t\t// behavior.  It may be removed at some point.\n\t\tif (name == null || name.isEmpty()) {\n\t\t\treturn \"arg\" + index;\n\t\t} else {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the {@code Class} which is the type of the parameter.\n\t *\n\t * @return The type of the parameter.\n\t */\n\tpublic Class<?> getType() {\n\t\treturn type;\n\t}\n\n\tpublic Type getGenericType() {\n\t\treturn genericType;\n\t}\n\n\t/**\n\t * Return annotations which declared on the parameter.\n\t *\n\t * @return Annotations declared on the parameter.\n\t */\n\tpublic Annotation[] getDeclaredAnnotations() {\n\t\tif (method == null) {\n\t\t\t/*\n\t\t\t * According to oracle sources (for jdk 8) for java.lang.reflect.Executable#getParameterAnnotations(),\n\t\t\t * the length of the returned array may vary at the discretion of the compiler.\n\t\t\t * It seems that eclipse and javac do not produce the same results.\n\t\t\t * In our case the value of index is based on getGenericParameterTypes(), so if\n\t\t\t * getParameterAnnotations() returns a smaller array, we can assume that\n\t\t\t * a synthetic parameter pointing to the outer class has been added at the begining of\n\t\t\t * getGenericParameterTypes() and not in getParameterAnnotations().\n\t\t\t * The actual index is then shifted by the difference.\n\t\t\t */\n\t\t\tint diff = constructor.getGenericParameterTypes().length - constructor.getParameterAnnotations().length;\n\t\t\treturn constructor.getParameterAnnotations()[index - diff];\n\t\t}\n\t\treturn method.getParameterAnnotations()[index];\n\t}\n\n\t/**\n\t * Returns {@code true} if this parameter represents a variable\n\t * argument list; returns {@code false} otherwise.\n\t *\n\t * @return {@code true} if an only if this parameter represents a\n\t * variable argument list.\n\t */\n\tpublic boolean isVarArgs() {\n\t\tif (method == null) {\n\t\t\treturn constructor.isVarArgs() && index == constructor.getParameterTypes().length - 1;\n\t\t}\n\t\treturn method.isVarArgs() && index == method.getParameterTypes().length - 1;\n\t}\n\n\t/**\n\t * Compares based on the executable and the index.\n\t *\n\t * @param obj\n\t * \t\tThe object to compare.\n\t * @return Whether or not this is equal to the argument.\n\t */\n\tpublic boolean equals(Object obj) {\n\t\tif (obj instanceof RtParameter) {\n\t\t\tRtParameter other = (RtParameter) obj;\n\t\t\tif (method == null) {\n\t\t\t\treturn (other.constructor.equals(constructor) && other.index == index);\n\t\t\t}\n\t\t\treturn (other.method.equals(method) && other.index == index);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns a hash code based on the executable's hash code and the\n\t * index.\n\t *\n\t * @return A hash code based on the executable's hash code.\n\t */\n\tpublic int hashCode() {\n\t\tif (method == null) {\n\t\t\treturn constructor.hashCode() ^ index;\n\t\t}\n\t\treturn method.hashCode() ^ index;\n\t}\n\n\t/**\n\t * Get parameters in a method to spoon parameters.\n\t *\n\t * @param method\n\t * \t\tParent executable of parameters.\n\t * @return Parameters of the executable.\n\t */\n\tpublic static RtParameter[] parametersOf(RtMethod method) {\n\t\tRtParameter[] parameters = new RtParameter[method.getParameterTypes().length];\n\t\tfor (int index = 0; index < method.getParameterTypes().length; index++) {\n\t\t\tparameters[index] = new RtParameter(null, method.getParameterTypes()[index], method.getGenericParameterTypes()[index], method, null, index);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\t/**\n\t * Get parameters in a constructor to spoon parameters.\n\t *\n\t * @param constructor\n\t * \t\tParent executable of parameters.\n\t * @return Parameters of the executable.\n\t */\n\tpublic static RtParameter[] parametersOf(Constructor constructor) {\n\t\tRtParameter[] parameters;\n\t\t// Apparently getGenericParameterTypes and getParameterTypes could have different length\n\t\t// if the first parameter is implicit: a private non-static inner class will have an implicit parameter for its superclass\n\t\t// but it won't be present in the result of getGenericParameterTypes (e.g. ArrayList$SubList)\n\t\t// moreover if it's an enum, there will be 2 implicit parameters (String and int) we won't consider them in the model.\n\t\tint lengthGenericParameterTypes = constructor.getGenericParameterTypes().length;\n\t\tint lengthParameterTypes = constructor.getParameterTypes().length;\n\n\t\tint offset;\n\t\tif (lengthGenericParameterTypes == lengthParameterTypes) {\n\t\t\tparameters = new RtParameter[lengthParameterTypes];\n\t\t\toffset = 0;\n\t\t} else if (lengthGenericParameterTypes == lengthParameterTypes - 1) {\n\t\t\tparameters = new RtParameter[lengthGenericParameterTypes];\n\t\t\toffset = 1;\n\t\t} else if (constructor.getDeclaringClass().isEnum() && lengthGenericParameterTypes == lengthParameterTypes - 2) {\n\t\t\tparameters = new RtParameter[lengthGenericParameterTypes];\n\t\t\toffset = 2;\n\t\t} else {\n\t\t\tthrow new SpoonException(\"Error while analyzing parameters of constructor: \" + constructor + \". # of parameters: \" + lengthParameterTypes + \" - # of generic parameter types: \" + lengthGenericParameterTypes);\n\t\t}\n\n\t\tfor (int index = 0; index < constructor.getGenericParameterTypes().length; index++) {\n\t\t\tparameters[index] = new RtParameter(null, constructor.getParameterTypes()[index + offset], constructor.getGenericParameterTypes()[index], null, constructor, index);\n\t\t}\n\t\treturn parameters;\n\t}\n}\n"
    }, {
      "name" : "support/visitor/java/JavaReflectionVisitor.java",
      "weight" : 32.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor.java;\n\nimport spoon.reflect.path.CtRole;\nimport spoon.support.visitor.java.reflect.RtMethod;\nimport spoon.support.visitor.java.reflect.RtParameter;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\n\n/**\n * Internal, package-visible interface for building shadow classes.\n * Client code should not rely on it.\n */\ninterface JavaReflectionVisitor {\n\t/** Visits a {@link java.lang.Package} */\n\tvoid visitPackage(Package aPackage);\n\n\t/** Visits a {@link java.lang.Class} */\n\t<T> void visitClass(Class<T> clazz);\n\n\t/** Visits a {@link java.lang.Class} representing an interface, see {@link Class#isInterface()} ()} */\n\t<T> void visitInterface(Class<T> clazz);\n\n\t/** Visits a {@link java.lang.Class} representing an enum, see {@link Class#isEnum()} */\n\t<T> void visitEnum(Class<T> clazz);\n\n\t/** Visits a {@link java.lang.Class} representing an enum, see {@link Class#isAnnotation()} */\n\t<T extends Annotation> void visitAnnotationClass(Class<T> clazz);\n\n\t/** Visits an {@link Annotation} instance */\n\tvoid visitAnnotation(Annotation annotation);\n\n\t/** Visits a {@link Constructor} */\n\t<T> void visitConstructor(Constructor<T> constructor);\n\n\t/** Visits a {@link RtMethod} (spoon wrapper) */\n\tvoid visitMethod(RtMethod method);\n\n\t/** Visits a {@link Field} */\n\tvoid visitField(Field field);\n\n\t/** Visits a {@link Field} from an enum */\n\tvoid visitEnumValue(Field field);\n\n\t/** Visits a {@link RtParameter} (spoon wrapper) */\n\tvoid visitParameter(RtParameter parameter);\n\n\t/** Visits a {@link TypeVariable} */\n\t<T extends GenericDeclaration> void visitTypeParameter(TypeVariable<T> parameter);\n\n\t/** Visits a {@link TypeVariable}\n\t * @param role {@link CtRole} which this reference plays*/\n\t<T extends GenericDeclaration> void visitTypeParameterReference(CtRole role, TypeVariable<T> parameter);\n\n\t/** Visits a {@link Type}\n\t * @param role {@link CtRole} which this reference plays*/\n\tvoid visitTypeReference(CtRole role, Type type);\n\n\t/** Visits a {@link ParameterizedType}\n\t * @param role {@link CtRole} which this reference plays*/\n\tvoid visitTypeReference(CtRole role, ParameterizedType type);\n\n\t/** Visits a {@link WildcardType}\n\t * @param role {@link CtRole} which this reference plays*/\n\tvoid visitTypeReference(CtRole role, WildcardType type);\n\n\t/** Visits a {@link Class} in generic parameters\n\t * @param role {@link CtRole} which this reference plays*/\n\t<T> void visitTypeReference(CtRole role, Class<T> clazz);\n\n\t/** Visits a class as an array reference\n\t * @param role {@link CtRole} which this reference plays*/\n\t<T> void visitArrayReference(CtRole role, Type typeArray);\n}\n"
    }, {
      "name" : "support/visitor/ClassTypingContext.java",
      "weight" : 445.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtFormalTypeDeclarer;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtParameter;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.declaration.ModifierKind;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.reflect.visitor.chain.ScanningMode;\nimport spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction;\nimport spoon.support.SpoonClassNotFoundException;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Helper class created from type X or reference to X.\n * It provides access to actual type arguments\n * of any super type of type X adapted to type X.<br>\n * Example:<br>\n * <pre>\n * //reference to `ArrayList` with actual type argument `Integer`\n * CtTypeReference arrayListRef = ... //ArrayList&lt;Integer&gt;\n * //type java.util.List with type parameter `E`\n * CtType list = ... //List&lt;E&gt;\n * //adapting of type parameter `E` to scope of arrayListRef\n * CtTypeReference typeParamE_adaptedTo_arrayListRef = new ClassTypingContext(arrayListRef).adaptType(list.getFormalCtTypeParameters().get(0))\n * //the value of `E` in scope of arrayListRef is `Integer`\n * assertEquals(Integer.class.getName(), typeParamE_adaptedTo_arrayListRef.getQualifiedName());\n * </pre>\n */\npublic class ClassTypingContext extends AbstractTypingContext {\n\n\tprivate final CtType<?> scopeType;\n\t/*\n\t * super type hierarchy of the enclosing class\n\t */\n\tprivate ClassTypingContext enclosingClassTypingContext;\n\n\t/*\n\t * maps qualified name of the type to the actual type arguments of this type in `scope`\n\t */\n\tprivate Map<String, List<CtTypeReference<?>>> typeToArguments = new HashMap<>();\n\t/**\n\t * remember which super class was last visited.\n\t * The next super class scanning will start here\n\t */\n\tprivate CtTypeInformation lastResolvedSuperclass;\n\t/**\n\t * the set of qualified names of all visited classes and interfaces, which assures that interfaces are visited only once\n\t */\n\tprivate Set<String> visitedSet;\n\n\t/**\n\t * @param typeReference {@link CtTypeReference} whose actual type arguments are used for resolving of input type parameters\n\t */\n\tpublic ClassTypingContext(CtTypeReference<?> typeReference) {\n\t\tscopeType = typeReference.getTypeDeclaration();\n\t\tlastResolvedSuperclass = typeReference;\n\t\tCtTypeReference<?> enclosing = getEnclosingType(typeReference);\n\t\tif (enclosing != null) {\n\t\t\tenclosingClassTypingContext = createEnclosingHierarchy(enclosing);\n\t\t}\n\t\ttypeToArguments.put(typeReference.getQualifiedName(), typeReference.getActualTypeArguments());\n\t}\n\n\t/**\n\t * @param type {@link CtType} whose formal type parameters are transformed to {@link CtTypeReference}s,\n\t * which plays role of actual type arguments, used for resolving of input type parameters\n\t */\n\tpublic ClassTypingContext(CtType<?> type) {\n\t\tscopeType = type;\n\t\tlastResolvedSuperclass = type;\n\t\tCtType<?> enclosing = getEnclosingType(type);\n\t\tif (enclosing != null) {\n\t\t\tenclosingClassTypingContext = createEnclosingHierarchy(enclosing);\n\t\t}\n\t\ttypeToArguments.put(type.getQualifiedName(), getTypeReferences(type.getFormalCtTypeParameters()));\n\t}\n\n\t@Override\n\tpublic CtType<?> getAdaptationScope() {\n\t\treturn scopeType;\n\t}\n\n\t/**\n\t * detects if `superTypeRef` is a super type of the type or type reference,\n\t * which was send to constructor of this instance.\n\t * It takes into account the actual type arguments of this type and `superTypeRef`\n\t *\n\t * So for example:<br>\n\t * <pre>\n\t * CtTypeReference listInteger = ...//List&lt;Integer&gt;\n\t * CtTypeReference listString = ...//List&lt;Integer&gt;\n\t * assertFalse(new ClassTypingContext(listInteger).isSubtypeOf(listString))\n\t * CtTypeReference listExtendsNumber = ...//List&lt;? extends Number&gt;\n\t * assertTrue(new ClassTypingContext(listInteger).isSubtypeOf(listExtendsNumber))\n\t * </pre>\n\t * @param superTypeRef the reference\n\t * @return true if this type (including actual type arguments) is a subtype of superTypeRef\n\t */\n\tpublic boolean isSubtypeOf(CtTypeReference<?> superTypeRef) {\n\t\tList<CtTypeReference<?>> adaptedArgs = resolveActualTypeArgumentsOf(superTypeRef);\n\t\tif (adaptedArgs == null) {\n\t\t\t//the superTypeRef was not found in super type hierarchy\n\t\t\treturn false;\n\t\t}\n\t\tif (isSubTypeByActualTypeArguments(superTypeRef, adaptedArgs) == false) {\n\t\t\treturn false;\n\t\t}\n\t\tCtTypeReference<?> enclosingTypeRef = getEnclosingType(superTypeRef);\n\t\tif (enclosingTypeRef != null) {\n\t\t\tif (enclosingClassTypingContext == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn enclosingClassTypingContext.isSubtypeOf(enclosingTypeRef);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * resolve actual type argument values of the provided type reference\n\t * @param typeRef the reference to the type\n\t * \twhose actual type argument values has to be resolved in scope of `scope` type\n\t * @return actual type arguments of `typeRef` in scope of `scope` element or null if typeRef is not a super type of `scope`\n\t */\n\tpublic List<CtTypeReference<?>> resolveActualTypeArgumentsOf(CtTypeReference<?> typeRef) {\n\t\tfinal String typeQualifiedName = typeRef.getQualifiedName();\n\t\tList<CtTypeReference<?>> args = typeToArguments.get(typeQualifiedName);\n\t\tif (args != null) {\n\t\t\t//the actual type arguments of `type` are already resolved\n\t\t\treturn args;\n\t\t}\n\t\t//resolve hierarchy of enclosing class first.\n\t\tCtTypeReference<?> enclosingTypeRef = getEnclosingType(typeRef);\n\t\tif (enclosingTypeRef != null) {\n\t\t\tif (enclosingClassTypingContext == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t//`type` is inner class. Resolve its enclosing class arguments first\n\t\t\tif (enclosingClassTypingContext.resolveActualTypeArgumentsOf(enclosingTypeRef) == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * the `type` is either top level, static or resolved inner class.\n\t\t * So it has no parent actual type arguments or they are resolved now\n\t\t */\n\t\t/*\n\t\t * detect where to start/continue with resolving of super classes and super interfaces\n\t\t * to found actual type arguments of input `type`\n\t\t */\n\t\tif (lastResolvedSuperclass == null) {\n\t\t\t/*\n\t\t\t * whole super inheritance hierarchy was already resolved for this level.\n\t\t\t * It means that `type` is not a super type of `scope` on the level `level`\n\t\t\t */\n\t\t\treturn null;\n\t\t}\n\t\tfinal HierarchyListener listener = new HierarchyListener(getVisitedSet());\n\t\t/*\n\t\t * remove last resolved class from the list of visited,\n\t\t * because it would avoid visiting its super hierarchy\n\t\t */\n\t\tgetVisitedSet().remove(lastResolvedSuperclass.getQualifiedName());\n\t\t/*\n\t\t * visit super inheritance class hierarchy of lastResolve type of level of `type` to found its actual type arguments.\n\t\t */\n\t\t((CtElement) lastResolvedSuperclass).map(new SuperInheritanceHierarchyFunction()\n\t\t\t\t.interfacesExtendObject(true)\n\t\t\t\t.includingSelf(false)\n\t\t\t\t.returnTypeReferences(true)\n\t\t\t\t.setListener(listener))\n\t\t.forEach(new CtConsumer<CtTypeReference<?>>() {\n\t\t\t@Override\n\t\t\tpublic void accept(CtTypeReference<?> typeRef) {\n\t\t\t\t/*\n\t\t\t\t * typeRef is a reference from subtype to super type.\n\t\t\t\t * It contains actual type arguments in scope of subtype,\n\t\t\t\t * which are going to be substituted as arguments to formal type parameters of super type\n\t\t\t\t */\n\t\t\t\tString superTypeQualifiedName = typeRef.getQualifiedName();\n\t\t\t\tList<CtTypeReference<?>> actualTypeArguments = typeRef.getActualTypeArguments();\n\t\t\t\tif (actualTypeArguments.isEmpty()) {\n\t\t\t\t\t//maybe they are not set - check whether type declares some generic parameters\n\t\t\t\t\tList<CtTypeParameter> typeParams;\n\t\t\t\t\tCtType<?> type = typeRef.getTypeDeclaration();\n\t\t\t\t\tif (type != null) {\n\t\t\t\t\t\ttypeParams = type.getFormalCtTypeParameters();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// not in classpath\n\t\t\t\t\t\tif (typeRef.getFactory().getEnvironment().getNoClasspath()) {\n\t\t\t\t\t\t\ttypeParams = Collections.emptyList();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new SpoonClassNotFoundException(typeRef.getQualifiedName() + \" cannot be found in the sourcepath or classpath\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!typeParams.isEmpty()) {\n\t\t\t\t\t\t//yes, there are generic type parameters. Reference should use actualTypeArguments computed from their bounds\n\t\t\t\t\t\tactualTypeArguments = new ArrayList<>(typeParams.size());\n\t\t\t\t\t\tfor (CtTypeParameter typeParam : typeParams) {\n\t\t\t\t\t\t\tactualTypeArguments.add(typeParam.getTypeErasure());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tList<CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(actualTypeArguments);\n\t\t\t\t//Remember actual type arguments of `type`\n\t\t\t\ttypeToArguments.put(superTypeQualifiedName, superTypeActualTypeArgumentsResolvedFromSubType);\n\t\t\t\tif (typeQualifiedName.equals(superTypeQualifiedName)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * we have found actual type arguments of input `type`\n\t\t\t\t\t * We can finish. But only after all interfaces of last visited class are processed too\n\t\t\t\t\t */\n\t\t\t\t\tlistener.foundArguments = superTypeActualTypeArgumentsResolvedFromSubType;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (listener.foundArguments == null) {\n\t\t\t/*\n\t\t\t * superclass was not found. We have scanned whole hierarchy\n\t\t\t */\n\t\t\tlastResolvedSuperclass = null;\n\t\t}\n\t\treturn listener.foundArguments;\n\t}\n\n\t/**\n\t * thisMethod overrides thatMethod if\n\t * 1) thisMethod class is a subclass of thatMethod class\n\t * 2) thisMethod is a subsignature of thatMethod\n\t *\n\t * See http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.8.1\n\t *\n\t * @param thisMethod - the scope method\n\t * @param thatMethod - to be checked method\n\t * @return true if thisMethod overrides thatMethod\n\t */\n\tpublic boolean isOverriding(CtMethod<?> thisMethod, CtMethod<?> thatMethod) {\n\t\tif (thisMethod == thatMethod) {\n\t\t\t//method overrides itself in spoon model\n\t\t\treturn true;\n\t\t}\n\t\tCtType<?> thatDeclType = thatMethod.getDeclaringType();\n\t\tCtType<?> thisDeclType = getAdaptationScope();\n\t\tif (thatDeclType != thisDeclType) {\n\t\t\tif (isSubtypeOf(thatDeclType.getReference()) == false) {\n\t\t\t\t//the declaringType of that method must be superType of this scope type\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t//TODO check method visibility following https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.8.1\n\t\treturn isSubSignature(thisMethod, thatMethod);\n\t}\n\n\t/**\n\t * isSubsignature is defined as an oriented relation between two methods as defined in\n\t * See https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t *\n\t * thisMethod is subsignature of thatMethod if either\n\t * A) thisMethod is same signature like thatMethod\n\t * B) thisMethod is same signature like type erasure of thatMethod\n\t *\n\t * @param thisMethod - the scope method to be checked with\n\t * @param thatMethod - the checked method\n\t * @return true if thisMethod is subsignature of thatMethod\n\t */\n\tpublic boolean isSubSignature(CtMethod<?> thisMethod, CtMethod<?> thatMethod) {\n\t\treturn isSameSignature(thisMethod, thatMethod, true);\n\t}\n\n\t/**\n\t * Two methods are considered as having the same signature if they have the same name and argument types\n\t * See https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t *\n\t * @param thisExecutable - the scope method to be checked with\n\t * @param thatExecutable - the checked method\n\t * @return true if this method and thatMethod has same signature\n\t */\n\tpublic boolean isSameSignature(CtExecutable<?> thisExecutable, CtMethod<?> thatExecutable) {\n\t\tif ((thatExecutable instanceof CtMethod || thatExecutable instanceof CtConstructor) == false) {\n\t\t\t//only method or constructor can have same signature\n\t\t\treturn false;\n\t\t}\n\t\treturn isSameSignature(thisExecutable, thatExecutable, false);\n\t}\n\n\t@Override\n\tpublic ClassTypingContext getEnclosingGenericTypeAdapter() {\n\t\treturn enclosingClassTypingContext;\n\t}\n\n\t/**\n\t * might be used to create custom chain of super type hierarchies\n\t */\n\tprotected ClassTypingContext createEnclosingHierarchy(CtType<?> enclosingType) {\n\t\treturn new ClassTypingContext(enclosingType);\n\t}\n\t/**\n\t * might be used to create custom chain of super type hierarchies\n\t */\n\tprotected ClassTypingContext createEnclosingHierarchy(CtTypeReference<?> enclosingTypeRef) {\n\t\treturn new ClassTypingContext(enclosingTypeRef);\n\t}\n\n\tstatic List<CtTypeReference<?>> getTypeReferences(List<? extends CtType<?>> types) {\n\t\tList<CtTypeReference<?>> refs = new ArrayList<>(types.size());\n\t\tfor (CtType<?> type : types) {\n\t\t\trefs.add(type.getReference());\n\t\t}\n\t\treturn refs;\n\t}\n\n\t/**\n\t * @param type the potential inner class, whose enclosing type should be returned\n\t * @return enclosing type of a `type` is an inner type or null if `type` is explicitly or implicitly static or top level type\n\t */\n\tprivate CtType<?> getEnclosingType(CtType<?> type) {\n\t\tif (type.hasModifier(ModifierKind.STATIC)) {\n\t\t\treturn null;\n\t\t}\n\t\tCtType<?> declType = type.getDeclaringType();\n\t\tif (declType == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (declType.isInterface()) {\n\t\t\t//nested types of interfaces are static\n\t\t\treturn null;\n\t\t}\n\t\treturn declType;\n\t}\n\n\t/**\n\t * @param typeRef the potential inner class, whose enclosing type should be returned\n\t * @return enclosing type of a `type` is an inner type or null if `type` is explicitly or implicitly static or top level type\n\t */\n\tprivate CtTypeReference<?> getEnclosingType(CtTypeReference<?> typeRef) {\n\t\tCtType<?> type = typeRef.getTypeDeclaration();\n\t\tif (type != null) {\n\t\t\tif (type.hasModifier(ModifierKind.STATIC)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tCtType<?> declType = type.getDeclaringType();\n\t\t\tif (declType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (declType.isInterface()) {\n\t\t\t\t//nested types of interfaces are static\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn typeRef.getDeclaringType();\n\t}\n\n\t/**\n\t * adapts `typeParam` to the {@link CtTypeReference}\n\t * of scope of this {@link ClassTypingContext}\n\t * In can be {@link CtTypeParameterReference} again - depending actual type arguments of this {@link ClassTypingContext}.\n\t *\n\t * @param typeParam to be resolved {@link CtTypeParameter}\n\t * @return {@link CtTypeReference} or {@link CtTypeParameterReference} adapted to scope of this {@link ClassTypingContext}\n\t *  or null if `typeParam` cannot be adapted to target `scope`\n\t */\n\t@Override\n\tprotected CtTypeReference<?> adaptTypeParameter(CtTypeParameter typeParam) {\n\t\tif (typeParam == null) {\n\t\t\tthrow new SpoonException(\"You cannot adapt a null type parameter.\");\n\t\t}\n\t\tCtFormalTypeDeclarer declarer = typeParam.getTypeParameterDeclarer();\n\t\tif ((declarer instanceof CtType<?>) == false) {\n\t\t\treturn null;\n\t\t}\n\t\t//get the actual type argument values for the declarer of `typeParam`\n\t\tList<CtTypeReference<?>> actualTypeArguments = resolveActualTypeArgumentsOf(((CtType<?>) declarer).getReference());\n\t\tif (actualTypeArguments == null) {\n\t\t\tif (enclosingClassTypingContext != null) {\n\t\t\t\t//try to adapt parameter using enclosing class typing context\n\t\t\t\treturn enclosingClassTypingContext.adaptType(typeParam);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn getValue(actualTypeArguments, typeParam, declarer);\n\t}\n\n\t/**\n\t * Create visitedSet lazily\n\t */\n\tprivate Set<String> getVisitedSet() {\n\t\tif (visitedSet == null) {\n\t\t\tvisitedSet = new HashSet<>();\n\t\t}\n\t\treturn visitedSet;\n\t}\n\n\t/**\n\t * the listener which assures that\n\t * - each interface of super inheritance hierarchy is visited only once\n\t * - the scanning of super inheritance hierarchy early stops when we have found\n\t */\n\tprivate class HierarchyListener extends SuperInheritanceHierarchyFunction.DistinctTypeListener {\n\t\tList<CtTypeReference<?>> foundArguments;\n\t\tHierarchyListener(Set<String> visitedSet) {\n\t\t\tsuper(visitedSet);\n\t\t}\n\t\t@Override\n\t\tpublic ScanningMode enter(CtTypeReference<?> typeRef, boolean isClass) {\n\t\t\tif (isClass) {\n\t\t\t\t/*\n\t\t\t\t * test foundArguments and skip all before call of super.enter,\n\t\t\t\t * which would add that not visited type into visitedSet\n\t\t\t\t */\n\t\t\t\tif (foundArguments != null) {\n\t\t\t\t\t//we have found result then we can finish before entering super class. All interfaces of found type should be still visited\n\t\t\t\t\t//skip before super class (and its interfaces) of found type is visited\n\t\t\t\t\treturn ScanningMode.SKIP_ALL;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * we are visiting class (not interface)\n\t\t\t\t * Remember that, so we can continue at this place if needed.\n\t\t\t\t * If we enter class, then this listener assures that that class and all it's not yet visited interfaces are visited\n\t\t\t\t */\n\t\t\t\tlastResolvedSuperclass = typeRef;\n\t\t\t}\n\t\t\tScanningMode mode = super.enter(typeRef);\n\t\t\tif (mode == ScanningMode.SKIP_ALL) {\n\t\t\t\t//this interface was already visited. Do not visit it again\n\t\t\t\treturn mode;\n\t\t\t}\n\t\t\t//this type was not visited yet. Visit it normally\n\t\t\treturn ScanningMode.NORMAL;\n\t\t}\n\t}\n\n\t/**\n\t * resolve typeRefs declared in scope of declarer using actual type arguments registered in typeScopeToActualTypeArguments\n\t * @param typeRefs to be resolved type references\n\t * @return resolved type references - one for each `typeRefs`\n\t * @throws SpoonException if they cannot be resolved. It should not normally happen. If it happens then spoon AST model is probably not consistent.\n\t */\n\tprivate List<CtTypeReference<?>> resolveTypeParameters(List<CtTypeReference<?>> typeRefs) {\n\t\tList<CtTypeReference<?>> result = new ArrayList<>(typeRefs.size());\n\t\tfor (CtTypeReference<?> typeRef : typeRefs) {\n\t\t\tif (typeRef instanceof CtTypeParameterReference) {\n\t\t\t\tCtTypeParameterReference typeParamRef = (CtTypeParameterReference) typeRef;\n\t\t\t\tCtTypeParameter typeParam = typeParamRef.getDeclaration();\n\t\t\t\tif (typeParam == null) {\n\t\t\t\t\tthrow new SpoonException(\"The typeParam \" + typeRef.getQualifiedName() + \" declaration cannot be resolved\");\n\t\t\t\t}\n\t\t\t\tCtFormalTypeDeclarer declarer = typeParam.getTypeParameterDeclarer();\n\t\t\t\ttypeRef = resolveTypeParameter(declarer, typeParamRef, typeParam, typeRef);\n\t\t\t}\n\t\t\tresult.add(typeRef);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate CtTypeReference<?> resolveTypeParameter(CtFormalTypeDeclarer declarer, CtTypeParameterReference typeParamRef, CtTypeParameter typeParam, CtTypeReference<?> typeRef) {\n\t\tif ((declarer instanceof CtType<?>) == false) {\n\t\t\t/*\n\t\t\t * The declarer is probably out of the scope of this ClassTypingContext.\n\t\t\t * For example outer class or method declares type parameter,\n\t\t\t * which is then used as argument in inner class, whose ClassTypingContext we have now\n\t\t\t * See GenericsTest#testCannotAdaptTypeOfNonTypeScope.\n\t\t\t *\n\t\t\t * Use that outer type parameter reference directly without adaptation\n\t\t\t */\n\t\t\treturn typeRef;\n\t\t}\n\t\tCtType<?> typeDeclarer = (CtType<?>) declarer;\n\t\tList<CtTypeReference<?>> actualTypeArguments = getActualTypeArguments(typeDeclarer.getQualifiedName());\n\t\tif (actualTypeArguments == null) {\n\t\t\t/*\n\t\t\t * The declarer is probably out of the scope of this ClassTypingContext.\n\t\t\t * For example outer class or method declares type parameter,\n\t\t\t * which is then used as argument in inner class, whose ClassTypingContext we have now\n\t\t\t * See GenericsTest#testCannotAdaptTypeOfNonTypeScope.\n\t\t\t *\n\t\t\t * Use that outer type parameter reference directly without adaptation\n\t\t\t */\n\t\t\treturn typeRef;\n\t\t}\n\t\tif (actualTypeArguments.size() != typeDeclarer.getFormalCtTypeParameters().size()) {\n\t\t\tif (actualTypeArguments.isEmpty() == false) {\n\t\t\t\tthrow new SpoonException(\"Unexpected actual type arguments \" + actualTypeArguments + \" on \" + typeDeclarer);\n\t\t\t}\n\t\t\t/*\n\t\t\t * the scope type was delivered as type reference without appropriate type arguments.\n\t\t\t * Use references to formal type parameters\n\t\t\t */\n\t\t\tactualTypeArguments = getTypeReferences(typeDeclarer.getFormalCtTypeParameters());\n\t\t\ttypeToArguments.put(typeDeclarer.getQualifiedName(), actualTypeArguments);\n\t\t}\n\t\treturn getValue(actualTypeArguments, typeParam, declarer);\n\t}\n\n\tprivate List<CtTypeReference<?>> getActualTypeArguments(String qualifiedName) {\n\t\tList<CtTypeReference<?>> actualTypeArguments = typeToArguments.get(qualifiedName);\n\t\tif (actualTypeArguments != null) {\n\t\t\treturn actualTypeArguments;\n\t\t}\n\t\tif (enclosingClassTypingContext != null) {\n\t\t\treturn enclosingClassTypingContext.getActualTypeArguments(qualifiedName);\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static CtTypeReference<?> getValue(List<CtTypeReference<?>> arguments, CtTypeParameter typeParam, CtFormalTypeDeclarer declarer) {\n\t\tif (declarer.getFormalCtTypeParameters().size() != arguments.size()) {\n\t\t\tthrow new SpoonException(\"Unexpected count of actual type arguments\");\n\t\t}\n\t\tint typeParamIdx = declarer.getFormalCtTypeParameters().indexOf(typeParam);\n\t\treturn arguments.get(typeParamIdx);\n\t}\n\n\t/**\n\t * Substitutes the typeParameter by its value\n\t * @param typeParameter - to be substituted parameter\n\t * @param declarer - the declarer of typeParameter\n\t * @param values - the list of parameter values\n\t * @return the value from values on the same position as typeParameter in declarer.getFormalCtTypeParameters()\n\t */\n\tstatic <T, U extends List<T>> T substituteBy(CtTypeParameter typeParameter, CtFormalTypeDeclarer declarer, U values) {\n\t\tList<CtTypeParameter> typeParams = declarer.getFormalCtTypeParameters();\n\t\tint position = typeParams.indexOf(typeParameter);\n\t\tif (position == -1) {\n\t\t\tthrow new SpoonException(\"Type parameter <\" + typeParameter.getSimpleName() + \" not found in scope \" + declarer.getShortRepresentation());\n\t\t}\n\t\tif (values.size() != typeParams.size()) {\n\t\t\tthrow new SpoonException(\"Unexpected count of parameters\");\n\t\t}\n\t\treturn values.get(position);\n\t}\n\n\t/**\n\t * @return true if actualType arguments of `scope` are fitting as a subtype of superTypeArgs\n\t */\n\tprivate boolean isSubTypeByActualTypeArguments(CtTypeReference<?> superTypeRef, List<CtTypeReference<?>> expectedSuperTypeArguments) {\n\t\tList<CtTypeReference<?>> superTypeArgs = superTypeRef.getActualTypeArguments();\n\t\tif (superTypeArgs.isEmpty()) {\n\t\t\t//the raw type or not a generic type. Arguments are ignored in subtype detection\n\t\t\treturn true;\n\t\t}\n\t\tList<CtTypeReference<?>> subTypeArgs = expectedSuperTypeArguments;\n\t\tif (subTypeArgs.isEmpty()) {\n\t\t\t//the raw type or not a generic type\n\t\t\treturn true;\n\t\t}\n\t\tif (subTypeArgs.size() != superTypeArgs.size()) {\n\t\t\t//the number of arguments is not same - it should not happen ...\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < subTypeArgs.size(); i++) {\n\t\t\tCtTypeReference<?> superArg = superTypeArgs.get(i);\n\t\t\tCtTypeReference<?> subArg = subTypeArgs.get(i);\n\t\t\tif (isSubTypeArg(subArg, superArg) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return true if actualType argument `subArg` is fitting as a subtype of actual type argument `superArg`\n\t */\n\tprivate boolean isSubTypeArg(CtTypeReference<?> subArg, CtTypeReference<?> superArg) {\n\t\tif (superArg instanceof CtWildcardReference) {\n\t\t\tCtWildcardReference wr = (CtWildcardReference) superArg;\n\t\t\tCtTypeReference<?> superBound = wr.getBoundingType();\n\t\t\tif (superBound.equals(wr.getFactory().Type().OBJECT)) {\n\t\t\t\t//everything extends from object, nothing is super of Object\n\t\t\t\treturn wr.isUpper();\n\t\t\t}\n\t\t\tif (subArg instanceof CtWildcardReference) {\n\t\t\t\tCtWildcardReference subWr = (CtWildcardReference) subArg;\n\t\t\t\tCtTypeReference<?> subBound = subWr.getBoundingType();\n\t\t\t\tif (subBound.equals(wr.getFactory().Type().OBJECT)) {\n\t\t\t\t\t//nothing is super of object\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (wr.isUpper() != subWr.isUpper()) {\n\t\t\t\t\t//one is \"super\" second is \"extends\"\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (wr.isUpper()) {\n\t\t\t\t\t//both are extends\n\t\t\t\t\treturn subBound.isSubtypeOf(superBound);\n\t\t\t\t}\n\t\t\t\t//both are super\n\t\t\t\treturn superBound.isSubtypeOf(subBound);\n\t\t\t}\n\t\t\tif (wr.isUpper()) {\n\t\t\t\treturn subArg.isSubtypeOf(superBound);\n\t\t\t} else {\n\t\t\t\treturn superBound.isSubtypeOf(subArg);\n\t\t\t}\n\t\t}\n\t\t//superArg is not a wildcard. Only same type is matching\n\t\treturn subArg.equals(superArg);\n\t}\n\n\tprivate boolean isSameSignature(CtExecutable<?> thisMethod, CtExecutable<?> thatMethod, boolean canTypeErasure) {\n\t\tif (thisMethod == thatMethod) {\n\t\t\treturn true;\n\t\t}\n\t\tExecutableContext mtc = new ExecutableContext();\n\t\tmtc.setClassTypingContext(this);\n\n\t\tif (thisMethod instanceof CtMethod) {\n\t\t\tif (thatMethod instanceof CtMethod) {\n\t\t\t\tmtc.setMethod((CtMethod<?>) thisMethod);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (thisMethod instanceof CtConstructor) {\n\t\t\tif (thatMethod instanceof CtConstructor) {\n\t\t\t\tmtc.setConstructor((CtConstructor<?>) thisMethod);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\t//only method or constructor can compare signatures\n\t\t\treturn false;\n\t\t}\n\t\treturn mtc.isSameSignatureLikeScopeMethod(thatMethod, canTypeErasure);\n\t}\n\n\tprivate static class ExecutableContext extends MethodTypingContext {\n\t\tprivate boolean isSameSignatureLikeScopeMethod(CtExecutable<?> thatExecutable, boolean canTypeErasure) {\n\t\t\t//https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2\n\t\t\tCtFormalTypeDeclarer thatDeclarer = (CtFormalTypeDeclarer) thatExecutable;\n\t\t\tCtFormalTypeDeclarer thisDeclarer = getAdaptationScope();\n\t\t\tCtExecutable<?> thisExecutable = (CtExecutable<?>) thisDeclarer;\n\t\t\tif (thatExecutable.getSimpleName().equals(thisExecutable.getSimpleName()) == false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (thisExecutable.getParameters().size() != thatExecutable.getParameters().size()) {\n\t\t\t\t//the executables have different count of parameters they cannot have same signature\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList<CtTypeParameter> thisTypeParameters = thisDeclarer.getFormalCtTypeParameters();\n\t\t\tList<CtTypeParameter> thatTypeParameters = thatDeclarer.getFormalCtTypeParameters();\n\t\t\tboolean useTypeErasure = false;\n\t\t\tif (thisTypeParameters.size() == thatTypeParameters.size()) {\n\t\t\t\t//the methods have same count of formal parameters\n\t\t\t\t//check that formal type parameters are same\n\t\t\t\tif (hasSameMethodFormalTypeParameters((CtFormalTypeDeclarer) thatExecutable) == false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//the methods have different count of formal type parameters.\n\t\t\t\tif (canTypeErasure == false) {\n\t\t\t\t\t//type erasure is not allowed. So non-generic methods cannot match with generic methods\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//non-generic method can override a generic one if type erasure is allowed\n\t\t\t\tif (thisTypeParameters.isEmpty() == false) {\n\t\t\t\t\t//scope method has some parameters. It is generic too, it is not a subsignature of that method\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//scope method has zero formal type parameters. It is not generic.\n\t\t\t\tuseTypeErasure = true;\n\t\t\t}\n\t\t\tList<CtTypeReference<?>> thisParameterTypes = getParameterTypes(thisExecutable.getParameters());\n\t\t\tList<CtTypeReference<?>> thatParameterTypes = getParameterTypes(thatExecutable.getParameters());\n\t\t\t//check that parameters are same after adapting to the same scope\n\t\t\tfor (int i = 0; i < thisParameterTypes.size(); i++) {\n\t\t\t\tCtTypeReference<?> thisType = thisParameterTypes.get(i);\n\t\t\t\tCtTypeReference<?> thatType = thatParameterTypes.get(i);\n\t\t\t\tif (useTypeErasure) {\n\t\t\t\t\tif (thatType instanceof CtTypeParameterReference) {\n\t\t\t\t\t\tthatType = ((CtTypeParameterReference) thatType).getTypeErasure();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthatType = adaptType(thatType);\n\t\t\t\t}\n\t\t\t\tif (thatType == null) {\n\t\t\t\t\t//the type cannot be adapted.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// we can be in a case where thisType is CtType and thatType is CtType<?>\n\t\t\t\t// the types are not equals but it's overridden\n\t\t\t\t// in that specific case we simply remove the list of actualTypeArguments from thatType\n\t\t\t\tif (thisType.getActualTypeArguments().isEmpty() && thatType.getActualTypeArguments().size() == 1) {\n\t\t\t\t\tCtTypeReference actualTA = thatType.getActualTypeArguments().get(0);\n\t\t\t\t\tif (actualTA instanceof CtWildcardReference) {\n\t\t\t\t\t\tCtWildcardReference wildcardReference = (CtWildcardReference) actualTA;\n\t\t\t\t\t\tif (wildcardReference.isDefaultBoundingType()) {\n\t\t\t\t\t\t\tthatType.setActualTypeArguments(Collections.EMPTY_LIST);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (thisType.equals(thatType) == false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate static List<CtTypeReference<?>> getParameterTypes(List<CtParameter<?>> params) {\n\t\t\tList<CtTypeReference<?>> types = new ArrayList<>(params.size());\n\t\t\tfor (CtParameter<?> param : params) {\n\t\t\t\ttypes.add(param.getType());\n\t\t\t}\n\t\t\treturn types;\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "support/visitor/AbstractTypingContext.java",
      "weight" : 61.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support.visitor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeInformation;\nimport spoon.reflect.declaration.CtTypeParameter;\nimport spoon.reflect.reference.CtTypeParameterReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.reference.CtWildcardReference;\n\n/**\n * Implements common adapting algorithm of {@link ClassTypingContext} and {@link MethodTypingContext}\n */\nabstract class AbstractTypingContext implements GenericTypeAdapter {\n\n\tprotected AbstractTypingContext() {\n\t}\n\n\t@Override\n\tpublic CtTypeReference<?> adaptType(CtTypeInformation type) {\n\t\tCtTypeReference<?> result;\n\t\tboolean isCopy = false;\n\t\tif (type instanceof CtTypeReference<?>) {\n\t\t\tif (type instanceof CtTypeParameterReference) {\n\t\t\t\treturn adaptTypeParameterReference((CtTypeParameterReference) type);\n\t\t\t}\n\t\t\tresult = (CtTypeReference<?>) type;\n\t\t} else {\n\t\t\tif (type instanceof CtTypeParameter) {\n\t\t\t\treturn adaptTypeParameter((CtTypeParameter) type);\n\t\t\t}\n\t\t\tCtType<?> t = (CtType<?>) type;\n\t\t\tresult = t.getFactory().Type().createReference(t, true);\n\t\t\tisCopy = true;\n\t\t}\n\t\tif (!result.getActualTypeArguments().isEmpty()) {\n\t\t\t//we have to adapt actual type arguments recursive too\n\t\t\tif (isCopy == false) {\n\t\t\t\tCtElement parent = result.getParent();\n\t\t\t\tresult = result.clone();\n\t\t\t\tresult.setParent(parent);\n\t\t\t\tList<CtTypeReference<?>> actTypeArgs = new ArrayList<>(result.getActualTypeArguments());\n\t\t\t\tfor (int i = 0; i < actTypeArgs.size(); i++) {\n\t\t\t\t\tCtTypeReference adaptedTypeArgs = adaptType(actTypeArgs.get(i));\n\t\t\t\t\t// for some type argument we might return null to avoid recursive calls\n\t\t\t\t\tif (adaptedTypeArgs != null) {\n\t\t\t\t\t\tactTypeArgs.set(i, adaptedTypeArgs.clone());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.setActualTypeArguments(actTypeArgs);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate CtTypeReference<?> adaptTypeParameterReference(CtTypeParameterReference typeParamRef) {\n\t\tif ((typeParamRef instanceof CtWildcardReference)) {\n\t\t\treturn adaptTypeParameterReferenceBoundingType((CtWildcardReference) typeParamRef, typeParamRef.getBoundingType());\n\t\t}\n\t\treturn adaptTypeParameter(typeParamRef.getDeclaration());\n\t}\n\n\tprivate CtTypeReference<?> adaptTypeParameterReferenceBoundingType(CtWildcardReference typeParamRef, CtTypeReference<?> boundingType) {\n\t\tCtWildcardReference typeParamRefAdapted = typeParamRef.clone();\n\t\ttypeParamRefAdapted.setParent(typeParamRef.getParent());\n\t\ttypeParamRefAdapted.setBoundingType(boundingType.equals(boundingType.getFactory().Type().getDefaultBoundingType()) ? boundingType.getFactory().Type().getDefaultBoundingType() : adaptType(boundingType));\n\t\treturn typeParamRefAdapted;\n\t}\n\n\t/**\n\t * adapts `typeParam` to the {@link CtTypeReference}\n\t * of scope of this {@link GenericTypeAdapter}\n\t * In can be {@link CtTypeParameterReference} again - depending actual type arguments of this {@link GenericTypeAdapter}.\n\t *\n\t * @param typeParam to be resolved {@link CtTypeParameter}\n\t * @return {@link CtTypeReference} or {@link CtTypeParameterReference} adapted to scope of this {@link GenericTypeAdapter}\n\t *  or null if `typeParam` cannot be adapted to target `scope`\n\t */\n\tprotected abstract CtTypeReference<?> adaptTypeParameter(CtTypeParameter typeParam);\n}\n"
    }, {
      "name" : "support/Internal.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.support;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Tells that a class or method is not in the public API (even if it has Java visibility \"public\")\n * Required because package-visibility is too coarse-grained.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, ElementType.TYPE })\npublic @interface Internal {\n}\n"
    } ]
  }, {
    "name" : "template",
    "children" : [ {
      "name" : "template/Substitution.java",
      "weight" : 305.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.SpoonException;\nimport spoon.pattern.PatternBuilder;\nimport spoon.processing.FactoryAccessor;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtAnonymousExecutable;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtConstructor;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtExecutable;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtInterface;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtPackageReference;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.reflect.visitor.Query;\nimport spoon.reflect.visitor.filter.ReferenceTypeFilter;\nimport spoon.support.template.Parameters;\n\nimport java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This class defines the substitution API for templates (see {@link Template}).\n */\npublic abstract class Substitution {\n\n\tprivate Substitution() {\n\t}\n\n\t/**\n\t * Inserts all the methods, fields, constructors, initialization blocks (if\n\t * target is a class), inner types, and super interfaces (except\n\t * {@link Template}) from a given template by substituting all the template\n\t * parameters by their values. Members annotated with\n\t * {@link spoon.template.Local} or {@link Parameter} are not inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static <T extends Template<?>> void insertAll(CtType<?> targetType, T template) {\n\n\t\tCtClass<T> templateClass = getTemplateCtClass(targetType, template);\n\t\t// insert all the interfaces\n\t\tinsertAllSuperInterfaces(targetType, template);\n\t\t// insert all the methods\n\t\tinsertAllMethods(targetType, template);\n\t\t// insert all the constructors and all the initialization blocks (only for classes)\n\t\tinsertAllConstructors(targetType, template);\n\t\tfor (CtTypeMember typeMember : templateClass.getTypeMembers()) {\n\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\t// insert all the fields\n\t\t\t\tinsertGeneratedField(targetType, template, (CtField<?>) typeMember);\n\t\t\t} else if (typeMember instanceof CtType) {\n\t\t\t\t// insert all the inner types\n\t\t\t\tinsertGeneratedNestedType(targetType, template, (CtType) typeMember);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generates a type (class, interface, enum, ...) from the template model `templateOfType`\n\t * by by substituting all the template parameters by their values.\n\t *\n\t * Inserts all the methods, fields, constructors, initialization blocks (if\n\t * target is a class), inner types, super class and super interfaces.\n\t *\n\t * Note!\n\t * This algorithm does NOT handle interfaces or annotations\n\t * {@link Template}, {@link spoon.template.Local}, {@link TemplateParameter} or {@link Parameter}\n\t * in a special way, it means they all will be added to the generated type too.\n\t * If you do not want to add them then clone your templateOfType and remove these nodes from that model before.\n\t *\n\t * @param qualifiedTypeName\n\t * \t\tthe qualified name of the new type\n\t * @param templateOfType\n\t * \t\tthe model used as source of generation.\n\t * @param templateParameters\n\t * \t\tthe substitution parameters\n\t */\n\tpublic static <T extends CtType<?>> T createTypeFromTemplate(String qualifiedTypeName, CtType<?> templateOfType, Map<String, Object> templateParameters) {\n\t\treturn PatternBuilder\n\t\t\t\t.create(templateOfType)\n\t\t\t\t.configurePatternParameters(pc -> {\n\t\t\t\t\tpc.byTemplateParameter(templateParameters);\n\t\t\t\t\tpc.byParameterValues(templateParameters);\n\t\t\t\t})\n\t\t\t\t.build()\n\t\t\t\t.generator()\n\t\t\t\t.generateType(qualifiedTypeName, templateParameters);\n\t}\n\n\t/**\n\t * Inserts all the super interfaces (except {@link Template}) from a given\n\t * template by substituting all the template parameters by their values.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static void insertAllSuperInterfaces(CtType<?> targetType, Template<?> template) {\n\n\t\tCtClass<? extends Template<?>> sourceClass = getTemplateCtClass(targetType, template);\n\t\tinsertAllSuperInterfaces(targetType, template, sourceClass);\n\t}\n\t/**\n\t * Inserts all the super interfaces (except {@link Template}) from a given\n\t * template by substituting all the template parameters by their values.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t * @param sourceClass\n\t * \t\tthe model of source template\n\t */\n\tstatic void insertAllSuperInterfaces(CtType<?> targetType, Template<?> template, CtClass<? extends Template<?>> sourceClass) {\n\n\t\t// insert all the interfaces\n\t\tfor (CtTypeReference<?> t : sourceClass.getSuperInterfaces()) {\n\t\t\tif (!t.equals(targetType.getFactory().Type().createReference(Template.class))) {\n\t\t\t\tCtTypeReference<?> t1 = t;\n\t\t\t\t// substitute ref if needed\n\t\t\t\tif (Parameters.getNames(sourceClass).contains(t.getSimpleName())) {\n\t\t\t\t\tObject o = Parameters.getValue(template, t.getSimpleName(), null);\n\t\t\t\t\tif (o instanceof CtTypeReference) {\n\t\t\t\t\t\tt1 = (CtTypeReference<?>) o;\n\t\t\t\t\t} else if (o instanceof Class) {\n\t\t\t\t\t\tt1 = targetType.getFactory().Type().createReference((Class<?>) o);\n\t\t\t\t\t} else if (o instanceof String) {\n\t\t\t\t\t\tt1 = targetType.getFactory().Type().createReference((String) o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!t1.equals(targetType.getReference())) {\n\t\t\t\t\tClass<?> c = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tc = t1.getActualClass();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t// swallow it\n\t\t\t\t\t}\n\t\t\t\t\tif (c != null && c.isInterface()) {\n\t\t\t\t\t\ttargetType.addSuperInterface(t1);\n\t\t\t\t\t}\n\t\t\t\t\tif (c == null) {\n\t\t\t\t\t\ttargetType.addSuperInterface(t1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Inserts all the methods from a given template by substituting all the\n\t * template parameters by their values. Members annotated with\n\t * {@link spoon.template.Local} or {@link Parameter} are not inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static void insertAllMethods(CtType<?> targetType, Template<?> template) {\n\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetType, template);\n\t\tinsertAllMethods(targetType, template, sourceClass);\n\t}\n\t/**\n\t * Inserts all the methods from a given template by substituting all the\n\t * template parameters by their values. Members annotated with\n\t * {@link spoon.template.Local} or {@link Parameter} are not inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t * @param sourceClass\n\t * \t\tthe model of source template\n\t */\n\tstatic void insertAllMethods(CtType<?> targetType, Template<?> template, CtClass<?> sourceClass) {\n\t\tSet<CtMethod<?>> methodsOfTemplate = sourceClass.getFactory().Type().get(Template.class).getMethods();\n\t\t// insert all the methods\n\t\tfor (CtMethod<?> m : sourceClass.getMethods()) {\n\t\t\tif (m.getAnnotation(Local.class) != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (m.getAnnotation(Parameter.class) != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean isOverridingTemplateItf = false;\n\t\t\tfor (CtMethod m2 : methodsOfTemplate) {\n\t\t\t\tif (m.isOverriding(m2)) {\n\t\t\t\t\tisOverridingTemplateItf = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isOverridingTemplateItf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinsertMethod(targetType, template, m);\n\t\t}\n\t}\n\n\t/**\n\t * Inserts all the fields from a given template by substituting all the\n\t * template parameters by their values. Members annotated with\n\t * {@link spoon.template.Local} or {@link Parameter} are not inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static void insertAllFields(CtType<?> targetType, Template<?> template) {\n\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetType, template);\n\t\t// insert all the fields\n\t\tfor (CtTypeMember typeMember: sourceClass.getTypeMembers()) {\n\t\t\tif (typeMember instanceof CtField) {\n\t\t\t\tinsertGeneratedField(targetType, template, (CtField<?>) typeMember);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Inserts the field by substituting all the\n\t * template parameters by their values. Field annotated with\n\t * {@link spoon.template.Local} or {@link Parameter} is not inserted.\n\n\t * @param targetType\n\t * @param template\n\t * @param field\n\t */\n\tstatic void insertGeneratedField(CtType<?> targetType, Template<?> template, CtField<?> field) {\n\n\t\tif (field.getAnnotation(Local.class) != null) {\n\t\t\treturn;\n\t\t}\n\t\tif (Parameters.isParameterSource(field.getReference())) {\n\t\t\treturn;\n\t\t}\n\n\t\tinsertField(targetType, template, field);\n\t}\n\n\t/**\n\t * Inserts all the nested types from a given template by substituting all the\n\t * template parameters by their values. Members annotated with\n\t * {@link spoon.template.Local} are not inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static void insertAllNestedTypes(CtType<?> targetType, Template<?> template) {\n\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetType, template);\n\t\t// insert all the fields\n\t\tfor (CtTypeMember typeMember: sourceClass.getTypeMembers()) {\n\t\t\tif (typeMember instanceof CtType) {\n\t\t\t\tinsertGeneratedNestedType(targetType, template, (CtType<?>) typeMember);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Inserts the nestedType by substituting all the\n\t * template parameters by their values. Nested type annotated with\n\t * {@link spoon.template.Local} is not inserted.\n\t *  @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t * @param nestedType\n * \t\tto be insterted nested type\n\t */\n\tstatic void insertGeneratedNestedType(CtType<?> targetType, Template<?> template, CtType<?> nestedType) {\n\n\t\tif (nestedType.getAnnotation(Local.class) != null) {\n\t\t\treturn;\n\t\t}\n\t\tCtType<?> result = substitute(targetType, template, (CtType) nestedType);\n\t\ttargetType.addNestedType(result);\n\t}\n\n\t/**\n\t * Inserts all constructors and initialization blocks from a given template\n\t * by substituting all the template parameters by their values. Members\n\t * annotated with {@link spoon.template.Local} or {@link Parameter} are not\n\t * inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t */\n\tpublic static void insertAllConstructors(CtType<?> targetType, Template<?> template) {\n\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetType, template);\n\t\tinsertAllConstructors(targetType, template, sourceClass);\n\t}\n\t/**\n\t * Inserts all constructors and initialization blocks from a given template\n\t * by substituting all the template parameters by their values. Members\n\t * annotated with {@link spoon.template.Local} or {@link Parameter} are not\n\t * inserted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe source template\n\t * @param sourceClass\n\t * \t\tthe model of source template\n\t */\n\tstatic void insertAllConstructors(CtType<?> targetType, Template<?> template, CtClass<?> sourceClass) {\n\n\t\t// insert all the constructors\n\t\tif (targetType instanceof CtClass) {\n\t\t\tfor (CtConstructor<?> c : sourceClass.getConstructors()) {\n\t\t\t\tif (c.isImplicit()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c.getAnnotation(Local.class) != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tinsertConstructor((CtClass<?>) targetType, template, c);\n\t\t\t}\n\t\t}\n\t\t// insert all the initialization blocks (only for classes)\n\t\tif (targetType instanceof CtClass) {\n\t\t\tfor (CtAnonymousExecutable e : sourceClass.getAnonymousExecutables()) {\n\t\t\t\t((CtClass<?>) targetType).addAnonymousExecutable(substitute(targetType, template, e));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generates a constructor from a template method by substituting all the\n\t * template parameters by their values.\n\t *\n\t * @param targetClass\n\t * \t\tthe target class where to insert the generated constructor\n\t * @param template\n\t * \t\tthe template instance that holds the source template method\n\t * \t\tand that defines the parameter values\n\t * @param sourceMethod\n\t * \t\tthe source template method\n\t * @return the generated method\n\t */\n\tpublic static <T> CtConstructor<T> insertConstructor(CtClass<T> targetClass, Template<?> template, CtMethod<?> sourceMethod) {\n\n\t\tif (targetClass instanceof CtInterface) {\n\t\t\treturn null;\n\t\t}\n\t\tCtConstructor<T> newConstructor = targetClass.getFactory().Constructor().create(targetClass, sourceMethod);\n\t\tnewConstructor = substitute(targetClass, template, newConstructor);\n\t\ttargetClass.addConstructor(newConstructor);\n\t\treturn newConstructor;\n\t}\n\n\t/**\n\t * Generates a method from a template method by substituting all the\n\t * template parameters by their values.\n\t *\n\t * @param targetType\n\t * \t\tthe target type where to insert the generated method\n\t * @param template\n\t * \t\tthe template instance that holds the source template method\n\t * \t\tand that defines the parameter values\n\t * @param sourceMethod\n\t * \t\tthe source template method\n\t * @return the generated method\n\t */\n\tpublic static <T> CtMethod<T> insertMethod(CtType<?> targetType, Template<?> template, CtMethod<T> sourceMethod) {\n\n\t\tCtMethod<T> newMethod = substitute(targetType, template, sourceMethod);\n\t\tif (targetType instanceof CtInterface) {\n\t\t\tnewMethod.setBody(null);\n\t\t}\n\t\ttargetType.addMethod(newMethod);\n\t\treturn newMethod;\n\t}\n\n\t/**\n\t * Generates a constructor from a template constructor by substituting all\n\t * the template parameters by their values.\n\t *\n\t * @param targetClass\n\t * \t\tthe target class where to insert the generated constructor\n\t * @param template\n\t * \t\tthe template instance that holds the source template\n\t * \t\tconstructor and that defines the parameter values\n\t * @param sourceConstructor\n\t * \t\tthe source template constructor\n\t * @return the generated constructor\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> CtConstructor<T> insertConstructor(CtClass<T> targetClass, Template<?> template, CtConstructor<?> sourceConstructor) {\n\n\t\tCtConstructor<T> newConstrutor = substitute(targetClass, template, (CtConstructor<T>) sourceConstructor);\n\t\t// remove the implicit constructor if clashing\n\t\tif (newConstrutor.getParameters().isEmpty()) {\n\t\t\tCtConstructor<?> c = targetClass.getConstructor();\n\t\t\tif (c != null && c.isImplicit()) {\n\t\t\t\ttargetClass.removeConstructor((CtConstructor<T>) c);\n\t\t\t}\n\t\t}\n\t\ttargetClass.addConstructor(newConstrutor);\n\t\treturn newConstrutor;\n\t}\n\n\t/**\n\t * Gets a body from a template executable with all the template parameters\n\t * substituted.\n\t *\n\t * @param targetClass\n\t * \t\tthe target class\n\t * @param template\n\t * \t\tthe template that holds the executable\n\t * @param executableName\n\t * \t\tthe source executable template\n\t * @param parameterTypes\n\t * \t\tthe parameter types of the source executable\n\t * @return the body expression of the source executable template with all\n\t * the template parameters substituted\n\t */\n\tpublic static CtBlock<?> substituteMethodBody(CtClass<?> targetClass, Template<?> template, String executableName, CtTypeReference<?>... parameterTypes) {\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetClass, template);\n\t\tCtExecutable<?> sourceExecutable = executableName.equals(template.getClass().getSimpleName())\n\t\t\t\t? sourceClass.getConstructor(parameterTypes)\n\t\t\t\t: sourceClass.getMethod(executableName, parameterTypes);\n\t\treturn substitute(targetClass, template, sourceExecutable.getBody());\n\t}\n\n\t/**\n\t * Gets a statement from a template executable with all the template\n\t * parameters substituted.\n\t *\n\t * @param targetClass\n\t * \t\tthe target class\n\t * @param template\n\t * \t\tthe template that holds the executable\n\t * @param statementIndex\n\t * \t\tthe statement index in the executable's body\n\t * @param executableName\n\t * \t\tthe source executable template\n\t * @param parameterTypes\n\t * \t\tthe parameter types of the source executable\n\t * @return the body expression of the source executable template with all\n\t * the template parameters substituted\n\t */\n\tpublic static CtStatement substituteStatement(CtClass<?> targetClass, Template<?> template, int statementIndex, String executableName, CtTypeReference<?>... parameterTypes) {\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetClass, template);\n\t\tCtExecutable<?> sourceExecutable = executableName.equals(template.getClass().getSimpleName())\n\t\t\t\t? sourceClass.getConstructor(parameterTypes)\n\t\t\t\t: sourceClass.getMethod(executableName, parameterTypes);\n\t\treturn substitute(targetClass, template, sourceExecutable.getBody().getStatement(statementIndex));\n\t}\n\n\t/**\n\t * Gets a default expression from a template field with all the template\n\t * parameters substituted.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe template that holds the field\n\t * @param fieldName\n\t * \t\tthe template source field\n\t * @return the expression of the template source field with all the template\n\t * parameters substituted\n\t */\n\n\tpublic static CtExpression<?> substituteFieldDefaultExpression(CtType<?> targetType, Template<?> template, String fieldName) {\n\t\tCtClass<?> sourceClass = getTemplateCtClass(targetType, template);\n\t\tCtField<?> sourceField = sourceClass.getField(fieldName);\n\t\treturn substitute(targetType, template, sourceField.getDefaultExpression());\n\t}\n\n\t/**\n\t * Substitutes all the template parameters in a random piece of code.\n\t *\n\t * @param targetType\n\t * \t\tthe target type\n\t * @param template\n\t * \t\tthe template instance\n\t * @param code\n\t * \t\tthe code\n\t * @return the code where all the template parameters has been substituted\n\t * by their values\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <E extends CtElement> E substitute(CtType<?> targetType, Template<?> template, E code) {\n\t\tif (code == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (targetType == null) {\n\t\t\tthrow new RuntimeException(\"target is null in substitution\");\n\t\t}\n\t\tTemplateBuilder tb = TemplateBuilder.createPattern(code, template);\n\t\tif (template instanceof AbstractTemplate) {\n\t\t\ttb.setAddGeneratedBy(((AbstractTemplate) template).isAddGeneratedBy());\n\t\t}\n\t\treturn (E) tb.substituteSingle(targetType, CtElement.class);\n\t}\n\n\t/**\n\t * Substitutes all the template parameters in a given template type and\n\t * returns the resulting type.\n\t *\n\t * @param template\n\t * \t\tthe template instance (holds the parameter values)\n\t * @param templateType\n\t * \t\tthe template type\n\t * @return a copy of the template type where all the parameters has been\n\t * substituted\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T extends CtType<?>> T substitute(Template<?> template, T templateType) {\n\t\t// result.setParent(templateType.getParent());\n\t\tCtType<?> result = TemplateBuilder.createPattern(templateType, template).substituteSingle(null, CtType.class);\n\t\t//TODO check if it is still needed\n\t\tresult.setPositions(null);\n\t\treturn (T) result;\n\t}\n\n\t/**\n\t * Generates a field (and its initialization expression) from a template\n\t * field by substituting all the template parameters by their values.\n\t *\n\t * @param <T>\n\t * \t\tthe type of the field\n\t * @param targetType\n\t * \t\tthe target type where the field is inserted\n\t * @param template\n\t * \t\tthe template that defines the source template field\n\t * @param sourceField\n\t * \t\tthe source template field\n\t * @return the inserted field\n\t */\n\tpublic static <T> CtField<T> insertField(CtType<?> targetType, Template<?> template, CtField<T> sourceField) {\n\t\tCtField<T> field = substitute(targetType, template, sourceField);\n\t\ttargetType.addField(field);\n\t\treturn field;\n\t}\n\n\t/**\n\t * A helper method that recursively redirects all the type references from a\n\t * source type to a target type in the given element.\n\t */\n\tpublic static void redirectTypeReferences(CtElement element, CtTypeReference<?> source, CtTypeReference<?> target) {\n\n\t\tList<CtTypeReference<?>> refs = Query.getReferences(element, new ReferenceTypeFilter<>(CtTypeReference.class));\n\n\t\tString srcName = source.getQualifiedName();\n\t\tString targetName = target.getSimpleName();\n\t\tCtPackageReference targetPackage = target.getPackage();\n\n\t\tfor (CtTypeReference<?> ref : refs) {\n\t\t\tif (ref.getQualifiedName().equals(srcName)) {\n\t\t\t\tref.setSimpleName(targetName);\n\t\t\t\tref.setPackage(targetPackage);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param targetType - the element which is going to receive the model produced by the template.\n\t * It is needed here just to provide the spoon factory, which contains the model of the template\n\t *\n\t * @param template - java instance of the template\n\t *\n\t * @return - CtClass from the already built spoon model, which represents the template\n\t */\n\tstatic <T> CtClass<T> getTemplateCtClass(CtType<?> targetType, Template<?> template) {\n\t\tFactory factory;\n\t\t// we first need a factory\n\t\tif (targetType != null) {\n\t\t\t// if it's template with reference replacement\n\t\t\tfactory = targetType.getFactory();\n\t\t} else {\n\t\t\t// else we have at least one template parameter with a factory\n\t\t\tfactory = getFactory(template);\n\t\t}\n\t\treturn getTemplateCtClass(factory, template);\n\t}\n\n\t/**\n\t * @param factory - the factory, which contains the model of the template\n\t *\n\t * @param template - java instance of the template\n\t *\n\t * @return - CtClass from the already built spoon model, which represents the template\n\t */\n\tpublic static <T> CtClass<T> getTemplateCtClass(Factory factory, Template<?> template) {\n\t\tCtClass<T> c = factory.Class().get(template.getClass());\n\t\tif (c.isShadow()) {\n\t\t\tthrow new SpoonException(\"The template \" + template.getClass().getName() + \" is not part of model. Add template sources to spoon template path.\");\n\t\t}\n\t\tcheckTemplateContracts(c);\n\t\treturn c;\n\t}\n\n\tprivate static <T> void checkTemplateContracts(CtClass<T> c) {\n\t\tfor (CtField f : c.getFields()) {\n\t\t\tParameter templateParamAnnotation = f.getAnnotation(Parameter.class);\n\t\t\tif (templateParamAnnotation != null && !templateParamAnnotation.value().isEmpty()) {\n\t\t\t\tString proxyName = templateParamAnnotation.value();\n\t\t\t\t// contract: if value, then the field type must be String or CtTypeReference\n\t\t\t\tString fieldTypeQName = f.getType().getQualifiedName();\n\t\t\t\tif (fieldTypeQName.equals(String.class.getName())) {\n\t\t\t\t\t// contract: the name of the template parameter must correspond to the name of the field\n\t\t\t\t\t// as found, by Pavel, this is not good contract because it prevents easy refactoring of templates\n\t\t\t\t\t// we remove it but keep the commented code in case somebody would come up with this bad idea\n//\t\t\t\t\tif (!f.getSimpleName().equals(\"_\" + f.getAnnotation(Parameter.class).value())) {\n//\t\t\t\t\t\tthrow new TemplateException(\"the field name of a proxy template parameter must be called _\" + f.getSimpleName());\n//\t\t\t\t\t}\n\n\t\t\t\t\t// contract: if a proxy parameter is declared and named \"x\" (@Parameter(\"x\")), then a type member named \"x\" must exist.\n\t\t\t\t\tboolean found = false;\n\t\t\t\t\tfor (CtTypeMember member: c.getTypeMembers()) {\n\t\t\t\t\t\tif (member.getSimpleName().equals(proxyName)) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found) {\n\t\t\t\t\t\tthrow new TemplateException(\"if a proxy parameter is declared and named \\\"\" + proxyName + \"\\\", then a type member named \\\"\\\" + proxyName + \\\"\\\" must exist.\");\n\t\t\t\t\t}\n\t\t\t\t} else if (fieldTypeQName.equals(CtTypeReference.class.getName())) {\n\t\t\t\t\t//OK it is CtTypeReference\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TemplateException(\"proxy template parameter must be typed as String or CtTypeReference, but it is \" + fieldTypeQName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns a Spoon factory object from the first template parameter that contains one\n\t */\n\tstatic Factory getFactory(Template<?> template) {\n\t\ttry {\n\t\t\tfor (Field f : Parameters.getAllTemplateParameterFields(template.getClass())) {\n\t\t\t\tif (f.get(template) != null && f.get(template) instanceof FactoryAccessor) {\n\t\t\t\t\treturn ((FactoryAccessor) f.get(template)).getFactory();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t\tthrow new TemplateException(\"no factory found in template \" + template.getClass().getName());\n\t}\n}\n"
    }, {
      "name" : "template/package-info.java",
      "weight" : 1.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\n/**\n * <p>This package defines a framework for well-typed pure-Java templates.</p>\n * <p>A template is a regular Java class that implements the {@link spoon.template.Template} interface and\n * that contains some template parameters.\n * <h2>Related Documentation</h2>\n * <ul>\n * <li><a href=\"http://spoon.gforge.inria.fr/\">Spoon Official Web Site</a>\n * </ul>\n */\npackage spoon.template;\n\n"
    }, {
      "name" : "template/TemplateParameter.java",
      "weight" : 4.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\n/**\n * This interface defines a typed template parameter. It is parameterized by\n * <code>T</code>, the type of the template parameter, which can be retrieved\n * by the {@link #S()} method. For more details on how to use template\n * parameters, see {@link Template}.\n */\npublic interface TemplateParameter<T> {\n\n\t/**\n\t * Gets the type of the template parameter. This methods has no runtime\n\t * meaning (should return a <code>null</code> reference) but is used as a\n\t * marker in a template code.\n\t */\n\tT S();\n\n}\n"
    }, {
      "name" : "template/Parameter.java",
      "weight" : 10.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation should be placed on templates' fields or methods to indicate\n * that they represent template parameters. It is only mandatory for names,\n * literals, and types, where it avoids having to use\n * {@link spoon.template.TemplateParameter} and allows for the direct accesses\n * of the parameters. A parameter is never considered as a templated element and\n * it is not necessary to annotate it with a {@link Local} annotation.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.FIELD, ElementType.METHOD })\npublic @interface Parameter {\n\t/**\n\t * Defines the name of the parameter (optional, mostly to avoid name\n\t * clashes). In most cases, the annotation does not have a \"value\" and the name of a template parameter is the simple name\n\t * of the annotated field.\n\t *\n\t * <pre>\n\t * class T extends Template {\n\t * \t\\@Parameter\n\t * \tCtExpression&lt;String&gt; $i;\n\t *\n\t * \tString s = $i.S();\n\t * }\n\t * </pre>\n\t *\n\t * However, in rare cases, eg to rename named elements that are in the same scope\n\t * as the template parameter, such as renaming of fields or nested types, the annotation value\n\t * is used to set a\n\t * template parameter name (aka a proxy). In this case:\n\t * contract 1: if \"value\" is set, then the template field type must be String\n\t * contract 2: if a proxy parameter is declared and named \"x\" (@Parameter(\"x\")), then a type member named \"x\" must exist (the one to be renamed).\n\t *\n\t * <pre>\n\t * class T extends Template {\n\t * \t// this parameter will contain the actual value of the _i_ field's name\n\t * \t\\@Parameter(&quot;_i_&quot;)\n\t * \tString __i_;\n\t *\n\t * \tint _i_; // the field to be renamed\n\t * }\n\t * </pre>\n\t */\n\tString value() default \"\";\n\n}\n"
    }, {
      "name" : "template/Local.java",
      "weight" : 9.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Target;\n\n/**\n * This annotation should be placed on templates' members to indicate that they\n * are local elements of the template class. As such, they are not used either\n * for matching or generating code.\n *\n * @see spoon.template.Substitution#insertAll(spoon.reflect.declaration.CtType, Template)\n */\n@Target({\n\t\tElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.FIELD,\n\t\tElementType.TYPE\n})\npublic @interface Local {\n}\n"
    }, {
      "name" : "template/TemplateBuilder.java",
      "weight" : 97.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\nimport spoon.SpoonException;\nimport spoon.pattern.Pattern;\nimport spoon.pattern.PatternBuilderHelper;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtField;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.reference.CtTypeReference;\nimport spoon.support.template.Parameters;\nimport spoon.support.util.ImmutableMapImpl;\n\n/**\n * Internal class used to provide pattern-based implementation of Template and TemplateMatcher\n */\nclass TemplateBuilder {\n\n\t/**\n\t * Creates a {@link TemplateBuilder}, which builds {@link Pattern} from {@link Template}\n\t * @param templateRoot the root element of {@link Template} model\n\t * @param template a instance of the {@link Template}. It is needed here,\n\t * \t\t\tbecause parameter value types influences which AST nodes will be the target of substitution\n\t * @return {@link TemplateBuilder}\n\t */\n\tpublic static TemplateBuilder createPattern(CtElement templateRoot, Template<?> template) {\n\t\tCtClass<? extends Template<?>> templateType = Substitution.getTemplateCtClass(templateRoot.getFactory(), template);\n\t\treturn createPattern(templateRoot, templateType, template);\n\t}\n\t//needed to provide access to protected members\n\tprivate static class PatternBuilder extends spoon.pattern.PatternBuilder {\n\n\t\tPatternBuilder(List<CtElement> template) {\n\t\t\tsuper(template);\n\t\t}\n\n\t\tListOfNodes getListOfNodes() {\n\t\t\treturn new ListOfNodes(patternNodes.getNodes());\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link TemplateBuilder}, which builds {@link Pattern} from {@link Template}\n\t * @param templateRoot the root element of {@link Template} model\n\t * @param templateType {@link CtClass} model of `template`\n\t * @param template a instance of the {@link Template}. It is needed here,\n\t * \t\t\tbecause parameter value types influences which AST nodes will be the target of substitution\n\t * @return\n\t */\n\tpublic static TemplateBuilder createPattern(CtElement templateRoot, CtClass<?> templateType, Template<?> template) {\n\t\tFactory f = templateRoot.getFactory();\n\n\t\tif (template != null && templateType.getQualifiedName().equals(template.getClass().getName()) == false) {\n\t\t\tthrow new SpoonException(\"Unexpected template instance \" + template.getClass().getName() + \". Expects \" + templateType.getQualifiedName());\n\t\t}\n\n\t\tPatternBuilder pb;\n\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tCtTypeReference<TemplateParameter> templateParamRef = f.Type().createReference(TemplateParameter.class);\n\t\tif (templateType == templateRoot) {\n\t\t\t//templateRoot is a class which extends from Template. We have to remove all Templating stuff from the patter model\n\t\t\tPatternBuilderHelper tv = new PatternBuilderHelper(templateType);\n\t\t\t{\n\t\t\t\ttv.keepTypeMembers(typeMember -> {\n\t\t\t\t\tif (typeMember.getAnnotation(Parameter.class) != null) {\n\t\t\t\t\t\t//remove all type members annotated with @Parameter\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeMember.getAnnotation(Local.class) != null) {\n\t\t\t\t\t\t//remove all type members annotated with @Local\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t//remove all Fields of type TemplateParameter\n\t\t\t\t\treturn !(typeMember instanceof CtField<?>) || !((CtField<?>) typeMember).getType().isSubtypeOf(templateParamRef);\n\t\t\t\t});\n\t\t\t\t//remove `... extends Template`, which doesn't have to be part of pattern model\n\t\t\t\ttv.removeSuperClass();\n\t\t\t}\n\t\t\tpb = new PatternBuilder(tv.getPatternElements());\n\t\t} else {\n\t\t\tpb = new PatternBuilder(Collections.singletonList(templateRoot));\n\t\t}\n\t\tMap<String, Object> templateParameters = template == null ? null : Parameters.getTemplateParametersAsMap(f, null, template);\n\t\t//legacy templates always automatically simplifies generated code\n\t\tpb.setAutoSimplifySubstitutions(true);\n\t\tpb.configurePatternParameters(pc -> {\n\t\t\tpc.byTemplateParameter(templateParameters);\n\t\t\tpc.byParameterValues(templateParameters);\n\t\t});\n\n\t\treturn new TemplateBuilder(templateType, pb, template);\n\t}\n\n\tprivate Template<?> template;\n\tprivate PatternBuilder patternBuilder;\n\tprivate CtClass<?> templateType;\n\n\tprivate TemplateBuilder(CtClass<?> templateType, PatternBuilder patternBuilder, Template<?> template) {\n\t\tthis.template = template;\n\t\tthis.patternBuilder = patternBuilder;\n\t\tthis.templateType = templateType;\n\t}\n\n\t/**\n\t * @return a {@link Pattern} built by this {@link TemplateBuilder}\n\t */\n\tpublic Pattern build() {\n\t\treturn patternBuilder.build();\n\t}\n\n\tPattern build(Consumer<ListOfNodes> nodes) {\n\t\tnodes.accept(patternBuilder.getListOfNodes());\n\t\treturn build();\n\t}\n\n\t/**\n\t * @param addGeneratedBy true if \"generated by\" comments has to be added into code generated by {@link Pattern} made by this {@link TemplateBuilder}\n\t * @return this to support fluent API\n\t */\n\tpublic TemplateBuilder setAddGeneratedBy(boolean addGeneratedBy) {\n\t\tpatternBuilder.setAddGeneratedBy(addGeneratedBy);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @return Map of template parameters from `template`\n\t */\n\tpublic Map<String, Object> getTemplateParameters() {\n\t\treturn getTemplateParameters(null);\n\t}\n\t/**\n\t * @param targetType the type which will receive the model generated using returned parameters\n\t * @return Map of template parameters from `template`\n\t */\n\tpublic Map<String, Object> getTemplateParameters(CtType<?> targetType) {\n\t\tFactory f = templateType.getFactory();\n\t\treturn Parameters.getTemplateParametersAsMap(f, targetType, template);\n\t}\n\n\t/**\n\t * generates a new AST node made by cloning of `patternModel` and by substitution of parameters by their values\n\t * @param targetType the CtType, which will receive the result of substitution\n\t * @return a substituted element\n\t */\n\tpublic <T extends CtElement> T substituteSingle(CtType<?> targetType, Class<T> itemType) {\n\t\treturn build().generator().generate(itemType, new ImmutableMapImpl(getTemplateParameters(targetType))).get(0);\n\t}\n\t/**\n\t * generates a new AST nodes made by cloning of `patternModel` and by substitution of parameters by their values\n\t * @param factory TODO\n\t * @param targetType the CtType, which will receive the result of substitution\n\t * @return List of substituted elements\n\t */\n\tpublic <T extends CtElement> List<T> substituteList(Factory factory, CtType<?> targetType, Class<T> itemType) {\n\t\treturn build().generator().generate(itemType, getTemplateParameters(targetType));\n\t}\n}\n"
    }, {
      "name" : "template/StatementTemplate.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.reflect.code.CtStatement;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtType;\n\nimport java.util.List;\n\n/**\n * This class represents a template parameter that defines a statement list\n * directly expressed in Java (no returns).\n *\n * <p>\n * To define a new statement list template parameter, you must subclass this\n * class and implement the {@link #statement()} method, which actually defines\n * the Java statements. It corresponds to a\n * {@link spoon.reflect.code.CtStatementList}.\n */\npublic abstract class StatementTemplate extends AbstractTemplate<CtStatement> {\n\n\t/**\n\t * Creates a new statement list template parameter.\n\t */\n\tpublic StatementTemplate() {\n\t}\n\n\t@Override\n\tpublic CtStatement apply(CtType<?> targetType) {\n\t\tCtClass<?> c = Substitution.getTemplateCtClass(targetType, this);\n\t\t// we substitute the first statement of method statement\n\t\tCtStatement patternModel = c.getMethod(\"statement\").getBody().getStatements().get(0);\n\t\tList<CtStatement> statements = TemplateBuilder.createPattern(patternModel, this)\n\t\t\t\t.setAddGeneratedBy(isAddGeneratedBy())\n\t\t\t\t.substituteList(c.getFactory(), targetType, CtStatement.class);\n\t\tif (statements.size() != 1) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\treturn statements.get(0);\n\t}\n\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * This method must be implemented to define the template statement list.\n\t */\n\tpublic abstract void statement() throws Throwable;\n}\n"
    }, {
      "name" : "template/TemplateMatcher.java",
      "weight" : 47.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport static spoon.pattern.internal.matcher.TobeMatched.getMatchedParameters;\n\nimport java.util.List;\n\nimport spoon.pattern.Match;\nimport spoon.pattern.Pattern;\nimport spoon.pattern.internal.matcher.TobeMatched;\nimport spoon.pattern.internal.node.ListOfNodes;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.meta.ContainerKind;\nimport spoon.reflect.visitor.Filter;\nimport spoon.reflect.visitor.chain.CtConsumer;\nimport spoon.support.util.ImmutableMap;\nimport spoon.support.util.ImmutableMapImpl;\n\n/**\n * This class defines an engine for matching a template to pieces of code.\n */\npublic class TemplateMatcher implements Filter<CtElement> {\n\n\tprivate final Pattern pattern;\n\tprivate ListOfNodes patternModel;\n\tprivate final CtElement templateRoot;\n\n\t/**\n\t * Holds matches of template parameters name to matching values.\n\t * The values can be:\n\t * <ul>\n\t * <li>single CtElement</li>\n\t * <li>list or set of CtElements</li>\n\t * <li>any value of primitive attribute, like String, Enum value, number, ...</li>\n\t * </ul>\n\t */\n\tprivate ImmutableMap matches;\n\n\t/**\n\t * Constructs a matcher for a given template.\n\t *\n\t * @param templateRoot the template to match against\n\t *\n\t */\n\tpublic TemplateMatcher(CtElement templateRoot) {\n\t\tthis(templateRoot, templateRoot.getParent(CtClass.class));\n\t}\n\n\t/**\n\t * Constructs a matcher for a given template. All parameters must be declared using Template fields.\n\t *\n\t * @param templateRoot the template model to match against. It must be a child of `templateType`\n\t * @param templateType the class of the template, which contains all the template parameters\n\t */\n\tpublic TemplateMatcher(CtElement templateRoot, CtClass<?> templateType) {\n\t\tthis.pattern = TemplateBuilder.createPattern(templateRoot, templateType, null).build(nodes -> this.patternModel = nodes);\n\t\tthis.templateRoot = templateRoot;\n\t}\n\n\t@Override\n\tpublic boolean matches(CtElement element) {\n\t\t//clear all matches from previous run before we start matching with `element`\n\t\tif (element == templateRoot) {\n\t\t\t// This case can occur when we are scanning the entire package for example see TemplateTest#testTemplateMatcherWithWholePackage\n\t\t\t// Correct template matches itself of course, but client does not want that\n\t\t\treturn false;\n\t\t}\n\t\tmatches = getMatchedParameters(patternModel.matchAllWith(TobeMatched.create(\n\t\t\t\tnew ImmutableMapImpl(),\n\t\t\t\tContainerKind.SINGLE,\n\t\t\t\telement)));\n\t\treturn matches != null;\n\t}\n\n\t/**\n\t * Returns all the matches where the keys are the corresponding\n\t * template parameters.\n\t * The {@link #matches(CtElement)} method must have been called before and must return true.\n\t * Otherwise it returns null.\n\t */\n\tpublic ImmutableMap getMatches() {\n\t\treturn matches;\n\t}\n\n\t/**\n\t * Finds all target program sub-trees that correspond to a template.\n\t *\n\t * @param targetRoot\n\t * \t\tthe target to be tested for match\n\t * @return the matched elements\n\t */\n\tpublic <T extends CtElement> List<T> find(final CtElement targetRoot) {\n\t\treturn targetRoot.filterChildren(this).list();\n\t}\n\n\t/**\n\t * Finds all target program sub-trees that correspond to a template\n\t * and calls consumer.accept(matchingElement, )\n\t * @param rootElement the root of to be searched AST\n\t * @param consumer the receiver of matches\n\t */\n\tpublic void forEachMatch(CtElement rootElement, CtConsumer<Match> consumer) {\n\t\tpattern.forEachMatch(rootElement, consumer);\n\t}\n}\n"
    }, {
      "name" : "template/TypedStatementListTemplateParameter.java",
      "weight" : 30.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtStatementList;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * This class represents a template parameter that defines a statement list\n * directly expressed in Java (the statement list ends with a return statement\n * returning a expression of type <code>R</code>).\n *\n * <p>\n * To define a new statement list template parameter, you must subclass this\n * class and implement the {@link #statements()} method, which actually defines\n * the Java statements. It corresponds to a\n * {@link spoon.reflect.code.CtStatementList}.\n */\npublic abstract class TypedStatementListTemplateParameter<R> implements TemplateParameter<R> {\n\n\t/**\n\t * Creates a new statement list template parameter.\n\t */\n\tpublic TypedStatementListTemplateParameter() {\n\t}\n\n\tpublic CtStatementList getSubstitution(CtType<?> targetType) {\n\t\tCtClass<?> c;\n\t\tCtBlock<?> b;\n\t\tc = targetType.getFactory().Class().get(this.getClass());\n\t\tif (c == null) {\n\t\t\tc = targetType.getFactory().Class().get(this.getClass());\n\t\t}\n\t\tCtStatementList l = targetType.getFactory().Core().createStatementList();\n\t\tif (this instanceof Template) {\n\t\t\tb = Substitution.substitute(targetType, (Template<?>) this, c.getMethod(\"statements\").getBody());\n\t\t} else {\n\t\t\tb = c.getMethod(\"statements\").getBody().clone();\n\t\t}\n\t\tl.setStatements(b.getStatements());\n\t\treturn l;\n\t}\n\n\t@Override\n\tpublic R S() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * This method must be implemented to define the template statement list.\n\t */\n\tpublic abstract R statements();\n}\n"
    }, {
      "name" : "template/TemplateException.java",
      "weight" : 13.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.SpoonException;\n\n/**\n * This runtime exception can be throws when something wrong occurs in template\n * operations such as loading, substitution, and matching.\n *\n * @see spoon.template.Substitution\n * @see spoon.template.TemplateMatcher\n */\npublic class TemplateException extends SpoonException {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Empty exception.\n\t */\n\tpublic TemplateException() {\n\t}\n\n\t/**\n\t * Exception with a message.\n\t */\n\tpublic TemplateException(String message) {\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * Exception with a cause.\n\t */\n\tpublic TemplateException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n}\n"
    }, {
      "name" : "template/ExtensionTemplate.java",
      "weight" : 24.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport java.util.ArrayList;\n\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.declaration.CtTypeMember;\nimport spoon.reflect.reference.CtTypeReference;\n\n/**\n * Inserts all the methods, fields, constructors, initialization blocks (if\n * target is a class), inner types, and super interfaces (except\n * {@link Template}) from a given template by substituting all the template\n * parameters by their values. Members annotated with\n * {@link spoon.template.Local} or {@link Parameter} are not inserted.\n */\npublic class ExtensionTemplate extends AbstractTemplate<CtType<?>> {\n\t@Override\n\tpublic CtType<?> apply(CtType<?> target) {\n\t\tCtClass<? extends Template<?>> templateType = Substitution.getTemplateCtClass(target.getFactory(), this);\n\t\tCtType<?> generated = TemplateBuilder.createPattern(templateType, templateType, this)\n\t\t.setAddGeneratedBy(isAddGeneratedBy())\n\t\t.substituteSingle(target, CtType.class);\n\t\tfor (CtTypeReference<?> iface : new ArrayList<>(generated.getSuperInterfaces())) {\n\t\t\tiface.delete();\n\t\t\ttarget.addSuperInterface(iface);\n\t\t}\n\t\tfor (CtTypeMember tm : new ArrayList<>(generated.getTypeMembers())) {\n\t\t\ttm.delete();\n\t\t\ttarget.addTypeMember(tm);\n\t\t}\n\t\treturn target;\n\t}\n}\n"
    }, {
      "name" : "template/Template.java",
      "weight" : 6.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * <p>\n * A template code is simply a piece of code that uses a\n * {@link TemplateParameter}'s instance. It must then invoke the\n * {@link TemplateParameter#S()} method.\n *\n * <p>\n * When the template parameter is a String it is used to rename element of the code such as fields or methods.\n * When it is another primitive type (or a boxing\n * type) representing a literal, or a Class, the template parameter can be\n * directly accessed. To use a standard parameter containing a String type, use a CtLiteral&lt;String&gt;\n *\n * <pre>\n *       import spoon.template.Template;\n *       import spoon.template.Value;\n *\n *       public class SimpleTemplate implements Template {\n *           // template parameter fields\n *            \\@Parameter String _parameter_;\n *\n *            \\@Parameter CtLiteral&lt;String&gt; _anotherParameter;\n *\n *\n *           // parameters binding\n *            \\@Local\n *           public SimpleTemplate(String parameter, CtLiteral&lt;String&gt; anotherParameter) {\n *               _parameter_ = parameter;\n *               _anotherParameter = anotherParameter;\n *           }\n *\n *           // template method\n *           public void methodwith_parameter_() {\n *               System.out.println(_anotherParameter);\n *           }\n *       }\n * </pre>\n *\n * <p>\n * The template parameters must be bound to their values in the template's\n * constructor (which should be defined as a template's\n * {@link spoon.template.Local}. A possible use of a template would be to\n * insert the template into a target class, by using\n * {@link Substitution#insertAll(CtType, Template)}:\n *\n * <pre>\n *       spoon.reflect.CtClass target=...;\n *       CtLiteral&lt;String&gt; anotherParameter = factory.createLiteral();\n *       anotherParameter.setValue(&quot;hello templated world&quot;);\n *\n *       Template template=new SimpleTemplate(&quot;ParameterizedName&quot;, anotherParameter);\n *       Substitution.insertAll(target,template);\n * </pre>\n *\n * <p>\n * If the target class is an empty class named <code>A</code>, the resulting\n * code will be:\n *\n * <pre>\n * public class A {\n * \tpublic void methodwithParameterizedName() {\n * \t\tSystem.out.println(&quot;hello templated world&quot;);\n *    }\n * }\n * </pre>\n */\npublic interface Template<T extends CtElement> {\n\t/**\n\t * Returns the code which results from applying the template.\n\t *\n\t * @param targetType\n\t * \t\tthe type that defines the context of the substitution.\n\t * \t\tIt may be null for templates with no context.\n\t */\n\tT apply(CtType<?> targetType);\n\n}\n"
    }, {
      "name" : "template/TypedBlockTemplateParameter.java",
      "weight" : 27.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtMethod;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * This class represents a template parameter that defines a block statement\n * directly expressed in Java (must return an expression of type <code>R</code>\n * ).\n *\n * <p>\n * To define a new block template parameter, you must subclass this class and\n * implement the {@link #block()} method, which actually defines the Java block.\n * It corresponds to a {@link spoon.reflect.code.CtBlock}.\n */\npublic abstract class TypedBlockTemplateParameter<R> implements TemplateParameter<R> {\n\n\t/**\n\t * Creates a new block template parameter.\n\t */\n\tpublic TypedBlockTemplateParameter() {\n\t}\n\n\t/**\n\t * This method must be implemented to define the template block.\n\t */\n\tpublic abstract R block();\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtBlock<R> getSubstitution(CtType<?> targetType) {\n\t\tCtClass<?> c;\n\t\tc = targetType.getFactory().Class().get(this.getClass());\n\t\tif (c == null) {\n\t\t\tc = targetType.getFactory().Class().get(this.getClass());\n\t\t}\n\t\tCtMethod m = c.getMethod(\"block\");\n\t\tif (this instanceof Template) {\n\t\t\treturn Substitution.substitute(targetType, (Template<?>) this, m.getBody());\n\t\t}\n\t\treturn m.getBody().clone();\n\t}\n\n\t@Override\n\tpublic R S() {\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "template/ExpressionTemplate.java",
      "weight" : 33.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.pattern.PatternBuilderHelper;\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.code.CtExpression;\nimport spoon.reflect.code.CtReturn;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * This class represents an expression template parameter expressed in Java.\n *\n * <p>\n * To define a new expression template parameter, you must subclass this class\n * and implement the {@link #expression()} method, which actually defines the\n * Java expression. It corresponds to a {@link spoon.reflect.code.CtExpression}.\n */\npublic abstract class ExpressionTemplate<T> extends AbstractTemplate<CtExpression<T>> {\n\n\t/**\n\t * Returns the expression.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> CtExpression<T> getExpression(\n\t\t\tCtClass<? extends ExpressionTemplate<?>> p) {\n\t\tCtBlock<?> b = getExpressionBlock(p);\n\t\treturn ((CtReturn<T>) b.getStatements().get(0)).getReturnedExpression();\n\t}\n\n\tprivate static CtBlock<?> getExpressionBlock(\n\t\t\tCtClass<? extends ExpressionTemplate<?>> p) {\n\t\treturn p.getMethod(\"expression\").getBody();\n\t}\n\n\t/**\n\t * Creates a new expression template parameter.\n\t */\n\tpublic ExpressionTemplate() {\n\t}\n\n\t/**\n\t * This method must be implemented to define the template expression. The\n\t * convention is that the defined expression corresponds to the expression\n\t * returned by the return statement of the method.\n\t */\n\tpublic abstract T expression() throws Throwable;\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic CtExpression<T> apply(CtType<?> targetType) {\n\t\tCtClass<? extends ExpressionTemplate<?>> c = Substitution.getTemplateCtClass(targetType, this);\n\t\treturn TemplateBuilder.createPattern(\n\t\t\t\tnew PatternBuilderHelper(c).setReturnExpressionOfMethod(\"expression\").getPatternElements().get(0), this)\n\t\t\t\t.setAddGeneratedBy(isAddGeneratedBy()).substituteSingle(targetType, CtExpression.class);\n\t}\n\n\tpublic T S() {\n\t\treturn null;\n\t}\n}\n"
    }, {
      "name" : "template/AbstractTemplate.java",
      "weight" : 34.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport java.lang.reflect.Field;\n\nimport spoon.SpoonException;\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.template.Parameters;\n\n/**\n * handles the well-formedness and helper methods of templates\n */\npublic abstract class AbstractTemplate<T extends CtElement> implements Template<T> {\n\n\tprivate boolean addGeneratedBy = false;\n\t/**\n\t * verifies whether there is at least one template parameter.\n\t */\n\tpublic boolean isWellFormed() {\n\t\treturn !Parameters.getAllTemplateParameterFields(this.getClass()).isEmpty();\n\t}\n\n\t/**\n\t * verifies whether all template parameters are filled.\n\t */\n\tpublic boolean isValid() {\n\t\ttry {\n\t\t\tfor (Field f : Parameters.getAllTemplateParameterFields(this.getClass())) {\n\t\t\t\tif (f.get(this) == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new SpoonException(e);\n\t\t}\n\t}\n\n\t/**\n\t * returns a Spoon factory object from the first template parameter that contains one\n\t */\n\tpublic Factory getFactory() {\n\t\treturn Substitution.getFactory(this);\n\t}\n\n\t/**\n\t * @return true if the template engine adds Generated by ... comments into generated code\n\t */\n\tpublic boolean isAddGeneratedBy() {\n\t\treturn addGeneratedBy;\n\t}\n\n\t/**\n\t * @param addGeneratedBy if true the template engine will add Generated by ... comments into generated code\n\t */\n\tpublic AbstractTemplate<T> addGeneratedBy(boolean addGeneratedBy) {\n\t\tthis.addGeneratedBy = addGeneratedBy;\n\t\treturn this;\n\t}\n}\n"
    }, {
      "name" : "template/BlockTemplate.java",
      "weight" : 20.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.template;\n\nimport spoon.reflect.code.CtBlock;\nimport spoon.reflect.declaration.CtClass;\nimport spoon.reflect.declaration.CtType;\n\n/**\n * This class represents a template parameter that defines a void block\n * statement directly expressed in Java (no returns).\n *\n *\n * <p>\n * To define a new block template parameter, you must subclass this class and\n * implement the {@link #block()} method, which actually defines the Java block.\n * It corresponds to a {@link spoon.reflect.code.CtBlock}.\n */\npublic abstract class BlockTemplate extends AbstractTemplate<CtBlock<?>> {\n\n\t/**\n\t * Returns the block.\n\t */\n\tpublic static CtBlock<?> getBlock(CtClass<? extends BlockTemplate> p) {\n\t\treturn p.getMethod(\"block\").getBody();\n\t}\n\n\t/**\n\t * Creates a new block template parameter.\n\t */\n\tpublic BlockTemplate() {\n\t}\n\n\t@Override\n\tpublic CtBlock<?> apply(CtType<?> targetType) {\n\t\tCtClass<? extends BlockTemplate> c = Substitution.getTemplateCtClass(targetType, this);\n\t\treturn TemplateBuilder.createPattern(getBlock(c), this).setAddGeneratedBy(isAddGeneratedBy()).substituteSingle(targetType, CtBlock.class);\n\t}\n\n\tpublic Void S() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * This method must be implemented to define the template block.\n\t */\n\tpublic abstract void block() throws Throwable;\n}\n"
    } ]
  }, {
    "name" : "testing",
    "children" : [ {
      "name" : "testing/AbstractAssert.java",
      "weight" : 36.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.SpoonException;\nimport spoon.processing.Processor;\n\nimport java.util.LinkedList;\n\n/**\n * Base contract for all assertion objects: the minimum functionality that\n * any assertion object should provide.\n *\n * @param <T>\n * \t\tthe self type of this assertion class.\n * @param <A>\n * \t\tthe type of the actual value.\n */\npublic abstract class AbstractAssert<T extends AbstractAssert<T, A>, A> {\n\tprotected final LinkedList<Processor<?>> processors = new LinkedList<>();\n\tprotected final A actual;\n\tprotected final T myself;\n\n\tprotected AbstractAssert(A actual, Class<?> selfType) {\n\t\tthis.myself = (T) selfType.cast(this);\n\t\tthis.actual = actual;\n\t}\n\n\t/**\n\t * Applies the processor on the actual value.\n\t *\n\t * @param processor\n\t * \t\tthe given processor.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T withProcessor(Processor<?> processor) {\n\t\tprocessors.add(processor);\n\t\treturn myself;\n\t}\n\n\t/**\n\t * Applies the processor on the actual value.\n\t *\n\t * @param processor\n\t * \t\tthe class of the given processor.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T withProcessor(Class<? extends Processor<?>> processor) {\n\t\ttry {\n\t\t\twithProcessor(processor.newInstance());\n\t\t} catch (InstantiationException | IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\"Can't instantiate class processor.\", e);\n\t\t}\n\t\treturn myself;\n\t}\n\n\t/**\n\t * Applies the processor on the actual value.\n\t *\n\t * @param qualifiedName\n\t * \t\tthe qualified name of the given processor.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T withProcessor(String qualifiedName) {\n\t\ttry {\n\t\t\twithProcessor((Class<? extends Processor<?>>) Thread.currentThread().getContextClassLoader().loadClass(qualifiedName));\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new SpoonException(\"Unable to load processor \\\"\" + qualifiedName + \"\\\"\", e);\n\t\t}\n\t\treturn myself;\n\t}\n\n\tpublic int hashCode() {\n\t\treturn 1;\n\t}\n}\n"
    }, {
      "name" : "testing/FileAssert.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport java.io.File;\n\npublic class FileAssert extends AbstractFileAssert<FileAssert> {\n\tpublic FileAssert(File actual) {\n\t\tsuper(actual, FileAssert.class);\n\t}\n}\n"
    }, {
      "name" : "testing/utils/Check.java",
      "weight" : 47.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing.utils;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.support.visitor.equals.EqualsVisitor;\n\nimport java.io.File;\n\npublic final class Check {\n\tprivate Check() {\n\t\tthrow new AssertionError();\n\t}\n\n\t/** if ct1 is not equals to ct2, tells the exact difference */\n\tpublic static void assertCtElementEquals(CtElement ct1, CtElement ct2) {\n\t\tEqualsVisitor ev = new EqualsVisitor();\n\t\tev.checkEquals(ct1, ct2);\n\t\tif (!ev.isEqual()) {\n\t\t\tObject notEqual1 = ev.getNotEqualElement();\n\t\t\tObject notEqual2 = ev.getNotEqualOther();\n\t\t\tthrow new AssertionError(\"elements no equal -- difference:\\n\"\n\t\t\t\t\t+ ev.getNotEqualRole() + \"\\n\"\n\t\t\t\t\t+ (notEqual1 instanceof CtElement && ((CtElement) notEqual1).getPosition() != null ? ((CtElement) notEqual1).getPosition().toString() : \"<unknown position>\") + \" \\n\"\n\t\t\t\t\t+ (notEqual1 != null ? notEqual1.toString() : \"null\")\n\t\t\t\t\t+ \"\\n is not \\n\"\n\t\t\t\t\t+ (notEqual2 != null ? notEqual2.toString() : \"null\")\n\t\t\t);\n\t\t}\n\n\t}\n\t/** throws AssertionError if \"reference\" is null */\n\tpublic static <T> T assertNotNull(String msg, T reference) {\n\t\tif (reference == null) {\n\t\t\tthrow new AssertionError(msg);\n\t\t}\n\t\treturn reference;\n\t}\n\n\tpublic static <T> T assertNotNull(T reference) {\n\t\treturn assertNotNull(\"Your parameter can't be null.\", reference);\n\t}\n\n\tpublic static <T extends File> T assertExists(T file) {\n\t\tif (!file.exists()) {\n\t\t\tthrow new AssertionError(\"You should specify an existing file.\");\n\t\t}\n\t\treturn file;\n\t}\n\n\tpublic static <A extends CtElement, E extends CtElement> A assertIsSame(A actual, E expected) {\n\t\tassertNotNull(actual);\n\t\tassertNotNull(expected);\n\t\tif (!actual.getClass().equals(expected.getClass())) {\n\t\t\tthrow new AssertionError(String.format(\"Actual value is typed by %1$s and expected is typed by %2$s, these objects should be the same type.\", actual.getClass().getName(), expected.getClass().getName()));\n\t\t}\n\t\treturn actual;\n\t}\n}\n"
    }, {
      "name" : "testing/utils/ProcessorUtils.java",
      "weight" : 54.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing.utils;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.apache.log4j.Level;\nimport spoon.Launcher;\nimport spoon.SpoonException;\nimport spoon.processing.Processor;\nimport spoon.processing.ProcessorProperties;\nimport spoon.processing.Property;\nimport spoon.reflect.factory.Factory;\nimport spoon.support.compiler.jdt.JDTBasedSpoonCompiler;\nimport spoon.support.util.RtHelper;\n\nimport java.lang.reflect.Field;\nimport java.util.Collection;\n\npublic final class ProcessorUtils {\n\tprivate static final ObjectMapper converter = new ObjectMapper();\n\n\tprivate ProcessorUtils() {\n\t\tthrow new AssertionError();\n\t}\n\n\tpublic static void process(Factory factory, Collection<Processor<?>> processors) {\n\t\tfinal JDTBasedSpoonCompiler compiler = (JDTBasedSpoonCompiler) new Launcher().createCompiler(factory);\n\t\tcompiler.process(processors);\n\t}\n\n\t/** sets the fields of processor \"p\" given as parameter according to the properties */\n\tpublic static void initProperties(Processor<?> p, ProcessorProperties properties) {\n\t\tif (properties != null) {\n\t\t\tfor (Field f : RtHelper.getAllFields(p.getClass())) {\n\t\t\t\tif (f.isAnnotationPresent(Property.class)) {\n\t\t\t\t\tObject obj = properties.get(f.getType(), f.getName());\n\t\t\t\t\tif (obj != null) {\n\t\t\t\t\t\tf.setAccessible(true);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tf.set(p, obj);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tthrow new SpoonException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj = properties.get(String.class, f.getName());\n\t\t\t\t\t\tif (obj != null) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tobj = converter.readValue((String) obj, f.getType());\n\t\t\t\t\t\t\t\tf.setAccessible(true);\n\t\t\t\t\t\t\t\tf.set(p, obj);\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tthrow new SpoonException(\"Error while assigning the value to \" + f.getName(), e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp.getFactory().getEnvironment().report(p, Level.WARN,\n\t\t\t\t\t\t\t\t\t\"No value found for property '\" + f.getName() + \"' in processor \" + p.getClass().getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
    }, {
      "name" : "testing/utils/ModelUtils.java",
      "weight" : 116.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing.utils;\n\nimport spoon.Launcher;\nimport spoon.SpoonModelBuilder;\nimport spoon.compiler.SpoonResourceHelper;\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\nimport spoon.reflect.factory.FactoryImpl;\nimport spoon.support.DefaultCoreFactory;\nimport spoon.support.StandardEnvironment;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.function.Consumer;\n\npublic final class ModelUtils {\n\tprivate ModelUtils() {\n\t\tthrow new AssertionError();\n\t}\n\n\tpublic static Factory createFactory() {\n\t\treturn new FactoryImpl(new DefaultCoreFactory(), new StandardEnvironment());\n\t}\n\n\t/** Utility method for testing: creates the model of `packageName` from src/test/java and returns the CtType corresponding to `className` */\n\tpublic static <T extends CtType<?>> T build(String packageName, String className) throws Exception {\n\t\tLauncher launcher = new Launcher();\n\t\tlauncher.getEnvironment().setCommentEnabled(false); // we don't want to parse the comments for equals\n\t\tSpoonModelBuilder comp = launcher.createCompiler();\n\t\tcomp.addInputSources(SpoonResourceHelper.resources(\"./src/test/java/\" + packageName.replace('.', '/') + \"/\" + className + \".java\"));\n\t\tcomp.build();\n\t\treturn comp.getFactory().Package().get(packageName).getType(className);\n\t}\n\n\t/** Utility method for testing: creates the model of `packageName` and the factory from src/test/java and returns the CtType corresponding to `className` */\n\tpublic static <T extends CtType<?>> T build(String packageName, String className, final Factory f) throws Exception {\n\t\tLauncher launcher = new Launcher() {\n\t\t\t@Override\n\t\t\tpublic Factory createFactory() {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t};\n\t\tSpoonModelBuilder comp = launcher.createCompiler();\n\t\tcomp.addInputSources(SpoonResourceHelper.resources(\"./src/test/java/\" + packageName.replace('.', '/') + \"/\" + className + \".java\"));\n\t\tcomp.build();\n\t\treturn comp.getFactory().Package().get(packageName).getType(className);\n\t}\n\n\t/** Utility method for testing: creates the model of the given `classesToBuild` from src/test/java and returns the factory */\n\tpublic static Factory build(Class<?>... classesToBuild) throws Exception {\n\t\treturn build(launcher -> {\n\t\t\tlauncher.getEnvironment().setNoClasspath(false);\n\t\t\tlauncher.getEnvironment().setCommentEnabled(false);\n\t\t}, classesToBuild);\n\t}\n\n\t/** Utility method for testing: creates the noclasspath model of the given `classesToBuild` from src/test/java and returns the factory */\n\tpublic static Factory buildNoClasspath(Class<?>... classesToBuild) throws Exception {\n\t\treturn build(launcher -> launcher.getEnvironment().setNoClasspath(true), classesToBuild);\n\t}\n\n\t/**\n\t * Utility method for testing: creates the model of the given `classesToBuild` from src/test/java and returns the factory\n\t * and allows to configure the Launcher first using `config`\n\t */\n\tpublic static Factory build(Consumer<Launcher> config, Class<?>... classesToBuild) throws Exception {\n\t\tfinal Launcher launcher = new Launcher();\n\t\tconfig.accept(launcher);\n\t\tSpoonModelBuilder comp = launcher.createCompiler();\n\t\tfor (Class<?> classToBuild : classesToBuild) {\n\t\t\tcomp.addInputSources(SpoonResourceHelper.resources(\"./src/test/java/\" + classToBuild.getName().replace('.', '/') + \".java\"));\n\t\t}\n\t\tcomp.build();\n\t\treturn comp.getFactory();\n\t}\n\n\t/** Builds the Spoon mode of the `filesToBuild` given as parameter */\n\tpublic static Factory build(File... filesToBuild) {\n\t\tfinal Launcher launcher = new Launcher();\n\t\tlauncher.getEnvironment().setNoClasspath(true);\n\t\tSpoonModelBuilder comp = launcher.createCompiler();\n\t\tfor (File fileToBuild : filesToBuild) {\n\t\t\ttry {\n\t\t\t\tcomp.addInputSource(SpoonResourceHelper.createResource(fileToBuild));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"File not found\", e);\n\t\t\t}\n\t\t}\n\t\tcomp.build();\n\t\treturn comp.getFactory();\n\t}\n\n\tpublic static <T> CtType<T> buildClass(Class<T> classToBuild) throws Exception {\n\t\treturn buildClass(classToBuild, true);\n\t}\n\n\t/** Builds and returns the Spoon model of `` classToBuild */\n\tpublic static <T> CtType<T> buildClass(Class<T> classToBuild, boolean ensureFullclasspath) throws Exception {\n\t\tif (ensureFullclasspath) {\n\t\t\treturn build(classToBuild).Type().get(classToBuild);\n\t\t} else {\n\t\t\treturn buildNoClasspath(classToBuild).Type().get(classToBuild);\n\t\t}\n\t}\n\n\tpublic static <T> CtType<T> buildClass(Consumer<Launcher> config, Class<T> classToBuild) throws Exception {\n\t\treturn build(config, classToBuild).Type().get(classToBuild);\n\t}\n\n\t/** checks that the file `outputDirectoryFile` can be parsed with Spoon , given a compliance level. */\n\tpublic static void canBeBuilt(File outputDirectoryFile, int complianceLevel) {\n\t\tcanBeBuilt(outputDirectoryFile, complianceLevel, false);\n\t}\n\n\t/** checks that the file at path `outputDirectory` can be parsed with Spoon , given a compliance level. */\n\tpublic static void canBeBuilt(String outputDirectory, int complianceLevel) {\n\t\tcanBeBuilt(outputDirectory, complianceLevel, false);\n\t}\n\n\t/** checks that the file `outputDirectoryFile` can be parsed with Spoon , given a compliance level and the noclasspath option. */\n\tpublic static void canBeBuilt(File outputDirectoryFile, int complianceLevel, boolean noClasspath) {\n\t\tfinal Launcher launcher = new Launcher();\n\t\tfinal Factory factory = launcher.getFactory();\n\t\tfactory.getEnvironment().setComplianceLevel(complianceLevel);\n\t\tfactory.getEnvironment().setNoClasspath(noClasspath);\n\t\tfinal SpoonModelBuilder compiler = launcher.createCompiler(factory);\n\t\tcompiler.addInputSource(outputDirectoryFile);\n\t\ttry {\n\t\t\tcompiler.build();\n\t\t} catch (Exception e) {\n\t\t\tfinal AssertionError error = new AssertionError(\"Can't compile \" + outputDirectoryFile.getName() + \" because \" + e.getMessage());\n\t\t\terror.initCause(e);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/** checks that the file at path `outputDirectory` can be parsed with Spoon , given a compliance level and noclasspath option. */\n\tpublic static void canBeBuilt(String outputDirectory, int complianceLevel, boolean noClasspath) {\n\t\tcanBeBuilt(new File(outputDirectory), complianceLevel, noClasspath);\n\t}\n\n\t/**\n\t * Converts `obj` to String and all EOLs and TABs are removed and sequences of white spaces are replaced by single space\n\t * @param obj to be converted object\n\t * @return single line string optimized for comparation\n\t */\n\tpublic static String getOptimizedString(Object obj) {\n\t\tif (obj == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\treturn obj.toString().replaceAll(\"[\\\\r\\\\n\\\\t]+\", \"\").replaceAll(\"\\\\s{2,}\", \" \");\n\t}\n\n}\n"
    }, {
      "name" : "testing/AbstractCtElementAssert.java",
      "weight" : 26.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtElement;\n\nimport static spoon.testing.utils.Check.assertCtElementEquals;\nimport static spoon.testing.utils.Check.assertNotNull;\nimport static spoon.testing.utils.Check.assertIsSame;\nimport static spoon.testing.utils.ProcessorUtils.process;\n\npublic abstract class AbstractCtElementAssert<T extends AbstractCtElementAssert<T>> extends AbstractAssert<T, CtElement> {\n\tprotected AbstractCtElementAssert(CtElement actual, Class<?> selfType) {\n\t\tsuper(actual, selfType);\n\t}\n\n\t/**\n\t * Verifies that the actual value is equal to the given one.\n\t *\n\t * @param expected\n\t * \t\tThe expected element.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T isEqualTo(CtElement expected) {\n\t\tassertNotNull(expected);\n\t\tassertIsSame(actual, expected);\n\n\t\tprocess(actual.getFactory(), processors);\n\n\t\t// using the new method to have a nice error message\n\t\tassertCtElementEquals(expected, actual);\n\n\t\treturn this.myself;\n\t}\n\n\t/**\n\t * Verifies that the actual value is equal to the given one.\n\t *\n\t * @param expected\n\t * \t\tThe expected render of the element.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T isEqualTo(String expected) {\n\t\tassertNotNull(expected);\n\n\t\tprocess(actual.getFactory(), processors);\n\n\t\tif (!actual.toString().equals(expected)) {\n\t\t\tthrow new AssertionError(String.format(\"%1$s and %2$s aren't equals.\", actual.getShortRepresentation(), expected));\n\t\t}\n\t\treturn this.myself;\n\t}\n}\n"
    }, {
      "name" : "testing/CtPackageAssert.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtPackage;\n\npublic class CtPackageAssert extends AbstractCtPackageAssert<CtPackageAssert> {\n\tpublic CtPackageAssert(CtPackage actual) {\n\t\tsuper(actual, CtPackageAssert.class);\n\t}\n}\n"
    }, {
      "name" : "testing/CtElementAssert.java",
      "weight" : 7.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtElement;\n\npublic class CtElementAssert extends AbstractCtElementAssert<CtElementAssert> {\n\tprotected CtElementAssert(CtElement actual) {\n\t\tsuper(actual, CtElementAssert.class);\n\t}\n}\n"
    }, {
      "name" : "testing/AbstractFileAssert.java",
      "weight" : 34.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtType;\nimport spoon.reflect.factory.Factory;\n\nimport java.io.File;\nimport java.util.List;\n\nimport static spoon.testing.utils.Check.assertExists;\nimport static spoon.testing.utils.Check.assertNotNull;\nimport static spoon.testing.utils.ModelUtils.build;\nimport static spoon.testing.utils.ProcessorUtils.process;\n\npublic abstract class AbstractFileAssert<T extends AbstractFileAssert<T>> extends AbstractAssert<T, File> {\n\tpublic AbstractFileAssert(File actual, Class<?> selfType) {\n\t\tsuper(actual, selfType);\n\t}\n\n\t/**\n\t * Verifies that the actual value is equal to the given one.\n\t *\n\t * @param expected\n\t * \t\tThe expected location of source code.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T isEqualTo(String expected) {\n\t\treturn isEqualTo(new File(expected));\n\t}\n\n\t/**\n\t * Verifies that the actual value is equal to the given one.\n\t *\n\t * @param expected\n\t * \t\tThe expected location of source code.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T isEqualTo(File expected) {\n\t\tassertNotNull(expected);\n\t\tassertExists(expected);\n\n\t\tfinal Factory actualFactory = build(actual);\n\t\tfinal Factory expectedFactory = build(expected);\n\n\t\tprocess(actualFactory, processors);\n\t\tfinal List<CtType<?>> allActual = actualFactory.Type().getAll();\n\t\tfinal List<CtType<?>> allExpected = expectedFactory.Type().getAll();\n\t\tfor (int i = 0; i < allActual.size(); i++) {\n\t\t\tfinal CtType<?> currentActual = allActual.get(i);\n\t\t\tfinal CtType<?> currentExpected = allExpected.get(i);\n\t\t\tif (!currentActual.equals(currentExpected)) {\n\t\t\t\tthrow new AssertionError(String.format(\"%1$s and %2$s aren't equals.\", currentActual.getQualifiedName(), currentExpected.getQualifiedName()));\n\t\t\t}\n\t\t}\n\t\treturn this.myself;\n\t}\n}\n"
    }, {
      "name" : "testing/AbstractCtPackageAssert.java",
      "weight" : 57.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtPackage;\nimport spoon.reflect.declaration.CtType;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport static spoon.testing.Assert.assertThat;\nimport static spoon.testing.utils.Check.assertNotNull;\nimport static spoon.testing.utils.ProcessorUtils.process;\n\npublic abstract class AbstractCtPackageAssert<T extends AbstractCtPackageAssert<T>> extends AbstractAssert<T, CtPackage> {\n\tprotected AbstractCtPackageAssert(CtPackage actual, Class<?> selfType) {\n\t\tsuper(actual, selfType);\n\t}\n\n\t/**\n\t * Verifies that the actual value is equal to the given one.\n\t *\n\t * @param expected\n\t * \t\tThe expected package.\n\t * @return {@code this} assertion object.\n\t */\n\tpublic T isEqualTo(CtPackage expected) {\n\t\tassertNotNull(expected);\n\n\t\tif (!actual.getSimpleName().equals(expected.getSimpleName())) {\n\t\t\tthrow new AssertionError(String.format(\"The actual package named %1$s isn't equals to the expected package named %2$s\", actual.getSimpleName(), expected.getSimpleName()));\n\t\t}\n\n\t\tif (processors != null && !processors.isEmpty()) {\n\t\t\tprocess(actual.getFactory(), processors);\n\t\t}\n\n\t\tclass TypeComparator implements Comparator<CtType<?>> {\n\t\t\t@Override\n\t\t\tpublic int compare(CtType<?> o1, CtType<?> o2) {\n\t\t\t\treturn o1.getSimpleName().compareTo(o2.getSimpleName());\n\t\t\t}\n\t\t}\n\n\t\tfinal List<CtType<?>> actualTypes = new ArrayList<>(actual.getTypes());\n\t\tCollections.sort(actualTypes, new TypeComparator());\n\t\tfinal List<CtType<?>> expectedTypes = new ArrayList<>(expected.getTypes());\n\t\tCollections.sort(expectedTypes, new TypeComparator());\n\t\tfor (int i = 0; i < actual.getTypes().size(); i++) {\n\t\t\tfinal CtType<?> actualType = actualTypes.get(i);\n\t\t\tfinal CtType<?> expectedType = expectedTypes.get(i);\n\t\t\tif (!actualType.toString().equals(expectedType.toString())) {\n\t\t\t\tthrow new AssertionError(String.format(\"%1$s and %2$s aren't equals.\", actualType.getShortRepresentation(), expectedType.getShortRepresentation()));\n\t\t\t}\n\t\t}\n\n\t\tclass PackageComparator implements Comparator<CtPackage> {\n\t\t\t@Override\n\t\t\tpublic int compare(CtPackage o1, CtPackage o2) {\n\t\t\t\treturn o1.getSimpleName().compareTo(o2.getSimpleName());\n\t\t\t}\n\t\t}\n\n\t\tfinal List<CtPackage> actualPackages = new ArrayList<>(actual.getPackages());\n\t\tCollections.sort(actualPackages, new PackageComparator());\n\t\tfinal List<CtPackage> expectedPackages = new ArrayList<>(expected.getPackages());\n\t\tCollections.sort(expectedPackages, new PackageComparator());\n\n\t\tfor (int i = 0; i < actualPackages.size(); i++) {\n\t\t\tfinal CtPackage actualPackage = actualPackages.get(i);\n\t\t\tfinal CtPackage expectedPackage = expectedPackages.get(i);\n\t\t\tassertThat(actualPackage).isEqualTo(expectedPackage);\n\t\t}\n\n\t\treturn this.myself;\n\t}\n}\n"
    }, {
      "name" : "testing/Assert.java",
      "weight" : 25.0,
      "text" : "/**\n * Copyright (C) 2006-2019 INRIA and contributors\n *\n * Spoon is available either under the terms of the MIT License (see LICENSE-MIT.txt) of the Cecill-C License (see LICENSE-CECILL-C.txt). You as the user are entitled to choose the terms under which to adopt Spoon.\n */\npackage spoon.testing;\n\nimport spoon.reflect.declaration.CtElement;\nimport spoon.reflect.declaration.CtPackage;\n\nimport java.io.File;\n\nimport static spoon.testing.utils.Check.assertExists;\nimport static spoon.testing.utils.Check.assertNotNull;\n\n/**\n * Entry point for assertion methods for different data types.\n * Each method in this class is a static factory for the type-specific\n * assertion objects. The purpose of this class is to make test code\n * more readable.\n */\npublic class Assert {\n\tprivate Assert() { }\n\t/**\n\t * Create a new instance of <code>{@link FileAssert}</code>.\n\t *\n\t * @param actual\n\t * \t\tThe actual value.\n\t * @return the created assertion object.\n\t */\n\tpublic static AbstractFileAssert<?> assertThat(String actual) {\n\t\treturn assertThat(new File(actual));\n\t}\n\n\t/**\n\t * Create a new instance of <code>{@link FileAssert}</code>.\n\t *\n\t * @param actual\n\t * \t\tThe actual value.\n\t * @return the created assertion object.\n\t */\n\tpublic static AbstractFileAssert<?> assertThat(File actual) {\n\t\tassertNotNull(actual);\n\t\tassertExists(actual);\n\t\treturn new FileAssert(actual);\n\t}\n\n\t/**\n\t * Create a new instance of <code>{@link CtElementAssert}</code>.\n\t * Note that a package typed by CtElement will call this method and\n\t * not {@link Assert#assertThat(CtPackage)}.\n\t *\n\t * @param actual\n\t * \t\tThe actual value.\n\t * @return the created assertion object.\n\t */\n\tpublic static AbstractCtElementAssert<?> assertThat(CtElement actual) {\n\t\tassertNotNull(actual);\n\t\treturn new CtElementAssert(actual);\n\t}\n\n\t/**\n\t * Create a new instance of <code>{@link CtPackageAssert}</code>.\n\t * Note that this assert will be make a deep equals with its content\n\t * (all types).\n\t *\n\t * @param actual\n\t * \t\tThe actual value.\n\t * @return the created assertion object.\n\t */\n\tpublic static AbstractCtPackageAssert<?> assertThat(CtPackage actual) {\n\t\tassertNotNull(actual);\n\t\treturn new CtPackageAssert(actual);\n\t}\n}\n"
    } ]
  } ]
}